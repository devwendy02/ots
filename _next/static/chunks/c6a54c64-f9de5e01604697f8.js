"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [210], {
        80282: function(_, O, B) {
            let N, k, F, U, j, G, Y, Q, K, $, ee, et, ei, er, ea, en, eo, el, eh, ec, eu, ep, ef, em, eg, ev, ex, eb, e_, eS, eA, eM, eE, eC, eT, eD, eP, eI, eO, eL, eR, eB, eN, ek, eF, eU, ej, eG, eH, eW, eq, eY, eX, eQ, eZ, eK, eJ, e$, e0, e1, e2, e3, e4, e5, e6, e8, e9, e7, te, tt, ti, tr, ts, ta, to, tl, th, tc, td, tu, tp, tf, tm, tg, tx, tb, t_, tS, tA, tM, tE, tC, tT, tD, tP, tI, tR, tB, tN, tk, tF, tU, tj, tG, tH, tW, tq, tY, tX, tQ, tZ, tK, tJ, t$, t0, t2, t3, t4, t5, t6, t8, t9, t7, ie, it, ii;
            B.d(O, {
                M: function() {
                    return Px
                }
            });
            var is, ia, io = B(25566),
                il = B(67133).Buffer,
                ih = Object.create,
                ic = Object.defineProperty,
                id = Object.getOwnPropertyDescriptor,
                im = Object.getOwnPropertyNames,
                iv = Object.getPrototypeOf,
                iy = Object.prototype.hasOwnProperty,
                M3 = (_, O, B) => O in _ ? ic(_, O, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: B
                }) : _[O] = B,
                Gn = (_, O) => () => (O || _((O = {
                    exports: {}
                }).exports, O), O.exports),
                C3 = (_, O, B, N) => {
                    if (O && "object" == typeof O || "function" == typeof O)
                        for (let k of im(O)) iy.call(_, k) || k === B || ic(_, k, {
                            get: () => O[k],
                            enumerable: !(N = id(O, k)) || N.enumerable
                        });
                    return _
                },
                pn = (_, O, B) => (B = null != _ ? ih(iv(_)) : {}, C3(!O && _ && _.__esModule ? B : ic(B, "default", {
                    value: _,
                    enumerable: !0
                }), _)),
                mn = (_, O, B) => (M3(_, "symbol" != typeof O ? O + "" : O, B), B),
                ix = Gn((_, O) => {
                    var B;
                    B = function() {
                        return i.importState = function(_) {
                            var O = new i;
                            return O.importState(_), O
                        }, i;

                        function i() {
                            return function(_) {
                                var O, B, N = 0,
                                    k = 0,
                                    F = 0,
                                    U = 1;
                                0 == _.length && (_ = [+new Date]);
                                var j = (O = 4022871197, (B = function(_) {
                                    _ = _.toString();
                                    for (var B = 0; B < _.length; B++) {
                                        var N = .02519603282416938 * (O += _.charCodeAt(B));
                                        O = N >>> 0, N -= O, N *= O, O = N >>> 0, N -= O, O += 4294967296 * N
                                    }
                                    return (O >>> 0) * 23283064365386963e-26
                                }).version = "Mash 0.9", B);
                                N = j(" "), k = j(" "), F = j(" ");
                                for (var G = 0; G < _.length; G++)(N -= j(_[G])) < 0 && (N += 1), (k -= j(_[G])) < 0 && (k += 1), (F -= j(_[G])) < 0 && (F += 1);
                                j = null;
                                var u = function() {
                                    var _ = 2091639 * N + 23283064365386963e-26 * U;
                                    return N = k, k = F, F = _ - (U = 0 | _)
                                };
                                return u.next = u, u.uint32 = function() {
                                    return 4294967296 * u()
                                }, u.fract53 = function() {
                                    return u() + (2097152 * u() | 0) * 11102230246251565e-32
                                }, u.version = "Alea 0.9", u.args = _, u.exportState = function() {
                                    return [N, k, F, U]
                                }, u.importState = function(_) {
                                    N = +_[0] || 0, k = +_[1] || 0, F = +_[2] || 0, U = +_[3] || 0
                                }, u
                            }(Array.prototype.slice.call(arguments))
                        }
                    }, "object" == typeof _ ? O.exports = B() : "function" == typeof define && define.amd ? define(B) : _.Alea = B()
                }),
                ib = Gn((_, O) => {
                    var B, N;
                    B = _, N = function(_) {
                        _.SVD = function(_, O, B, N, k) {
                            if (O = void 0 === O || O, B = void 0 === B || B, k = 1e-64 / (N = N || 2220446049250313e-31), !_) throw TypeError("Matrix a is not defined");
                            var F, U, j, G, Y, Q, K, $, ee, et, ei, er, ea = _[0].length,
                                en = _.length;
                            if (en < ea) throw TypeError("Invalid matrix: m < n");
                            for (var eo = [], el = [], eh = [], ec = "f" === O ? en : ea, eu = et = K = 0; eu < en; eu++) el[eu] = Array(ec).fill(0);
                            for (eu = 0; eu < ea; eu++) eh[eu] = Array(ea).fill(0);
                            var ep, ef = Array(ea).fill(0);
                            for (eu = 0; eu < en; eu++)
                                for (F = 0; F < ea; F++) el[eu][F] = _[eu][F];
                            for (eu = 0; eu < ea; eu++) {
                                for (eo[eu] = K, ee = 0, j = eu + 1, F = eu; F < en; F++) ee += Math.pow(el[F][eu], 2);
                                if (ee < k) K = 0;
                                else
                                    for ($ = (Q = el[eu][eu]) * (K = Q < 0 ? Math.sqrt(ee) : -Math.sqrt(ee)) - ee, el[eu][eu] = Q - K, F = j; F < ea; F++) {
                                        for (ee = 0, U = eu; U < en; U++) ee += el[U][eu] * el[U][F];
                                        for (Q = ee / $, U = eu; U < en; U++) el[U][F] = el[U][F] + Q * el[U][eu]
                                    }
                                for (ef[eu] = K, ee = 0, F = j; F < ea; F++) ee += Math.pow(el[eu][F], 2);
                                if (ee < k) K = 0;
                                else {
                                    for ($ = (Q = el[eu][eu + 1]) * (K = Q < 0 ? Math.sqrt(ee) : -Math.sqrt(ee)) - ee, el[eu][eu + 1] = Q - K, F = j; F < ea; F++) eo[F] = el[eu][F] / $;
                                    for (F = j; F < en; F++) {
                                        for (ee = 0, U = j; U < ea; U++) ee += el[F][U] * el[eu][U];
                                        for (U = j; U < ea; U++) el[F][U] = el[F][U] + ee * eo[U]
                                    }
                                }
                                et < (ei = Math.abs(ef[eu]) + Math.abs(eo[eu])) && (et = ei)
                            }
                            if (B)
                                for (eu = ea - 1; 0 <= eu; eu--) {
                                    if (0 !== K) {
                                        for ($ = el[eu][eu + 1] * K, F = j; F < ea; F++) eh[F][eu] = el[eu][F] / $;
                                        for (F = j; F < ea; F++) {
                                            for (ee = 0, U = j; U < ea; U++) ee += el[eu][U] * eh[U][F];
                                            for (U = j; U < ea; U++) eh[U][F] = eh[U][F] + ee * eh[U][eu]
                                        }
                                    }
                                    for (F = j; F < ea; F++) eh[eu][F] = 0, eh[F][eu] = 0;
                                    eh[eu][eu] = 1, K = eo[eu], j = eu
                                }
                            if (O) {
                                if ("f" === O)
                                    for (eu = ea; eu < en; eu++) {
                                        for (F = ea; F < en; F++) el[eu][F] = 0;
                                        el[eu][eu] = 1
                                    }
                                for (eu = ea - 1; 0 <= eu; eu--) {
                                    for (j = eu + 1, K = ef[eu], F = j; F < ec; F++) el[eu][F] = 0;
                                    if (0 !== K) {
                                        for ($ = el[eu][eu] * K, F = j; F < ec; F++) {
                                            for (ee = 0, U = j; U < en; U++) ee += el[U][eu] * el[U][F];
                                            for (Q = ee / $, U = eu; U < en; U++) el[U][F] = el[U][F] + Q * el[U][eu]
                                        }
                                        for (F = eu; F < en; F++) el[F][eu] = el[F][eu] / K
                                    } else
                                        for (F = eu; F < en; F++) el[F][eu] = 0;
                                    el[eu][eu] = el[eu][eu] + 1
                                }
                            }
                            for (N *= et, U = ea - 1; 0 <= U; U--)
                                for (var em = 0; em < 50; em++) {
                                    for (ep = !1, j = U; 0 <= j; j--) {
                                        if (Math.abs(eo[j]) <= N) {
                                            ep = !0;
                                            break
                                        }
                                        if (Math.abs(ef[j - 1]) <= N) break
                                    }
                                    if (!ep) {
                                        for (Y = 0, G = j - (ee = 1), eu = j; eu < U + 1 && (Q = ee * eo[eu], eo[eu] = Y * eo[eu], !(Math.abs(Q) <= N)); eu++)
                                            if (K = ef[eu], ef[eu] = Math.sqrt(Q * Q + K * K), Y = K / ($ = ef[eu]), ee = -Q / $, O)
                                                for (F = 0; F < en; F++) ei = el[F][G], er = el[F][eu], el[F][G] = ei * Y + er * ee, el[F][eu] = -ei * ee + er * Y
                                    }
                                    if (er = ef[U], j === U) {
                                        if (er < 0 && (ef[U] = -er, B))
                                            for (F = 0; F < ea; F++) eh[F][U] = -eh[F][U];
                                        break
                                    }
                                    for (et = ef[j], K = Math.sqrt((Q = (((ei = ef[U - 1]) - er) * (ei + er) + ((K = eo[U - 1]) - ($ = eo[U])) * (K + $)) / (2 * $ * ei)) * Q + 1), Q = ((et - er) * (et + er) + $ * (ei / (Q < 0 ? Q - K : Q + K) - $)) / et, eu = j + (ee = Y = 1); eu < U + 1; eu++) {
                                        if (K = eo[eu], ei = ef[eu], $ = ee * K, K *= Y, er = Math.sqrt(Q * Q + $ * $), Q = et * (Y = Q / (eo[eu - 1] = er)) + K * (ee = $ / er), K = -et * ee + K * Y, $ = ei * ee, ei *= Y, B)
                                            for (F = 0; F < ea; F++) et = eh[F][eu - 1], er = eh[F][eu], eh[F][eu - 1] = et * Y + er * ee, eh[F][eu] = -et * ee + er * Y;
                                        if (er = Math.sqrt(Q * Q + $ * $), Q = (Y = Q / (ef[eu - 1] = er)) * K + (ee = $ / er) * ei, et = -ee * K + Y * ei, O)
                                            for (F = 0; F < en; F++) ei = el[F][eu - 1], er = el[F][eu], el[F][eu - 1] = ei * Y + er * ee, el[F][eu] = -ei * ee + er * Y
                                    }
                                    eo[j] = 0, eo[U] = Q, ef[U] = et
                                }
                            for (eu = 0; eu < ea; eu++) ef[eu] < N && (ef[eu] = 0);
                            return {
                                u: el,
                                q: ef,
                                v: eh
                            }
                        }, _.VERSION = "1.1.1", Object.defineProperty(_, "__esModule", {
                            value: !0
                        })
                    }, "object" == typeof _ && "u" > typeof O ? N(_) : "function" == typeof define && define.amd ? define(["exports"], N) : N((B = "u" > typeof globalThis ? globalThis : B || self).SVDJS = {})
                }),
                iw = Gn((_, O) => {
                    var B, N;
                    B = _, N = function() {
                        var i = function(_, O) {
                            if (void 0 === _ && (_ = []), void 0 === O && (O = t), this.data = _, this.length = this.data.length, this.compare = O, this.length > 0)
                                for (var B = (this.length >> 1) - 1; B >= 0; B--) this._down(B)
                        };

                        function t(_, O) {
                            return _ < O ? -1 : _ > O ? 1 : 0
                        }
                        return i.prototype.push = function(_) {
                            this.data.push(_), this.length++, this._up(this.length - 1)
                        }, i.prototype.pop = function() {
                            if (0 !== this.length) {
                                var _ = this.data[0],
                                    O = this.data.pop();
                                return this.length--, this.length > 0 && (this.data[0] = O, this._down(0)), _
                            }
                        }, i.prototype.peek = function() {
                            return this.data[0]
                        }, i.prototype._up = function(_) {
                            for (var O = this.data, B = this.compare, N = O[_]; _ > 0;) {
                                var k = _ - 1 >> 1,
                                    F = O[k];
                                if (B(N, F) >= 0) break;
                                O[_] = F, _ = k
                            }
                            O[_] = N
                        }, i.prototype._down = function(_) {
                            for (var O = this.data, B = this.compare, N = this.length >> 1, k = O[_]; _ < N;) {
                                var F = (_ << 1) + 1,
                                    U = O[F],
                                    j = F + 1;
                                if (j < this.length && 0 > B(O[j], U) && (F = j, U = O[j]), B(U, k) >= 0) break;
                                O[_] = U, _ = F
                            }
                            O[_] = k
                        }, i
                    }, "object" == typeof _ && "u" > typeof O ? O.exports = N() : "function" == typeof define && define.amd ? define(N) : (B = B || self).TinyQueue = N()
                }),
                i_ = Gn((_, O) => {
                    var B = iw();

                    function pD(_, O, N) {
                        O = O || 1;
                        for (var k, F, U, j, G = 0; G < _[0].length; G++) {
                            var Y = _[0][G];
                            (!G || Y[0] < k) && (k = Y[0]), (!G || Y[1] < F) && (F = Y[1]), (!G || Y[0] > U) && (U = Y[0]), (!G || Y[1] > j) && (j = Y[1])
                        }
                        var Q = U - k,
                            K = j - F,
                            $ = Math.min(Q, K),
                            ee = $ / 2;
                        if (0 === $) {
                            var et = [k, F];
                            return et.distance = 0, et
                        }
                        for (var ei = new B(void 0, V8), er = k; er < U; er += $)
                            for (var ea = F; ea < j; ea += $) ei.push(new cl(er + ee, ea + ee, ee, _));
                        var en = function(_) {
                                for (var O = 0, B = 0, N = 0, k = _[0], F = 0, U = k.length, j = U - 1; F < U; j = F++) {
                                    var G = k[F],
                                        Y = k[j],
                                        Q = G[0] * Y[1] - Y[0] * G[1];
                                    B += (G[0] + Y[0]) * Q, N += (G[1] + Y[1]) * Q, O += 3 * Q
                                }
                                return 0 === O ? new cl(k[0][0], k[0][1], 0, _) : new cl(B / O, N / O, 0, _)
                            }(_),
                            eo = new cl(k + Q / 2, F + K / 2, 0, _);
                        eo.d > en.d && (en = eo);
                        for (var el = ei.length; ei.length;) {
                            var eh = ei.pop();
                            eh.d > en.d && (en = eh, N && console.log("found best %d after %d probes", Math.round(1e4 * eh.d) / 1e4, el)), eh.max - en.d <= O || (ee = eh.h / 2, ei.push(new cl(eh.x - ee, eh.y - ee, ee, _)), ei.push(new cl(eh.x + ee, eh.y - ee, ee, _)), ei.push(new cl(eh.x - ee, eh.y + ee, ee, _)), ei.push(new cl(eh.x + ee, eh.y + ee, ee, _)), el += 4)
                        }
                        N && (console.log("num probes: " + el), console.log("best distance: " + en.d));
                        var ec = [en.x, en.y];
                        return ec.distance = en.d, ec
                    }

                    function V8(_, O) {
                        return O.max - _.max
                    }

                    function cl(_, O, B, N) {
                        this.x = _, this.y = O, this.h = B, this.d = function(_, O, B) {
                            for (var N = !1, k = 1 / 0, F = 0; F < B.length; F++)
                                for (var U = B[F], j = 0, G = U.length, Y = G - 1; j < G; Y = j++) {
                                    var Q = U[j],
                                        K = U[Y];
                                    Q[1] > O != K[1] > O && _ < (K[0] - Q[0]) * (O - Q[1]) / (K[1] - Q[1]) + Q[0] && (N = !N), k = Math.min(k, function(_, O, B, N) {
                                        var k = B[0],
                                            F = B[1],
                                            U = N[0] - k,
                                            j = N[1] - F;
                                        if (0 !== U || 0 !== j) {
                                            var G = ((_ - k) * U + (O - F) * j) / (U * U + j * j);
                                            G > 1 ? (k = N[0], F = N[1]) : G > 0 && (k += U * G, F += j * G)
                                        }
                                        return (U = _ - k) * U + (j = O - F) * j
                                    }(_, O, Q, K))
                                }
                            return 0 === k ? 0 : (N ? 1 : -1) * Math.sqrt(k)
                        }(_, O, N), this.max = this.d + this.h * Math.SQRT2
                    }
                    B.default && (B = B.default), O.exports = pD, O.exports.default = pD
                }),
                iS = Gn((_, O) => {
                    Object.defineProperty(_, "__esModule", {
                        value: !0
                    }), _.default = function(_) {
                        if (null === _ || !0 === _ || !1 === _) return NaN;
                        var O = Number(_);
                        return isNaN(O) ? O : O < 0 ? Math.ceil(O) : Math.floor(O)
                    }, O.exports = _.default
                }),
                iA = Gn((_, O) => {
                    Object.defineProperty(_, "__esModule", {
                        value: !0
                    }), _.default = function(_) {
                        var O = new Date(Date.UTC(_.getFullYear(), _.getMonth(), _.getDate(), _.getHours(), _.getMinutes(), _.getSeconds(), _.getMilliseconds()));
                        return O.setUTCFullYear(_.getFullYear()), _.getTime() - O.getTime()
                    }, O.exports = _.default
                }),
                iM = Gn(_ => {
                    var O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et;
                    (O = function() {
                        this.init()
                    }).prototype = {
                        init: function() {
                            var _ = this || B;
                            return _._counter = 1e3, _._html5AudioPool = [], _.html5PoolSize = 10, _._codecs = {}, _._howls = [], _._muted = !1, _._volume = 1, _._canPlayEvent = "canplaythrough", _._navigator = "u" > typeof window && window.navigator ? window.navigator : null, _.masterGain = null, _.noAudio = !1, _.usingWebAudio = !0, _.autoSuspend = !0, _.ctx = null, _.autoUnlock = !0, _._setup(), _
                        },
                        volume: function(_) {
                            var O = this || B;
                            if (_ = parseFloat(_), O.ctx || Q(), "u" > typeof _ && _ >= 0 && _ <= 1) {
                                if (O._volume = _, O._muted) return O;
                                O.usingWebAudio && O.masterGain.gain.setValueAtTime(_, B.ctx.currentTime);
                                for (var N = 0; N < O._howls.length; N++)
                                    if (!O._howls[N]._webAudio)
                                        for (var k = O._howls[N]._getSoundIds(), F = 0; F < k.length; F++) {
                                            var U = O._howls[N]._soundById(k[F]);
                                            U && U._node && (U._node.volume = U._volume * _)
                                        }
                                return O
                            }
                            return O._volume
                        },
                        mute: function(_) {
                            var O = this || B;
                            O.ctx || Q(), O._muted = _, O.usingWebAudio && O.masterGain.gain.setValueAtTime(_ ? 0 : O._volume, B.ctx.currentTime);
                            for (var N = 0; N < O._howls.length; N++)
                                if (!O._howls[N]._webAudio)
                                    for (var k = O._howls[N]._getSoundIds(), F = 0; F < k.length; F++) {
                                        var U = O._howls[N]._soundById(k[F]);
                                        U && U._node && (U._node.muted = !!_ || U._muted)
                                    }
                            return O
                        },
                        stop: function() {
                            for (var _ = this || B, O = 0; O < _._howls.length; O++) _._howls[O].stop();
                            return _
                        },
                        unload: function() {
                            for (var _ = this || B, O = _._howls.length - 1; O >= 0; O--) _._howls[O].unload();
                            return _.usingWebAudio && _.ctx && "u" > typeof _.ctx.close && (_.ctx.close(), _.ctx = null, Q()), _
                        },
                        codecs: function(_) {
                            return (this || B)._codecs[_.replace(/^x-/, "")]
                        },
                        _setup: function() {
                            var _ = this || B;
                            if (_.state = _.ctx && _.ctx.state || "suspended", _._autoSuspend(), !_.usingWebAudio) {
                                if ("u" > typeof Audio) try {
                                    var O = new Audio;
                                    typeof O.oncanplaythrough > "u" && (_._canPlayEvent = "canplay")
                                } catch {
                                    _.noAudio = !0
                                } else _.noAudio = !0
                            }
                            try {
                                var O = new Audio;
                                O.muted && (_.noAudio = !0)
                            } catch {}
                            return _.noAudio || _._setupCodecs(), _
                        },
                        _setupCodecs: function() {
                            var _ = this || B,
                                O = null;
                            try {
                                O = "u" > typeof Audio ? new Audio : null
                            } catch {
                                return _
                            }
                            if (!O || "function" != typeof O.canPlayType) return _;
                            var N = O.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                                k = _._navigator ? _._navigator.userAgent : "",
                                F = k.match(/OPR\/([0-6].)/g),
                                U = F && 33 > parseInt(F[0].split("/")[1], 10),
                                j = -1 !== k.indexOf("Safari") && -1 === k.indexOf("Chrome"),
                                G = k.match(/Version\/(.*?) /),
                                Y = j && G && 15 > parseInt(G[1], 10);
                            return _._codecs = {
                                mp3: !!(!U && (N || O.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                                mpeg: !!N,
                                opus: !!O.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                                ogg: !!O.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                oga: !!O.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                wav: !!(O.canPlayType('audio/wav; codecs="1"') || O.canPlayType("audio/wav")).replace(/^no$/, ""),
                                aac: !!O.canPlayType("audio/aac;").replace(/^no$/, ""),
                                caf: !!O.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                                m4a: !!(O.canPlayType("audio/x-m4a;") || O.canPlayType("audio/m4a;") || O.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                m4b: !!(O.canPlayType("audio/x-m4b;") || O.canPlayType("audio/m4b;") || O.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                mp4: !!(O.canPlayType("audio/x-mp4;") || O.canPlayType("audio/mp4;") || O.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                weba: !!(!Y && O.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                                webm: !!(!Y && O.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                                dolby: !!O.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                                flac: !!(O.canPlayType("audio/x-flac;") || O.canPlayType("audio/flac;")).replace(/^no$/, "")
                            }, _
                        },
                        _unlockAudio: function() {
                            var _ = this || B;
                            if (!(_._audioUnlocked || !_.ctx)) {
                                _._audioUnlocked = !1, _.autoUnlock = !1, _._mobileUnloaded || 44100 === _.ctx.sampleRate || (_._mobileUnloaded = !0, _.unload()), _._scratchBuffer = _.ctx.createBuffer(1, 1, 22050);
                                var h = function(O) {
                                    for (; _._html5AudioPool.length < _.html5PoolSize;) try {
                                        var B = new Audio;
                                        B._unlocked = !0, _._releaseHtml5Audio(B)
                                    } catch {
                                        _.noAudio = !0;
                                        break
                                    }
                                    for (var N = 0; N < _._howls.length; N++)
                                        if (!_._howls[N]._webAudio)
                                            for (var k = _._howls[N]._getSoundIds(), F = 0; F < k.length; F++) {
                                                var U = _._howls[N]._soundById(k[F]);
                                                U && U._node && !U._node._unlocked && (U._node._unlocked = !0, U._node.load())
                                            }
                                    _._autoResume();
                                    var j = _.ctx.createBufferSource();
                                    j.buffer = _._scratchBuffer, j.connect(_.ctx.destination), typeof j.start > "u" ? j.noteOn(0) : j.start(0), "function" == typeof _.ctx.resume && _.ctx.resume(), j.onended = function() {
                                        j.disconnect(0), _._audioUnlocked = !0, document.removeEventListener("touchstart", h, !0), document.removeEventListener("touchend", h, !0), document.removeEventListener("click", h, !0), document.removeEventListener("keydown", h, !0);
                                        for (var O = 0; O < _._howls.length; O++) _._howls[O]._emit("unlock")
                                    }
                                };
                                return document.addEventListener("touchstart", h, !0), document.addEventListener("touchend", h, !0), document.addEventListener("click", h, !0), document.addEventListener("keydown", h, !0), _
                            }
                        },
                        _obtainHtml5Audio: function() {
                            var _ = this || B;
                            if (_._html5AudioPool.length) return _._html5AudioPool.pop();
                            var O = new Audio().play();
                            return O && "u" > typeof Promise && (O instanceof Promise || "function" == typeof O.then) && O.catch(function() {
                                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                            }), new Audio
                        },
                        _releaseHtml5Audio: function(_) {
                            var O = this || B;
                            return _._unlocked && O._html5AudioPool.push(_), O
                        },
                        _autoSuspend: function() {
                            var _ = this;
                            if (!(!_.autoSuspend || !_.ctx || typeof _.ctx.suspend > "u" || !B.usingWebAudio)) {
                                for (var O = 0; O < _._howls.length; O++)
                                    if (_._howls[O]._webAudio) {
                                        for (var N = 0; N < _._howls[O]._sounds.length; N++)
                                            if (!_._howls[O]._sounds[N]._paused) return _
                                    }
                                return _._suspendTimer && clearTimeout(_._suspendTimer), _._suspendTimer = setTimeout(function() {
                                    if (_.autoSuspend) {
                                        _._suspendTimer = null, _.state = "suspending";
                                        var f = function() {
                                            _.state = "suspended", _._resumeAfterSuspend && (delete _._resumeAfterSuspend, _._autoResume())
                                        };
                                        _.ctx.suspend().then(f, f)
                                    }
                                }, 3e4), _
                            }
                        },
                        _autoResume: function() {
                            var _ = this;
                            if (!(!_.ctx || typeof _.ctx.resume > "u" || !B.usingWebAudio)) return "running" === _.state && "interrupted" !== _.ctx.state && _._suspendTimer ? (clearTimeout(_._suspendTimer), _._suspendTimer = null) : "suspended" === _.state || "running" === _.state && "interrupted" === _.ctx.state ? (_.ctx.resume().then(function() {
                                _.state = "running";
                                for (var O = 0; O < _._howls.length; O++) _._howls[O]._emit("resume")
                            }), _._suspendTimer && (clearTimeout(_._suspendTimer), _._suspendTimer = null)) : "suspending" === _.state && (_._resumeAfterSuspend = !0), _
                        }
                    }, B = new O, (N = function(_) {
                        if (!_.src || 0 === _.src.length) {
                            console.error("An array of source files must be passed with any new Howl.");
                            return
                        }
                        this.init(_)
                    }).prototype = {
                        init: function(_) {
                            var O = this;
                            return B.ctx || Q(), O._autoplay = _.autoplay || !1, O._format = "string" != typeof _.format ? _.format : [_.format], O._html5 = _.html5 || !1, O._muted = _.mute || !1, O._loop = _.loop || !1, O._pool = _.pool || 5, O._preload = "boolean" != typeof _.preload && "metadata" !== _.preload || _.preload, O._rate = _.rate || 1, O._sprite = _.sprite || {}, O._src = "string" != typeof _.src ? _.src : [_.src], O._volume = void 0 !== _.volume ? _.volume : 1, O._xhr = {
                                method: _.xhr && _.xhr.method ? _.xhr.method : "GET",
                                headers: _.xhr && _.xhr.headers ? _.xhr.headers : null,
                                withCredentials: !!_.xhr && !!_.xhr.withCredentials && _.xhr.withCredentials
                            }, O._duration = 0, O._state = "unloaded", O._sounds = [], O._endTimers = {}, O._queue = [], O._playLock = !1, O._onend = _.onend ? [{
                                fn: _.onend
                            }] : [], O._onfade = _.onfade ? [{
                                fn: _.onfade
                            }] : [], O._onload = _.onload ? [{
                                fn: _.onload
                            }] : [], O._onloaderror = _.onloaderror ? [{
                                fn: _.onloaderror
                            }] : [], O._onplayerror = _.onplayerror ? [{
                                fn: _.onplayerror
                            }] : [], O._onpause = _.onpause ? [{
                                fn: _.onpause
                            }] : [], O._onplay = _.onplay ? [{
                                fn: _.onplay
                            }] : [], O._onstop = _.onstop ? [{
                                fn: _.onstop
                            }] : [], O._onmute = _.onmute ? [{
                                fn: _.onmute
                            }] : [], O._onvolume = _.onvolume ? [{
                                fn: _.onvolume
                            }] : [], O._onrate = _.onrate ? [{
                                fn: _.onrate
                            }] : [], O._onseek = _.onseek ? [{
                                fn: _.onseek
                            }] : [], O._onunlock = _.onunlock ? [{
                                fn: _.onunlock
                            }] : [], O._onresume = [], O._webAudio = B.usingWebAudio && !O._html5, "u" > typeof B.ctx && B.ctx && B.autoUnlock && B._unlockAudio(), B._howls.push(O), O._autoplay && O._queue.push({
                                event: "play",
                                action: function() {
                                    O.play()
                                }
                            }), O._preload && "none" !== O._preload && O.load(), O
                        },
                        load: function() {
                            var _, O, N = null;
                            if (B.noAudio) {
                                this._emit("loaderror", null, "No audio support.");
                                return
                            }
                            "string" == typeof this._src && (this._src = [this._src]);
                            for (var F = 0; F < this._src.length; F++) {
                                if (this._format && this._format[F]) _ = this._format[F];
                                else {
                                    if ("string" != typeof(O = this._src[F])) {
                                        this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                        continue
                                    }(_ = /^data:audio\/([^;,]+);/i.exec(O)) || (_ = /\.([^.]+)$/.exec(O.split("?", 1)[0])), _ && (_ = _[1].toLowerCase())
                                }
                                if (_ || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), _ && B.codecs(_)) {
                                    N = this._src[F];
                                    break
                                }
                            }
                            if (!N) {
                                this._emit("loaderror", null, "No codec support for selected audio sources.");
                                return
                            }
                            return this._src = N, this._state = "loading", "https:" === window.location.protocol && "http:" === N.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new k(this), this._webAudio && U(this), this
                        },
                        play: function(_, O) {
                            var N = this,
                                k = null;
                            if ("number" == typeof _) k = _, _ = null;
                            else {
                                if ("string" == typeof _ && "loaded" === N._state && !N._sprite[_]) return null;
                                if (typeof _ > "u" && (_ = "__default", !N._playLock)) {
                                    for (var F = 0, U = 0; U < N._sounds.length; U++) N._sounds[U]._paused && !N._sounds[U]._ended && (F++, k = N._sounds[U]._id);
                                    1 === F ? _ = null : k = null
                                }
                            }
                            var j = k ? N._soundById(k) : N._inactiveSound();
                            if (!j) return null;
                            if (k && !_ && (_ = j._sprite || "__default"), "loaded" !== N._state) {
                                j._sprite = _, j._ended = !1;
                                var G = j._id;
                                return N._queue.push({
                                    event: "play",
                                    action: function() {
                                        N.play(G)
                                    }
                                }), G
                            }
                            if (k && !j._paused) return O || N._loadQueue("play"), j._id;
                            N._webAudio && B._autoResume();
                            var Y = Math.max(0, j._seek > 0 ? j._seek : N._sprite[_][0] / 1e3),
                                Q = Math.max(0, (N._sprite[_][0] + N._sprite[_][1]) / 1e3 - Y),
                                K = 1e3 * Q / Math.abs(j._rate),
                                $ = N._sprite[_][0] / 1e3,
                                ee = (N._sprite[_][0] + N._sprite[_][1]) / 1e3;
                            j._sprite = _, j._ended = !1;
                            var E = function() {
                                j._paused = !1, j._seek = Y, j._start = $, j._stop = ee, j._loop = !!(j._loop || N._sprite[_][2])
                            };
                            if (Y >= ee) {
                                N._ended(j);
                                return
                            }
                            var et = j._node;
                            if (N._webAudio) {
                                var M = function() {
                                    N._playLock = !1, E(), N._refreshBuffer(j);
                                    var _ = j._muted || N._muted ? 0 : j._volume;
                                    et.gain.setValueAtTime(_, B.ctx.currentTime), j._playStart = B.ctx.currentTime, typeof et.bufferSource.start > "u" ? j._loop ? et.bufferSource.noteGrainOn(0, Y, 86400) : et.bufferSource.noteGrainOn(0, Y, Q) : j._loop ? et.bufferSource.start(0, Y, 86400) : et.bufferSource.start(0, Y, Q), K !== 1 / 0 && (N._endTimers[j._id] = setTimeout(N._ended.bind(N, j), K)), O || setTimeout(function() {
                                        N._emit("play", j._id), N._loadQueue()
                                    }, 0)
                                };
                                "running" === B.state && "interrupted" !== B.ctx.state ? M() : (N._playLock = !0, N.once("resume", M), N._clearTimer(j._id))
                            } else {
                                var T = function() {
                                    et.currentTime = Y, et.muted = j._muted || N._muted || B._muted || et.muted, et.volume = j._volume * B.volume(), et.playbackRate = j._rate;
                                    try {
                                        var k = et.play();
                                        if (k && "u" > typeof Promise && (k instanceof Promise || "function" == typeof k.then) ? (N._playLock = !0, E(), k.then(function() {
                                                N._playLock = !1, et._unlocked = !0, O ? N._loadQueue() : N._emit("play", j._id)
                                            }).catch(function() {
                                                N._playLock = !1, N._emit("playerror", j._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), j._ended = !0, j._paused = !0
                                            })) : O || (N._playLock = !1, E(), N._emit("play", j._id)), et.playbackRate = j._rate, et.paused) {
                                            N._emit("playerror", j._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                            return
                                        }
                                        "__default" !== _ || j._loop ? N._endTimers[j._id] = setTimeout(N._ended.bind(N, j), K) : (N._endTimers[j._id] = function() {
                                            N._ended(j), et.removeEventListener("ended", N._endTimers[j._id], !1)
                                        }, et.addEventListener("ended", N._endTimers[j._id], !1))
                                    } catch (_) {
                                        N._emit("playerror", j._id, _)
                                    }
                                };
                                "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === et.src && (et.src = N._src, et.load());
                                var ei = window && window.ejecta || !et.readyState && B._navigator.isCocoonJS;
                                if (et.readyState >= 3 || ei) T();
                                else {
                                    N._playLock = !0, N._state = "loading";
                                    var P = function() {
                                        N._state = "loaded", T(), et.removeEventListener(B._canPlayEvent, P, !1)
                                    };
                                    et.addEventListener(B._canPlayEvent, P, !1), N._clearTimer(j._id)
                                }
                            }
                            return j._id
                        },
                        pause: function(_) {
                            var O = this;
                            if ("loaded" !== O._state || O._playLock) return O._queue.push({
                                event: "pause",
                                action: function() {
                                    O.pause(_)
                                }
                            }), O;
                            for (var B = O._getSoundIds(_), N = 0; N < B.length; N++) {
                                O._clearTimer(B[N]);
                                var k = O._soundById(B[N]);
                                if (k && !k._paused && (k._seek = O.seek(B[N]), k._rateSeek = 0, k._paused = !0, O._stopFade(B[N]), k._node)) {
                                    if (O._webAudio) {
                                        if (!k._node.bufferSource) continue;
                                        typeof k._node.bufferSource.stop > "u" ? k._node.bufferSource.noteOff(0) : k._node.bufferSource.stop(0), O._cleanBuffer(k._node)
                                    } else isNaN(k._node.duration) && k._node.duration !== 1 / 0 || k._node.pause()
                                }
                                arguments[1] || O._emit("pause", k ? k._id : null)
                            }
                            return O
                        },
                        stop: function(_, O) {
                            var B = this;
                            if ("loaded" !== B._state || B._playLock) return B._queue.push({
                                event: "stop",
                                action: function() {
                                    B.stop(_)
                                }
                            }), B;
                            for (var N = B._getSoundIds(_), k = 0; k < N.length; k++) {
                                B._clearTimer(N[k]);
                                var F = B._soundById(N[k]);
                                F && (F._seek = F._start || 0, F._rateSeek = 0, F._paused = !0, F._ended = !0, B._stopFade(N[k]), F._node && (B._webAudio ? F._node.bufferSource && (typeof F._node.bufferSource.stop > "u" ? F._node.bufferSource.noteOff(0) : F._node.bufferSource.stop(0), B._cleanBuffer(F._node)) : isNaN(F._node.duration) && F._node.duration !== 1 / 0 || (F._node.currentTime = F._start || 0, F._node.pause(), F._node.duration === 1 / 0 && B._clearSound(F._node))), O || B._emit("stop", F._id))
                            }
                            return B
                        },
                        mute: function(_, O) {
                            var N = this;
                            if ("loaded" !== N._state || N._playLock) return N._queue.push({
                                event: "mute",
                                action: function() {
                                    N.mute(_, O)
                                }
                            }), N;
                            if (typeof O > "u") {
                                if ("boolean" != typeof _) return N._muted;
                                N._muted = _
                            }
                            for (var k = N._getSoundIds(O), F = 0; F < k.length; F++) {
                                var U = N._soundById(k[F]);
                                U && (U._muted = _, U._interval && N._stopFade(U._id), N._webAudio && U._node ? U._node.gain.setValueAtTime(_ ? 0 : U._volume, B.ctx.currentTime) : U._node && (U._node.muted = !!B._muted || _), N._emit("mute", U._id))
                            }
                            return N
                        },
                        volume: function() {
                            var _, O, N, k = this,
                                F = arguments;
                            if (0 === F.length) return k._volume;
                            if (1 === F.length || 2 === F.length && typeof F[1] > "u" ? k._getSoundIds().indexOf(F[0]) >= 0 ? N = parseInt(F[0], 10) : O = parseFloat(F[0]) : F.length >= 2 && (O = parseFloat(F[0]), N = parseInt(F[1], 10)), !("u" > typeof O) || !(O >= 0) || !(O <= 1)) return (_ = N ? k._soundById(N) : k._sounds[0]) ? _._volume : 0;
                            if ("loaded" !== k._state || k._playLock) return k._queue.push({
                                event: "volume",
                                action: function() {
                                    k.volume.apply(k, F)
                                }
                            }), k;
                            typeof N > "u" && (k._volume = O), N = k._getSoundIds(N);
                            for (var U = 0; U < N.length; U++)(_ = k._soundById(N[U])) && (_._volume = O, F[2] || k._stopFade(N[U]), k._webAudio && _._node && !_._muted ? _._node.gain.setValueAtTime(O, B.ctx.currentTime) : _._node && !_._muted && (_._node.volume = O * B.volume()), k._emit("volume", _._id));
                            return k
                        },
                        fade: function(_, O, N, k) {
                            var F = this;
                            if ("loaded" !== F._state || F._playLock) return F._queue.push({
                                event: "fade",
                                action: function() {
                                    F.fade(_, O, N, k)
                                }
                            }), F;
                            _ = Math.min(Math.max(0, parseFloat(_)), 1), O = Math.min(Math.max(0, parseFloat(O)), 1), N = parseFloat(N), F.volume(_, k);
                            for (var U = F._getSoundIds(k), j = 0; j < U.length; j++) {
                                var G = F._soundById(U[j]);
                                if (G) {
                                    if (k || F._stopFade(U[j]), F._webAudio && !G._muted) {
                                        var Y = B.ctx.currentTime,
                                            Q = Y + N / 1e3;
                                        G._volume = _, G._node.gain.setValueAtTime(_, Y), G._node.gain.linearRampToValueAtTime(O, Q)
                                    }
                                    F._startFadeInterval(G, _, O, N, U[j], typeof k > "u")
                                }
                            }
                            return F
                        },
                        _startFadeInterval: function(_, O, B, N, k, F) {
                            var U = this,
                                j = O,
                                G = B - O,
                                Y = Math.abs(G / .01),
                                Q = Math.max(4, Y > 0 ? N / Y : N),
                                K = Date.now();
                            _._fadeTo = B, _._interval = setInterval(function() {
                                var k = (Date.now() - K) / N;
                                K = Date.now(), j += G * k, j = Math.round(100 * j) / 100, j = G < 0 ? Math.max(B, j) : Math.min(B, j), U._webAudio ? _._volume = j : U.volume(j, _._id, !0), F && (U._volume = j), (B < O && j <= B || B > O && j >= B) && (clearInterval(_._interval), _._interval = null, _._fadeTo = null, U.volume(B, _._id), U._emit("fade", _._id))
                            }, Q)
                        },
                        _stopFade: function(_) {
                            var O = this._soundById(_);
                            return O && O._interval && (this._webAudio && O._node.gain.cancelScheduledValues(B.ctx.currentTime), clearInterval(O._interval), O._interval = null, this.volume(O._fadeTo, _), O._fadeTo = null, this._emit("fade", _)), this
                        },
                        loop: function() {
                            var _, O, B, N = arguments;
                            if (0 === N.length) return this._loop;
                            if (1 === N.length) {
                                if ("boolean" != typeof N[0]) return !!(B = this._soundById(parseInt(N[0], 10))) && B._loop;
                                _ = N[0], this._loop = _
                            } else 2 === N.length && (_ = N[0], O = parseInt(N[1], 10));
                            for (var k = this._getSoundIds(O), F = 0; F < k.length; F++)(B = this._soundById(k[F])) && (B._loop = _, this._webAudio && B._node && B._node.bufferSource && (B._node.bufferSource.loop = _, _ && (B._node.bufferSource.loopStart = B._start || 0, B._node.bufferSource.loopEnd = B._stop, this.playing(k[F]) && (this.pause(k[F], !0), this.play(k[F], !0)))));
                            return this
                        },
                        rate: function() {
                            var _, O, N, k = this,
                                F = arguments;
                            if (0 === F.length ? N = k._sounds[0]._id : 1 === F.length ? k._getSoundIds().indexOf(F[0]) >= 0 ? N = parseInt(F[0], 10) : O = parseFloat(F[0]) : 2 === F.length && (O = parseFloat(F[0]), N = parseInt(F[1], 10)), "number" != typeof O) return (_ = k._soundById(N)) ? _._rate : k._rate;
                            if ("loaded" !== k._state || k._playLock) return k._queue.push({
                                event: "rate",
                                action: function() {
                                    k.rate.apply(k, F)
                                }
                            }), k;
                            typeof N > "u" && (k._rate = O), N = k._getSoundIds(N);
                            for (var U = 0; U < N.length; U++)
                                if (_ = k._soundById(N[U])) {
                                    k.playing(N[U]) && (_._rateSeek = k.seek(N[U]), _._playStart = k._webAudio ? B.ctx.currentTime : _._playStart), _._rate = O, k._webAudio && _._node && _._node.bufferSource ? _._node.bufferSource.playbackRate.setValueAtTime(O, B.ctx.currentTime) : _._node && (_._node.playbackRate = O);
                                    var j = k.seek(N[U]),
                                        G = 1e3 * ((k._sprite[_._sprite][0] + k._sprite[_._sprite][1]) / 1e3 - j) / Math.abs(_._rate);
                                    (k._endTimers[N[U]] || !_._paused) && (k._clearTimer(N[U]), k._endTimers[N[U]] = setTimeout(k._ended.bind(k, _), G)), k._emit("rate", _._id)
                                }
                            return k
                        },
                        seek: function() {
                            var _, O, N = this,
                                k = arguments;
                            if (0 === k.length ? N._sounds.length && (O = N._sounds[0]._id) : 1 === k.length ? N._getSoundIds().indexOf(k[0]) >= 0 ? O = parseInt(k[0], 10) : N._sounds.length && (O = N._sounds[0]._id, _ = parseFloat(k[0])) : 2 === k.length && (_ = parseFloat(k[0]), O = parseInt(k[1], 10)), typeof O > "u") return 0;
                            if ("number" == typeof _ && ("loaded" !== N._state || N._playLock)) return N._queue.push({
                                event: "seek",
                                action: function() {
                                    N.seek.apply(N, k)
                                }
                            }), N;
                            var F = N._soundById(O);
                            if (F) {
                                if ("number" == typeof _ && _ >= 0) {
                                    var U = N.playing(O);
                                    U && N.pause(O, !0), F._seek = _, F._ended = !1, N._clearTimer(O), N._webAudio || !F._node || isNaN(F._node.duration) || (F._node.currentTime = _);
                                    var v = function() {
                                        U && N.play(O, !0), N._emit("seek", O)
                                    };
                                    if (U && !N._webAudio) {
                                        var x = function() {
                                            N._playLock ? setTimeout(x, 0) : v()
                                        };
                                        setTimeout(x, 0)
                                    } else v()
                                } else {
                                    if (!N._webAudio) return F._node.currentTime;
                                    var j = N.playing(O) ? B.ctx.currentTime - F._playStart : 0,
                                        G = F._rateSeek ? F._rateSeek - F._seek : 0;
                                    return F._seek + (G + j * Math.abs(F._rate))
                                }
                            }
                            return N
                        },
                        playing: function(_) {
                            if ("number" == typeof _) {
                                var O = this._soundById(_);
                                return !!O && !O._paused
                            }
                            for (var B = 0; B < this._sounds.length; B++)
                                if (!this._sounds[B]._paused) return !0;
                            return !1
                        },
                        duration: function(_) {
                            var O = this._duration,
                                B = this._soundById(_);
                            return B && (O = this._sprite[B._sprite][1] / 1e3), O
                        },
                        state: function() {
                            return this._state
                        },
                        unload: function() {
                            for (var _ = this, O = _._sounds, N = 0; N < O.length; N++) O[N]._paused || _.stop(O[N]._id), _._webAudio || (_._clearSound(O[N]._node), O[N]._node.removeEventListener("error", O[N]._errorFn, !1), O[N]._node.removeEventListener(B._canPlayEvent, O[N]._loadFn, !1), O[N]._node.removeEventListener("ended", O[N]._endFn, !1), B._releaseHtml5Audio(O[N]._node)), delete O[N]._node, _._clearTimer(O[N]._id);
                            var k = B._howls.indexOf(_);
                            k >= 0 && B._howls.splice(k, 1);
                            var U = !0;
                            for (N = 0; N < B._howls.length; N++)
                                if (B._howls[N]._src === _._src || _._src.indexOf(B._howls[N]._src) >= 0) {
                                    U = !1;
                                    break
                                }
                            return F && U && delete F[_._src], B.noAudio = !1, _._state = "unloaded", _._sounds = [], _ = null, null
                        },
                        on: function(_, O, B, N) {
                            var k = this["_on" + _];
                            return "function" == typeof O && k.push(N ? {
                                id: B,
                                fn: O,
                                once: N
                            } : {
                                id: B,
                                fn: O
                            }), this
                        },
                        off: function(_, O, B) {
                            var N = this["_on" + _],
                                k = 0;
                            if ("number" == typeof O && (B = O, O = null), O || B)
                                for (k = 0; k < N.length; k++) {
                                    var F = B === N[k].id;
                                    if (O === N[k].fn && F || !O && F) {
                                        N.splice(k, 1);
                                        break
                                    }
                                } else if (_) this["_on" + _] = [];
                                else {
                                    var U = Object.keys(this);
                                    for (k = 0; k < U.length; k++) 0 === U[k].indexOf("_on") && Array.isArray(this[U[k]]) && (this[U[k]] = [])
                                }
                            return this
                        },
                        once: function(_, O, B) {
                            return this.on(_, O, B, 1), this
                        },
                        _emit: function(_, O, B) {
                            for (var N = this["_on" + _], k = N.length - 1; k >= 0; k--)(!N[k].id || N[k].id === O || "load" === _) && (setTimeout((function(_) {
                                _.call(this, O, B)
                            }).bind(this, N[k].fn), 0), N[k].once && this.off(_, N[k].fn, N[k].id));
                            return this._loadQueue(_), this
                        },
                        _loadQueue: function(_) {
                            if (this._queue.length > 0) {
                                var O = this._queue[0];
                                O.event === _ && (this._queue.shift(), this._loadQueue()), _ || O.action()
                            }
                            return this
                        },
                        _ended: function(_) {
                            var O = _._sprite;
                            if (!this._webAudio && _._node && !_._node.paused && !_._node.ended && _._node.currentTime < _._stop) return setTimeout(this._ended.bind(this, _), 100), this;
                            var N = !!(_._loop || this._sprite[O][2]);
                            if (this._emit("end", _._id), !this._webAudio && N && this.stop(_._id, !0).play(_._id), this._webAudio && N) {
                                this._emit("play", _._id), _._seek = _._start || 0, _._rateSeek = 0, _._playStart = B.ctx.currentTime;
                                var k = (_._stop - _._start) * 1e3 / Math.abs(_._rate);
                                this._endTimers[_._id] = setTimeout(this._ended.bind(this, _), k)
                            }
                            return this._webAudio && !N && (_._paused = !0, _._ended = !0, _._seek = _._start || 0, _._rateSeek = 0, this._clearTimer(_._id), this._cleanBuffer(_._node), B._autoSuspend()), this._webAudio || N || this.stop(_._id, !0), this
                        },
                        _clearTimer: function(_) {
                            if (this._endTimers[_]) {
                                if ("function" != typeof this._endTimers[_]) clearTimeout(this._endTimers[_]);
                                else {
                                    var O = this._soundById(_);
                                    O && O._node && O._node.removeEventListener("ended", this._endTimers[_], !1)
                                }
                                delete this._endTimers[_]
                            }
                            return this
                        },
                        _soundById: function(_) {
                            for (var O = 0; O < this._sounds.length; O++)
                                if (_ === this._sounds[O]._id) return this._sounds[O];
                            return null
                        },
                        _inactiveSound: function() {
                            this._drain();
                            for (var _ = 0; _ < this._sounds.length; _++)
                                if (this._sounds[_]._ended) return this._sounds[_].reset();
                            return new k(this)
                        },
                        _drain: function() {
                            var _ = this._pool,
                                O = 0,
                                B = 0;
                            if (!(this._sounds.length < _)) {
                                for (B = 0; B < this._sounds.length; B++) this._sounds[B]._ended && O++;
                                for (B = this._sounds.length - 1; B >= 0; B--) {
                                    if (O <= _) return;
                                    this._sounds[B]._ended && (this._webAudio && this._sounds[B]._node && this._sounds[B]._node.disconnect(0), this._sounds.splice(B, 1), O--)
                                }
                            }
                        },
                        _getSoundIds: function(_) {
                            if (!(typeof _ > "u")) return [_];
                            for (var O = [], B = 0; B < this._sounds.length; B++) O.push(this._sounds[B]._id);
                            return O
                        },
                        _refreshBuffer: function(_) {
                            return _._node.bufferSource = B.ctx.createBufferSource(), _._node.bufferSource.buffer = F[this._src], _._panner ? _._node.bufferSource.connect(_._panner) : _._node.bufferSource.connect(_._node), _._node.bufferSource.loop = _._loop, _._loop && (_._node.bufferSource.loopStart = _._start || 0, _._node.bufferSource.loopEnd = _._stop || 0), _._node.bufferSource.playbackRate.setValueAtTime(_._rate, B.ctx.currentTime), this
                        },
                        _cleanBuffer: function(_) {
                            var O = B._navigator && B._navigator.vendor.indexOf("Apple") >= 0;
                            if (B._scratchBuffer && _.bufferSource && (_.bufferSource.onended = null, _.bufferSource.disconnect(0), O)) try {
                                _.bufferSource.buffer = B._scratchBuffer
                            } catch {}
                            return _.bufferSource = null, this
                        },
                        _clearSound: function(_) {
                            /MSIE |Trident\//.test(B._navigator && B._navigator.userAgent) || (_.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                        }
                    }, (k = function(_) {
                        this._parent = _, this.init()
                    }).prototype = {
                        init: function() {
                            var _ = this._parent;
                            return this._muted = _._muted, this._loop = _._loop, this._volume = _._volume, this._rate = _._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++B._counter, _._sounds.push(this), this.create(), this
                        },
                        create: function() {
                            var _ = this._parent,
                                O = B._muted || this._muted || this._parent._muted ? 0 : this._volume;
                            return _._webAudio ? (this._node = typeof B.ctx.createGain > "u" ? B.ctx.createGainNode() : B.ctx.createGain(), this._node.gain.setValueAtTime(O, B.ctx.currentTime), this._node.paused = !0, this._node.connect(B.masterGain)) : B.noAudio || (this._node = B._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(B._canPlayEvent, this._loadFn, !1), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, !1), this._node.src = _._src, this._node.preload = !0 === _._preload ? "auto" : _._preload, this._node.volume = O * B.volume(), this._node.load()), this
                        },
                        reset: function() {
                            var _ = this._parent;
                            return this._muted = _._muted, this._loop = _._loop, this._volume = _._volume, this._rate = _._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++B._counter, this
                        },
                        _errorListener: function() {
                            this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1)
                        },
                        _loadListener: function() {
                            var _ = this._parent;
                            _._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(_._sprite).length && (_._sprite = {
                                __default: [0, 1e3 * _._duration]
                            }), "loaded" !== _._state && (_._state = "loaded", _._emit("load"), _._loadQueue()), this._node.removeEventListener(B._canPlayEvent, this._loadFn, !1)
                        },
                        _endListener: function() {
                            var _ = this._parent;
                            _._duration === 1 / 0 && (_._duration = Math.ceil(10 * this._node.duration) / 10, _._sprite.__default[1] === 1 / 0 && (_._sprite.__default[1] = 1e3 * _._duration), _._ended(this)), this._node.removeEventListener("ended", this._endFn, !1)
                        }
                    }, F = {}, U = function(_) {
                        var O = _._src;
                        if (F[O]) {
                            _._duration = F[O].duration, Y(_);
                            return
                        }
                        if (/^data:[^;]+;base64,/.test(O)) {
                            for (var B = atob(O.split(",")[1]), N = new Uint8Array(B.length), k = 0; k < B.length; ++k) N[k] = B.charCodeAt(k);
                            G(N.buffer, _)
                        } else {
                            var U = new XMLHttpRequest;
                            U.open(_._xhr.method, O, !0), U.withCredentials = _._xhr.withCredentials, U.responseType = "arraybuffer", _._xhr.headers && Object.keys(_._xhr.headers).forEach(function(O) {
                                U.setRequestHeader(O, _._xhr.headers[O])
                            }), U.onload = function() {
                                var O = (U.status + "")[0];
                                if ("0" !== O && "2" !== O && "3" !== O) {
                                    _._emit("loaderror", null, "Failed loading audio file with status: " + U.status + ".");
                                    return
                                }
                                G(U.response, _)
                            }, U.onerror = function() {
                                _._webAudio && (_._html5 = !0, _._webAudio = !1, _._sounds = [], delete F[O], _.load())
                            }, j(U)
                        }
                    }, j = function(_) {
                        try {
                            _.send()
                        } catch {
                            _.onerror()
                        }
                    }, G = function(_, O) {
                        var d = function() {
                                O._emit("loaderror", null, "Decoding audio data failed.")
                            },
                            f = function(_) {
                                _ && O._sounds.length > 0 ? (F[O._src] = _, Y(O, _)) : d()
                            };
                        "u" > typeof Promise && 1 === B.ctx.decodeAudioData.length ? B.ctx.decodeAudioData(_).then(f).catch(d) : B.ctx.decodeAudioData(_, f, d)
                    }, Y = function(_, O) {
                        O && !_._duration && (_._duration = O.duration), 0 === Object.keys(_._sprite).length && (_._sprite = {
                            __default: [0, 1e3 * _._duration]
                        }), "loaded" !== _._state && (_._state = "loaded", _._emit("load"), _._loadQueue())
                    }, Q = function() {
                        if (B.usingWebAudio) {
                            try {
                                "u" > typeof AudioContext ? B.ctx = new AudioContext : "u" > typeof webkitAudioContext ? B.ctx = new webkitAudioContext : B.usingWebAudio = !1
                            } catch {
                                B.usingWebAudio = !1
                            }
                            B.ctx || (B.usingWebAudio = !1);
                            var _ = /iP(hone|od|ad)/.test(B._navigator && B._navigator.platform),
                                O = B._navigator && B._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                N = O ? parseInt(O[1], 10) : null;
                            if (_ && N && N < 9) {
                                var k = /safari/.test(B._navigator && B._navigator.userAgent.toLowerCase());
                                B._navigator && !k && (B.usingWebAudio = !1)
                            }
                            B.usingWebAudio && (B.masterGain = typeof B.ctx.createGain > "u" ? B.ctx.createGainNode() : B.ctx.createGain(), B.masterGain.gain.setValueAtTime(B._muted ? 0 : B._volume, B.ctx.currentTime), B.masterGain.connect(B.ctx.destination)), B._setup()
                        }
                    }, "function" == typeof define && define.amd && define([], function() {
                        return {
                            Howler: B,
                            Howl: N
                        }
                    }), "u" > typeof _ && (_.Howler = B, _.Howl = N), "u" > typeof global ? (global.HowlerGlobal = O, global.Howler = B, global.Howl = N, global.Sound = k) : "u" > typeof window && (window.HowlerGlobal = O, window.Howler = B, window.Howl = N, window.Sound = k), HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(_) {
                        if (!this.ctx || !this.ctx.listener) return this;
                        for (var O = this._howls.length - 1; O >= 0; O--) this._howls[O].stereo(_);
                        return this
                    }, HowlerGlobal.prototype.pos = function(_, O, B) {
                        return this.ctx && this.ctx.listener ? (O = "number" != typeof O ? this._pos[1] : O, B = "number" != typeof B ? this._pos[2] : B, "number" != typeof _) ? this._pos : (this._pos = [_, O, B], "u" > typeof this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this) : this
                    }, HowlerGlobal.prototype.orientation = function(_, O, B, N, k, F) {
                        if (!this.ctx || !this.ctx.listener) return this;
                        var U = this._orientation;
                        return (O = "number" != typeof O ? U[1] : O, B = "number" != typeof B ? U[2] : B, N = "number" != typeof N ? U[3] : N, k = "number" != typeof k ? U[4] : k, F = "number" != typeof F ? U[5] : F, "number" != typeof _) ? U : (this._orientation = [_, O, B, N, k, F], "u" > typeof this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(_, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(O, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(B, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(N, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(k, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(F, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(_, O, B, N, k, F), this)
                    }, Howl.prototype.init = (K = Howl.prototype.init, function(_) {
                        return this._orientation = _.orientation || [1, 0, 0], this._stereo = _.stereo || null, this._pos = _.pos || null, this._pannerAttr = {
                            coneInnerAngle: "u" > typeof _.coneInnerAngle ? _.coneInnerAngle : 360,
                            coneOuterAngle: "u" > typeof _.coneOuterAngle ? _.coneOuterAngle : 360,
                            coneOuterGain: "u" > typeof _.coneOuterGain ? _.coneOuterGain : 0,
                            distanceModel: "u" > typeof _.distanceModel ? _.distanceModel : "inverse",
                            maxDistance: "u" > typeof _.maxDistance ? _.maxDistance : 1e4,
                            panningModel: "u" > typeof _.panningModel ? _.panningModel : "HRTF",
                            refDistance: "u" > typeof _.refDistance ? _.refDistance : 1,
                            rolloffFactor: "u" > typeof _.rolloffFactor ? _.rolloffFactor : 1
                        }, this._onstereo = _.onstereo ? [{
                            fn: _.onstereo
                        }] : [], this._onpos = _.onpos ? [{
                            fn: _.onpos
                        }] : [], this._onorientation = _.onorientation ? [{
                            fn: _.onorientation
                        }] : [], K.call(this, _)
                    }), Howl.prototype.stereo = function(_, O) {
                        var B = this;
                        if (!B._webAudio) return B;
                        if ("loaded" !== B._state) return B._queue.push({
                            event: "stereo",
                            action: function() {
                                B.stereo(_, O)
                            }
                        }), B;
                        var N = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
                        if (typeof O > "u") {
                            if ("number" != typeof _) return B._stereo;
                            B._stereo = _, B._pos = [_, 0, 0]
                        }
                        for (var k = B._getSoundIds(O), F = 0; F < k.length; F++) {
                            var U = B._soundById(k[F]);
                            if (U) {
                                if ("number" != typeof _) return U._stereo;
                                U._stereo = _, U._pos = [_, 0, 0], U._node && (U._pannerAttr.panningModel = "equalpower", U._panner && U._panner.pan || et(U, N), "spatial" === N ? "u" > typeof U._panner.positionX ? (U._panner.positionX.setValueAtTime(_, Howler.ctx.currentTime), U._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), U._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : U._panner.setPosition(_, 0, 0) : U._panner.pan.setValueAtTime(_, Howler.ctx.currentTime)), B._emit("stereo", U._id)
                            }
                        }
                        return B
                    }, Howl.prototype.pos = function(_, O, B, N) {
                        var k = this;
                        if (!k._webAudio) return k;
                        if ("loaded" !== k._state) return k._queue.push({
                            event: "pos",
                            action: function() {
                                k.pos(_, O, B, N)
                            }
                        }), k;
                        if (O = "number" != typeof O ? 0 : O, B = "number" != typeof B ? -.5 : B, typeof N > "u") {
                            if ("number" != typeof _) return k._pos;
                            k._pos = [_, O, B]
                        }
                        for (var F = k._getSoundIds(N), U = 0; U < F.length; U++) {
                            var j = k._soundById(F[U]);
                            if (j) {
                                if ("number" != typeof _) return j._pos;
                                j._pos = [_, O, B], j._node && ((!j._panner || j._panner.pan) && et(j, "spatial"), "u" > typeof j._panner.positionX ? (j._panner.positionX.setValueAtTime(_, Howler.ctx.currentTime), j._panner.positionY.setValueAtTime(O, Howler.ctx.currentTime), j._panner.positionZ.setValueAtTime(B, Howler.ctx.currentTime)) : j._panner.setPosition(_, O, B)), k._emit("pos", j._id)
                            }
                        }
                        return k
                    }, Howl.prototype.orientation = function(_, O, B, N) {
                        var k = this;
                        if (!k._webAudio) return k;
                        if ("loaded" !== k._state) return k._queue.push({
                            event: "orientation",
                            action: function() {
                                k.orientation(_, O, B, N)
                            }
                        }), k;
                        if (O = "number" != typeof O ? k._orientation[1] : O, B = "number" != typeof B ? k._orientation[2] : B, typeof N > "u") {
                            if ("number" != typeof _) return k._orientation;
                            k._orientation = [_, O, B]
                        }
                        for (var F = k._getSoundIds(N), U = 0; U < F.length; U++) {
                            var j = k._soundById(F[U]);
                            if (j) {
                                if ("number" != typeof _) return j._orientation;
                                j._orientation = [_, O, B], j._node && (j._panner || (j._pos || (j._pos = k._pos || [0, 0, -.5]), et(j, "spatial")), "u" > typeof j._panner.orientationX ? (j._panner.orientationX.setValueAtTime(_, Howler.ctx.currentTime), j._panner.orientationY.setValueAtTime(O, Howler.ctx.currentTime), j._panner.orientationZ.setValueAtTime(B, Howler.ctx.currentTime)) : j._panner.setOrientation(_, O, B)), k._emit("orientation", j._id)
                            }
                        }
                        return k
                    }, Howl.prototype.pannerAttr = function() {
                        var _, O, B, N = arguments;
                        if (!this._webAudio) return this;
                        if (0 === N.length) return this._pannerAttr;
                        if (1 === N.length) {
                            if ("object" != typeof N[0]) return (B = this._soundById(parseInt(N[0], 10))) ? B._pannerAttr : this._pannerAttr;
                            _ = N[0], typeof O > "u" && (_.pannerAttr || (_.pannerAttr = {
                                coneInnerAngle: _.coneInnerAngle,
                                coneOuterAngle: _.coneOuterAngle,
                                coneOuterGain: _.coneOuterGain,
                                distanceModel: _.distanceModel,
                                maxDistance: _.maxDistance,
                                refDistance: _.refDistance,
                                rolloffFactor: _.rolloffFactor,
                                panningModel: _.panningModel
                            }), this._pannerAttr = {
                                coneInnerAngle: "u" > typeof _.pannerAttr.coneInnerAngle ? _.pannerAttr.coneInnerAngle : this._coneInnerAngle,
                                coneOuterAngle: "u" > typeof _.pannerAttr.coneOuterAngle ? _.pannerAttr.coneOuterAngle : this._coneOuterAngle,
                                coneOuterGain: "u" > typeof _.pannerAttr.coneOuterGain ? _.pannerAttr.coneOuterGain : this._coneOuterGain,
                                distanceModel: "u" > typeof _.pannerAttr.distanceModel ? _.pannerAttr.distanceModel : this._distanceModel,
                                maxDistance: "u" > typeof _.pannerAttr.maxDistance ? _.pannerAttr.maxDistance : this._maxDistance,
                                refDistance: "u" > typeof _.pannerAttr.refDistance ? _.pannerAttr.refDistance : this._refDistance,
                                rolloffFactor: "u" > typeof _.pannerAttr.rolloffFactor ? _.pannerAttr.rolloffFactor : this._rolloffFactor,
                                panningModel: "u" > typeof _.pannerAttr.panningModel ? _.pannerAttr.panningModel : this._panningModel
                            })
                        } else 2 === N.length && (_ = N[0], O = parseInt(N[1], 10));
                        for (var k = this._getSoundIds(O), F = 0; F < k.length; F++)
                            if (B = this._soundById(k[F])) {
                                var U = B._pannerAttr;
                                U = {
                                    coneInnerAngle: "u" > typeof _.coneInnerAngle ? _.coneInnerAngle : U.coneInnerAngle,
                                    coneOuterAngle: "u" > typeof _.coneOuterAngle ? _.coneOuterAngle : U.coneOuterAngle,
                                    coneOuterGain: "u" > typeof _.coneOuterGain ? _.coneOuterGain : U.coneOuterGain,
                                    distanceModel: "u" > typeof _.distanceModel ? _.distanceModel : U.distanceModel,
                                    maxDistance: "u" > typeof _.maxDistance ? _.maxDistance : U.maxDistance,
                                    refDistance: "u" > typeof _.refDistance ? _.refDistance : U.refDistance,
                                    rolloffFactor: "u" > typeof _.rolloffFactor ? _.rolloffFactor : U.rolloffFactor,
                                    panningModel: "u" > typeof _.panningModel ? _.panningModel : U.panningModel
                                };
                                var j = B._panner;
                                j ? (j.coneInnerAngle = U.coneInnerAngle, j.coneOuterAngle = U.coneOuterAngle, j.coneOuterGain = U.coneOuterGain, j.distanceModel = U.distanceModel, j.maxDistance = U.maxDistance, j.refDistance = U.refDistance, j.rolloffFactor = U.rolloffFactor, j.panningModel = U.panningModel) : (B._pos || (B._pos = this._pos || [0, 0, -.5]), et(B, "spatial"))
                            }
                        return this
                    }, Sound.prototype.init = ($ = Sound.prototype.init, function() {
                        var _ = this._parent;
                        this._orientation = _._orientation, this._stereo = _._stereo, this._pos = _._pos, this._pannerAttr = _._pannerAttr, $.call(this), this._stereo ? _.stereo(this._stereo) : this._pos && _.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
                    }), Sound.prototype.reset = (ee = Sound.prototype.reset, function() {
                        var _ = this._parent;
                        return this._orientation = _._orientation, this._stereo = _._stereo, this._pos = _._pos, this._pannerAttr = _._pannerAttr, this._stereo ? _.stereo(this._stereo) : this._pos ? _.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, _._refreshBuffer(this)), ee.call(this)
                    }), et = function(_, O) {
                        "spatial" === (O = O || "spatial") ? (_._panner = Howler.ctx.createPanner(), _._panner.coneInnerAngle = _._pannerAttr.coneInnerAngle, _._panner.coneOuterAngle = _._pannerAttr.coneOuterAngle, _._panner.coneOuterGain = _._pannerAttr.coneOuterGain, _._panner.distanceModel = _._pannerAttr.distanceModel, _._panner.maxDistance = _._pannerAttr.maxDistance, _._panner.refDistance = _._pannerAttr.refDistance, _._panner.rolloffFactor = _._pannerAttr.rolloffFactor, _._panner.panningModel = _._pannerAttr.panningModel, "u" > typeof _._panner.positionX ? (_._panner.positionX.setValueAtTime(_._pos[0], Howler.ctx.currentTime), _._panner.positionY.setValueAtTime(_._pos[1], Howler.ctx.currentTime), _._panner.positionZ.setValueAtTime(_._pos[2], Howler.ctx.currentTime)) : _._panner.setPosition(_._pos[0], _._pos[1], _._pos[2]), "u" > typeof _._panner.orientationX ? (_._panner.orientationX.setValueAtTime(_._orientation[0], Howler.ctx.currentTime), _._panner.orientationY.setValueAtTime(_._orientation[1], Howler.ctx.currentTime), _._panner.orientationZ.setValueAtTime(_._orientation[2], Howler.ctx.currentTime)) : _._panner.setOrientation(_._orientation[0], _._orientation[1], _._orientation[2])) : (_._panner = Howler.ctx.createStereoPanner(), _._panner.pan.setValueAtTime(_._stereo, Howler.ctx.currentTime)), _._panner.connect(_._node), _._paused || _._parent.pause(_._id, !0).play(_._id, !0)
                    }
                }),
                iE = Gn((_, O) => {
                    O.exports = function(_) {
                        for (var O = Array(_), B = 0; B < _; ++B) O[B] = B;
                        return O
                    }
                }),
                iD = Gn((_, O) => {
                    function JO(_) {
                        return !!_.constructor && "function" == typeof _.constructor.isBuffer && _.constructor.isBuffer(_)
                    }
                    O.exports = function(_) {
                        return null != _ && (JO(_) || "function" == typeof _.readFloatLE && "function" == typeof _.slice && JO(_.slice(0, 0)) || !!_._isBuffer)
                    }
                }),
                iP = Gn((_, O) => {
                    var B = iE(),
                        N = iD(),
                        k = "u" > typeof Float64Array;

                    function w7(_, O) {
                        return _[0] - O[0]
                    }

                    function S7() {
                        var _, O = this.stride,
                            B = Array(O.length);
                        for (_ = 0; _ < B.length; ++_) B[_] = [Math.abs(O[_]), _];
                        B.sort(w7);
                        var N = Array(B.length);
                        for (_ = 0; _ < N.length; ++_) N[_] = B[_][1];
                        return N
                    }
                    var F = {
                        float32: [],
                        float64: [],
                        int8: [],
                        int16: [],
                        int32: [],
                        uint8: [],
                        uint16: [],
                        uint32: [],
                        array: [],
                        uint8_clamped: [],
                        bigint64: [],
                        biguint64: [],
                        buffer: [],
                        generic: []
                    };
                    O.exports = function(_, O, U, j) {
                        if (void 0 === _) {
                            var G = F.array[0];
                            return G([])
                        }
                        "number" == typeof _ && (_ = [_]), void 0 === O && (O = [_.length]);
                        var Y = O.length;
                        if (void 0 === U) {
                            U = Array(Y);
                            for (var Q = Y - 1, K = 1; Q >= 0; --Q) U[Q] = K, K *= O[Q]
                        }
                        if (void 0 === j) {
                            j = 0;
                            for (var Q = 0; Q < Y; ++Q) U[Q] < 0 && (j -= (O[Q] - 1) * U[Q])
                        }
                        for (var $ = function(_) {
                                if (N(_)) return "buffer";
                                if (k) switch (Object.prototype.toString.call(_)) {
                                    case "[object Float64Array]":
                                        return "float64";
                                    case "[object Float32Array]":
                                        return "float32";
                                    case "[object Int8Array]":
                                        return "int8";
                                    case "[object Int16Array]":
                                        return "int16";
                                    case "[object Int32Array]":
                                        return "int32";
                                    case "[object Uint8Array]":
                                        return "uint8";
                                    case "[object Uint16Array]":
                                        return "uint16";
                                    case "[object Uint32Array]":
                                        return "uint32";
                                    case "[object Uint8ClampedArray]":
                                        return "uint8_clamped";
                                    case "[object BigInt64Array]":
                                        return "bigint64";
                                    case "[object BigUint64Array]":
                                        return "biguint64"
                                }
                                return Array.isArray(_) ? "array" : "generic"
                            }(_), ee = F[$]; ee.length <= Y + 1;) ee.push(function(_, O) {
                            var N = ["View", O, "d", _].join("");
                            O < 0 && (N = "View_Nil" + _);
                            var k = "generic" === _;
                            if (-1 === O) {
                                var U = "function " + N + "(a){this.data=a;};var proto=" + N + ".prototype;proto.dtype='" + _ + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + N + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + N + "(a){return new " + N + "(a);}",
                                    j = Function(U);
                                return j()
                            }
                            if (0 === O) {
                                var U = "function " + N + "(a,d) {this.data = a;this.offset = d};var proto=" + N + ".prototype;proto.dtype='" + _ + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + N + "_copy() {return new " + N + "(this.data,this.offset)};proto.pick=function " + N + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + N + "_get(){return " + (k ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + N + "_set(v){return " + (k ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + N + "(a,b,c,d){return new " + N + "(a,d)}",
                                    j = Function("TrivialArray", U);
                                return j(F[_][0])
                            }
                            var U = ["'use strict'"],
                                G = B(O),
                                Y = G.map(function(_) {
                                    return "i" + _
                                }),
                                Q = "this.offset+" + G.map(function(_) {
                                    return "this.stride[" + _ + "]*i" + _
                                }).join("+"),
                                K = G.map(function(_) {
                                    return "b" + _
                                }).join(","),
                                $ = G.map(function(_) {
                                    return "c" + _
                                }).join(",");
                            U.push("function " + N + "(a," + K + "," + $ + ",d){this.data=a", "this.shape=[" + K + "]", "this.stride=[" + $ + "]", "this.offset=d|0}", "var proto=" + N + ".prototype", "proto.dtype='" + _ + "'", "proto.dimension=" + O), U.push("Object.defineProperty(proto,'size',{get:function " + N + "_size(){return " + G.map(function(_) {
                                return "this.shape[" + _ + "]"
                            }).join("*"), "}})"), 1 === O ? U.push("proto.order=[0]") : (U.push("Object.defineProperty(proto,'order',{get:"), O < 4 ? (U.push("function " + N + "_order(){"), 2 === O ? U.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})") : 3 === O && U.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")) : U.push("ORDER})")), U.push("proto.set=function " + N + "_set(" + Y.join(",") + ",v){"), k ? U.push("return this.data.set(" + Q + ",v)}") : U.push("return this.data[" + Q + "]=v}"), U.push("proto.get=function " + N + "_get(" + Y.join(",") + "){"), k ? U.push("return this.data.get(" + Q + ")}") : U.push("return this.data[" + Q + "]}"), U.push("proto.index=function " + N + "_index(", Y.join(), "){return " + Q + "}"), U.push("proto.hi=function " + N + "_hi(" + Y.join(",") + "){return new " + N + "(this.data," + G.map(function(_) {
                                return ["(typeof i", _, "!=='number'||i", _, "<0)?this.shape[", _, "]:i", _, "|0"].join("")
                            }).join(",") + "," + G.map(function(_) {
                                return "this.stride[" + _ + "]"
                            }).join(",") + ",this.offset)}");
                            var ee = G.map(function(_) {
                                    return "a" + _ + "=this.shape[" + _ + "]"
                                }),
                                et = G.map(function(_) {
                                    return "c" + _ + "=this.stride[" + _ + "]"
                                });
                            U.push("proto.lo=function " + N + "_lo(" + Y.join(",") + "){var b=this.offset,d=0," + ee.join(",") + "," + et.join(","));
                            for (var ei = 0; ei < O; ++ei) U.push("if(typeof i" + ei + "==='number'&&i" + ei + ">=0){d=i" + ei + "|0;b+=c" + ei + "*d;a" + ei + "-=d}");
                            U.push("return new " + N + "(this.data," + G.map(function(_) {
                                return "a" + _
                            }).join(",") + "," + G.map(function(_) {
                                return "c" + _
                            }).join(",") + ",b)}"), U.push("proto.step=function " + N + "_step(" + Y.join(",") + "){var " + G.map(function(_) {
                                return "a" + _ + "=this.shape[" + _ + "]"
                            }).join(",") + "," + G.map(function(_) {
                                return "b" + _ + "=this.stride[" + _ + "]"
                            }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
                            for (var ei = 0; ei < O; ++ei) U.push("if(typeof i" + ei + "==='number'){d=i" + ei + "|0;if(d<0){c+=b" + ei + "*(a" + ei + "-1);a" + ei + "=ceil(-a" + ei + "/d)}else{a" + ei + "=ceil(a" + ei + "/d)}b" + ei + "*=d}");
                            U.push("return new " + N + "(this.data," + G.map(function(_) {
                                return "a" + _
                            }).join(",") + "," + G.map(function(_) {
                                return "b" + _
                            }).join(",") + ",c)}");
                            for (var er = Array(O), ea = Array(O), ei = 0; ei < O; ++ei) er[ei] = "a[i" + ei + "]", ea[ei] = "b[i" + ei + "]";
                            U.push("proto.transpose=function " + N + "_transpose(" + Y + "){" + Y.map(function(_, O) {
                                return _ + "=(" + _ + "===undefined?" + O + ":" + _ + "|0)"
                            }).join(";"), "var a=this.shape,b=this.stride;return new " + N + "(this.data," + er.join(",") + "," + ea.join(",") + ",this.offset)}"), U.push("proto.pick=function " + N + "_pick(" + Y + "){var a=[],b=[],c=this.offset");
                            for (var ei = 0; ei < O; ++ei) U.push("if(typeof i" + ei + "==='number'&&i" + ei + ">=0){c=(c+this.stride[" + ei + "]*i" + ei + ")|0}else{a.push(this.shape[" + ei + "]);b.push(this.stride[" + ei + "])}");
                            U.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"), U.push("return function construct_" + N + "(data,shape,stride,offset){return new " + N + "(data," + G.map(function(_) {
                                return "shape[" + _ + "]"
                            }).join(",") + "," + G.map(function(_) {
                                return "stride[" + _ + "]"
                            }).join(",") + ",offset)}");
                            var j = Function("CTOR_LIST", "ORDER", U.join(`
`));
                            return j(F[_], S7)
                        }($, ee.length - 1));
                        var G = ee[Y + 1];
                        return G(_, O, U, j)
                    }
                }),
                iO = Gn((_, O) => {
                    O.exports = function(_, O, B) {
                        return 0 === _.length ? _ : O ? (B || _.sort(O), function(_, O) {
                            for (var B = 1, N = _.length, k = _[0], F = _[0], U = 1; U < N; ++U)
                                if (F = k, O(k = _[U], F)) {
                                    if (U === B) {
                                        B++;
                                        continue
                                    }
                                    _[B++] = k
                                }
                            return _.length = B, _
                        }(_, O)) : (B || _.sort(), function(_) {
                            for (var O = 1, B = _.length, N = _[0], k = _[0], F = 1; F < B; ++F, k = N)
                                if (k = N, (N = _[F]) !== k) {
                                    if (F === O) {
                                        O++;
                                        continue
                                    }
                                    _[O++] = N
                                }
                            return _.length = O, _
                        }(_))
                    }
                }),
                iB = Gn((_, O) => {
                    var B = iO();

                    function iR(_, O, B) {
                        var N, k, F = _.length,
                            U = O.arrayArgs.length,
                            j = O.indexArgs.length > 0,
                            G = [],
                            Y = [],
                            Q = 0,
                            K = 0;
                        for (N = 0; N < F; ++N) Y.push(["i", N, "=0"].join(""));
                        for (k = 0; k < U; ++k)
                            for (N = 0; N < F; ++N) K = Q, Q = _[N], 0 === N ? Y.push(["d", k, "s", N, "=t", k, "p", Q].join("")) : Y.push(["d", k, "s", N, "=(t", k, "p", Q, "-s", K, "*t", k, "p", K, ")"].join(""));
                        for (Y.length > 0 && G.push("var " + Y.join(",")), N = F - 1; N >= 0; --N) Q = _[N], G.push(["for(i", N, "=0;i", N, "<s", Q, ";++i", N, "){"].join(""));
                        for (G.push(B), N = 0; N < F; ++N) {
                            for (K = Q, Q = _[N], k = 0; k < U; ++k) G.push(["p", k, "+=d", k, "s", N].join(""));
                            j && (N > 0 && G.push(["index[", K, "]-=s", K].join("")), G.push(["++index[", Q, "]"].join(""))), G.push("}")
                        }
                        return G.join(`
`)
                    }

                    function a1(_, O, B) {
                        for (var N = _.body, k = [], F = [], U = 0; U < _.args.length; ++U) {
                            var j = _.args[U];
                            if (!(j.count <= 0)) {
                                var G = RegExp(j.name, "g"),
                                    Y = "",
                                    Q = O.arrayArgs.indexOf(U);
                                switch (O.argTypes[U]) {
                                    case "offset":
                                        var K = O.offsetArgIndex.indexOf(U);
                                        Q = O.offsetArgs[K].array, Y = "+q" + K;
                                    case "array":
                                        Y = "p" + Q + Y;
                                        var $ = "l" + U,
                                            ee = "a" + Q;
                                        if (0 === O.arrayBlockIndices[Q]) 1 === j.count ? "generic" === B[Q] ? j.lvalue ? (k.push(["var ", $, "=", ee, ".get(", Y, ")"].join("")), N = N.replace(G, $), F.push([ee, ".set(", Y, ",", $, ")"].join(""))) : N = N.replace(G, [ee, ".get(", Y, ")"].join("")) : N = N.replace(G, [ee, "[", Y, "]"].join("")) : "generic" === B[Q] ? (k.push(["var ", $, "=", ee, ".get(", Y, ")"].join("")), N = N.replace(G, $), j.lvalue && F.push([ee, ".set(", Y, ",", $, ")"].join(""))) : (k.push(["var ", $, "=", ee, "[", Y, "]"].join("")), N = N.replace(G, $), j.lvalue && F.push([ee, "[", Y, "]=", $].join("")));
                                        else {
                                            for (var et = [j.name], ei = [Y], er = 0; er < Math.abs(O.arrayBlockIndices[Q]); er++) et.push("\\s*\\[([^\\]]+)\\]"), ei.push("$" + (er + 1) + "*t" + Q + "b" + er);
                                            if (G = RegExp(et.join(""), "g"), Y = ei.join("+"), "generic" === B[Q]) throw Error("cwise: Generic arrays not supported in combination with blocks!");
                                            N = N.replace(G, [ee, "[", Y, "]"].join(""))
                                        }
                                        break;
                                    case "scalar":
                                        N = N.replace(G, "Y" + O.scalarArgs.indexOf(U));
                                        break;
                                    case "index":
                                        N = N.replace(G, "index");
                                        break;
                                    case "shape":
                                        N = N.replace(G, "shape")
                                }
                            }
                        }
                        return [k.join(`
`), N, F.join(`
`)].join(`
`).trim()
                    }
                    O.exports = function(_, O) {
                        for (var N = O[1].length - Math.abs(_.arrayBlockIndices[0]) | 0, k = Array(_.arrayArgs.length), F = Array(_.arrayArgs.length), U = 0; U < _.arrayArgs.length; ++U) F[U] = O[2 * U], k[U] = O[2 * U + 1];
                        for (var j = [], G = [], Y = [], Q = [], K = [], U = 0; U < _.arrayArgs.length; ++U) {
                            _.arrayBlockIndices[U] < 0 ? (Y.push(0), Q.push(N), j.push(N), G.push(N + _.arrayBlockIndices[U])) : (Y.push(_.arrayBlockIndices[U]), Q.push(_.arrayBlockIndices[U] + N), j.push(0), G.push(_.arrayBlockIndices[U]));
                            for (var $ = [], ee = 0; ee < k[U].length; ee++) Y[U] <= k[U][ee] && k[U][ee] < Q[U] && $.push(k[U][ee] - Y[U]);
                            K.push($)
                        }
                        for (var et = ["SS"], ei = ["'use strict'"], er = [], ee = 0; ee < N; ++ee) er.push(["s", ee, "=SS[", ee, "]"].join(""));
                        for (var U = 0; U < _.arrayArgs.length; ++U) {
                            et.push("a" + U), et.push("t" + U), et.push("p" + U);
                            for (var ee = 0; ee < N; ++ee) er.push(["t", U, "p", ee, "=t", U, "[", Y[U] + ee, "]"].join(""));
                            for (var ee = 0; ee < Math.abs(_.arrayBlockIndices[U]); ++ee) er.push(["t", U, "b", ee, "=t", U, "[", j[U] + ee, "]"].join(""))
                        }
                        for (var U = 0; U < _.scalarArgs.length; ++U) et.push("Y" + U);
                        if (_.shapeArgs.length > 0 && er.push("shape=SS.slice(0)"), _.indexArgs.length > 0) {
                            for (var ea = Array(N), U = 0; U < N; ++U) ea[U] = "0";
                            er.push(["index=[", ea.join(","), "]"].join(""))
                        }
                        for (var U = 0; U < _.offsetArgs.length; ++U) {
                            for (var en = _.offsetArgs[U], eo = [], ee = 0; ee < en.offset.length; ++ee) 0 !== en.offset[ee] && (1 === en.offset[ee] ? eo.push(["t", en.array, "p", ee].join("")) : eo.push([en.offset[ee], "*t", en.array, "p", ee].join("")));
                            0 === eo.length ? er.push("q" + U + "=0") : er.push(["q", U, "=", eo.join("+")].join(""))
                        }
                        var el = B([].concat(_.pre.thisVars).concat(_.body.thisVars).concat(_.post.thisVars));
                        (er = er.concat(el)).length > 0 && ei.push("var " + er.join(","));
                        for (var U = 0; U < _.arrayArgs.length; ++U) ei.push("p" + U + "|=0");
                        _.pre.body.length > 3 && ei.push(a1(_.pre, _, F));
                        var eh = a1(_.body, _, F),
                            ec = function(_) {
                                for (var O = 0, B = _[0].length; O < B;) {
                                    for (var N = 1; N < _.length; ++N)
                                        if (_[N][O] !== _[0][O]) return O;
                                    ++O
                                }
                                return O
                            }(K);
                        ec < N ? ei.push(function(_, O, B, N) {
                            for (var k = O.length, F = B.arrayArgs.length, U = B.blockSize, j = B.indexArgs.length > 0, G = [], Y = 0; Y < F; ++Y) G.push(["var offset", Y, "=p", Y].join(""));
                            for (var Y = _; Y < k; ++Y) G.push(["for(var j" + Y + "=SS[", O[Y], "]|0;j", Y, ">0;){"].join("")), G.push(["if(j", Y, "<", U, "){"].join("")), G.push(["s", O[Y], "=j", Y].join("")), G.push(["j", Y, "=0"].join("")), G.push(["}else{s", O[Y], "=", U].join("")), G.push(["j", Y, "-=", U, "}"].join("")), j && G.push(["index[", O[Y], "]=j", Y].join(""));
                            for (var Y = 0; Y < F; ++Y) {
                                for (var Q = ["offset" + Y], K = _; K < k; ++K) Q.push(["j", K, "*t", Y, "p", O[K]].join(""));
                                G.push(["p", Y, "=(", Q.join("+"), ")"].join(""))
                            }
                            G.push(iR(O, B, N));
                            for (var Y = _; Y < k; ++Y) G.push("}");
                            return G.join(`
`)
                        }(ec, K[0], _, eh)) : ei.push(iR(K[0], _, eh)), _.post.body.length > 3 && ei.push(a1(_.post, _, F)), _.debug && console.log("-----Generated cwise routine for ", O, `:
` + ei.join(`
`) + `
----------`);
                        var eu = [_.funcName || "unnamed", "_cwise_loop_", k[0].join("s"), "m", ec, function(_) {
                            for (var O = Array(_.length), B = !0, N = 0; N < _.length; ++N) {
                                var k = _[N],
                                    F = k.match(/\d+/);
                                F = F ? F[0] : "", 0 === k.charAt(0) ? O[N] = "u" + k.charAt(1) + F : O[N] = k.charAt(0) + F, N > 0 && (B = B && O[N] === O[N - 1])
                            }
                            return B ? O[0] : O.join("")
                        }(F)].join("");
                        return Function(["function ", eu, "(", et.join(","), "){", ei.join(`
`), "} return ", eu].join(""))()
                    }
                }),
                iN = Gn((_, O) => {
                    var B = iB();
                    O.exports = function(_) {
                        var O = ["'use strict'", "var CACHED={}"],
                            N = [];
                        O.push(["return function ", _.funcName + "_cwise_thunk", "(", _.shimArgs.join(","), "){"].join(""));
                        for (var k = [], F = [], U = [
                                ["array", _.arrayArgs[0], ".shape.slice(", Math.max(0, _.arrayBlockIndices[0]), _.arrayBlockIndices[0] < 0 ? "," + _.arrayBlockIndices[0] + ")" : ")"].join("")
                            ], j = [], G = [], Y = 0; Y < _.arrayArgs.length; ++Y) {
                            var Q = _.arrayArgs[Y];
                            N.push(["t", Q, "=array", Q, ".dtype,", "r", Q, "=array", Q, ".order"].join("")), k.push("t" + Q), k.push("r" + Q), F.push("t" + Q), F.push("r" + Q + ".join()"), U.push("array" + Q + ".data"), U.push("array" + Q + ".stride"), U.push("array" + Q + ".offset|0"), Y > 0 && (j.push("array" + _.arrayArgs[0] + ".shape.length===array" + Q + ".shape.length+" + (Math.abs(_.arrayBlockIndices[0]) - Math.abs(_.arrayBlockIndices[Y]))), G.push("array" + _.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, _.arrayBlockIndices[0]) + "]===array" + Q + ".shape[shapeIndex+" + Math.max(0, _.arrayBlockIndices[Y]) + "]"))
                        }
                        _.arrayArgs.length > 1 && (O.push("if (!(" + j.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"), O.push("for(var shapeIndex=array" + _.arrayArgs[0] + ".shape.length-" + Math.abs(_.arrayBlockIndices[0]) + "; shapeIndex-->0;) {"), O.push("if (!(" + G.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')"), O.push("}"));
                        for (var Y = 0; Y < _.scalarArgs.length; ++Y) U.push("scalar" + _.scalarArgs[Y]);
                        return N.push(["type=[", F.join(","), "].join()"].join("")), N.push("proc=CACHED[type]"), O.push("var " + N.join(",")), O.push(["if(!proc){", "CACHED[type]=proc=compile([", k.join(","), "])}", "return proc(", U.join(","), ")}"].join("")), _.debug && console.log(`-----Generated thunk:
` + O.join(`
`) + `
----------`), Function("compile", O.join(`
`))(B.bind(void 0, _))
                    }
                }),
                ik = Gn((_, O) => {
                    var B = iN();

                    function F7() {
                        this.argTypes = [], this.shimArgs = [], this.arrayArgs = [], this.arrayBlockIndices = [], this.scalarArgs = [], this.offsetArgs = [], this.offsetArgIndex = [], this.indexArgs = [], this.shapeArgs = [], this.funcName = "", this.pre = null, this.body = null, this.post = null, this.debug = !1
                    }
                    O.exports = function(_) {
                        var O = new F7;
                        O.pre = _.pre, O.body = _.body, O.post = _.post;
                        var N = _.args.slice(0);
                        O.argTypes = N;
                        for (var k = 0; k < N.length; ++k) {
                            var F = N[k];
                            if ("array" === F || "object" == typeof F && F.blockIndices) {
                                if (O.argTypes[k] = "array", O.arrayArgs.push(k), O.arrayBlockIndices.push(F.blockIndices ? F.blockIndices : 0), O.shimArgs.push("array" + k), k < O.pre.args.length && O.pre.args[k].count > 0) throw Error("cwise: pre() block may not reference array args");
                                if (k < O.post.args.length && O.post.args[k].count > 0) throw Error("cwise: post() block may not reference array args")
                            } else if ("scalar" === F) O.scalarArgs.push(k), O.shimArgs.push("scalar" + k);
                            else if ("index" === F) {
                                if (O.indexArgs.push(k), k < O.pre.args.length && O.pre.args[k].count > 0) throw Error("cwise: pre() block may not reference array index");
                                if (k < O.body.args.length && O.body.args[k].lvalue) throw Error("cwise: body() block may not write to array index");
                                if (k < O.post.args.length && O.post.args[k].count > 0) throw Error("cwise: post() block may not reference array index")
                            } else if ("shape" === F) {
                                if (O.shapeArgs.push(k), k < O.pre.args.length && O.pre.args[k].lvalue) throw Error("cwise: pre() block may not write to array shape");
                                if (k < O.body.args.length && O.body.args[k].lvalue) throw Error("cwise: body() block may not write to array shape");
                                if (k < O.post.args.length && O.post.args[k].lvalue) throw Error("cwise: post() block may not write to array shape")
                            } else if ("object" == typeof F && F.offset) O.argTypes[k] = "offset", O.offsetArgs.push({
                                array: F.array,
                                offset: F.offset
                            }), O.offsetArgIndex.push(k);
                            else throw Error("cwise: Unknown argument type " + N[k])
                        }
                        if (O.arrayArgs.length <= 0) throw Error("cwise: No array arguments specified");
                        if (O.pre.args.length > N.length) throw Error("cwise: Too many arguments in pre() block");
                        if (O.body.args.length > N.length) throw Error("cwise: Too many arguments in body() block");
                        if (O.post.args.length > N.length) throw Error("cwise: Too many arguments in post() block");
                        return O.debug = !!_.printCode || !!_.debug, O.funcName = _.funcName || "cwise", O.blockSize = _.blockSize || 64, B(O)
                    }
                }),
                iF = Gn(_ => {
                    var O = ik(),
                        B = {
                            body: "",
                            args: [],
                            thisVars: [],
                            localVars: []
                        };

                    function l1(_) {
                        if (!_) return B;
                        for (var O = 0; O < _.args.length; ++O) {
                            var N = _.args[O];
                            0 === O ? _.args[O] = {
                                name: N,
                                lvalue: !0,
                                rvalue: !!_.rvalue,
                                count: _.count || 1
                            } : _.args[O] = {
                                name: N,
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }
                        }
                        return _.thisVars || (_.thisVars = []), _.localVars || (_.localVars = []), _
                    }

                    function Sr(_) {
                        for (var B = [], N = 0; N < _.args.length; ++N) B.push("a" + N);
                        return Function("P", ["return function ", _.funcName, "_ndarrayops(", B.join(","), ") {P(", B.join(","), ");return a0}"].join(""))(O({
                            args: _.args,
                            pre: l1(_.pre),
                            body: l1(_.body),
                            post: l1(_.proc),
                            funcName: _.funcName
                        }))
                    }
                    var N = {
                        add: "+",
                        sub: "-",
                        mul: "*",
                        div: "/",
                        mod: "%",
                        band: "&",
                        bor: "|",
                        bxor: "^",
                        lshift: "<<",
                        rshift: ">>",
                        rrshift: ">>>"
                    };
                    ! function() {
                        for (var O in N) {
                            var B = N[O];
                            _[O] = Sr({
                                args: ["array", "array", "array"],
                                body: {
                                    args: ["a", "b", "c"],
                                    body: "a=b" + B + "c"
                                },
                                funcName: O
                            }), _[O + "eq"] = Sr({
                                args: ["array", "array"],
                                body: {
                                    args: ["a", "b"],
                                    body: "a" + B + "=b"
                                },
                                rvalue: !0,
                                funcName: O + "eq"
                            }), _[O + "s"] = Sr({
                                args: ["array", "array", "scalar"],
                                body: {
                                    args: ["a", "b", "s"],
                                    body: "a=b" + B + "s"
                                },
                                funcName: O + "s"
                            }), _[O + "seq"] = Sr({
                                args: ["array", "scalar"],
                                body: {
                                    args: ["a", "s"],
                                    body: "a" + B + "=s"
                                },
                                rvalue: !0,
                                funcName: O + "seq"
                            })
                        }
                    }();
                    var k = {
                        not: "!",
                        bnot: "~",
                        neg: "-",
                        recip: "1.0/"
                    };
                    ! function() {
                        for (var O in k) {
                            var B = k[O];
                            _[O] = Sr({
                                args: ["array", "array"],
                                body: {
                                    args: ["a", "b"],
                                    body: "a=" + B + "b"
                                },
                                funcName: O
                            }), _[O + "eq"] = Sr({
                                args: ["array"],
                                body: {
                                    args: ["a"],
                                    body: "a=" + B + "a"
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: O + "eq"
                            })
                        }
                    }();
                    var F = {
                        and: "&&",
                        or: "||",
                        eq: "===",
                        neq: "!==",
                        lt: "<",
                        gt: ">",
                        leq: "<=",
                        geq: ">="
                    };
                    ! function() {
                        for (var O in F) {
                            var B = F[O];
                            _[O] = Sr({
                                args: ["array", "array", "array"],
                                body: {
                                    args: ["a", "b", "c"],
                                    body: "a=b" + B + "c"
                                },
                                funcName: O
                            }), _[O + "s"] = Sr({
                                args: ["array", "array", "scalar"],
                                body: {
                                    args: ["a", "b", "s"],
                                    body: "a=b" + B + "s"
                                },
                                funcName: O + "s"
                            }), _[O + "eq"] = Sr({
                                args: ["array", "array"],
                                body: {
                                    args: ["a", "b"],
                                    body: "a=a" + B + "b"
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: O + "eq"
                            }), _[O + "seq"] = Sr({
                                args: ["array", "scalar"],
                                body: {
                                    args: ["a", "s"],
                                    body: "a=a" + B + "s"
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: O + "seq"
                            })
                        }
                    }();
                    var U = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan"];
                    ! function() {
                        for (var O = 0; O < U.length; ++O) {
                            var B = U[O];
                            _[B] = Sr({
                                args: ["array", "array"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b"],
                                    body: "a=this_f(b)",
                                    thisVars: ["this_f"]
                                },
                                funcName: B
                            }), _[B + "eq"] = Sr({
                                args: ["array"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a"],
                                    body: "a=this_f(a)",
                                    thisVars: ["this_f"]
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: B + "eq"
                            })
                        }
                    }();
                    var j = ["max", "min", "atan2", "pow"];
                    ! function() {
                        for (var O = 0; O < j.length; ++O) {
                            var B = j[O];
                            _[B] = Sr({
                                args: ["array", "array", "array"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b", "c"],
                                    body: "a=this_f(b,c)",
                                    thisVars: ["this_f"]
                                },
                                funcName: B
                            }), _[B + "s"] = Sr({
                                args: ["array", "array", "scalar"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b", "c"],
                                    body: "a=this_f(b,c)",
                                    thisVars: ["this_f"]
                                },
                                funcName: B + "s"
                            }), _[B + "eq"] = Sr({
                                args: ["array", "array"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b"],
                                    body: "a=this_f(a,b)",
                                    thisVars: ["this_f"]
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: B + "eq"
                            }), _[B + "seq"] = Sr({
                                args: ["array", "scalar"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b"],
                                    body: "a=this_f(a,b)",
                                    thisVars: ["this_f"]
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: B + "seq"
                            })
                        }
                    }();
                    var G = ["atan2", "pow"];
                    ! function() {
                        for (var O = 0; O < G.length; ++O) {
                            var B = G[O];
                            _[B + "op"] = Sr({
                                args: ["array", "array", "array"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b", "c"],
                                    body: "a=this_f(c,b)",
                                    thisVars: ["this_f"]
                                },
                                funcName: B + "op"
                            }), _[B + "ops"] = Sr({
                                args: ["array", "array", "scalar"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b", "c"],
                                    body: "a=this_f(c,b)",
                                    thisVars: ["this_f"]
                                },
                                funcName: B + "ops"
                            }), _[B + "opeq"] = Sr({
                                args: ["array", "array"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b"],
                                    body: "a=this_f(b,a)",
                                    thisVars: ["this_f"]
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: B + "opeq"
                            }), _[B + "opseq"] = Sr({
                                args: ["array", "scalar"],
                                pre: {
                                    args: [],
                                    body: "this_f=Math." + B,
                                    thisVars: ["this_f"]
                                },
                                body: {
                                    args: ["a", "b"],
                                    body: "a=this_f(b,a)",
                                    thisVars: ["this_f"]
                                },
                                rvalue: !0,
                                count: 2,
                                funcName: B + "opseq"
                            })
                        }
                    }(), _.any = O({
                        args: ["array"],
                        pre: B,
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            body: "if(a){return true}",
                            localVars: [],
                            thisVars: []
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: [],
                            body: "return false"
                        },
                        funcName: "any"
                    }), _.all = O({
                        args: ["array"],
                        pre: B,
                        body: {
                            args: [{
                                name: "x",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            body: "if(!x){return false}",
                            localVars: [],
                            thisVars: []
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: [],
                            body: "return true"
                        },
                        funcName: "all"
                    }), _.sum = O({
                        args: ["array"],
                        pre: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "this_s=0"
                        },
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            body: "this_s+=a",
                            localVars: [],
                            thisVars: ["this_s"]
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "return this_s"
                        },
                        funcName: "sum"
                    }), _.prod = O({
                        args: ["array"],
                        pre: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "this_s=1"
                        },
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            body: "this_s*=a",
                            localVars: [],
                            thisVars: ["this_s"]
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "return this_s"
                        },
                        funcName: "prod"
                    }), _.norm2squared = O({
                        args: ["array"],
                        pre: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "this_s=0"
                        },
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }],
                            body: "this_s+=a*a",
                            localVars: [],
                            thisVars: ["this_s"]
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "return this_s"
                        },
                        funcName: "norm2squared"
                    }), _.norm2 = O({
                        args: ["array"],
                        pre: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "this_s=0"
                        },
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }],
                            body: "this_s+=a*a",
                            localVars: [],
                            thisVars: ["this_s"]
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "return Math.sqrt(this_s)"
                        },
                        funcName: "norm2"
                    }), _.norminf = O({
                        args: ["array"],
                        pre: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "this_s=0"
                        },
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 4
                            }],
                            body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
                            localVars: [],
                            thisVars: ["this_s"]
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "return this_s"
                        },
                        funcName: "norminf"
                    }), _.norm1 = O({
                        args: ["array"],
                        pre: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "this_s=0"
                        },
                        body: {
                            args: [{
                                name: "a",
                                lvalue: !1,
                                rvalue: !0,
                                count: 3
                            }],
                            body: "this_s+=a<0?-a:a",
                            localVars: [],
                            thisVars: ["this_s"]
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: ["this_s"],
                            body: "return this_s"
                        },
                        funcName: "norm1"
                    }), _.sup = O({
                        args: ["array"],
                        pre: {
                            body: "this_h=-Infinity",
                            args: [],
                            thisVars: ["this_h"],
                            localVars: []
                        },
                        body: {
                            body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
                            args: [{
                                name: "_inline_1_arg0_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }],
                            thisVars: ["this_h"],
                            localVars: []
                        },
                        post: {
                            body: "return this_h",
                            args: [],
                            thisVars: ["this_h"],
                            localVars: []
                        }
                    }), _.inf = O({
                        args: ["array"],
                        pre: {
                            body: "this_h=Infinity",
                            args: [],
                            thisVars: ["this_h"],
                            localVars: []
                        },
                        body: {
                            body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
                            args: [{
                                name: "_inline_1_arg0_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }],
                            thisVars: ["this_h"],
                            localVars: []
                        },
                        post: {
                            body: "return this_h",
                            args: [],
                            thisVars: ["this_h"],
                            localVars: []
                        }
                    }), _.argmin = O({
                        args: ["index", "array", "shape"],
                        pre: {
                            body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
                            args: [{
                                name: "_inline_0_arg0_",
                                lvalue: !1,
                                rvalue: !1,
                                count: 0
                            }, {
                                name: "_inline_0_arg1_",
                                lvalue: !1,
                                rvalue: !1,
                                count: 0
                            }, {
                                name: "_inline_0_arg2_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            thisVars: ["this_i", "this_v"],
                            localVars: []
                        },
                        body: {
                            body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                            args: [{
                                name: "_inline_1_arg0_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }, {
                                name: "_inline_1_arg1_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }],
                            thisVars: ["this_i", "this_v"],
                            localVars: ["_inline_1_k"]
                        },
                        post: {
                            body: "{return this_i}",
                            args: [],
                            thisVars: ["this_i"],
                            localVars: []
                        }
                    }), _.argmax = O({
                        args: ["index", "array", "shape"],
                        pre: {
                            body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
                            args: [{
                                name: "_inline_0_arg0_",
                                lvalue: !1,
                                rvalue: !1,
                                count: 0
                            }, {
                                name: "_inline_0_arg1_",
                                lvalue: !1,
                                rvalue: !1,
                                count: 0
                            }, {
                                name: "_inline_0_arg2_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            thisVars: ["this_i", "this_v"],
                            localVars: []
                        },
                        body: {
                            body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                            args: [{
                                name: "_inline_1_arg0_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }, {
                                name: "_inline_1_arg1_",
                                lvalue: !1,
                                rvalue: !0,
                                count: 2
                            }],
                            thisVars: ["this_i", "this_v"],
                            localVars: ["_inline_1_k"]
                        },
                        post: {
                            body: "{return this_i}",
                            args: [],
                            thisVars: ["this_i"],
                            localVars: []
                        }
                    }), _.random = Sr({
                        args: ["array"],
                        pre: {
                            args: [],
                            body: "this_f=Math.random",
                            thisVars: ["this_f"]
                        },
                        body: {
                            args: ["a"],
                            body: "a=this_f()",
                            thisVars: ["this_f"]
                        },
                        funcName: "random"
                    }), _.assign = Sr({
                        args: ["array", "array"],
                        body: {
                            args: ["a", "b"],
                            body: "a=b"
                        },
                        funcName: "assign"
                    }), _.assigns = Sr({
                        args: ["array", "scalar"],
                        body: {
                            args: ["a", "b"],
                            body: "a=b"
                        },
                        funcName: "assigns"
                    }), _.equals = O({
                        args: ["array", "array"],
                        pre: B,
                        body: {
                            args: [{
                                name: "x",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }, {
                                name: "y",
                                lvalue: !1,
                                rvalue: !0,
                                count: 1
                            }],
                            body: "if(x!==y){return false}",
                            localVars: [],
                            thisVars: []
                        },
                        post: {
                            args: [],
                            localVars: [],
                            thisVars: [],
                            body: "return true"
                        },
                        funcName: "equals"
                    })
                }),
                iU = Gn((_, O) => {
                    O.exports = function(_, O) {
                        for (var B = _.split("."), N = O.split("."), k = 0; k < 3; k++) {
                            var F = Number(B[k]),
                                U = Number(N[k]);
                            if (F > U) return 1;
                            if (U > F) return -1;
                            if (!isNaN(F) && isNaN(U)) return 1;
                            if (isNaN(F) && !isNaN(U)) return -1
                        }
                        return 0
                    }
                }),
                ij = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                iG = "srgb",
                iH = "srgb-linear",
                iW = "300 es",
                iq = class {
                    addEventListener(_, O) {
                        void 0 === this._listeners && (this._listeners = {});
                        let B = this._listeners;
                        void 0 === B[_] && (B[_] = []), -1 === B[_].indexOf(O) && B[_].push(O)
                    }
                    hasEventListener(_, O) {
                        if (void 0 === this._listeners) return !1;
                        let B = this._listeners;
                        return void 0 !== B[_] && -1 !== B[_].indexOf(O)
                    }
                    removeEventListener(_, O) {
                        if (void 0 === this._listeners) return;
                        let B = this._listeners[_];
                        if (void 0 !== B) {
                            let _ = B.indexOf(O); - 1 !== _ && B.splice(_, 1)
                        }
                    }
                    dispatchEvent(_) {
                        if (void 0 === this._listeners) return;
                        let O = this._listeners[_.type];
                        if (void 0 !== O) {
                            _.target = this;
                            let B = O.slice(0);
                            for (let O = 0, N = B.length; O < N; O++) B[O].call(this, _);
                            _.target = null
                        }
                    }
                },
                iY = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
                iX = 1234567,
                iQ = Math.PI / 180,
                iZ = 180 / Math.PI;

            function Ui() {
                let _ = 4294967295 * Math.random() | 0,
                    O = 4294967295 * Math.random() | 0,
                    B = 4294967295 * Math.random() | 0,
                    N = 4294967295 * Math.random() | 0;
                return (iY[255 & _] + iY[_ >> 8 & 255] + iY[_ >> 16 & 255] + iY[_ >> 24 & 255] + "-" + iY[255 & O] + iY[O >> 8 & 255] + "-" + iY[O >> 16 & 15 | 64] + iY[O >> 24 & 255] + "-" + iY[63 & B | 128] + iY[B >> 8 & 255] + "-" + iY[B >> 16 & 255] + iY[B >> 24 & 255] + iY[255 & N] + iY[N >> 8 & 255] + iY[N >> 16 & 255] + iY[N >> 24 & 255]).toLowerCase()
            }

            function Yr(_, O, B) {
                return Math.max(O, Math.min(B, _))
            }

            function $b(_, O) {
                return (_ % O + O) % O
            }

            function Cf(_, O, B) {
                return (1 - B) * _ + B * O
            }

            function xb(_) {
                return (_ & _ - 1) == 0 && 0 !== _
            }

            function rM(_) {
                return Math.pow(2, Math.ceil(Math.log(_) / Math.LN2))
            }

            function dg(_) {
                return Math.pow(2, Math.floor(Math.log(_) / Math.LN2))
            }

            function zo(_, O) {
                switch (O.constructor) {
                    case Float32Array:
                        return _;
                    case Uint16Array:
                        return _ / 65535;
                    case Uint8Array:
                        return _ / 255;
                    case Int16Array:
                        return Math.max(_ / 32767, -1);
                    case Int8Array:
                        return Math.max(_ / 127, -1);
                    default:
                        throw Error("Invalid component type.")
                }
            }

            function Kt(_, O) {
                switch (O.constructor) {
                    case Float32Array:
                        return _;
                    case Uint16Array:
                        return Math.round(65535 * _);
                    case Uint8Array:
                        return Math.round(255 * _);
                    case Int16Array:
                        return Math.round(32767 * _);
                    case Int8Array:
                        return Math.round(127 * _);
                    default:
                        throw Error("Invalid component type.")
                }
            }
            var iK = Object.freeze({
                    __proto__: null,
                    DEG2RAD: iQ,
                    RAD2DEG: iZ,
                    ceilPowerOfTwo: rM,
                    clamp: Yr,
                    damp: function(_, O, B, N) {
                        return Cf(_, O, 1 - Math.exp(-B * N))
                    },
                    degToRad: function(_) {
                        return _ * iQ
                    },
                    denormalize: zo,
                    euclideanModulo: $b,
                    floorPowerOfTwo: dg,
                    generateUUID: Ui,
                    inverseLerp: function(_, O, B) {
                        return _ !== O ? (B - _) / (O - _) : 0
                    },
                    isPowerOfTwo: xb,
                    lerp: Cf,
                    mapLinear: function(_, O, B, N, k) {
                        return N + (_ - O) * (k - N) / (B - O)
                    },
                    normalize: Kt,
                    pingpong: function(_, O = 1) {
                        return O - Math.abs($b(_, 2 * O) - O)
                    },
                    radToDeg: function(_) {
                        return _ * iZ
                    },
                    randFloat: function(_, O) {
                        return _ + Math.random() * (O - _)
                    },
                    randFloatSpread: function(_) {
                        return _ * (.5 - Math.random())
                    },
                    randInt: function(_, O) {
                        return _ + Math.floor(Math.random() * (O - _ + 1))
                    },
                    seededRandom: function(_) {
                        void 0 !== _ && (iX = _);
                        let O = iX += 1831565813;
                        return O = Math.imul(O ^ O >>> 15, 1 | O), (((O ^= O + Math.imul(O ^ O >>> 7, 61 | O)) ^ O >>> 14) >>> 0) / 4294967296
                    },
                    setQuaternionFromProperEuler: function(_, O, B, N, k) {
                        let F = Math.cos,
                            U = Math.sin,
                            j = F(B / 2),
                            G = U(B / 2),
                            Y = F((O + N) / 2),
                            Q = U((O + N) / 2),
                            K = F((O - N) / 2),
                            $ = U((O - N) / 2),
                            ee = F((N - O) / 2),
                            et = U((N - O) / 2);
                        switch (k) {
                            case "XYX":
                                _.set(j * Q, G * K, G * $, j * Y);
                                break;
                            case "YZY":
                                _.set(G * $, j * Q, G * K, j * Y);
                                break;
                            case "ZXZ":
                                _.set(G * K, G * $, j * Q, j * Y);
                                break;
                            case "XZX":
                                _.set(j * Q, G * et, G * ee, j * Y);
                                break;
                            case "YXY":
                                _.set(G * ee, j * Q, G * et, j * Y);
                                break;
                            case "ZYZ":
                                _.set(G * et, G * ee, j * Q, j * Y);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + k)
                        }
                    },
                    smootherstep: function(_, O, B) {
                        return _ <= O ? 0 : _ >= B ? 1 : (_ = (_ - O) / (B - O)) * _ * _ * (_ * (6 * _ - 15) + 10)
                    },
                    smoothstep: function(_, O, B) {
                        return _ <= O ? 0 : _ >= B ? 1 : (_ = (_ - O) / (B - O)) * _ * (3 - 2 * _)
                    }
                }),
                iJ = class {
                    constructor(_ = 0, O = 0) {
                        iJ.prototype.isVector2 = !0, this.x = _, this.y = O
                    }
                    get width() {
                        return this.x
                    }
                    set width(_) {
                        this.x = _
                    }
                    get height() {
                        return this.y
                    }
                    set height(_) {
                        this.y = _
                    }
                    set(_, O) {
                        return this.x = _, this.y = O, this
                    }
                    setScalar(_) {
                        return this.x = _, this.y = _, this
                    }
                    setX(_) {
                        return this.x = _, this
                    }
                    setY(_) {
                        return this.y = _, this
                    }
                    setComponent(_, O) {
                        switch (_) {
                            case 0:
                                this.x = O;
                                break;
                            case 1:
                                this.y = O;
                                break;
                            default:
                                throw Error("index is out of range: " + _)
                        }
                        return this
                    }
                    getComponent(_) {
                        switch (_) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw Error("index is out of range: " + _)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y)
                    }
                    copy(_) {
                        return this.x = _.x, this.y = _.y, this
                    }
                    add(_) {
                        return this.x += _.x, this.y += _.y, this
                    }
                    addScalar(_) {
                        return this.x += _, this.y += _, this
                    }
                    addVectors(_, O) {
                        return this.x = _.x + O.x, this.y = _.y + O.y, this
                    }
                    addScaledVector(_, O) {
                        return this.x += _.x * O, this.y += _.y * O, this
                    }
                    sub(_) {
                        return this.x -= _.x, this.y -= _.y, this
                    }
                    subScalar(_) {
                        return this.x -= _, this.y -= _, this
                    }
                    subVectors(_, O) {
                        return this.x = _.x - O.x, this.y = _.y - O.y, this
                    }
                    multiply(_) {
                        return this.x *= _.x, this.y *= _.y, this
                    }
                    multiplyScalar(_) {
                        return this.x *= _, this.y *= _, this
                    }
                    divide(_) {
                        return this.x /= _.x, this.y /= _.y, this
                    }
                    divideScalar(_) {
                        return this.multiplyScalar(1 / _)
                    }
                    applyMatrix3(_) {
                        let O = this.x,
                            B = this.y,
                            N = _.elements;
                        return this.x = N[0] * O + N[3] * B + N[6], this.y = N[1] * O + N[4] * B + N[7], this
                    }
                    min(_) {
                        return this.x = Math.min(this.x, _.x), this.y = Math.min(this.y, _.y), this
                    }
                    max(_) {
                        return this.x = Math.max(this.x, _.x), this.y = Math.max(this.y, _.y), this
                    }
                    clamp(_, O) {
                        return this.x = Math.max(_.x, Math.min(O.x, this.x)), this.y = Math.max(_.y, Math.min(O.y, this.y)), this
                    }
                    clampScalar(_, O) {
                        return this.x = Math.max(_, Math.min(O, this.x)), this.y = Math.max(_, Math.min(O, this.y)), this
                    }
                    clampLength(_, O) {
                        let B = this.length();
                        return this.divideScalar(B || 1).multiplyScalar(Math.max(_, Math.min(O, B)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this
                    }
                    dot(_) {
                        return this.x * _.x + this.y * _.y
                    }
                    cross(_) {
                        return this.x * _.y - this.y * _.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    distanceTo(_) {
                        return Math.sqrt(this.distanceToSquared(_))
                    }
                    distanceToSquared(_) {
                        let O = this.x - _.x,
                            B = this.y - _.y;
                        return O * O + B * B
                    }
                    manhattanDistanceTo(_) {
                        return Math.abs(this.x - _.x) + Math.abs(this.y - _.y)
                    }
                    setLength(_) {
                        return this.normalize().multiplyScalar(_)
                    }
                    lerp(_, O) {
                        return this.x += (_.x - this.x) * O, this.y += (_.y - this.y) * O, this
                    }
                    lerpVectors(_, O, B) {
                        return this.x = _.x + (O.x - _.x) * B, this.y = _.y + (O.y - _.y) * B, this
                    }
                    equals(_) {
                        return _.x === this.x && _.y === this.y
                    }
                    fromArray(_, O = 0) {
                        return this.x = _[O], this.y = _[O + 1], this
                    }
                    toArray(_ = [], O = 0) {
                        return _[O] = this.x, _[O + 1] = this.y, _
                    }
                    fromBufferAttribute(_, O) {
                        return this.x = _.getX(O), this.y = _.getY(O), this
                    }
                    rotateAround(_, O) {
                        let B = Math.cos(O),
                            N = Math.sin(O),
                            k = this.x - _.x,
                            F = this.y - _.y;
                        return this.x = k * B - F * N + _.x, this.y = k * N + F * B + _.y, this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this
                    }*[Symbol.iterator]() {
                        yield this.x, yield this.y
                    }
                },
                i$ = class {
                    constructor() {
                        i$.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
                    }
                    set(_, O, B, N, k, F, U, j, G) {
                        let Y = this.elements;
                        return Y[0] = _, Y[1] = N, Y[2] = U, Y[3] = O, Y[4] = k, Y[5] = j, Y[6] = B, Y[7] = F, Y[8] = G, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                    }
                    copy(_) {
                        let O = this.elements,
                            B = _.elements;
                        return O[0] = B[0], O[1] = B[1], O[2] = B[2], O[3] = B[3], O[4] = B[4], O[5] = B[5], O[6] = B[6], O[7] = B[7], O[8] = B[8], this
                    }
                    extractBasis(_, O, B) {
                        return _.setFromMatrix3Column(this, 0), O.setFromMatrix3Column(this, 1), B.setFromMatrix3Column(this, 2), this
                    }
                    setFromMatrix4(_) {
                        let O = _.elements;
                        return this.set(O[0], O[4], O[8], O[1], O[5], O[9], O[2], O[6], O[10]), this
                    }
                    multiply(_) {
                        return this.multiplyMatrices(this, _)
                    }
                    premultiply(_) {
                        return this.multiplyMatrices(_, this)
                    }
                    multiplyMatrices(_, O) {
                        let B = _.elements,
                            N = O.elements,
                            k = this.elements,
                            F = B[0],
                            U = B[3],
                            j = B[6],
                            G = B[1],
                            Y = B[4],
                            Q = B[7],
                            K = B[2],
                            $ = B[5],
                            ee = B[8],
                            et = N[0],
                            ei = N[3],
                            er = N[6],
                            ea = N[1],
                            en = N[4],
                            eo = N[7],
                            el = N[2],
                            eh = N[5],
                            ec = N[8];
                        return k[0] = F * et + U * ea + j * el, k[3] = F * ei + U * en + j * eh, k[6] = F * er + U * eo + j * ec, k[1] = G * et + Y * ea + Q * el, k[4] = G * ei + Y * en + Q * eh, k[7] = G * er + Y * eo + Q * ec, k[2] = K * et + $ * ea + ee * el, k[5] = K * ei + $ * en + ee * eh, k[8] = K * er + $ * eo + ee * ec, this
                    }
                    multiplyScalar(_) {
                        let O = this.elements;
                        return O[0] *= _, O[3] *= _, O[6] *= _, O[1] *= _, O[4] *= _, O[7] *= _, O[2] *= _, O[5] *= _, O[8] *= _, this
                    }
                    determinant() {
                        let _ = this.elements,
                            O = _[0],
                            B = _[1],
                            N = _[2],
                            k = _[3],
                            F = _[4],
                            U = _[5],
                            j = _[6],
                            G = _[7],
                            Y = _[8];
                        return O * F * Y - O * U * G - B * k * Y + B * U * j + N * k * G - N * F * j
                    }
                    invert() {
                        let _ = this.elements,
                            O = _[0],
                            B = _[1],
                            N = _[2],
                            k = _[3],
                            F = _[4],
                            U = _[5],
                            j = _[6],
                            G = _[7],
                            Y = _[8],
                            Q = Y * F - U * G,
                            K = U * j - Y * k,
                            $ = G * k - F * j,
                            ee = O * Q + B * K + N * $;
                        if (0 === ee) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        let et = 1 / ee;
                        return _[0] = Q * et, _[1] = (N * G - Y * B) * et, _[2] = (U * B - N * F) * et, _[3] = K * et, _[4] = (Y * O - N * j) * et, _[5] = (N * k - U * O) * et, _[6] = $ * et, _[7] = (B * j - G * O) * et, _[8] = (F * O - B * k) * et, this
                    }
                    transpose() {
                        let _, O = this.elements;
                        return _ = O[1], O[1] = O[3], O[3] = _, _ = O[2], O[2] = O[6], O[6] = _, _ = O[5], O[5] = O[7], O[7] = _, this
                    }
                    getNormalMatrix(_) {
                        return this.setFromMatrix4(_).invert().transpose()
                    }
                    transposeIntoArray(_) {
                        let O = this.elements;
                        return _[0] = O[0], _[1] = O[3], _[2] = O[6], _[3] = O[1], _[4] = O[4], _[5] = O[7], _[6] = O[2], _[7] = O[5], _[8] = O[8], this
                    }
                    setUvTransform(_, O, B, N, k, F, U) {
                        let j = Math.cos(k),
                            G = Math.sin(k);
                        return this.set(B * j, B * G, -B * (j * F + G * U) + F + _, -N * G, N * j, -N * (-G * F + j * U) + U + O, 0, 0, 1), this
                    }
                    scale(_, O) {
                        return this.premultiply(i0.makeScale(_, O)), this
                    }
                    rotate(_) {
                        return this.premultiply(i0.makeRotation(-_)), this
                    }
                    translate(_, O) {
                        return this.premultiply(i0.makeTranslation(_, O)), this
                    }
                    makeTranslation(_, O) {
                        return this.set(1, 0, _, 0, 1, O, 0, 0, 1), this
                    }
                    makeRotation(_) {
                        let O = Math.cos(_),
                            B = Math.sin(_);
                        return this.set(O, -B, 0, B, O, 0, 0, 0, 1), this
                    }
                    makeScale(_, O) {
                        return this.set(_, 0, 0, 0, O, 0, 0, 0, 1), this
                    }
                    equals(_) {
                        let O = this.elements,
                            B = _.elements;
                        for (let _ = 0; _ < 9; _++)
                            if (O[_] !== B[_]) return !1;
                        return !0
                    }
                    fromArray(_, O = 0) {
                        for (let B = 0; B < 9; B++) this.elements[B] = _[B + O];
                        return this
                    }
                    toArray(_ = [], O = 0) {
                        let B = this.elements;
                        return _[O] = B[0], _[O + 1] = B[1], _[O + 2] = B[2], _[O + 3] = B[3], _[O + 4] = B[4], _[O + 5] = B[5], _[O + 6] = B[6], _[O + 7] = B[7], _[O + 8] = B[8], _
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements)
                    }
                },
                i0 = new i$;

            function nM(_) {
                for (let O = _.length - 1; O >= 0; --O)
                    if (_[O] >= 65535) return !0;
                return !1
            }
            var i1 = {
                Int8Array,
                Uint8Array,
                Uint8ClampedArray,
                Int16Array,
                Uint16Array,
                Int32Array,
                Uint32Array,
                Float32Array,
                Float64Array
            };

            function Nm(_, O) {
                return new i1[_](O)
            }

            function fg(_) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", _)
            }

            function zl(_) {
                return _ < .04045 ? .0773993808 * _ : Math.pow(.9478672986 * _ + .0521327014, 2.4)
            }

            function lg(_) {
                return _ < .0031308 ? 12.92 * _ : 1.055 * Math.pow(_, .41666) - .055
            }
            var i2 = {
                    [iG]: {
                        [iH]: zl
                    },
                    [iH]: {
                        [iG]: lg
                    }
                },
                i4 = {
                    legacyMode: !0,
                    get workingColorSpace() {
                        return iH
                    },
                    set workingColorSpace(i) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function(_, O, B) {
                        if (this.legacyMode || O === B || !O || !B) return _;
                        if (i2[O] && void 0 !== i2[O][B]) {
                            let N = i2[O][B];
                            return _.r = N(_.r), _.g = N(_.g), _.b = N(_.b), _
                        }
                        throw Error("Unsupported color space conversion.")
                    },
                    fromWorkingColorSpace: function(_, O) {
                        return this.convert(_, this.workingColorSpace, O)
                    },
                    toWorkingColorSpace: function(_, O) {
                        return this.convert(_, O, this.workingColorSpace)
                    }
                },
                i5 = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                i6 = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                i8 = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                i9 = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function zx(_, O, B) {
                return B < 0 && (B += 1), B > 1 && (B -= 1), B < 1 / 6 ? _ + (O - _) * 6 * B : B < .5 ? O : B < 2 / 3 ? _ + (O - _) * 6 * (2 / 3 - B) : _
            }

            function Fm(_, O) {
                return O.r = _.r, O.g = _.g, O.b = _.b, O
            }
            var re = class {
                constructor(_, O, B) {
                    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === O && void 0 === B ? this.set(_) : this.setRGB(_, O, B)
                }
                set(_) {
                    return _ && _.isColor ? this.copy(_) : "number" == typeof _ ? this.setHex(_) : "string" == typeof _ && this.setStyle(_), this
                }
                setScalar(_) {
                    return this.r = _, this.g = _, this.b = _, this
                }
                setHex(_, O = iG) {
                    return _ = Math.floor(_), this.r = (_ >> 16 & 255) / 255, this.g = (_ >> 8 & 255) / 255, this.b = (255 & _) / 255, i4.toWorkingColorSpace(this, O), this
                }
                setRGB(_, O, B, N = i4.workingColorSpace) {
                    return this.r = _, this.g = O, this.b = B, i4.toWorkingColorSpace(this, N), this
                }
                setHSL(_, O, B, N = i4.workingColorSpace) {
                    if (_ = $b(_, 1), O = Yr(O, 0, 1), B = Yr(B, 0, 1), 0 === O) this.r = this.g = this.b = B;
                    else {
                        let N = B <= .5 ? B * (1 + O) : B + O - B * O,
                            k = 2 * B - N;
                        this.r = zx(k, N, _ + 1 / 3), this.g = zx(k, N, _), this.b = zx(k, N, _ - 1 / 3)
                    }
                    return i4.toWorkingColorSpace(this, N), this
                }
                setStyle(_, O = iG) {
                    let B;

                    function r(O) {
                        void 0 !== O && 1 > parseFloat(O) && console.warn("THREE.Color: Alpha component of " + _ + " will be ignored.")
                    }
                    if (B = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(_)) {
                        let _, N = B[1],
                            k = B[2];
                        switch (N) {
                            case "rgb":
                            case "rgba":
                                if (_ = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(k)) return this.r = Math.min(255, parseInt(_[1], 10)) / 255, this.g = Math.min(255, parseInt(_[2], 10)) / 255, this.b = Math.min(255, parseInt(_[3], 10)) / 255, i4.toWorkingColorSpace(this, O), r(_[4]), this;
                                if (_ = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(k)) return this.r = Math.min(100, parseInt(_[1], 10)) / 100, this.g = Math.min(100, parseInt(_[2], 10)) / 100, this.b = Math.min(100, parseInt(_[3], 10)) / 100, i4.toWorkingColorSpace(this, O), r(_[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (_ = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(k)) {
                                    let B = parseFloat(_[1]) / 360,
                                        N = parseFloat(_[2]) / 100,
                                        k = parseFloat(_[3]) / 100;
                                    return r(_[4]), this.setHSL(B, N, k, O)
                                }
                        }
                    } else if (B = /^\#([A-Fa-f\d]+)$/.exec(_)) {
                        let _ = B[1],
                            N = _.length;
                        if (3 === N) return this.r = parseInt(_.charAt(0) + _.charAt(0), 16) / 255, this.g = parseInt(_.charAt(1) + _.charAt(1), 16) / 255, this.b = parseInt(_.charAt(2) + _.charAt(2), 16) / 255, i4.toWorkingColorSpace(this, O), this;
                        if (6 === N) return this.r = parseInt(_.charAt(0) + _.charAt(1), 16) / 255, this.g = parseInt(_.charAt(2) + _.charAt(3), 16) / 255, this.b = parseInt(_.charAt(4) + _.charAt(5), 16) / 255, i4.toWorkingColorSpace(this, O), this
                    }
                    return _ && _.length > 0 ? this.setColorName(_, O) : this
                }
                setColorName(_, O = iG) {
                    let B = i5[_.toLowerCase()];
                    return void 0 !== B ? this.setHex(B, O) : console.warn("THREE.Color: Unknown color " + _), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(_) {
                    return this.r = _.r, this.g = _.g, this.b = _.b, this
                }
                copySRGBToLinear(_) {
                    return this.r = zl(_.r), this.g = zl(_.g), this.b = zl(_.b), this
                }
                copyLinearToSRGB(_) {
                    return this.r = lg(_.r), this.g = lg(_.g), this.b = lg(_.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(_ = iG) {
                    return i4.fromWorkingColorSpace(Fm(this, i6), _), Yr(255 * i6.r, 0, 255) << 16 ^ Yr(255 * i6.g, 0, 255) << 8 ^ Yr(255 * i6.b, 0, 255) << 0
                }
                getHexString(_ = iG) {
                    return ("000000" + this.getHex(_).toString(16)).slice(-6)
                }
                getHSL(_, O = i4.workingColorSpace) {
                    i4.fromWorkingColorSpace(Fm(this, i6), O);
                    let B = i6.r,
                        N = i6.g,
                        k = i6.b,
                        F = Math.max(B, N, k),
                        U = Math.min(B, N, k),
                        j, G, Y = (U + F) / 2;
                    if (U === F) j = 0, G = 0;
                    else {
                        let _ = F - U;
                        switch (G = Y <= .5 ? _ / (F + U) : _ / (2 - F - U), F) {
                            case B:
                                j = (N - k) / _ + (N < k ? 6 : 0);
                                break;
                            case N:
                                j = (k - B) / _ + 2;
                                break;
                            case k:
                                j = (B - N) / _ + 4
                        }
                        j /= 6
                    }
                    return _.h = j, _.s = G, _.l = Y, _
                }
                getRGB(_, O = i4.workingColorSpace) {
                    return i4.fromWorkingColorSpace(Fm(this, i6), O), _.r = i6.r, _.g = i6.g, _.b = i6.b, _
                }
                getStyle(_ = iG) {
                    return i4.fromWorkingColorSpace(Fm(this, i6), _), _ !== iG ? `color(${_} ${i6.r} ${i6.g} ${i6.b})` : `rgb(${255*i6.r|0},${255*i6.g|0},${255*i6.b|0})`
                }
                offsetHSL(_, O, B) {
                    return this.getHSL(i8), i8.h += _, i8.s += O, i8.l += B, this.setHSL(i8.h, i8.s, i8.l), this
                }
                add(_) {
                    return this.r += _.r, this.g += _.g, this.b += _.b, this
                }
                addColors(_, O) {
                    return this.r = _.r + O.r, this.g = _.g + O.g, this.b = _.b + O.b, this
                }
                addScalar(_) {
                    return this.r += _, this.g += _, this.b += _, this
                }
                sub(_) {
                    return this.r = Math.max(0, this.r - _.r), this.g = Math.max(0, this.g - _.g), this.b = Math.max(0, this.b - _.b), this
                }
                multiply(_) {
                    return this.r *= _.r, this.g *= _.g, this.b *= _.b, this
                }
                multiplyScalar(_) {
                    return this.r *= _, this.g *= _, this.b *= _, this
                }
                lerp(_, O) {
                    return this.r += (_.r - this.r) * O, this.g += (_.g - this.g) * O, this.b += (_.b - this.b) * O, this
                }
                lerpColors(_, O, B) {
                    return this.r = _.r + (O.r - _.r) * B, this.g = _.g + (O.g - _.g) * B, this.b = _.b + (O.b - _.b) * B, this
                }
                lerpHSL(_, O) {
                    this.getHSL(i8), _.getHSL(i9);
                    let B = Cf(i8.h, i9.h, O),
                        N = Cf(i8.s, i9.s, O),
                        k = Cf(i8.l, i9.l, O);
                    return this.setHSL(B, N, k), this
                }
                equals(_) {
                    return _.r === this.r && _.g === this.g && _.b === this.b
                }
                fromArray(_, O = 0) {
                    return this.r = _[O], this.g = _[O + 1], this.b = _[O + 2], this
                }
                toArray(_ = [], O = 0) {
                    return _[O] = this.r, _[O + 1] = this.g, _[O + 2] = this.b, _
                }
                fromBufferAttribute(_, O) {
                    return this.r = _.getX(O), this.g = _.getY(O), this.b = _.getZ(O), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            };
            re.NAMES = i5;
            var rt, ri = class {
                    static getDataURL(_) {
                        let O;
                        if (/^data:/i.test(_.src) || typeof HTMLCanvasElement > "u") return _.src;
                        if (_ instanceof HTMLCanvasElement) O = _;
                        else {
                            void 0 === rt && (rt = fg("canvas")), rt.width = _.width, rt.height = _.height;
                            let B = rt.getContext("2d");
                            _ instanceof ImageData ? B.putImageData(_, 0, 0) : B.drawImage(_, 0, 0, _.width, _.height), O = rt
                        }
                        return O.width > 2048 || O.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", _), O.toDataURL("image/jpeg", .6)) : O.toDataURL("image/png")
                    }
                    static sRGBToLinear(_) {
                        if ("u" > typeof HTMLImageElement && _ instanceof HTMLImageElement || "u" > typeof HTMLCanvasElement && _ instanceof HTMLCanvasElement || "u" > typeof ImageBitmap && _ instanceof ImageBitmap) {
                            let O = fg("canvas");
                            O.width = _.width, O.height = _.height;
                            let B = O.getContext("2d");
                            B.drawImage(_, 0, 0, _.width, _.height);
                            let N = B.getImageData(0, 0, _.width, _.height),
                                k = N.data;
                            for (let _ = 0; _ < k.length; _++) k[_] = 255 * zl(k[_] / 255);
                            return B.putImageData(N, 0, 0), O
                        }
                        if (!_.data) return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), _; {
                            let O = _.data.slice(0);
                            for (let _ = 0; _ < O.length; _++) O instanceof Uint8Array || O instanceof Uint8ClampedArray ? O[_] = Math.floor(255 * zl(O[_] / 255)) : O[_] = zl(O[_]);
                            return {
                                data: O,
                                width: _.width,
                                height: _.height
                            }
                        }
                    }
                },
                rr = class {
                    constructor(_ = null) {
                        this.isSource = !0, this.uuid = Ui(), this.data = _, this.version = 0
                    }
                    set needsUpdate(_) {
                        !0 === _ && this.version++
                    }
                    toJSON(_) {
                        let O = void 0 === _ || "string" == typeof _;
                        if (!O && void 0 !== _.images[this.uuid]) return _.images[this.uuid];
                        let B = {
                                uuid: this.uuid,
                                url: ""
                            },
                            N = this.data;
                        if (null !== N) {
                            let _;
                            if (Array.isArray(N)) {
                                _ = [];
                                for (let O = 0, B = N.length; O < B; O++) N[O].isDataTexture ? _.push(Ux(N[O].image)) : _.push(Ux(N[O]))
                            } else _ = Ux(N);
                            B.url = _
                        }
                        return O || (_.images[this.uuid] = B), B
                    }
                };

            function Ux(_) {
                return "u" > typeof HTMLImageElement && _ instanceof HTMLImageElement || "u" > typeof HTMLCanvasElement && _ instanceof HTMLCanvasElement || "u" > typeof ImageBitmap && _ instanceof ImageBitmap ? ri.getDataURL(_) : _.data ? {
                    data: Array.from(_.data),
                    width: _.width,
                    height: _.height,
                    type: _.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            var rs = 0,
                ro = class extends iq {
                    constructor(_ = ro.DEFAULT_IMAGE, O = ro.DEFAULT_MAPPING, B = 1001, N = 1001, k = 1006, F = 1008, U = 1023, j = 1009, G = ro.DEFAULT_ANISOTROPY, Y = 3e3) {
                        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                            value: rs++
                        }), this.uuid = Ui(), this.name = "", this.source = new rr(_), this.mipmaps = [], this.mapping = O, this.wrapS = B, this.wrapT = N, this.magFilter = k, this.minFilter = F, this.anisotropy = G, this.format = U, this.internalFormat = null, this.type = j, this.offset = new iJ(0, 0), this.repeat = new iJ(1, 1), this.center = new iJ(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new i$, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = Y, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(_) {
                        this.source.data = _
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        return this.name = _.name, this.source = _.source, this.mipmaps = _.mipmaps.slice(0), this.mapping = _.mapping, this.wrapS = _.wrapS, this.wrapT = _.wrapT, this.magFilter = _.magFilter, this.minFilter = _.minFilter, this.anisotropy = _.anisotropy, this.format = _.format, this.internalFormat = _.internalFormat, this.type = _.type, this.offset.copy(_.offset), this.repeat.copy(_.repeat), this.center.copy(_.center), this.rotation = _.rotation, this.matrixAutoUpdate = _.matrixAutoUpdate, this.matrix.copy(_.matrix), this.generateMipmaps = _.generateMipmaps, this.premultiplyAlpha = _.premultiplyAlpha, this.flipY = _.flipY, this.unpackAlignment = _.unpackAlignment, this.encoding = _.encoding, this.userData = JSON.parse(JSON.stringify(_.userData)), this.needsUpdate = !0, this
                    }
                    toJSON(_) {
                        let O = void 0 === _ || "string" == typeof _;
                        if (!O && void 0 !== _.textures[this.uuid]) return _.textures[this.uuid];
                        let B = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(_).uuid,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        return Object.keys(this.userData).length > 0 && (B.userData = this.userData), O || (_.textures[this.uuid] = B), B
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(_) {
                        if (300 !== this.mapping) return _;
                        if (_.applyMatrix3(this.matrix), _.x < 0 || _.x > 1) switch (this.wrapS) {
                            case 1e3:
                                _.x = _.x - Math.floor(_.x);
                                break;
                            case 1001:
                                _.x = _.x < 0 ? 0 : 1;
                                break;
                            case 1002:
                                1 === Math.abs(Math.floor(_.x) % 2) ? _.x = Math.ceil(_.x) - _.x : _.x = _.x - Math.floor(_.x)
                        }
                        if (_.y < 0 || _.y > 1) switch (this.wrapT) {
                            case 1e3:
                                _.y = _.y - Math.floor(_.y);
                                break;
                            case 1001:
                                _.y = _.y < 0 ? 0 : 1;
                                break;
                            case 1002:
                                1 === Math.abs(Math.floor(_.y) % 2) ? _.y = Math.ceil(_.y) - _.y : _.y = _.y - Math.floor(_.y)
                        }
                        return this.flipY && (_.y = 1 - _.y), _
                    }
                    set needsUpdate(_) {
                        !0 === _ && (this.version++, this.source.needsUpdate = !0)
                    }
                };
            ro.DEFAULT_IMAGE = null, ro.DEFAULT_MAPPING = 300, ro.DEFAULT_ANISOTROPY = 1;
            var rl = class {
                    constructor(_ = 0, O = 0, B = 0, N = 1) {
                        rl.prototype.isVector4 = !0, this.x = _, this.y = O, this.z = B, this.w = N
                    }
                    get width() {
                        return this.z
                    }
                    set width(_) {
                        this.z = _
                    }
                    get height() {
                        return this.w
                    }
                    set height(_) {
                        this.w = _
                    }
                    set(_, O, B, N) {
                        return this.x = _, this.y = O, this.z = B, this.w = N, this
                    }
                    setScalar(_) {
                        return this.x = _, this.y = _, this.z = _, this.w = _, this
                    }
                    setX(_) {
                        return this.x = _, this
                    }
                    setY(_) {
                        return this.y = _, this
                    }
                    setZ(_) {
                        return this.z = _, this
                    }
                    setW(_) {
                        return this.w = _, this
                    }
                    setComponent(_, O) {
                        switch (_) {
                            case 0:
                                this.x = O;
                                break;
                            case 1:
                                this.y = O;
                                break;
                            case 2:
                                this.z = O;
                                break;
                            case 3:
                                this.w = O;
                                break;
                            default:
                                throw Error("index is out of range: " + _)
                        }
                        return this
                    }
                    getComponent(_) {
                        switch (_) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw Error("index is out of range: " + _)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    }
                    copy(_) {
                        return this.x = _.x, this.y = _.y, this.z = _.z, this.w = void 0 !== _.w ? _.w : 1, this
                    }
                    add(_) {
                        return this.x += _.x, this.y += _.y, this.z += _.z, this.w += _.w, this
                    }
                    addScalar(_) {
                        return this.x += _, this.y += _, this.z += _, this.w += _, this
                    }
                    addVectors(_, O) {
                        return this.x = _.x + O.x, this.y = _.y + O.y, this.z = _.z + O.z, this.w = _.w + O.w, this
                    }
                    addScaledVector(_, O) {
                        return this.x += _.x * O, this.y += _.y * O, this.z += _.z * O, this.w += _.w * O, this
                    }
                    sub(_) {
                        return this.x -= _.x, this.y -= _.y, this.z -= _.z, this.w -= _.w, this
                    }
                    subScalar(_) {
                        return this.x -= _, this.y -= _, this.z -= _, this.w -= _, this
                    }
                    subVectors(_, O) {
                        return this.x = _.x - O.x, this.y = _.y - O.y, this.z = _.z - O.z, this.w = _.w - O.w, this
                    }
                    multiply(_) {
                        return this.x *= _.x, this.y *= _.y, this.z *= _.z, this.w *= _.w, this
                    }
                    multiplyScalar(_) {
                        return this.x *= _, this.y *= _, this.z *= _, this.w *= _, this
                    }
                    applyMatrix4(_) {
                        let O = this.x,
                            B = this.y,
                            N = this.z,
                            k = this.w,
                            F = _.elements;
                        return this.x = F[0] * O + F[4] * B + F[8] * N + F[12] * k, this.y = F[1] * O + F[5] * B + F[9] * N + F[13] * k, this.z = F[2] * O + F[6] * B + F[10] * N + F[14] * k, this.w = F[3] * O + F[7] * B + F[11] * N + F[15] * k, this
                    }
                    divideScalar(_) {
                        return this.multiplyScalar(1 / _)
                    }
                    setAxisAngleFromQuaternion(_) {
                        this.w = 2 * Math.acos(_.w);
                        let O = Math.sqrt(1 - _.w * _.w);
                        return O < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = _.x / O, this.y = _.y / O, this.z = _.z / O), this
                    }
                    setAxisAngleFromRotationMatrix(_) {
                        let O, B, N, k, F = _.elements,
                            U = F[0],
                            j = F[4],
                            G = F[8],
                            Y = F[1],
                            Q = F[5],
                            K = F[9],
                            $ = F[2],
                            ee = F[6],
                            et = F[10];
                        if (.01 > Math.abs(j - Y) && .01 > Math.abs(G - $) && .01 > Math.abs(K - ee)) {
                            if (.1 > Math.abs(j + Y) && .1 > Math.abs(G + $) && .1 > Math.abs(K + ee) && .1 > Math.abs(U + Q + et - 3)) return this.set(1, 0, 0, 0), this;
                            O = Math.PI;
                            let _ = (U + 1) / 2,
                                F = (Q + 1) / 2,
                                ei = (et + 1) / 2,
                                er = (j + Y) / 4,
                                ea = (G + $) / 4,
                                en = (K + ee) / 4;
                            return _ > F && _ > ei ? _ < .01 ? (B = 0, N = .707106781, k = .707106781) : (N = er / (B = Math.sqrt(_)), k = ea / B) : F > ei ? F < .01 ? (B = .707106781, N = 0, k = .707106781) : (B = er / (N = Math.sqrt(F)), k = en / N) : ei < .01 ? (B = .707106781, N = .707106781, k = 0) : (B = ea / (k = Math.sqrt(ei)), N = en / k), this.set(B, N, k, O), this
                        }
                        let ei = Math.sqrt((ee - K) * (ee - K) + (G - $) * (G - $) + (Y - j) * (Y - j));
                        return .001 > Math.abs(ei) && (ei = 1), this.x = (ee - K) / ei, this.y = (G - $) / ei, this.z = (Y - j) / ei, this.w = Math.acos((U + Q + et - 1) / 2), this
                    }
                    min(_) {
                        return this.x = Math.min(this.x, _.x), this.y = Math.min(this.y, _.y), this.z = Math.min(this.z, _.z), this.w = Math.min(this.w, _.w), this
                    }
                    max(_) {
                        return this.x = Math.max(this.x, _.x), this.y = Math.max(this.y, _.y), this.z = Math.max(this.z, _.z), this.w = Math.max(this.w, _.w), this
                    }
                    clamp(_, O) {
                        return this.x = Math.max(_.x, Math.min(O.x, this.x)), this.y = Math.max(_.y, Math.min(O.y, this.y)), this.z = Math.max(_.z, Math.min(O.z, this.z)), this.w = Math.max(_.w, Math.min(O.w, this.w)), this
                    }
                    clampScalar(_, O) {
                        return this.x = Math.max(_, Math.min(O, this.x)), this.y = Math.max(_, Math.min(O, this.y)), this.z = Math.max(_, Math.min(O, this.z)), this.w = Math.max(_, Math.min(O, this.w)), this
                    }
                    clampLength(_, O) {
                        let B = this.length();
                        return this.divideScalar(B || 1).multiplyScalar(Math.max(_, Math.min(O, B)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                    }
                    dot(_) {
                        return this.x * _.x + this.y * _.y + this.z * _.z + this.w * _.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(_) {
                        return this.normalize().multiplyScalar(_)
                    }
                    lerp(_, O) {
                        return this.x += (_.x - this.x) * O, this.y += (_.y - this.y) * O, this.z += (_.z - this.z) * O, this.w += (_.w - this.w) * O, this
                    }
                    lerpVectors(_, O, B) {
                        return this.x = _.x + (O.x - _.x) * B, this.y = _.y + (O.y - _.y) * B, this.z = _.z + (O.z - _.z) * B, this.w = _.w + (O.w - _.w) * B, this
                    }
                    equals(_) {
                        return _.x === this.x && _.y === this.y && _.z === this.z && _.w === this.w
                    }
                    fromArray(_, O = 0) {
                        return this.x = _[O], this.y = _[O + 1], this.z = _[O + 2], this.w = _[O + 3], this
                    }
                    toArray(_ = [], O = 0) {
                        return _[O] = this.x, _[O + 1] = this.y, _[O + 2] = this.z, _[O + 3] = this.w, _
                    }
                    fromBufferAttribute(_, O) {
                        return this.x = _.getX(O), this.y = _.getY(O), this.z = _.getZ(O), this.w = _.getW(O), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                    }*[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z, yield this.w
                    }
                },
                rh = class extends iq {
                    constructor(_ = 1, O = 1, B = {}) {
                        super(), this.isWebGLRenderTarget = !0, this.width = _, this.height = O, this.depth = 1, this.scissor = new rl(0, 0, _, O), this.scissorTest = !1, this.viewport = new rl(0, 0, _, O), this.texture = new ro({
                            width: _,
                            height: O,
                            depth: 1
                        }, B.mapping, B.wrapS, B.wrapT, B.magFilter, B.minFilter, B.format, B.type, B.anisotropy, B.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== B.generateMipmaps && B.generateMipmaps, this.texture.internalFormat = void 0 !== B.internalFormat ? B.internalFormat : null, this.texture.minFilter = void 0 !== B.minFilter ? B.minFilter : 1006, this.depthBuffer = void 0 === B.depthBuffer || B.depthBuffer, this.stencilBuffer = void 0 !== B.stencilBuffer && B.stencilBuffer, this.depthTexture = void 0 !== B.depthTexture ? B.depthTexture : null, this.samples = void 0 !== B.samples ? B.samples : 0
                    }
                    setSize(_, O, B = 1) {
                        (this.width !== _ || this.height !== O || this.depth !== B) && (this.width = _, this.height = O, this.depth = B, this.texture.image.width = _, this.texture.image.height = O, this.texture.image.depth = B, this.dispose()), this.viewport.set(0, 0, _, O), this.scissor.set(0, 0, _, O)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        this.width = _.width, this.height = _.height, this.depth = _.depth, this.viewport.copy(_.viewport), this.texture = _.texture.clone(), this.texture.isRenderTargetTexture = !0;
                        let O = Object.assign({}, _.texture.image);
                        return this.texture.source = new rr(O), this.depthBuffer = _.depthBuffer, this.stencilBuffer = _.stencilBuffer, null !== _.depthTexture && (this.depthTexture = _.depthTexture.clone()), this.samples = _.samples, this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                },
                rd = class extends ro {
                    constructor(_ = null, O = 1, B = 1, N = 1) {
                        super(null), this.isDataArrayTexture = !0, this.image = {
                            data: _,
                            width: O,
                            height: B,
                            depth: N
                        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                },
                ru = class extends ro {
                    constructor(_ = null, O = 1, B = 1, N = 1) {
                        super(null), this.isData3DTexture = !0, this.image = {
                            data: _,
                            width: O,
                            height: B,
                            depth: N
                        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                },
                rf = class extends rh {
                    constructor(_ = 1, O = 1, B = 1, N = {}) {
                        super(_, O, N), this.isWebGLMultipleRenderTargets = !0;
                        let k = this.texture;
                        this.texture = [];
                        for (let _ = 0; _ < B; _++) this.texture[_] = k.clone(), this.texture[_].isRenderTargetTexture = !0
                    }
                    setSize(_, O, B = 1) {
                        if (this.width !== _ || this.height !== O || this.depth !== B) {
                            this.width = _, this.height = O, this.depth = B;
                            for (let N = 0, k = this.texture.length; N < k; N++) this.texture[N].image.width = _, this.texture[N].image.height = O, this.texture[N].image.depth = B;
                            this.dispose()
                        }
                        return this.viewport.set(0, 0, _, O), this.scissor.set(0, 0, _, O), this
                    }
                    copy(_) {
                        this.dispose(), this.width = _.width, this.height = _.height, this.depth = _.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = _.depthBuffer, this.stencilBuffer = _.stencilBuffer, null !== _.depthTexture && (this.depthTexture = _.depthTexture.clone()), this.texture.length = 0;
                        for (let O = 0, B = _.texture.length; O < B; O++) this.texture[O] = _.texture[O].clone(), this.texture[O].isRenderTargetTexture = !0;
                        return this
                    }
                },
                rm = class {
                    constructor(_ = 0, O = 0, B = 0, N = 1) {
                        this.isQuaternion = !0, this._x = _, this._y = O, this._z = B, this._w = N
                    }
                    static slerpFlat(_, O, B, N, k, F, U) {
                        let j = B[N + 0],
                            G = B[N + 1],
                            Y = B[N + 2],
                            Q = B[N + 3],
                            K = k[F + 0],
                            $ = k[F + 1],
                            ee = k[F + 2],
                            et = k[F + 3];
                        if (0 === U) {
                            _[O + 0] = j, _[O + 1] = G, _[O + 2] = Y, _[O + 3] = Q;
                            return
                        }
                        if (1 === U) {
                            _[O + 0] = K, _[O + 1] = $, _[O + 2] = ee, _[O + 3] = et;
                            return
                        }
                        if (Q !== et || j !== K || G !== $ || Y !== ee) {
                            let _ = 1 - U,
                                O = j * K + G * $ + Y * ee + Q * et,
                                B = O >= 0 ? 1 : -1,
                                N = 1 - O * O;
                            if (N > Number.EPSILON) {
                                let k = Math.sqrt(N),
                                    F = Math.atan2(k, O * B);
                                _ = Math.sin(_ * F) / k, U = Math.sin(U * F) / k
                            }
                            let k = U * B;
                            if (j = j * _ + K * k, G = G * _ + $ * k, Y = Y * _ + ee * k, Q = Q * _ + et * k, _ === 1 - U) {
                                let _ = 1 / Math.sqrt(j * j + G * G + Y * Y + Q * Q);
                                j *= _, G *= _, Y *= _, Q *= _
                            }
                        }
                        _[O] = j, _[O + 1] = G, _[O + 2] = Y, _[O + 3] = Q
                    }
                    static multiplyQuaternionsFlat(_, O, B, N, k, F) {
                        let U = B[N],
                            j = B[N + 1],
                            G = B[N + 2],
                            Y = B[N + 3],
                            Q = k[F],
                            K = k[F + 1],
                            $ = k[F + 2],
                            ee = k[F + 3];
                        return _[O] = U * ee + Y * Q + j * $ - G * K, _[O + 1] = j * ee + Y * K + G * Q - U * $, _[O + 2] = G * ee + Y * $ + U * K - j * Q, _[O + 3] = Y * ee - U * Q - j * K - G * $, _
                    }
                    get x() {
                        return this._x
                    }
                    set x(_) {
                        this._x = _, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(_) {
                        this._y = _, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(_) {
                        this._z = _, this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(_) {
                        this._w = _, this._onChangeCallback()
                    }
                    set(_, O, B, N) {
                        return this._x = _, this._y = O, this._z = B, this._w = N, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    }
                    copy(_) {
                        return this._x = _.x, this._y = _.y, this._z = _.z, this._w = _.w, this._onChangeCallback(), this
                    }
                    setFromEuler(_, O) {
                        let B = _._x,
                            N = _._y,
                            k = _._z,
                            F = _._order,
                            U = Math.cos,
                            j = Math.sin,
                            G = U(B / 2),
                            Y = U(N / 2),
                            Q = U(k / 2),
                            K = j(B / 2),
                            $ = j(N / 2),
                            ee = j(k / 2);
                        switch (F) {
                            case "XYZ":
                                this._x = K * Y * Q + G * $ * ee, this._y = G * $ * Q - K * Y * ee, this._z = G * Y * ee + K * $ * Q, this._w = G * Y * Q - K * $ * ee;
                                break;
                            case "YXZ":
                                this._x = K * Y * Q + G * $ * ee, this._y = G * $ * Q - K * Y * ee, this._z = G * Y * ee - K * $ * Q, this._w = G * Y * Q + K * $ * ee;
                                break;
                            case "ZXY":
                                this._x = K * Y * Q - G * $ * ee, this._y = G * $ * Q + K * Y * ee, this._z = G * Y * ee + K * $ * Q, this._w = G * Y * Q - K * $ * ee;
                                break;
                            case "ZYX":
                                this._x = K * Y * Q - G * $ * ee, this._y = G * $ * Q + K * Y * ee, this._z = G * Y * ee - K * $ * Q, this._w = G * Y * Q + K * $ * ee;
                                break;
                            case "YZX":
                                this._x = K * Y * Q + G * $ * ee, this._y = G * $ * Q + K * Y * ee, this._z = G * Y * ee - K * $ * Q, this._w = G * Y * Q - K * $ * ee;
                                break;
                            case "XZY":
                                this._x = K * Y * Q - G * $ * ee, this._y = G * $ * Q - K * Y * ee, this._z = G * Y * ee + K * $ * Q, this._w = G * Y * Q + K * $ * ee;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + F)
                        }
                        return !1 !== O && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(_, O) {
                        let B = O / 2,
                            N = Math.sin(B);
                        return this._x = _.x * N, this._y = _.y * N, this._z = _.z * N, this._w = Math.cos(B), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(_) {
                        let O = _.elements,
                            B = O[0],
                            N = O[4],
                            k = O[8],
                            F = O[1],
                            U = O[5],
                            j = O[9],
                            G = O[2],
                            Y = O[6],
                            Q = O[10],
                            K = B + U + Q;
                        if (K > 0) {
                            let _ = .5 / Math.sqrt(K + 1);
                            this._w = .25 / _, this._x = (Y - j) * _, this._y = (k - G) * _, this._z = (F - N) * _
                        } else if (B > U && B > Q) {
                            let _ = 2 * Math.sqrt(1 + B - U - Q);
                            this._w = (Y - j) / _, this._x = .25 * _, this._y = (N + F) / _, this._z = (k + G) / _
                        } else if (U > Q) {
                            let _ = 2 * Math.sqrt(1 + U - B - Q);
                            this._w = (k - G) / _, this._x = (N + F) / _, this._y = .25 * _, this._z = (j + Y) / _
                        } else {
                            let _ = 2 * Math.sqrt(1 + Q - B - U);
                            this._w = (F - N) / _, this._x = (k + G) / _, this._y = (j + Y) / _, this._z = .25 * _
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(_, O) {
                        let B = _.dot(O) + 1;
                        return B < Number.EPSILON ? (B = 0, Math.abs(_.x) > Math.abs(_.z) ? (this._x = -_.y, this._y = _.x, this._z = 0) : (this._x = 0, this._y = -_.z, this._z = _.y)) : (this._x = _.y * O.z - _.z * O.y, this._y = _.z * O.x - _.x * O.z, this._z = _.x * O.y - _.y * O.x), this._w = B, this.normalize()
                    }
                    angleTo(_) {
                        return 2 * Math.acos(Math.abs(Yr(this.dot(_), -1, 1)))
                    }
                    rotateTowards(_, O) {
                        let B = this.angleTo(_);
                        if (0 === B) return this;
                        let N = Math.min(1, O / B);
                        return this.slerp(_, N), this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                    }
                    dot(_) {
                        return this._x * _._x + this._y * _._y + this._z * _._z + this._w * _._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let _ = this.length();
                        return 0 === _ ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (_ = 1 / _, this._x = this._x * _, this._y = this._y * _, this._z = this._z * _, this._w = this._w * _), this._onChangeCallback(), this
                    }
                    multiply(_) {
                        return this.multiplyQuaternions(this, _)
                    }
                    premultiply(_) {
                        return this.multiplyQuaternions(_, this)
                    }
                    multiplyQuaternions(_, O) {
                        let B = _._x,
                            N = _._y,
                            k = _._z,
                            F = _._w,
                            U = O._x,
                            j = O._y,
                            G = O._z,
                            Y = O._w;
                        return this._x = B * Y + F * U + N * G - k * j, this._y = N * Y + F * j + k * U - B * G, this._z = k * Y + F * G + B * j - N * U, this._w = F * Y - B * U - N * j - k * G, this._onChangeCallback(), this
                    }
                    slerp(_, O) {
                        if (0 === O) return this;
                        if (1 === O) return this.copy(_);
                        let B = this._x,
                            N = this._y,
                            k = this._z,
                            F = this._w,
                            U = F * _._w + B * _._x + N * _._y + k * _._z;
                        if (U < 0 ? (this._w = -_._w, this._x = -_._x, this._y = -_._y, this._z = -_._z, U = -U) : this.copy(_), U >= 1) return this._w = F, this._x = B, this._y = N, this._z = k, this;
                        let j = 1 - U * U;
                        if (j <= Number.EPSILON) {
                            let _ = 1 - O;
                            return this._w = _ * F + O * this._w, this._x = _ * B + O * this._x, this._y = _ * N + O * this._y, this._z = _ * k + O * this._z, this.normalize(), this._onChangeCallback(), this
                        }
                        let G = Math.sqrt(j),
                            Y = Math.atan2(G, U),
                            Q = Math.sin((1 - O) * Y) / G,
                            K = Math.sin(O * Y) / G;
                        return this._w = F * Q + this._w * K, this._x = B * Q + this._x * K, this._y = N * Q + this._y * K, this._z = k * Q + this._z * K, this._onChangeCallback(), this
                    }
                    slerpQuaternions(_, O, B) {
                        return this.copy(_).slerp(O, B)
                    }
                    random() {
                        let _ = Math.random(),
                            O = Math.sqrt(1 - _),
                            B = Math.sqrt(_),
                            N = 2 * Math.PI * Math.random(),
                            k = 2 * Math.PI * Math.random();
                        return this.set(O * Math.cos(N), B * Math.sin(k), B * Math.cos(k), O * Math.sin(N))
                    }
                    equals(_) {
                        return _._x === this._x && _._y === this._y && _._z === this._z && _._w === this._w
                    }
                    fromArray(_, O = 0) {
                        return this._x = _[O], this._y = _[O + 1], this._z = _[O + 2], this._w = _[O + 3], this._onChangeCallback(), this
                    }
                    toArray(_ = [], O = 0) {
                        return _[O] = this._x, _[O + 1] = this._y, _[O + 2] = this._z, _[O + 3] = this._w, _
                    }
                    fromBufferAttribute(_, O) {
                        return this._x = _.getX(O), this._y = _.getY(O), this._z = _.getZ(O), this._w = _.getW(O), this
                    }
                    _onChange(_) {
                        return this._onChangeCallback = _, this
                    }
                    _onChangeCallback() {}*[Symbol.iterator]() {
                        yield this._x, yield this._y, yield this._z, yield this._w
                    }
                },
                rv = class {
                    constructor(_ = 0, O = 0, B = 0) {
                        rv.prototype.isVector3 = !0, this.x = _, this.y = O, this.z = B
                    }
                    set(_, O, B) {
                        return void 0 === B && (B = this.z), this.x = _, this.y = O, this.z = B, this
                    }
                    setScalar(_) {
                        return this.x = _, this.y = _, this.z = _, this
                    }
                    setX(_) {
                        return this.x = _, this
                    }
                    setY(_) {
                        return this.y = _, this
                    }
                    setZ(_) {
                        return this.z = _, this
                    }
                    setComponent(_, O) {
                        switch (_) {
                            case 0:
                                this.x = O;
                                break;
                            case 1:
                                this.y = O;
                                break;
                            case 2:
                                this.z = O;
                                break;
                            default:
                                throw Error("index is out of range: " + _)
                        }
                        return this
                    }
                    getComponent(_) {
                        switch (_) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw Error("index is out of range: " + _)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                    copy(_) {
                        return this.x = _.x, this.y = _.y, this.z = _.z, this
                    }
                    add(_) {
                        return this.x += _.x, this.y += _.y, this.z += _.z, this
                    }
                    addScalar(_) {
                        return this.x += _, this.y += _, this.z += _, this
                    }
                    addVectors(_, O) {
                        return this.x = _.x + O.x, this.y = _.y + O.y, this.z = _.z + O.z, this
                    }
                    addScaledVector(_, O) {
                        return this.x += _.x * O, this.y += _.y * O, this.z += _.z * O, this
                    }
                    sub(_) {
                        return this.x -= _.x, this.y -= _.y, this.z -= _.z, this
                    }
                    subScalar(_) {
                        return this.x -= _, this.y -= _, this.z -= _, this
                    }
                    subVectors(_, O) {
                        return this.x = _.x - O.x, this.y = _.y - O.y, this.z = _.z - O.z, this
                    }
                    multiply(_) {
                        return this.x *= _.x, this.y *= _.y, this.z *= _.z, this
                    }
                    multiplyScalar(_) {
                        return this.x *= _, this.y *= _, this.z *= _, this
                    }
                    multiplyVectors(_, O) {
                        return this.x = _.x * O.x, this.y = _.y * O.y, this.z = _.z * O.z, this
                    }
                    applyEuler(_) {
                        return this.applyQuaternion(rx.setFromEuler(_))
                    }
                    applyAxisAngle(_, O) {
                        return this.applyQuaternion(rx.setFromAxisAngle(_, O))
                    }
                    applyMatrix3(_) {
                        let O = this.x,
                            B = this.y,
                            N = this.z,
                            k = _.elements;
                        return this.x = k[0] * O + k[3] * B + k[6] * N, this.y = k[1] * O + k[4] * B + k[7] * N, this.z = k[2] * O + k[5] * B + k[8] * N, this
                    }
                    applyNormalMatrix(_) {
                        return this.applyMatrix3(_).normalize()
                    }
                    applyMatrix4(_) {
                        let O = this.x,
                            B = this.y,
                            N = this.z,
                            k = _.elements,
                            F = 1 / (k[3] * O + k[7] * B + k[11] * N + k[15]);
                        return this.x = (k[0] * O + k[4] * B + k[8] * N + k[12]) * F, this.y = (k[1] * O + k[5] * B + k[9] * N + k[13]) * F, this.z = (k[2] * O + k[6] * B + k[10] * N + k[14]) * F, this
                    }
                    applyQuaternion(_) {
                        let O = this.x,
                            B = this.y,
                            N = this.z,
                            k = _.x,
                            F = _.y,
                            U = _.z,
                            j = _.w,
                            G = j * O + F * N - U * B,
                            Y = j * B + U * O - k * N,
                            Q = j * N + k * B - F * O,
                            K = -k * O - F * B - U * N;
                        return this.x = G * j + -(K * k) + -(Y * U) - -(Q * F), this.y = Y * j + -(K * F) + -(Q * k) - -(G * U), this.z = Q * j + -(K * U) + -(G * F) - -(Y * k), this
                    }
                    project(_) {
                        return this.applyMatrix4(_.matrixWorldInverse).applyMatrix4(_.projectionMatrix)
                    }
                    unproject(_) {
                        return this.applyMatrix4(_.projectionMatrixInverse).applyMatrix4(_.matrixWorld)
                    }
                    transformDirection(_) {
                        let O = this.x,
                            B = this.y,
                            N = this.z,
                            k = _.elements;
                        return this.x = k[0] * O + k[4] * B + k[8] * N, this.y = k[1] * O + k[5] * B + k[9] * N, this.z = k[2] * O + k[6] * B + k[10] * N, this.normalize()
                    }
                    divide(_) {
                        return this.x /= _.x, this.y /= _.y, this.z /= _.z, this
                    }
                    divideScalar(_) {
                        return this.multiplyScalar(1 / _)
                    }
                    min(_) {
                        return this.x = Math.min(this.x, _.x), this.y = Math.min(this.y, _.y), this.z = Math.min(this.z, _.z), this
                    }
                    max(_) {
                        return this.x = Math.max(this.x, _.x), this.y = Math.max(this.y, _.y), this.z = Math.max(this.z, _.z), this
                    }
                    clamp(_, O) {
                        return this.x = Math.max(_.x, Math.min(O.x, this.x)), this.y = Math.max(_.y, Math.min(O.y, this.y)), this.z = Math.max(_.z, Math.min(O.z, this.z)), this
                    }
                    clampScalar(_, O) {
                        return this.x = Math.max(_, Math.min(O, this.x)), this.y = Math.max(_, Math.min(O, this.y)), this.z = Math.max(_, Math.min(O, this.z)), this
                    }
                    clampLength(_, O) {
                        let B = this.length();
                        return this.divideScalar(B || 1).multiplyScalar(Math.max(_, Math.min(O, B)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    }
                    dot(_) {
                        return this.x * _.x + this.y * _.y + this.z * _.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(_) {
                        return this.normalize().multiplyScalar(_)
                    }
                    lerp(_, O) {
                        return this.x += (_.x - this.x) * O, this.y += (_.y - this.y) * O, this.z += (_.z - this.z) * O, this
                    }
                    lerpVectors(_, O, B) {
                        return this.x = _.x + (O.x - _.x) * B, this.y = _.y + (O.y - _.y) * B, this.z = _.z + (O.z - _.z) * B, this
                    }
                    cross(_) {
                        return this.crossVectors(this, _)
                    }
                    crossVectors(_, O) {
                        let B = _.x,
                            N = _.y,
                            k = _.z,
                            F = O.x,
                            U = O.y,
                            j = O.z;
                        return this.x = N * j - k * U, this.y = k * F - B * j, this.z = B * U - N * F, this
                    }
                    projectOnVector(_) {
                        let O = _.lengthSq();
                        if (0 === O) return this.set(0, 0, 0);
                        let B = _.dot(this) / O;
                        return this.copy(_).multiplyScalar(B)
                    }
                    projectOnPlane(_) {
                        return ry.copy(this).projectOnVector(_), this.sub(ry)
                    }
                    reflect(_) {
                        return this.sub(ry.copy(_).multiplyScalar(2 * this.dot(_)))
                    }
                    angleTo(_) {
                        let O = Math.sqrt(this.lengthSq() * _.lengthSq());
                        return 0 === O ? Math.PI / 2 : Math.acos(Yr(this.dot(_) / O, -1, 1))
                    }
                    distanceTo(_) {
                        return Math.sqrt(this.distanceToSquared(_))
                    }
                    distanceToSquared(_) {
                        let O = this.x - _.x,
                            B = this.y - _.y,
                            N = this.z - _.z;
                        return O * O + B * B + N * N
                    }
                    manhattanDistanceTo(_) {
                        return Math.abs(this.x - _.x) + Math.abs(this.y - _.y) + Math.abs(this.z - _.z)
                    }
                    setFromSpherical(_) {
                        return this.setFromSphericalCoords(_.radius, _.phi, _.theta)
                    }
                    setFromSphericalCoords(_, O, B) {
                        let N = Math.sin(O) * _;
                        return this.x = N * Math.sin(B), this.y = Math.cos(O) * _, this.z = N * Math.cos(B), this
                    }
                    setFromCylindrical(_) {
                        return this.setFromCylindricalCoords(_.radius, _.theta, _.y)
                    }
                    setFromCylindricalCoords(_, O, B) {
                        return this.x = _ * Math.sin(O), this.y = B, this.z = _ * Math.cos(O), this
                    }
                    setFromMatrixPosition(_) {
                        let O = _.elements;
                        return this.x = O[12], this.y = O[13], this.z = O[14], this
                    }
                    setFromMatrixScale(_) {
                        let O = this.setFromMatrixColumn(_, 0).length(),
                            B = this.setFromMatrixColumn(_, 1).length(),
                            N = this.setFromMatrixColumn(_, 2).length();
                        return this.x = O, this.y = B, this.z = N, this
                    }
                    setFromMatrixColumn(_, O) {
                        return this.fromArray(_.elements, 4 * O)
                    }
                    setFromMatrix3Column(_, O) {
                        return this.fromArray(_.elements, 3 * O)
                    }
                    setFromEuler(_) {
                        return this.x = _._x, this.y = _._y, this.z = _._z, this
                    }
                    equals(_) {
                        return _.x === this.x && _.y === this.y && _.z === this.z
                    }
                    fromArray(_, O = 0) {
                        return this.x = _[O], this.y = _[O + 1], this.z = _[O + 2], this
                    }
                    toArray(_ = [], O = 0) {
                        return _[O] = this.x, _[O + 1] = this.y, _[O + 2] = this.z, _
                    }
                    fromBufferAttribute(_, O) {
                        return this.x = _.getX(O), this.y = _.getY(O), this.z = _.getZ(O), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                    }
                    randomDirection() {
                        let _ = (Math.random() - .5) * 2,
                            O = Math.random() * Math.PI * 2,
                            B = Math.sqrt(1 - _ ** 2);
                        return this.x = B * Math.cos(O), this.y = B * Math.sin(O), this.z = _, this
                    }*[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z
                    }
                },
                ry = new rv,
                rx = new rm,
                rb = class {
                    constructor(_ = new rv(1 / 0, 1 / 0, 1 / 0), O = new rv(-1 / 0, -1 / 0, -1 / 0)) {
                        this.isBox3 = !0, this.min = _, this.max = O
                    }
                    set(_, O) {
                        return this.min.copy(_), this.max.copy(O), this
                    }
                    setFromArray(_) {
                        let O = 1 / 0,
                            B = 1 / 0,
                            N = 1 / 0,
                            k = -1 / 0,
                            F = -1 / 0,
                            U = -1 / 0;
                        for (let j = 0, G = _.length; j < G; j += 3) {
                            let G = _[j],
                                Y = _[j + 1],
                                Q = _[j + 2];
                            G < O && (O = G), Y < B && (B = Y), Q < N && (N = Q), G > k && (k = G), Y > F && (F = Y), Q > U && (U = Q)
                        }
                        return this.min.set(O, B, N), this.max.set(k, F, U), this
                    }
                    setFromBufferAttribute(_) {
                        let O = 1 / 0,
                            B = 1 / 0,
                            N = 1 / 0,
                            k = -1 / 0,
                            F = -1 / 0,
                            U = -1 / 0;
                        for (let j = 0, G = _.count; j < G; j++) {
                            let G = _.getX(j),
                                Y = _.getY(j),
                                Q = _.getZ(j);
                            G < O && (O = G), Y < B && (B = Y), Q < N && (N = Q), G > k && (k = G), Y > F && (F = Y), Q > U && (U = Q)
                        }
                        return this.min.set(O, B, N), this.max.set(k, F, U), this
                    }
                    setFromPoints(_) {
                        this.makeEmpty();
                        for (let O = 0, B = _.length; O < B; O++) this.expandByPoint(_[O]);
                        return this
                    }
                    setFromCenterAndSize(_, O) {
                        let B = rS.copy(O).multiplyScalar(.5);
                        return this.min.copy(_).sub(B), this.max.copy(_).add(B), this
                    }
                    setFromObject(_, O = !1) {
                        return this.makeEmpty(), this.expandByObject(_, O)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        return this.min.copy(_.min), this.max.copy(_.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(_) {
                        return this.isEmpty() ? _.set(0, 0, 0) : _.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(_) {
                        return this.isEmpty() ? _.set(0, 0, 0) : _.subVectors(this.max, this.min)
                    }
                    expandByPoint(_) {
                        return this.min.min(_), this.max.max(_), this
                    }
                    expandByVector(_) {
                        return this.min.sub(_), this.max.add(_), this
                    }
                    expandByScalar(_) {
                        return this.min.addScalar(-_), this.max.addScalar(_), this
                    }
                    expandByObject(_, O = !1) {
                        _.updateWorldMatrix(!1, !1);
                        let B = _.geometry;
                        if (void 0 !== B) {
                            if (O && null != B.attributes && void 0 !== B.attributes.position) {
                                let O = B.attributes.position;
                                for (let B = 0, N = O.count; B < N; B++) rS.fromBufferAttribute(O, B).applyMatrix4(_.matrixWorld), this.expandByPoint(rS)
                            } else null === B.boundingBox && B.computeBoundingBox(), rA.copy(B.boundingBox), rA.applyMatrix4(_.matrixWorld), this.union(rA)
                        }
                        let N = _.children;
                        for (let _ = 0, B = N.length; _ < B; _++) this.expandByObject(N[_], O);
                        return this
                    }
                    containsPoint(_) {
                        return !(_.x < this.min.x || _.x > this.max.x || _.y < this.min.y || _.y > this.max.y || _.z < this.min.z || _.z > this.max.z)
                    }
                    containsBox(_) {
                        return this.min.x <= _.min.x && _.max.x <= this.max.x && this.min.y <= _.min.y && _.max.y <= this.max.y && this.min.z <= _.min.z && _.max.z <= this.max.z
                    }
                    getParameter(_, O) {
                        return O.set((_.x - this.min.x) / (this.max.x - this.min.x), (_.y - this.min.y) / (this.max.y - this.min.y), (_.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(_) {
                        return !(_.max.x < this.min.x || _.min.x > this.max.x || _.max.y < this.min.y || _.min.y > this.max.y || _.max.z < this.min.z || _.min.z > this.max.z)
                    }
                    intersectsSphere(_) {
                        return this.clampPoint(_.center, rS), rS.distanceToSquared(_.center) <= _.radius * _.radius
                    }
                    intersectsPlane(_) {
                        let O, B;
                        return _.normal.x > 0 ? (O = _.normal.x * this.min.x, B = _.normal.x * this.max.x) : (O = _.normal.x * this.max.x, B = _.normal.x * this.min.x), _.normal.y > 0 ? (O += _.normal.y * this.min.y, B += _.normal.y * this.max.y) : (O += _.normal.y * this.max.y, B += _.normal.y * this.min.y), _.normal.z > 0 ? (O += _.normal.z * this.min.z, B += _.normal.z * this.max.z) : (O += _.normal.z * this.max.z, B += _.normal.z * this.min.z), O <= -_.constant && B >= -_.constant
                    }
                    intersectsTriangle(_) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(rR), rB.subVectors(this.max, rR), rE.subVectors(_.a, rR), rC.subVectors(_.b, rR), rT.subVectors(_.c, rR), rD.subVectors(rC, rE), rP.subVectors(rT, rC), rI.subVectors(rE, rT);
                        let O = [0, -rD.z, rD.y, 0, -rP.z, rP.y, 0, -rI.z, rI.y, rD.z, 0, -rD.x, rP.z, 0, -rP.x, rI.z, 0, -rI.x, -rD.y, rD.x, 0, -rP.y, rP.x, 0, -rI.y, rI.x, 0];
                        return !!(jx(O, rE, rC, rT, rB) && jx(O = [1, 0, 0, 0, 1, 0, 0, 0, 1], rE, rC, rT, rB)) && (rN.crossVectors(rD, rP), jx(O = [rN.x, rN.y, rN.z], rE, rC, rT, rB))
                    }
                    clampPoint(_, O) {
                        return O.copy(_).clamp(this.min, this.max)
                    }
                    distanceToPoint(_) {
                        return rS.copy(_).clamp(this.min, this.max).sub(_).length()
                    }
                    getBoundingSphere(_) {
                        return this.getCenter(_.center), _.radius = .5 * this.getSize(rS).length(), _
                    }
                    intersect(_) {
                        return this.min.max(_.min), this.max.min(_.max), this.isEmpty() && this.makeEmpty(), this
                    }
                    union(_) {
                        return this.min.min(_.min), this.max.max(_.max), this
                    }
                    applyMatrix4(_) {
                        return this.isEmpty() || (r_[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(_), r_[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(_), r_[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(_), r_[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(_), r_[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(_), r_[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(_), r_[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(_), r_[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(_), this.setFromPoints(r_)), this
                    }
                    translate(_) {
                        return this.min.add(_), this.max.add(_), this
                    }
                    equals(_) {
                        return _.min.equals(this.min) && _.max.equals(this.max)
                    }
                },
                r_ = [new rv, new rv, new rv, new rv, new rv, new rv, new rv, new rv],
                rS = new rv,
                rA = new rb,
                rE = new rv,
                rC = new rv,
                rT = new rv,
                rD = new rv,
                rP = new rv,
                rI = new rv,
                rR = new rv,
                rB = new rv,
                rN = new rv,
                rk = new rv;

            function jx(_, O, B, N, k) {
                for (let F = 0, U = _.length - 3; F <= U; F += 3) {
                    rk.fromArray(_, F);
                    let U = k.x * Math.abs(rk.x) + k.y * Math.abs(rk.y) + k.z * Math.abs(rk.z),
                        j = O.dot(rk),
                        G = B.dot(rk),
                        Y = N.dot(rk);
                    if (Math.max(-Math.max(j, G, Y), Math.min(j, G, Y)) > U) return !1
                }
                return !0
            }
            var rF = new rb,
                rU = new rv,
                rj = new rv,
                rG = class {
                    constructor(_ = new rv, O = -1) {
                        this.center = _, this.radius = O
                    }
                    set(_, O) {
                        return this.center.copy(_), this.radius = O, this
                    }
                    setFromPoints(_, O) {
                        let B = this.center;
                        void 0 !== O ? B.copy(O) : rF.setFromPoints(_).getCenter(B);
                        let N = 0;
                        for (let O = 0, k = _.length; O < k; O++) N = Math.max(N, B.distanceToSquared(_[O]));
                        return this.radius = Math.sqrt(N), this
                    }
                    copy(_) {
                        return this.center.copy(_.center), this.radius = _.radius, this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0), this.radius = -1, this
                    }
                    containsPoint(_) {
                        return _.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(_) {
                        return _.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(_) {
                        let O = this.radius + _.radius;
                        return _.center.distanceToSquared(this.center) <= O * O
                    }
                    intersectsBox(_) {
                        return _.intersectsSphere(this)
                    }
                    intersectsPlane(_) {
                        return Math.abs(_.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(_, O) {
                        let B = this.center.distanceToSquared(_);
                        return O.copy(_), B > this.radius * this.radius && (O.sub(this.center).normalize(), O.multiplyScalar(this.radius).add(this.center)), O
                    }
                    getBoundingBox(_) {
                        return this.isEmpty() ? _.makeEmpty() : (_.set(this.center, this.center), _.expandByScalar(this.radius)), _
                    }
                    applyMatrix4(_) {
                        return this.center.applyMatrix4(_), this.radius = this.radius * _.getMaxScaleOnAxis(), this
                    }
                    translate(_) {
                        return this.center.add(_), this
                    }
                    expandByPoint(_) {
                        if (this.isEmpty()) return this.center.copy(_), this.radius = 0, this;
                        rU.subVectors(_, this.center);
                        let O = rU.lengthSq();
                        if (O > this.radius * this.radius) {
                            let _ = Math.sqrt(O),
                                B = (_ - this.radius) * .5;
                            this.center.addScaledVector(rU, B / _), this.radius += B
                        }
                        return this
                    }
                    union(_) {
                        return _.isEmpty() || (this.isEmpty() ? this.copy(_) : !0 === this.center.equals(_.center) ? this.radius = Math.max(this.radius, _.radius) : (rj.subVectors(_.center, this.center).setLength(_.radius), this.expandByPoint(rU.copy(_.center).add(rj)), this.expandByPoint(rU.copy(_.center).sub(rj)))), this
                    }
                    equals(_) {
                        return _.center.equals(this.center) && _.radius === this.radius
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                },
                rH = new rv,
                rW = new rv,
                rq = new rv,
                rY = new rv,
                rX = new rv,
                rQ = new rv,
                rZ = new rv,
                rK = class {
                    constructor(_ = new rv, O = new rv(0, 0, -1)) {
                        this.origin = _, this.direction = O
                    }
                    set(_, O) {
                        return this.origin.copy(_), this.direction.copy(O), this
                    }
                    copy(_) {
                        return this.origin.copy(_.origin), this.direction.copy(_.direction), this
                    }
                    at(_, O) {
                        return O.copy(this.direction).multiplyScalar(_).add(this.origin)
                    }
                    lookAt(_) {
                        return this.direction.copy(_).sub(this.origin).normalize(), this
                    }
                    recast(_) {
                        return this.origin.copy(this.at(_, rH)), this
                    }
                    closestPointToPoint(_, O) {
                        O.subVectors(_, this.origin);
                        let B = O.dot(this.direction);
                        return B < 0 ? O.copy(this.origin) : O.copy(this.direction).multiplyScalar(B).add(this.origin)
                    }
                    distanceToPoint(_) {
                        return Math.sqrt(this.distanceSqToPoint(_))
                    }
                    distanceSqToPoint(_) {
                        let O = rH.subVectors(_, this.origin).dot(this.direction);
                        return O < 0 ? this.origin.distanceToSquared(_) : (rH.copy(this.direction).multiplyScalar(O).add(this.origin), rH.distanceToSquared(_))
                    }
                    distanceSqToSegment(_, O, B, N) {
                        rW.copy(_).add(O).multiplyScalar(.5), rq.copy(O).sub(_).normalize(), rY.copy(this.origin).sub(rW);
                        let k = .5 * _.distanceTo(O),
                            F = -this.direction.dot(rq),
                            U = rY.dot(this.direction),
                            j = -rY.dot(rq),
                            G = rY.lengthSq(),
                            Y = Math.abs(1 - F * F),
                            Q, K, $, ee;
                        if (Y > 0) {
                            if (Q = F * j - U, K = F * U - j, ee = k * Y, Q >= 0) {
                                if (K >= -ee) {
                                    if (K <= ee) {
                                        let _ = 1 / Y;
                                        Q *= _, K *= _, $ = Q * (Q + F * K + 2 * U) + K * (F * Q + K + 2 * j) + G
                                    } else $ = -(Q = Math.max(0, -(F * (K = k) + U))) * Q + K * (K + 2 * j) + G
                                } else $ = -(Q = Math.max(0, -(F * (K = -k) + U))) * Q + K * (K + 2 * j) + G
                            } else K <= -ee ? (K = (Q = Math.max(0, -(-F * k + U))) > 0 ? -k : Math.min(Math.max(-k, -j), k), $ = -Q * Q + K * (K + 2 * j) + G) : K <= ee ? (Q = 0, $ = (K = Math.min(Math.max(-k, -j), k)) * (K + 2 * j) + G) : (K = (Q = Math.max(0, -(F * k + U))) > 0 ? k : Math.min(Math.max(-k, -j), k), $ = -Q * Q + K * (K + 2 * j) + G)
                        } else K = F > 0 ? -k : k, $ = -(Q = Math.max(0, -(F * K + U))) * Q + K * (K + 2 * j) + G;
                        return B && B.copy(this.direction).multiplyScalar(Q).add(this.origin), N && N.copy(rq).multiplyScalar(K).add(rW), $
                    }
                    intersectSphere(_, O) {
                        rH.subVectors(_.center, this.origin);
                        let B = rH.dot(this.direction),
                            N = rH.dot(rH) - B * B,
                            k = _.radius * _.radius;
                        if (N > k) return null;
                        let F = Math.sqrt(k - N),
                            U = B - F,
                            j = B + F;
                        return U < 0 && j < 0 ? null : U < 0 ? this.at(j, O) : this.at(U, O)
                    }
                    intersectsSphere(_) {
                        return this.distanceSqToPoint(_.center) <= _.radius * _.radius
                    }
                    distanceToPlane(_) {
                        let O = _.normal.dot(this.direction);
                        if (0 === O) return 0 === _.distanceToPoint(this.origin) ? 0 : null;
                        let B = -(this.origin.dot(_.normal) + _.constant) / O;
                        return B >= 0 ? B : null
                    }
                    intersectPlane(_, O) {
                        let B = this.distanceToPlane(_);
                        return null === B ? null : this.at(B, O)
                    }
                    intersectsPlane(_) {
                        let O = _.distanceToPoint(this.origin);
                        return 0 === O || _.normal.dot(this.direction) * O < 0
                    }
                    intersectBox(_, O) {
                        let B, N, k, F, U, j, G = 1 / this.direction.x,
                            Y = 1 / this.direction.y,
                            Q = 1 / this.direction.z,
                            K = this.origin;
                        return G >= 0 ? (B = (_.min.x - K.x) * G, N = (_.max.x - K.x) * G) : (B = (_.max.x - K.x) * G, N = (_.min.x - K.x) * G), Y >= 0 ? (k = (_.min.y - K.y) * Y, F = (_.max.y - K.y) * Y) : (k = (_.max.y - K.y) * Y, F = (_.min.y - K.y) * Y), B > F || k > N || ((k > B || isNaN(B)) && (B = k), (F < N || isNaN(N)) && (N = F), Q >= 0 ? (U = (_.min.z - K.z) * Q, j = (_.max.z - K.z) * Q) : (U = (_.max.z - K.z) * Q, j = (_.min.z - K.z) * Q), B > j || U > N) || ((U > B || B != B) && (B = U), (j < N || N != N) && (N = j), N < 0) ? null : this.at(B >= 0 ? B : N, O)
                    }
                    intersectsBox(_) {
                        return null !== this.intersectBox(_, rH)
                    }
                    intersectTriangle(_, O, B, N, k) {
                        rX.subVectors(O, _), rQ.subVectors(B, _), rZ.crossVectors(rX, rQ);
                        let F = this.direction.dot(rZ),
                            U;
                        if (F > 0) {
                            if (N) return null;
                            U = 1
                        } else {
                            if (!(F < 0)) return null;
                            U = -1, F = -F
                        }
                        rY.subVectors(this.origin, _);
                        let j = U * this.direction.dot(rQ.crossVectors(rY, rQ));
                        if (j < 0) return null;
                        let G = U * this.direction.dot(rX.cross(rY));
                        if (G < 0 || j + G > F) return null;
                        let Y = -U * rY.dot(rZ);
                        return Y < 0 ? null : this.at(Y / F, k)
                    }
                    applyMatrix4(_) {
                        return this.origin.applyMatrix4(_), this.direction.transformDirection(_), this
                    }
                    equals(_) {
                        return _.origin.equals(this.origin) && _.direction.equals(this.direction)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                },
                rJ = class {
                    constructor() {
                        rJ.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                    }
                    set(_, O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei) {
                        let er = this.elements;
                        return er[0] = _, er[4] = O, er[8] = B, er[12] = N, er[1] = k, er[5] = F, er[9] = U, er[13] = j, er[2] = G, er[6] = Y, er[10] = Q, er[14] = K, er[3] = $, er[7] = ee, er[11] = et, er[15] = ei, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    clone() {
                        return new rJ().fromArray(this.elements)
                    }
                    copy(_) {
                        let O = this.elements,
                            B = _.elements;
                        return O[0] = B[0], O[1] = B[1], O[2] = B[2], O[3] = B[3], O[4] = B[4], O[5] = B[5], O[6] = B[6], O[7] = B[7], O[8] = B[8], O[9] = B[9], O[10] = B[10], O[11] = B[11], O[12] = B[12], O[13] = B[13], O[14] = B[14], O[15] = B[15], this
                    }
                    copyPosition(_) {
                        let O = this.elements,
                            B = _.elements;
                        return O[12] = B[12], O[13] = B[13], O[14] = B[14], this
                    }
                    setFromMatrix3(_) {
                        let O = _.elements;
                        return this.set(O[0], O[3], O[6], 0, O[1], O[4], O[7], 0, O[2], O[5], O[8], 0, 0, 0, 0, 1), this
                    }
                    extractBasis(_, O, B) {
                        return _.setFromMatrixColumn(this, 0), O.setFromMatrixColumn(this, 1), B.setFromMatrixColumn(this, 2), this
                    }
                    makeBasis(_, O, B) {
                        return this.set(_.x, O.x, B.x, 0, _.y, O.y, B.y, 0, _.z, O.z, B.z, 0, 0, 0, 0, 1), this
                    }
                    extractRotation(_) {
                        let O = this.elements,
                            B = _.elements,
                            N = 1 / r$.setFromMatrixColumn(_, 0).length(),
                            k = 1 / r$.setFromMatrixColumn(_, 1).length(),
                            F = 1 / r$.setFromMatrixColumn(_, 2).length();
                        return O[0] = B[0] * N, O[1] = B[1] * N, O[2] = B[2] * N, O[3] = 0, O[4] = B[4] * k, O[5] = B[5] * k, O[6] = B[6] * k, O[7] = 0, O[8] = B[8] * F, O[9] = B[9] * F, O[10] = B[10] * F, O[11] = 0, O[12] = 0, O[13] = 0, O[14] = 0, O[15] = 1, this
                    }
                    makeRotationFromEuler(_) {
                        let O = this.elements,
                            B = _.x,
                            N = _.y,
                            k = _.z,
                            F = Math.cos(B),
                            U = Math.sin(B),
                            j = Math.cos(N),
                            G = Math.sin(N),
                            Y = Math.cos(k),
                            Q = Math.sin(k);
                        if ("XYZ" === _.order) {
                            let _ = F * Y,
                                B = F * Q,
                                N = U * Y,
                                k = U * Q;
                            O[0] = j * Y, O[4] = -j * Q, O[8] = G, O[1] = B + N * G, O[5] = _ - k * G, O[9] = -U * j, O[2] = k - _ * G, O[6] = N + B * G, O[10] = F * j
                        } else if ("YXZ" === _.order) {
                            let _ = j * Y,
                                B = j * Q,
                                N = G * Y,
                                k = G * Q;
                            O[0] = _ + k * U, O[4] = N * U - B, O[8] = F * G, O[1] = F * Q, O[5] = F * Y, O[9] = -U, O[2] = B * U - N, O[6] = k + _ * U, O[10] = F * j
                        } else if ("ZXY" === _.order) {
                            let _ = j * Y,
                                B = j * Q,
                                N = G * Y,
                                k = G * Q;
                            O[0] = _ - k * U, O[4] = -F * Q, O[8] = N + B * U, O[1] = B + N * U, O[5] = F * Y, O[9] = k - _ * U, O[2] = -F * G, O[6] = U, O[10] = F * j
                        } else if ("ZYX" === _.order) {
                            let _ = F * Y,
                                B = F * Q,
                                N = U * Y,
                                k = U * Q;
                            O[0] = j * Y, O[4] = N * G - B, O[8] = _ * G + k, O[1] = j * Q, O[5] = k * G + _, O[9] = B * G - N, O[2] = -G, O[6] = U * j, O[10] = F * j
                        } else if ("YZX" === _.order) {
                            let _ = F * j,
                                B = F * G,
                                N = U * j,
                                k = U * G;
                            O[0] = j * Y, O[4] = k - _ * Q, O[8] = N * Q + B, O[1] = Q, O[5] = F * Y, O[9] = -U * Y, O[2] = -G * Y, O[6] = B * Q + N, O[10] = _ - k * Q
                        } else if ("XZY" === _.order) {
                            let _ = F * j,
                                B = F * G,
                                N = U * j,
                                k = U * G;
                            O[0] = j * Y, O[4] = -Q, O[8] = G * Y, O[1] = _ * Q + k, O[5] = F * Y, O[9] = B * Q - N, O[2] = N * Q - B, O[6] = U * Y, O[10] = k * Q + _
                        }
                        return O[3] = 0, O[7] = 0, O[11] = 0, O[12] = 0, O[13] = 0, O[14] = 0, O[15] = 1, this
                    }
                    makeRotationFromQuaternion(_) {
                        return this.compose(r1, _, r2)
                    }
                    lookAt(_, O, B) {
                        let N = this.elements;
                        return r5.subVectors(_, O), 0 === r5.lengthSq() && (r5.z = 1), r5.normalize(), r3.crossVectors(B, r5), 0 === r3.lengthSq() && (1 === Math.abs(B.z) ? r5.x += 1e-4 : r5.z += 1e-4, r5.normalize(), r3.crossVectors(B, r5)), r3.normalize(), r4.crossVectors(r5, r3), N[0] = r3.x, N[4] = r4.x, N[8] = r5.x, N[1] = r3.y, N[5] = r4.y, N[9] = r5.y, N[2] = r3.z, N[6] = r4.z, N[10] = r5.z, this
                    }
                    multiply(_) {
                        return this.multiplyMatrices(this, _)
                    }
                    premultiply(_) {
                        return this.multiplyMatrices(_, this)
                    }
                    multiplyMatrices(_, O) {
                        let B = _.elements,
                            N = O.elements,
                            k = this.elements,
                            F = B[0],
                            U = B[4],
                            j = B[8],
                            G = B[12],
                            Y = B[1],
                            Q = B[5],
                            K = B[9],
                            $ = B[13],
                            ee = B[2],
                            et = B[6],
                            ei = B[10],
                            er = B[14],
                            ea = B[3],
                            en = B[7],
                            eo = B[11],
                            el = B[15],
                            eh = N[0],
                            ec = N[4],
                            eu = N[8],
                            ep = N[12],
                            ef = N[1],
                            em = N[5],
                            eg = N[9],
                            ev = N[13],
                            ex = N[2],
                            eb = N[6],
                            e_ = N[10],
                            eS = N[14],
                            eA = N[3],
                            eM = N[7],
                            eE = N[11],
                            eC = N[15];
                        return k[0] = F * eh + U * ef + j * ex + G * eA, k[4] = F * ec + U * em + j * eb + G * eM, k[8] = F * eu + U * eg + j * e_ + G * eE, k[12] = F * ep + U * ev + j * eS + G * eC, k[1] = Y * eh + Q * ef + K * ex + $ * eA, k[5] = Y * ec + Q * em + K * eb + $ * eM, k[9] = Y * eu + Q * eg + K * e_ + $ * eE, k[13] = Y * ep + Q * ev + K * eS + $ * eC, k[2] = ee * eh + et * ef + ei * ex + er * eA, k[6] = ee * ec + et * em + ei * eb + er * eM, k[10] = ee * eu + et * eg + ei * e_ + er * eE, k[14] = ee * ep + et * ev + ei * eS + er * eC, k[3] = ea * eh + en * ef + eo * ex + el * eA, k[7] = ea * ec + en * em + eo * eb + el * eM, k[11] = ea * eu + en * eg + eo * e_ + el * eE, k[15] = ea * ep + en * ev + eo * eS + el * eC, this
                    }
                    multiplyScalar(_) {
                        let O = this.elements;
                        return O[0] *= _, O[4] *= _, O[8] *= _, O[12] *= _, O[1] *= _, O[5] *= _, O[9] *= _, O[13] *= _, O[2] *= _, O[6] *= _, O[10] *= _, O[14] *= _, O[3] *= _, O[7] *= _, O[11] *= _, O[15] *= _, this
                    }
                    determinant() {
                        let _ = this.elements,
                            O = _[0],
                            B = _[4],
                            N = _[8],
                            k = _[12],
                            F = _[1],
                            U = _[5],
                            j = _[9],
                            G = _[13],
                            Y = _[2],
                            Q = _[6],
                            K = _[10],
                            $ = _[14];
                        return _[3] * (+k * j * Q - N * G * Q - k * U * K + B * G * K + N * U * $ - B * j * $) + _[7] * (+O * j * $ - O * G * K + k * F * K - N * F * $ + N * G * Y - k * j * Y) + _[11] * (+O * G * Q - O * U * $ - k * F * Q + B * F * $ + k * U * Y - B * G * Y) + _[15] * (-N * U * Y - O * j * Q + O * U * K + N * F * Q - B * F * K + B * j * Y)
                    }
                    transpose() {
                        let _ = this.elements,
                            O;
                        return O = _[1], _[1] = _[4], _[4] = O, O = _[2], _[2] = _[8], _[8] = O, O = _[6], _[6] = _[9], _[9] = O, O = _[3], _[3] = _[12], _[12] = O, O = _[7], _[7] = _[13], _[13] = O, O = _[11], _[11] = _[14], _[14] = O, this
                    }
                    setPosition(_, O, B) {
                        let N = this.elements;
                        return _.isVector3 ? (N[12] = _.x, N[13] = _.y, N[14] = _.z) : (N[12] = _, N[13] = O, N[14] = B), this
                    }
                    invert() {
                        let _ = this.elements,
                            O = _[0],
                            B = _[1],
                            N = _[2],
                            k = _[3],
                            F = _[4],
                            U = _[5],
                            j = _[6],
                            G = _[7],
                            Y = _[8],
                            Q = _[9],
                            K = _[10],
                            $ = _[11],
                            ee = _[12],
                            et = _[13],
                            ei = _[14],
                            er = _[15],
                            ea = Q * ei * G - et * K * G + et * j * $ - U * ei * $ - Q * j * er + U * K * er,
                            en = ee * K * G - Y * ei * G - ee * j * $ + F * ei * $ + Y * j * er - F * K * er,
                            eo = Y * et * G - ee * Q * G + ee * U * $ - F * et * $ - Y * U * er + F * Q * er,
                            el = ee * Q * j - Y * et * j - ee * U * K + F * et * K + Y * U * ei - F * Q * ei,
                            eh = O * ea + B * en + N * eo + k * el;
                        if (0 === eh) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        let ec = 1 / eh;
                        return _[0] = ea * ec, _[1] = (et * K * k - Q * ei * k - et * N * $ + B * ei * $ + Q * N * er - B * K * er) * ec, _[2] = (U * ei * k - et * j * k + et * N * G - B * ei * G - U * N * er + B * j * er) * ec, _[3] = (Q * j * k - U * K * k - Q * N * G + B * K * G + U * N * $ - B * j * $) * ec, _[4] = en * ec, _[5] = (Y * ei * k - ee * K * k + ee * N * $ - O * ei * $ - Y * N * er + O * K * er) * ec, _[6] = (ee * j * k - F * ei * k - ee * N * G + O * ei * G + F * N * er - O * j * er) * ec, _[7] = (F * K * k - Y * j * k + Y * N * G - O * K * G - F * N * $ + O * j * $) * ec, _[8] = eo * ec, _[9] = (ee * Q * k - Y * et * k - ee * B * $ + O * et * $ + Y * B * er - O * Q * er) * ec, _[10] = (F * et * k - ee * U * k + ee * B * G - O * et * G - F * B * er + O * U * er) * ec, _[11] = (Y * U * k - F * Q * k - Y * B * G + O * Q * G + F * B * $ - O * U * $) * ec, _[12] = el * ec, _[13] = (Y * et * N - ee * Q * N + ee * B * K - O * et * K - Y * B * ei + O * Q * ei) * ec, _[14] = (ee * U * N - F * et * N - ee * B * j + O * et * j + F * B * ei - O * U * ei) * ec, _[15] = (F * Q * N - Y * U * N + Y * B * j - O * Q * j - F * B * K + O * U * K) * ec, this
                    }
                    scale(_) {
                        let O = this.elements,
                            B = _.x,
                            N = _.y,
                            k = _.z;
                        return O[0] *= B, O[4] *= N, O[8] *= k, O[1] *= B, O[5] *= N, O[9] *= k, O[2] *= B, O[6] *= N, O[10] *= k, O[3] *= B, O[7] *= N, O[11] *= k, this
                    }
                    getMaxScaleOnAxis() {
                        let _ = this.elements;
                        return Math.sqrt(Math.max(_[0] * _[0] + _[1] * _[1] + _[2] * _[2], _[4] * _[4] + _[5] * _[5] + _[6] * _[6], _[8] * _[8] + _[9] * _[9] + _[10] * _[10]))
                    }
                    makeTranslation(_, O, B) {
                        return this.set(1, 0, 0, _, 0, 1, 0, O, 0, 0, 1, B, 0, 0, 0, 1), this
                    }
                    makeRotationX(_) {
                        let O = Math.cos(_),
                            B = Math.sin(_);
                        return this.set(1, 0, 0, 0, 0, O, -B, 0, 0, B, O, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(_) {
                        let O = Math.cos(_),
                            B = Math.sin(_);
                        return this.set(O, 0, B, 0, 0, 1, 0, 0, -B, 0, O, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(_) {
                        let O = Math.cos(_),
                            B = Math.sin(_);
                        return this.set(O, -B, 0, 0, B, O, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(_, O) {
                        let B = Math.cos(O),
                            N = Math.sin(O),
                            k = 1 - B,
                            F = _.x,
                            U = _.y,
                            j = _.z,
                            G = k * F,
                            Y = k * U;
                        return this.set(G * F + B, G * U - N * j, G * j + N * U, 0, G * U + N * j, Y * U + B, Y * j - N * F, 0, G * j - N * U, Y * j + N * F, k * j * j + B, 0, 0, 0, 0, 1), this
                    }
                    makeScale(_, O, B) {
                        return this.set(_, 0, 0, 0, 0, O, 0, 0, 0, 0, B, 0, 0, 0, 0, 1), this
                    }
                    makeShear(_, O, B, N, k, F) {
                        return this.set(1, B, k, 0, _, 1, F, 0, O, N, 1, 0, 0, 0, 0, 1), this
                    }
                    compose(_, O, B) {
                        let N = this.elements,
                            k = O._x,
                            F = O._y,
                            U = O._z,
                            j = O._w,
                            G = k + k,
                            Y = F + F,
                            Q = U + U,
                            K = k * G,
                            $ = k * Y,
                            ee = k * Q,
                            et = F * Y,
                            ei = F * Q,
                            er = U * Q,
                            ea = j * G,
                            en = j * Y,
                            eo = j * Q,
                            el = B.x,
                            eh = B.y,
                            ec = B.z;
                        return N[0] = (1 - (et + er)) * el, N[1] = ($ + eo) * el, N[2] = (ee - en) * el, N[3] = 0, N[4] = ($ - eo) * eh, N[5] = (1 - (K + er)) * eh, N[6] = (ei + ea) * eh, N[7] = 0, N[8] = (ee + en) * ec, N[9] = (ei - ea) * ec, N[10] = (1 - (K + et)) * ec, N[11] = 0, N[12] = _.x, N[13] = _.y, N[14] = _.z, N[15] = 1, this
                    }
                    decompose(_, O, B) {
                        let N = this.elements,
                            k = r$.set(N[0], N[1], N[2]).length(),
                            F = r$.set(N[4], N[5], N[6]).length(),
                            U = r$.set(N[8], N[9], N[10]).length();
                        0 > this.determinant() && (k = -k), _.x = N[12], _.y = N[13], _.z = N[14], r0.copy(this);
                        let j = 1 / k,
                            G = 1 / F,
                            Y = 1 / U;
                        return r0.elements[0] *= j, r0.elements[1] *= j, r0.elements[2] *= j, r0.elements[4] *= G, r0.elements[5] *= G, r0.elements[6] *= G, r0.elements[8] *= Y, r0.elements[9] *= Y, r0.elements[10] *= Y, O.setFromRotationMatrix(r0), B.x = k, B.y = F, B.z = U, this
                    }
                    makePerspective(_, O, B, N, k, F) {
                        let U = this.elements;
                        return U[0] = 2 * k / (O - _), U[4] = 0, U[8] = (O + _) / (O - _), U[12] = 0, U[1] = 0, U[5] = 2 * k / (B - N), U[9] = (B + N) / (B - N), U[13] = 0, U[2] = 0, U[6] = 0, U[10] = -(F + k) / (F - k), U[14] = -2 * F * k / (F - k), U[3] = 0, U[7] = 0, U[11] = -1, U[15] = 0, this
                    }
                    makeOrthographic(_, O, B, N, k, F) {
                        let U = this.elements,
                            j = 1 / (O - _),
                            G = 1 / (B - N),
                            Y = 1 / (F - k);
                        return U[0] = 2 * j, U[4] = 0, U[8] = 0, U[12] = -((O + _) * j), U[1] = 0, U[5] = 2 * G, U[9] = 0, U[13] = -((B + N) * G), U[2] = 0, U[6] = 0, U[10] = -2 * Y, U[14] = -((F + k) * Y), U[3] = 0, U[7] = 0, U[11] = 0, U[15] = 1, this
                    }
                    equals(_) {
                        let O = this.elements,
                            B = _.elements;
                        for (let _ = 0; _ < 16; _++)
                            if (O[_] !== B[_]) return !1;
                        return !0
                    }
                    fromArray(_, O = 0) {
                        for (let B = 0; B < 16; B++) this.elements[B] = _[B + O];
                        return this
                    }
                    toArray(_ = [], O = 0) {
                        let B = this.elements;
                        return _[O] = B[0], _[O + 1] = B[1], _[O + 2] = B[2], _[O + 3] = B[3], _[O + 4] = B[4], _[O + 5] = B[5], _[O + 6] = B[6], _[O + 7] = B[7], _[O + 8] = B[8], _[O + 9] = B[9], _[O + 10] = B[10], _[O + 11] = B[11], _[O + 12] = B[12], _[O + 13] = B[13], _[O + 14] = B[14], _[O + 15] = B[15], _
                    }
                },
                r$ = new rv,
                r0 = new rJ,
                r1 = new rv(0, 0, 0),
                r2 = new rv(1, 1, 1),
                r3 = new rv,
                r4 = new rv,
                r5 = new rv,
                r6 = new rJ,
                r8 = new rm,
                r9 = class {
                    constructor(_ = 0, O = 0, B = 0, N = r9.DEFAULT_ORDER) {
                        this.isEuler = !0, this._x = _, this._y = O, this._z = B, this._order = N
                    }
                    get x() {
                        return this._x
                    }
                    set x(_) {
                        this._x = _, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(_) {
                        this._y = _, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(_) {
                        this._z = _, this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(_) {
                        this._order = _, this._onChangeCallback()
                    }
                    set(_, O, B, N = this._order) {
                        return this._x = _, this._y = O, this._z = B, this._order = N, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    }
                    copy(_) {
                        return this._x = _._x, this._y = _._y, this._z = _._z, this._order = _._order, this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(_, O = this._order, B = !0) {
                        let N = _.elements,
                            k = N[0],
                            F = N[4],
                            U = N[8],
                            j = N[1],
                            G = N[5],
                            Y = N[9],
                            Q = N[2],
                            K = N[6],
                            $ = N[10];
                        switch (O) {
                            case "XYZ":
                                this._y = Math.asin(Yr(U, -1, 1)), .9999999 > Math.abs(U) ? (this._x = Math.atan2(-Y, $), this._z = Math.atan2(-F, k)) : (this._x = Math.atan2(K, G), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-Yr(Y, -1, 1)), .9999999 > Math.abs(Y) ? (this._y = Math.atan2(U, $), this._z = Math.atan2(j, G)) : (this._y = Math.atan2(-Q, k), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(Yr(K, -1, 1)), .9999999 > Math.abs(K) ? (this._y = Math.atan2(-Q, $), this._z = Math.atan2(-F, G)) : (this._y = 0, this._z = Math.atan2(j, k));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-Yr(Q, -1, 1)), .9999999 > Math.abs(Q) ? (this._x = Math.atan2(K, $), this._z = Math.atan2(j, k)) : (this._x = 0, this._z = Math.atan2(-F, G));
                                break;
                            case "YZX":
                                this._z = Math.asin(Yr(j, -1, 1)), .9999999 > Math.abs(j) ? (this._x = Math.atan2(-Y, G), this._y = Math.atan2(-Q, k)) : (this._x = 0, this._y = Math.atan2(U, $));
                                break;
                            case "XZY":
                                this._z = Math.asin(-Yr(F, -1, 1)), .9999999 > Math.abs(F) ? (this._x = Math.atan2(K, G), this._y = Math.atan2(U, k)) : (this._x = Math.atan2(-Y, $), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + O)
                        }
                        return this._order = O, !0 === B && this._onChangeCallback(), this
                    }
                    setFromQuaternion(_, O, B) {
                        return r6.makeRotationFromQuaternion(_), this.setFromRotationMatrix(r6, O, B)
                    }
                    setFromVector3(_, O = this._order) {
                        return this.set(_.x, _.y, _.z, O)
                    }
                    reorder(_) {
                        return r8.setFromEuler(this), this.setFromQuaternion(r8, _)
                    }
                    equals(_) {
                        return _._x === this._x && _._y === this._y && _._z === this._z && _._order === this._order
                    }
                    fromArray(_) {
                        return this._x = _[0], this._y = _[1], this._z = _[2], void 0 !== _[3] && (this._order = _[3]), this._onChangeCallback(), this
                    }
                    toArray(_ = [], O = 0) {
                        return _[O] = this._x, _[O + 1] = this._y, _[O + 2] = this._z, _[O + 3] = this._order, _
                    }
                    _onChange(_) {
                        return this._onChangeCallback = _, this
                    }
                    _onChangeCallback() {}*[Symbol.iterator]() {
                        yield this._x, yield this._y, yield this._z, yield this._order
                    }
                };
            r9.DEFAULT_ORDER = "XYZ";
            var r7 = class {
                    constructor() {
                        this.mask = 1
                    }
                    set(_) {
                        this.mask = (1 << _ | 0) >>> 0
                    }
                    enable(_) {
                        this.mask |= 1 << _ | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(_) {
                        this.mask ^= 1 << _ | 0
                    }
                    disable(_) {
                        this.mask &= ~(1 << _ | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(_) {
                        return (this.mask & _.mask) != 0
                    }
                    isEnabled(_) {
                        return (this.mask & (1 << _ | 0)) != 0
                    }
                },
                st = 0,
                si = new rv,
                sr = new rm,
                ss = new rJ,
                sa = new rv,
                sn = new rv,
                so = new rv,
                sl = new rm,
                sh = new rv(1, 0, 0),
                su = new rv(0, 1, 0),
                sp = new rv(0, 0, 1),
                sf = {
                    type: "added"
                },
                sg = {
                    type: "removed"
                },
                sv = class extends iq {
                    constructor() {
                        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                            value: st++
                        }), this.uuid = Ui(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = sv.DEFAULT_UP.clone();
                        let _ = new rv,
                            O = new r9,
                            B = new rm,
                            N = new rv(1, 1, 1);
                        O._onChange(function() {
                            B.setFromEuler(O, !1)
                        }), B._onChange(function() {
                            O.setFromQuaternion(B, void 0, !1)
                        }), Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: _
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: O
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: B
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: N
                            },
                            modelViewMatrix: {
                                value: new rJ
                            },
                            normalMatrix: {
                                value: new i$
                            }
                        }), this.matrix = new rJ, this.matrixWorld = new rJ, this.matrixAutoUpdate = sv.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = sv.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new r7, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(_) {
                        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(_), this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(_) {
                        return this.quaternion.premultiply(_), this
                    }
                    setRotationFromAxisAngle(_, O) {
                        this.quaternion.setFromAxisAngle(_, O)
                    }
                    setRotationFromEuler(_) {
                        this.quaternion.setFromEuler(_, !0)
                    }
                    setRotationFromMatrix(_) {
                        this.quaternion.setFromRotationMatrix(_)
                    }
                    setRotationFromQuaternion(_) {
                        this.quaternion.copy(_)
                    }
                    rotateOnAxis(_, O) {
                        return sr.setFromAxisAngle(_, O), this.quaternion.multiply(sr), this
                    }
                    rotateOnWorldAxis(_, O) {
                        return sr.setFromAxisAngle(_, O), this.quaternion.premultiply(sr), this
                    }
                    rotateX(_) {
                        return this.rotateOnAxis(sh, _)
                    }
                    rotateY(_) {
                        return this.rotateOnAxis(su, _)
                    }
                    rotateZ(_) {
                        return this.rotateOnAxis(sp, _)
                    }
                    translateOnAxis(_, O) {
                        return si.copy(_).applyQuaternion(this.quaternion), this.position.add(si.multiplyScalar(O)), this
                    }
                    translateX(_) {
                        return this.translateOnAxis(sh, _)
                    }
                    translateY(_) {
                        return this.translateOnAxis(su, _)
                    }
                    translateZ(_) {
                        return this.translateOnAxis(sp, _)
                    }
                    localToWorld(_) {
                        return this.updateWorldMatrix(!0, !1), _.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(_) {
                        return this.updateWorldMatrix(!0, !1), _.applyMatrix4(ss.copy(this.matrixWorld).invert())
                    }
                    lookAt(_, O, B) {
                        _.isVector3 ? sa.copy(_) : sa.set(_, O, B);
                        let N = this.parent;
                        this.updateWorldMatrix(!0, !1), sn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ss.lookAt(sn, sa, this.up) : ss.lookAt(sa, sn, this.up), this.quaternion.setFromRotationMatrix(ss), N && (ss.extractRotation(N.matrixWorld), sr.setFromRotationMatrix(ss), this.quaternion.premultiply(sr.invert()))
                    }
                    add(_) {
                        if (arguments.length > 1) {
                            for (let _ = 0; _ < arguments.length; _++) this.add(arguments[_]);
                            return this
                        }
                        return _ === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", _) : _ && _.isObject3D ? (null !== _.parent && _.parent.remove(_), _.parent = this, this.children.push(_), _.dispatchEvent(sf)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", _), this
                    }
                    remove(_) {
                        if (arguments.length > 1) {
                            for (let _ = 0; _ < arguments.length; _++) this.remove(arguments[_]);
                            return this
                        }
                        let O = this.children.indexOf(_);
                        return -1 !== O && (_.parent = null, this.children.splice(O, 1), _.dispatchEvent(sg)), this
                    }
                    removeFromParent() {
                        let _ = this.parent;
                        return null !== _ && _.remove(this), this
                    }
                    clear() {
                        for (let _ = 0; _ < this.children.length; _++) {
                            let O = this.children[_];
                            O.parent = null, O.dispatchEvent(sg)
                        }
                        return this.children.length = 0, this
                    }
                    attach(_) {
                        return this.updateWorldMatrix(!0, !1), ss.copy(this.matrixWorld).invert(), null !== _.parent && (_.parent.updateWorldMatrix(!0, !1), ss.multiply(_.parent.matrixWorld)), _.applyMatrix4(ss), this.add(_), _.updateWorldMatrix(!1, !0), this
                    }
                    getObjectById(_) {
                        return this.getObjectByProperty("id", _)
                    }
                    getObjectByName(_) {
                        return this.getObjectByProperty("name", _)
                    }
                    getObjectByProperty(_, O) {
                        if (this[_] === O) return this;
                        for (let B = 0, N = this.children.length; B < N; B++) {
                            let N = this.children[B].getObjectByProperty(_, O);
                            if (void 0 !== N) return N
                        }
                    }
                    getObjectsByProperty(_, O) {
                        let B = [];
                        this[_] === O && B.push(this);
                        for (let N = 0, k = this.children.length; N < k; N++) {
                            let k = this.children[N].getObjectsByProperty(_, O);
                            k.length > 0 && (B = B.concat(k))
                        }
                        return B
                    }
                    getWorldPosition(_) {
                        return this.updateWorldMatrix(!0, !1), _.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(_) {
                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sn, _, so), _
                    }
                    getWorldScale(_) {
                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sn, sl, _), _
                    }
                    getWorldDirection(_) {
                        this.updateWorldMatrix(!0, !1);
                        let O = this.matrixWorld.elements;
                        return _.set(O[8], O[9], O[10]).normalize()
                    }
                    raycast() {}
                    traverse(_) {
                        _(this);
                        let O = this.children;
                        for (let B = 0, N = O.length; B < N; B++) O[B].traverse(_)
                    }
                    traverseVisible(_) {
                        if (!1 === this.visible) return;
                        _(this);
                        let O = this.children;
                        for (let B = 0, N = O.length; B < N; B++) O[B].traverseVisible(_)
                    }
                    traverseAncestors(_) {
                        let O = this.parent;
                        null !== O && (_(O), O.traverseAncestors(_))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(_) {
                        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || _) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, _ = !0);
                        let O = this.children;
                        for (let B = 0, N = O.length; B < N; B++) {
                            let N = O[B];
                            (!0 === N.matrixWorldAutoUpdate || !0 === _) && N.updateMatrixWorld(_)
                        }
                    }
                    updateWorldMatrix(_, O) {
                        let B = this.parent;
                        if (!0 === _ && null !== B && !0 === B.matrixWorldAutoUpdate && B.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === O) {
                            let _ = this.children;
                            for (let O = 0, B = _.length; O < B; O++) {
                                let B = _[O];
                                !0 === B.matrixWorldAutoUpdate && B.updateWorldMatrix(!1, !0)
                            }
                        }
                    }
                    toJSON(_) {
                        let O = void 0 === _ || "string" == typeof _,
                            B = {};
                        O && (_ = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                            nodes: {}
                        }, B.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        let N = {};

                        function s(O, B) {
                            return void 0 === O[B.uuid] && (O[B.uuid] = B.toJSON(_)), B.uuid
                        }
                        if (N.uuid = this.uuid, N.type = this.type, "" !== this.name && (N.name = this.name), !0 === this.castShadow && (N.castShadow = !0), !0 === this.receiveShadow && (N.receiveShadow = !0), !1 === this.visible && (N.visible = !1), !1 === this.frustumCulled && (N.frustumCulled = !1), 0 !== this.renderOrder && (N.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (N.userData = this.userData), N.layers = this.layers.mask, N.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (N.matrixAutoUpdate = !1), this.isInstancedMesh && (N.type = "InstancedMesh", N.count = this.count, N.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (N.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? N.background = this.background.toJSON() : this.background.isTexture && (N.background = this.background.toJSON(_).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (N.environment = this.environment.toJSON(_).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            N.geometry = s(_.geometries, this.geometry);
                            let O = this.geometry.parameters;
                            if (void 0 !== O && void 0 !== O.shapes) {
                                let B = O.shapes;
                                if (Array.isArray(B))
                                    for (let O = 0, N = B.length; O < N; O++) {
                                        let N = B[O];
                                        s(_.shapes, N)
                                    } else s(_.shapes, B)
                            }
                        }
                        if (this.isSkinnedMesh && (N.bindMode = this.bindMode, N.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (s(_.skeletons, this.skeleton), N.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
                            if (Array.isArray(this.material)) {
                                let O = [];
                                for (let B = 0, N = this.material.length; B < N; B++) O.push(s(_.materials, this.material[B]));
                                N.material = O
                            } else N.material = s(_.materials, this.material)
                        }
                        if (this.children.length > 0) {
                            N.children = [];
                            for (let O = 0; O < this.children.length; O++) N.children.push(this.children[O].toJSON(_).object)
                        }
                        if (this.animations.length > 0) {
                            N.animations = [];
                            for (let O = 0; O < this.animations.length; O++) {
                                let B = this.animations[O];
                                N.animations.push(s(_.animations, B))
                            }
                        }
                        if (O) {
                            let O = o(_.geometries),
                                N = o(_.materials),
                                k = o(_.textures),
                                F = o(_.images),
                                U = o(_.shapes),
                                j = o(_.skeletons),
                                G = o(_.animations),
                                Y = o(_.nodes);
                            O.length > 0 && (B.geometries = O), N.length > 0 && (B.materials = N), k.length > 0 && (B.textures = k), F.length > 0 && (B.images = F), U.length > 0 && (B.shapes = U), j.length > 0 && (B.skeletons = j), G.length > 0 && (B.animations = G), Y.length > 0 && (B.nodes = Y)
                        }
                        return B.object = N, B;

                        function o(_) {
                            let O = [];
                            for (let B in _) {
                                let N = _[B];
                                delete N.metadata, O.push(N)
                            }
                            return O
                        }
                    }
                    clone(_) {
                        return new this.constructor().copy(this, _)
                    }
                    copy(_, O = !0) {
                        if (this.name = _.name, this.up.copy(_.up), this.position.copy(_.position), this.rotation.order = _.rotation.order, this.quaternion.copy(_.quaternion), this.scale.copy(_.scale), this.matrix.copy(_.matrix), this.matrixWorld.copy(_.matrixWorld), this.matrixAutoUpdate = _.matrixAutoUpdate, this.matrixWorldNeedsUpdate = _.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = _.matrixWorldAutoUpdate, this.layers.mask = _.layers.mask, this.visible = _.visible, this.castShadow = _.castShadow, this.receiveShadow = _.receiveShadow, this.frustumCulled = _.frustumCulled, this.renderOrder = _.renderOrder, this.userData = JSON.parse(JSON.stringify(_.userData)), !0 === O)
                            for (let O = 0; O < _.children.length; O++) {
                                let B = _.children[O];
                                this.add(B.clone())
                            }
                        return this
                    }
                };
            sv.DEFAULT_UP = new rv(0, 1, 0), sv.DEFAULT_MATRIX_AUTO_UPDATE = !0, sv.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            var sx = new rv,
                sb = new rv,
                sw = new rv,
                s_ = new rv,
                sS = new rv,
                sA = new rv,
                sE = new rv,
                sD = new rv,
                sP = new rv,
                sI = new rv,
                sO = class {
                    constructor(_ = new rv, O = new rv, B = new rv) {
                        this.a = _, this.b = O, this.c = B
                    }
                    static getNormal(_, O, B, N) {
                        N.subVectors(B, O), sx.subVectors(_, O), N.cross(sx);
                        let k = N.lengthSq();
                        return k > 0 ? N.multiplyScalar(1 / Math.sqrt(k)) : N.set(0, 0, 0)
                    }
                    static getBarycoord(_, O, B, N, k) {
                        sx.subVectors(N, O), sb.subVectors(B, O), sw.subVectors(_, O);
                        let F = sx.dot(sx),
                            U = sx.dot(sb),
                            j = sx.dot(sw),
                            G = sb.dot(sb),
                            Y = sb.dot(sw),
                            Q = F * G - U * U;
                        if (0 === Q) return k.set(-2, -1, -1);
                        let K = 1 / Q,
                            $ = (G * j - U * Y) * K,
                            ee = (F * Y - U * j) * K;
                        return k.set(1 - $ - ee, ee, $)
                    }
                    static containsPoint(_, O, B, N) {
                        return this.getBarycoord(_, O, B, N, s_), s_.x >= 0 && s_.y >= 0 && s_.x + s_.y <= 1
                    }
                    static getUV(_, O, B, N, k, F, U, j) {
                        return this.getBarycoord(_, O, B, N, s_), j.set(0, 0), j.addScaledVector(k, s_.x), j.addScaledVector(F, s_.y), j.addScaledVector(U, s_.z), j
                    }
                    static isFrontFacing(_, O, B, N) {
                        return sx.subVectors(B, O), sb.subVectors(_, O), 0 > sx.cross(sb).dot(N)
                    }
                    set(_, O, B) {
                        return this.a.copy(_), this.b.copy(O), this.c.copy(B), this
                    }
                    setFromPointsAndIndices(_, O, B, N) {
                        return this.a.copy(_[O]), this.b.copy(_[B]), this.c.copy(_[N]), this
                    }
                    setFromAttributeAndIndices(_, O, B, N) {
                        return this.a.fromBufferAttribute(_, O), this.b.fromBufferAttribute(_, B), this.c.fromBufferAttribute(_, N), this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        return this.a.copy(_.a), this.b.copy(_.b), this.c.copy(_.c), this
                    }
                    getArea() {
                        return sx.subVectors(this.c, this.b), sb.subVectors(this.a, this.b), .5 * sx.cross(sb).length()
                    }
                    getMidpoint(_) {
                        return _.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(_) {
                        return sO.getNormal(this.a, this.b, this.c, _)
                    }
                    getPlane(_) {
                        return _.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(_, O) {
                        return sO.getBarycoord(_, this.a, this.b, this.c, O)
                    }
                    getUV(_, O, B, N, k) {
                        return sO.getUV(_, this.a, this.b, this.c, O, B, N, k)
                    }
                    containsPoint(_) {
                        return sO.containsPoint(_, this.a, this.b, this.c)
                    }
                    isFrontFacing(_) {
                        return sO.isFrontFacing(this.a, this.b, this.c, _)
                    }
                    intersectsBox(_) {
                        return _.intersectsTriangle(this)
                    }
                    closestPointToPoint(_, O) {
                        let B = this.a,
                            N = this.b,
                            k = this.c,
                            F, U;
                        sS.subVectors(N, B), sA.subVectors(k, B), sD.subVectors(_, B);
                        let j = sS.dot(sD),
                            G = sA.dot(sD);
                        if (j <= 0 && G <= 0) return O.copy(B);
                        sP.subVectors(_, N);
                        let Y = sS.dot(sP),
                            Q = sA.dot(sP);
                        if (Y >= 0 && Q <= Y) return O.copy(N);
                        let K = j * Q - Y * G;
                        if (K <= 0 && j >= 0 && Y <= 0) return F = j / (j - Y), O.copy(B).addScaledVector(sS, F);
                        sI.subVectors(_, k);
                        let $ = sS.dot(sI),
                            ee = sA.dot(sI);
                        if (ee >= 0 && $ <= ee) return O.copy(k);
                        let et = $ * G - j * ee;
                        if (et <= 0 && G >= 0 && ee <= 0) return U = G / (G - ee), O.copy(B).addScaledVector(sA, U);
                        let ei = Y * ee - $ * Q;
                        if (ei <= 0 && Q - Y >= 0 && $ - ee >= 0) return sE.subVectors(k, N), U = (Q - Y) / (Q - Y + ($ - ee)), O.copy(N).addScaledVector(sE, U);
                        let er = 1 / (ei + et + K);
                        return F = et * er, U = K * er, O.copy(B).addScaledVector(sS, F).addScaledVector(sA, U)
                    }
                    equals(_) {
                        return _.a.equals(this.a) && _.b.equals(this.b) && _.c.equals(this.c)
                    }
                },
                sR = 0,
                sB = class extends iq {
                    constructor() {
                        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                            value: sR++
                        }), this.uuid = Ui(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(_) {
                        this._alphaTest > 0 != _ > 0 && this.version++, this._alphaTest = _
                    }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(_) {
                        if (void 0 !== _)
                            for (let O in _) {
                                let B = _[O];
                                if (void 0 === B) {
                                    console.warn("THREE.Material: '" + O + "' parameter is undefined.");
                                    continue
                                }
                                let N = this[O];
                                if (void 0 === N) {
                                    console.warn("THREE." + this.type + ": '" + O + "' is not a property of this material.");
                                    continue
                                }
                                N && N.isColor ? N.set(B) : N && N.isVector3 && B && B.isVector3 ? N.copy(B) : this[O] = B
                            }
                    }
                    toJSON(_) {
                        let O = void 0 === _ || "string" == typeof _;
                        O && (_ = {
                            textures: {},
                            images: {}
                        });
                        let B = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };

                        function n(_) {
                            let O = [];
                            for (let B in _) {
                                let N = _[B];
                                delete N.metadata, O.push(N)
                            }
                            return O
                        }
                        if (B.uuid = this.uuid, B.type = this.type, "" !== this.name && (B.name = this.name), this.color && this.color.isColor && (B.color = this.color.getHex()), void 0 !== this.roughness && (B.roughness = this.roughness), void 0 !== this.metalness && (B.metalness = this.metalness), void 0 !== this.sheen && (B.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (B.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (B.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (B.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (B.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (B.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (B.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (B.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (B.shininess = this.shininess), void 0 !== this.clearcoat && (B.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (B.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (B.clearcoatMap = this.clearcoatMap.toJSON(_).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (B.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(_).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (B.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(_).uuid, B.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (B.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (B.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (B.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (B.iridescenceMap = this.iridescenceMap.toJSON(_).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (B.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(_).uuid), this.map && this.map.isTexture && (B.map = this.map.toJSON(_).uuid), this.matcap && this.matcap.isTexture && (B.matcap = this.matcap.toJSON(_).uuid), this.alphaMap && this.alphaMap.isTexture && (B.alphaMap = this.alphaMap.toJSON(_).uuid), this.lightMap && this.lightMap.isTexture && (B.lightMap = this.lightMap.toJSON(_).uuid, B.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (B.aoMap = this.aoMap.toJSON(_).uuid, B.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (B.bumpMap = this.bumpMap.toJSON(_).uuid, B.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (B.normalMap = this.normalMap.toJSON(_).uuid, B.normalMapType = this.normalMapType, B.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (B.displacementMap = this.displacementMap.toJSON(_).uuid, B.displacementScale = this.displacementScale, B.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (B.roughnessMap = this.roughnessMap.toJSON(_).uuid), this.metalnessMap && this.metalnessMap.isTexture && (B.metalnessMap = this.metalnessMap.toJSON(_).uuid), this.emissiveMap && this.emissiveMap.isTexture && (B.emissiveMap = this.emissiveMap.toJSON(_).uuid), this.specularMap && this.specularMap.isTexture && (B.specularMap = this.specularMap.toJSON(_).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (B.specularIntensityMap = this.specularIntensityMap.toJSON(_).uuid), this.specularColorMap && this.specularColorMap.isTexture && (B.specularColorMap = this.specularColorMap.toJSON(_).uuid), this.envMap && this.envMap.isTexture && (B.envMap = this.envMap.toJSON(_).uuid, void 0 !== this.combine && (B.combine = this.combine)), void 0 !== this.envMapIntensity && (B.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (B.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (B.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (B.gradientMap = this.gradientMap.toJSON(_).uuid), void 0 !== this.transmission && (B.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (B.transmissionMap = this.transmissionMap.toJSON(_).uuid), void 0 !== this.thickness && (B.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (B.thicknessMap = this.thicknessMap.toJSON(_).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (B.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (B.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (B.size = this.size), null !== this.shadowSide && (B.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (B.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (B.blending = this.blending), 0 !== this.side && (B.side = this.side), this.vertexColors && (B.vertexColors = !0), this.opacity < 1 && (B.opacity = this.opacity), !0 === this.transparent && (B.transparent = this.transparent), B.depthFunc = this.depthFunc, B.depthTest = this.depthTest, B.depthWrite = this.depthWrite, B.colorWrite = this.colorWrite, B.stencilWrite = this.stencilWrite, B.stencilWriteMask = this.stencilWriteMask, B.stencilFunc = this.stencilFunc, B.stencilRef = this.stencilRef, B.stencilFuncMask = this.stencilFuncMask, B.stencilFail = this.stencilFail, B.stencilZFail = this.stencilZFail, B.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (B.rotation = this.rotation), !0 === this.polygonOffset && (B.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (B.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (B.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (B.linewidth = this.linewidth), void 0 !== this.dashSize && (B.dashSize = this.dashSize), void 0 !== this.gapSize && (B.gapSize = this.gapSize), void 0 !== this.scale && (B.scale = this.scale), !0 === this.dithering && (B.dithering = !0), this.alphaTest > 0 && (B.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (B.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (B.premultipliedAlpha = this.premultipliedAlpha), !0 === this.forceSinglePass && (B.forceSinglePass = this.forceSinglePass), !0 === this.wireframe && (B.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (B.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (B.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (B.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (B.flatShading = this.flatShading), !1 === this.visible && (B.visible = !1), !1 === this.toneMapped && (B.toneMapped = !1), !1 === this.fog && (B.fog = !1), Object.keys(this.userData).length > 0 && (B.userData = this.userData), O) {
                            let O = n(_.textures),
                                N = n(_.images);
                            O.length > 0 && (B.textures = O), N.length > 0 && (B.images = N)
                        }
                        return B
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        this.name = _.name, this.blending = _.blending, this.side = _.side, this.vertexColors = _.vertexColors, this.opacity = _.opacity, this.transparent = _.transparent, this.blendSrc = _.blendSrc, this.blendDst = _.blendDst, this.blendEquation = _.blendEquation, this.blendSrcAlpha = _.blendSrcAlpha, this.blendDstAlpha = _.blendDstAlpha, this.blendEquationAlpha = _.blendEquationAlpha, this.depthFunc = _.depthFunc, this.depthTest = _.depthTest, this.depthWrite = _.depthWrite, this.stencilWriteMask = _.stencilWriteMask, this.stencilFunc = _.stencilFunc, this.stencilRef = _.stencilRef, this.stencilFuncMask = _.stencilFuncMask, this.stencilFail = _.stencilFail, this.stencilZFail = _.stencilZFail, this.stencilZPass = _.stencilZPass, this.stencilWrite = _.stencilWrite;
                        let O = _.clippingPlanes,
                            B = null;
                        if (null !== O) {
                            let _ = O.length;
                            B = Array(_);
                            for (let N = 0; N !== _; ++N) B[N] = O[N].clone()
                        }
                        return this.clippingPlanes = B, this.clipIntersection = _.clipIntersection, this.clipShadows = _.clipShadows, this.shadowSide = _.shadowSide, this.colorWrite = _.colorWrite, this.precision = _.precision, this.polygonOffset = _.polygonOffset, this.polygonOffsetFactor = _.polygonOffsetFactor, this.polygonOffsetUnits = _.polygonOffsetUnits, this.dithering = _.dithering, this.alphaTest = _.alphaTest, this.alphaToCoverage = _.alphaToCoverage, this.premultipliedAlpha = _.premultipliedAlpha, this.forceSinglePass = _.forceSinglePass, this.visible = _.visible, this.toneMapped = _.toneMapped, this.userData = JSON.parse(JSON.stringify(_.userData)), this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(_) {
                        !0 === _ && this.version++
                    }
                },
                sz = class extends sB {
                    constructor(_) {
                        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new re(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(_)
                    }
                    copy(_) {
                        return super.copy(_), this.color.copy(_.color), this.map = _.map, this.lightMap = _.lightMap, this.lightMapIntensity = _.lightMapIntensity, this.aoMap = _.aoMap, this.aoMapIntensity = _.aoMapIntensity, this.specularMap = _.specularMap, this.alphaMap = _.alphaMap, this.envMap = _.envMap, this.combine = _.combine, this.reflectivity = _.reflectivity, this.refractionRatio = _.refractionRatio, this.wireframe = _.wireframe, this.wireframeLinewidth = _.wireframeLinewidth, this.wireframeLinecap = _.wireframeLinecap, this.wireframeLinejoin = _.wireframeLinejoin, this.fog = _.fog, this
                    }
                },
                sN = new rv,
                sk = new iJ,
                sF = class {
                    constructor(_, O, B = !1) {
                        if (Array.isArray(_)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0, this.name = "", this.array = _, this.itemSize = O, this.count = void 0 !== _ ? _.length / O : 0, this.normalized = B, this.usage = 35044, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(_) {
                        !0 === _ && this.version++
                    }
                    setUsage(_) {
                        return this.usage = _, this
                    }
                    copy(_) {
                        return this.name = _.name, this.array = new _.array.constructor(_.array), this.itemSize = _.itemSize, this.count = _.count, this.normalized = _.normalized, this.usage = _.usage, this
                    }
                    copyAt(_, O, B) {
                        _ *= this.itemSize, B *= O.itemSize;
                        for (let N = 0, k = this.itemSize; N < k; N++) this.array[_ + N] = O.array[B + N];
                        return this
                    }
                    copyArray(_) {
                        return this.array.set(_), this
                    }
                    applyMatrix3(_) {
                        if (2 === this.itemSize)
                            for (let O = 0, B = this.count; O < B; O++) sk.fromBufferAttribute(this, O), sk.applyMatrix3(_), this.setXY(O, sk.x, sk.y);
                        else if (3 === this.itemSize)
                            for (let O = 0, B = this.count; O < B; O++) sN.fromBufferAttribute(this, O), sN.applyMatrix3(_), this.setXYZ(O, sN.x, sN.y, sN.z);
                        return this
                    }
                    applyMatrix4(_) {
                        for (let O = 0, B = this.count; O < B; O++) sN.fromBufferAttribute(this, O), sN.applyMatrix4(_), this.setXYZ(O, sN.x, sN.y, sN.z);
                        return this
                    }
                    applyNormalMatrix(_) {
                        for (let O = 0, B = this.count; O < B; O++) sN.fromBufferAttribute(this, O), sN.applyNormalMatrix(_), this.setXYZ(O, sN.x, sN.y, sN.z);
                        return this
                    }
                    transformDirection(_) {
                        for (let O = 0, B = this.count; O < B; O++) sN.fromBufferAttribute(this, O), sN.transformDirection(_), this.setXYZ(O, sN.x, sN.y, sN.z);
                        return this
                    }
                    set(_, O = 0) {
                        return this.array.set(_, O), this
                    }
                    getX(_) {
                        let O = this.array[_ * this.itemSize];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    setX(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.array[_ * this.itemSize] = O, this
                    }
                    getY(_) {
                        let O = this.array[_ * this.itemSize + 1];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    setY(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.array[_ * this.itemSize + 1] = O, this
                    }
                    getZ(_) {
                        let O = this.array[_ * this.itemSize + 2];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    setZ(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.array[_ * this.itemSize + 2] = O, this
                    }
                    getW(_) {
                        let O = this.array[_ * this.itemSize + 3];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    setW(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.array[_ * this.itemSize + 3] = O, this
                    }
                    setXY(_, O, B) {
                        return _ *= this.itemSize, this.normalized && (O = Kt(O, this.array), B = Kt(B, this.array)), this.array[_ + 0] = O, this.array[_ + 1] = B, this
                    }
                    setXYZ(_, O, B, N) {
                        return _ *= this.itemSize, this.normalized && (O = Kt(O, this.array), B = Kt(B, this.array), N = Kt(N, this.array)), this.array[_ + 0] = O, this.array[_ + 1] = B, this.array[_ + 2] = N, this
                    }
                    setXYZW(_, O, B, N, k) {
                        return _ *= this.itemSize, this.normalized && (O = Kt(O, this.array), B = Kt(B, this.array), N = Kt(N, this.array), k = Kt(k, this.array)), this.array[_ + 0] = O, this.array[_ + 1] = B, this.array[_ + 2] = N, this.array[_ + 3] = k, this
                    }
                    onUpload(_) {
                        return this.onUploadCallback = _, this
                    }
                    clone() {
                        return new this.constructor(this.array, this.itemSize).copy(this)
                    }
                    toJSON() {
                        let _ = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        return "" !== this.name && (_.name = this.name), 35044 !== this.usage && (_.usage = this.usage), (0 !== this.updateRange.offset || -1 !== this.updateRange.count) && (_.updateRange = this.updateRange), _
                    }
                    copyColorsArray() {
                        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
                    }
                    copyVector2sArray() {
                        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
                    }
                    copyVector3sArray() {
                        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
                    }
                    copyVector4sArray() {
                        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
                    }
                },
                sU = class extends sF {
                    constructor(_, O, B) {
                        super(new Uint16Array(_), O, B)
                    }
                },
                sj = class extends sF {
                    constructor(_, O, B) {
                        super(new Uint32Array(_), O, B)
                    }
                },
                sG = class extends sF {
                    constructor(_, O, B) {
                        super(new Float32Array(_), O, B)
                    }
                },
                sH = 0,
                sW = new rJ,
                sq = new sv,
                sY = new rv,
                sX = new rb,
                sQ = new rb,
                sZ = new rv,
                sK = class extends iq {
                    constructor() {
                        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                            value: sH++
                        }), this.uuid = Ui(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        }, this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(_) {
                        return Array.isArray(_) ? this.index = new(nM(_) ? sj : sU)(_, 1) : this.index = _, this
                    }
                    getAttribute(_) {
                        return this.attributes[_]
                    }
                    setAttribute(_, O) {
                        return this.attributes[_] = O, this
                    }
                    deleteAttribute(_) {
                        return delete this.attributes[_], this
                    }
                    hasAttribute(_) {
                        return void 0 !== this.attributes[_]
                    }
                    addGroup(_, O, B = 0) {
                        this.groups.push({
                            start: _,
                            count: O,
                            materialIndex: B
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(_, O) {
                        this.drawRange.start = _, this.drawRange.count = O
                    }
                    applyMatrix4(_) {
                        let O = this.attributes.position;
                        void 0 !== O && (O.applyMatrix4(_), O.needsUpdate = !0);
                        let B = this.attributes.normal;
                        if (void 0 !== B) {
                            let O = new i$().getNormalMatrix(_);
                            B.applyNormalMatrix(O), B.needsUpdate = !0
                        }
                        let N = this.attributes.tangent;
                        return void 0 !== N && (N.transformDirection(_), N.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(_) {
                        return sW.makeRotationFromQuaternion(_), this.applyMatrix4(sW), this
                    }
                    rotateX(_) {
                        return sW.makeRotationX(_), this.applyMatrix4(sW), this
                    }
                    rotateY(_) {
                        return sW.makeRotationY(_), this.applyMatrix4(sW), this
                    }
                    rotateZ(_) {
                        return sW.makeRotationZ(_), this.applyMatrix4(sW), this
                    }
                    translate(_, O, B) {
                        return sW.makeTranslation(_, O, B), this.applyMatrix4(sW), this
                    }
                    scale(_, O, B) {
                        return sW.makeScale(_, O, B), this.applyMatrix4(sW), this
                    }
                    lookAt(_) {
                        return sq.lookAt(_), sq.updateMatrix(), this.applyMatrix4(sq.matrix), this
                    }
                    center() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(sY).negate(), this.translate(sY.x, sY.y, sY.z), this
                    }
                    setFromPoints(_) {
                        let O = [];
                        for (let B = 0, N = _.length; B < N; B++) {
                            let N = _[B];
                            O.push(N.x, N.y, N.z || 0)
                        }
                        return this.setAttribute("position", new sG(O, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new rb);
                        let _ = this.attributes.position,
                            O = this.morphAttributes.position;
                        if (_ && _.isGLBufferAttribute) {
                            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new rv(-1 / 0, -1 / 0, -1 / 0), new rv(1 / 0, 1 / 0, 1 / 0));
                            return
                        }
                        if (void 0 !== _) {
                            if (this.boundingBox.setFromBufferAttribute(_), O)
                                for (let _ = 0, B = O.length; _ < B; _++) {
                                    let B = O[_];
                                    sX.setFromBufferAttribute(B), this.morphTargetsRelative ? (sZ.addVectors(this.boundingBox.min, sX.min), this.boundingBox.expandByPoint(sZ), sZ.addVectors(this.boundingBox.max, sX.max), this.boundingBox.expandByPoint(sZ)) : (this.boundingBox.expandByPoint(sX.min), this.boundingBox.expandByPoint(sX.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new rG);
                        let _ = this.attributes.position,
                            O = this.morphAttributes.position;
                        if (_ && _.isGLBufferAttribute) {
                            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new rv, 1 / 0);
                            return
                        }
                        if (_) {
                            let B = this.boundingSphere.center;
                            if (sX.setFromBufferAttribute(_), O)
                                for (let _ = 0, B = O.length; _ < B; _++) {
                                    let B = O[_];
                                    sQ.setFromBufferAttribute(B), this.morphTargetsRelative ? (sZ.addVectors(sX.min, sQ.min), sX.expandByPoint(sZ), sZ.addVectors(sX.max, sQ.max), sX.expandByPoint(sZ)) : (sX.expandByPoint(sQ.min), sX.expandByPoint(sQ.max))
                                }
                            sX.getCenter(B);
                            let N = 0;
                            for (let O = 0, k = _.count; O < k; O++) sZ.fromBufferAttribute(_, O), N = Math.max(N, B.distanceToSquared(sZ));
                            if (O)
                                for (let k = 0, F = O.length; k < F; k++) {
                                    let F = O[k],
                                        U = this.morphTargetsRelative;
                                    for (let O = 0, k = F.count; O < k; O++) sZ.fromBufferAttribute(F, O), U && (sY.fromBufferAttribute(_, O), sZ.add(sY)), N = Math.max(N, B.distanceToSquared(sZ))
                                }
                            this.boundingSphere.radius = Math.sqrt(N), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        let _ = this.index,
                            O = this.attributes;
                        if (null === _ || void 0 === O.position || void 0 === O.normal || void 0 === O.uv) {
                            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            return
                        }
                        let B = _.array,
                            N = O.position.array,
                            k = O.normal.array,
                            F = O.uv.array,
                            U = N.length / 3;
                        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new sF(new Float32Array(4 * U), 4));
                        let j = this.getAttribute("tangent").array,
                            G = [],
                            Y = [];
                        for (let _ = 0; _ < U; _++) G[_] = new rv, Y[_] = new rv;
                        let Q = new rv,
                            K = new rv,
                            $ = new rv,
                            ee = new iJ,
                            et = new iJ,
                            ei = new iJ,
                            er = new rv,
                            ea = new rv,
                            en = this.groups;
                        0 === en.length && (en = [{
                            start: 0,
                            count: B.length
                        }]);
                        for (let _ = 0, O = en.length; _ < O; ++_) {
                            let O = en[_],
                                k = O.start,
                                U = O.count;
                            for (let _ = k, O = k + U; _ < O; _ += 3) ! function(_, O, B) {
                                Q.fromArray(N, 3 * _), K.fromArray(N, 3 * O), $.fromArray(N, 3 * B), ee.fromArray(F, 2 * _), et.fromArray(F, 2 * O), ei.fromArray(F, 2 * B), K.sub(Q), $.sub(Q), et.sub(ee), ei.sub(ee);
                                let k = 1 / (et.x * ei.y - ei.x * et.y);
                                isFinite(k) && (er.copy(K).multiplyScalar(ei.y).addScaledVector($, -et.y).multiplyScalar(k), ea.copy($).multiplyScalar(et.x).addScaledVector(K, -ei.x).multiplyScalar(k), G[_].add(er), G[O].add(er), G[B].add(er), Y[_].add(ea), Y[O].add(ea), Y[B].add(ea))
                            }(B[_ + 0], B[_ + 1], B[_ + 2])
                        }
                        let eo = new rv,
                            el = new rv,
                            eh = new rv,
                            ec = new rv;

                        function M(_) {
                            eh.fromArray(k, 3 * _), ec.copy(eh);
                            let O = G[_];
                            eo.copy(O), eo.sub(eh.multiplyScalar(eh.dot(O))).normalize(), el.crossVectors(ec, O);
                            let B = 0 > el.dot(Y[_]) ? -1 : 1;
                            j[4 * _] = eo.x, j[4 * _ + 1] = eo.y, j[4 * _ + 2] = eo.z, j[4 * _ + 3] = B
                        }
                        for (let _ = 0, O = en.length; _ < O; ++_) {
                            let O = en[_],
                                N = O.start,
                                k = O.count;
                            for (let _ = N, O = N + k; _ < O; _ += 3) M(B[_ + 0]), M(B[_ + 1]), M(B[_ + 2])
                        }
                    }
                    computeVertexNormals() {
                        let _ = this.index,
                            O = this.getAttribute("position");
                        if (void 0 !== O) {
                            let B = this.getAttribute("normal");
                            if (void 0 === B) B = new sF(new Float32Array(3 * O.count), 3), this.setAttribute("normal", B);
                            else
                                for (let _ = 0, O = B.count; _ < O; _++) B.setXYZ(_, 0, 0, 0);
                            let N = new rv,
                                k = new rv,
                                F = new rv,
                                U = new rv,
                                j = new rv,
                                G = new rv,
                                Y = new rv,
                                Q = new rv;
                            if (_)
                                for (let K = 0, $ = _.count; K < $; K += 3) {
                                    let $ = _.getX(K + 0),
                                        ee = _.getX(K + 1),
                                        et = _.getX(K + 2);
                                    N.fromBufferAttribute(O, $), k.fromBufferAttribute(O, ee), F.fromBufferAttribute(O, et), Y.subVectors(F, k), Q.subVectors(N, k), Y.cross(Q), U.fromBufferAttribute(B, $), j.fromBufferAttribute(B, ee), G.fromBufferAttribute(B, et), U.add(Y), j.add(Y), G.add(Y), B.setXYZ($, U.x, U.y, U.z), B.setXYZ(ee, j.x, j.y, j.z), B.setXYZ(et, G.x, G.y, G.z)
                                } else
                                    for (let _ = 0, U = O.count; _ < U; _ += 3) N.fromBufferAttribute(O, _ + 0), k.fromBufferAttribute(O, _ + 1), F.fromBufferAttribute(O, _ + 2), Y.subVectors(F, k), Q.subVectors(N, k), Y.cross(Q), B.setXYZ(_ + 0, Y.x, Y.y, Y.z), B.setXYZ(_ + 1, Y.x, Y.y, Y.z), B.setXYZ(_ + 2, Y.x, Y.y, Y.z);
                            this.normalizeNormals(), B.needsUpdate = !0
                        }
                    }
                    merge() {
                        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
                    }
                    normalizeNormals() {
                        let _ = this.attributes.normal;
                        for (let O = 0, B = _.count; O < B; O++) sZ.fromBufferAttribute(_, O), sZ.normalize(), _.setXYZ(O, sZ.x, sZ.y, sZ.z)
                    }
                    toNonIndexed() {
                        function t(_, O) {
                            let B = _.array,
                                N = _.itemSize,
                                k = _.normalized,
                                F = new B.constructor(O.length * N),
                                U = 0,
                                j = 0;
                            for (let k = 0, G = O.length; k < G; k++) {
                                U = _.isInterleavedBufferAttribute ? O[k] * _.data.stride + _.offset : O[k] * N;
                                for (let _ = 0; _ < N; _++) F[j++] = B[U++]
                            }
                            return new sF(F, N, k)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        let _ = new sK,
                            O = this.index.array,
                            B = this.attributes;
                        for (let N in B) {
                            let k = t(B[N], O);
                            _.setAttribute(N, k)
                        }
                        let N = this.morphAttributes;
                        for (let B in N) {
                            let k = [],
                                F = N[B];
                            for (let _ = 0, B = F.length; _ < B; _++) {
                                let B = t(F[_], O);
                                k.push(B)
                            }
                            _.morphAttributes[B] = k
                        }
                        _.morphTargetsRelative = this.morphTargetsRelative;
                        let k = this.groups;
                        for (let O = 0, B = k.length; O < B; O++) {
                            let B = k[O];
                            _.addGroup(B.start, B.count, B.materialIndex)
                        }
                        return _
                    }
                    toJSON() {
                        let _ = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (_.uuid = this.uuid, _.type = this.type, "" !== this.name && (_.name = this.name), Object.keys(this.userData).length > 0 && (_.userData = this.userData), void 0 !== this.parameters) {
                            let O = this.parameters;
                            for (let B in O) void 0 !== O[B] && (_[B] = O[B]);
                            return _
                        }
                        _.data = {
                            attributes: {}
                        };
                        let O = this.index;
                        null !== O && (_.data.index = {
                            type: O.array.constructor.name,
                            array: Array.prototype.slice.call(O.array)
                        });
                        let B = this.attributes;
                        for (let O in B) {
                            let N = B[O];
                            _.data.attributes[O] = N.toJSON(_.data)
                        }
                        let N = {},
                            k = !1;
                        for (let O in this.morphAttributes) {
                            let B = this.morphAttributes[O],
                                F = [];
                            for (let O = 0, N = B.length; O < N; O++) {
                                let N = B[O];
                                F.push(N.toJSON(_.data))
                            }
                            F.length > 0 && (N[O] = F, k = !0)
                        }
                        k && (_.data.morphAttributes = N, _.data.morphTargetsRelative = this.morphTargetsRelative);
                        let F = this.groups;
                        F.length > 0 && (_.data.groups = JSON.parse(JSON.stringify(F)));
                        let U = this.boundingSphere;
                        return null !== U && (_.data.boundingSphere = {
                            center: U.center.toArray(),
                            radius: U.radius
                        }), _
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        let O = {};
                        this.name = _.name;
                        let B = _.index;
                        null !== B && this.setIndex(B.clone(O));
                        let N = _.attributes;
                        for (let _ in N) {
                            let B = N[_];
                            this.setAttribute(_, B.clone(O))
                        }
                        let k = _.morphAttributes;
                        for (let _ in k) {
                            let B = [],
                                N = k[_];
                            for (let _ = 0, k = N.length; _ < k; _++) B.push(N[_].clone(O));
                            this.morphAttributes[_] = B
                        }
                        this.morphTargetsRelative = _.morphTargetsRelative;
                        let F = _.groups;
                        for (let _ = 0, O = F.length; _ < O; _++) {
                            let O = F[_];
                            this.addGroup(O.start, O.count, O.materialIndex)
                        }
                        let U = _.boundingBox;
                        null !== U && (this.boundingBox = U.clone());
                        let j = _.boundingSphere;
                        return null !== j && (this.boundingSphere = j.clone()), this.drawRange.start = _.drawRange.start, this.drawRange.count = _.drawRange.count, this.userData = _.userData, void 0 !== _.parameters && (this.parameters = Object.assign({}, _.parameters)), this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                },
                sJ = new rJ,
                s$ = new rK,
                s0 = new rG,
                s1 = new rv,
                s2 = new rv,
                s3 = new rv,
                s4 = new rv,
                s5 = new rv,
                s6 = new iJ,
                s8 = new iJ,
                s9 = new iJ,
                s7 = new rv,
                ae = new rv,
                at = class extends sv {
                    constructor(_ = new sK, O = new sz) {
                        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = _, this.material = O, this.updateMorphTargets()
                    }
                    copy(_, O) {
                        return super.copy(_, O), void 0 !== _.morphTargetInfluences && (this.morphTargetInfluences = _.morphTargetInfluences.slice()), void 0 !== _.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, _.morphTargetDictionary)), this.material = _.material, this.geometry = _.geometry, this
                    }
                    updateMorphTargets() {
                        let _ = this.geometry.morphAttributes,
                            O = Object.keys(_);
                        if (O.length > 0) {
                            let B = _[O[0]];
                            if (void 0 !== B) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let _ = 0, O = B.length; _ < O; _++) {
                                    let O = B[_].name || String(_);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[O] = _
                                }
                            }
                        }
                    }
                    getVertexPosition(_, O) {
                        let B = this.geometry,
                            N = B.attributes.position,
                            k = B.morphAttributes.position,
                            F = B.morphTargetsRelative;
                        O.fromBufferAttribute(N, _);
                        let U = this.morphTargetInfluences;
                        if (k && U) {
                            s5.set(0, 0, 0);
                            for (let B = 0, N = k.length; B < N; B++) {
                                let N = U[B],
                                    j = k[B];
                                0 !== N && (s4.fromBufferAttribute(j, _), F ? s5.addScaledVector(s4, N) : s5.addScaledVector(s4.sub(O), N))
                            }
                            O.add(s5)
                        }
                        return this.isSkinnedMesh && this.boneTransform(_, O), O
                    }
                    raycast(_, O) {
                        let B = this.geometry,
                            N = this.material,
                            k = this.matrixWorld;
                        if (void 0 === N || (null === B.boundingSphere && B.computeBoundingSphere(), s0.copy(B.boundingSphere), s0.applyMatrix4(k), !1 === _.ray.intersectsSphere(s0)) || (sJ.copy(k).invert(), s$.copy(_.ray).applyMatrix4(sJ), null !== B.boundingBox && !1 === s$.intersectsBox(B.boundingBox))) return;
                        let F, U = B.index,
                            j = B.attributes.position,
                            G = B.attributes.uv,
                            Y = B.attributes.uv2,
                            Q = B.groups,
                            K = B.drawRange;
                        if (null !== U) {
                            if (Array.isArray(N))
                                for (let B = 0, k = Q.length; B < k; B++) {
                                    let k = Q[B],
                                        j = N[k.materialIndex],
                                        $ = Math.max(k.start, K.start),
                                        ee = Math.min(U.count, Math.min(k.start + k.count, K.start + K.count));
                                    for (let B = $; B < ee; B += 3)(F = Km(this, j, _, s$, G, Y, U.getX(B), U.getX(B + 1), U.getX(B + 2))) && (F.faceIndex = Math.floor(B / 3), F.face.materialIndex = k.materialIndex, O.push(F))
                                } else {
                                    let B = Math.max(0, K.start),
                                        k = Math.min(U.count, K.start + K.count);
                                    for (let j = B; j < k; j += 3)(F = Km(this, N, _, s$, G, Y, U.getX(j), U.getX(j + 1), U.getX(j + 2))) && (F.faceIndex = Math.floor(j / 3), O.push(F))
                                }
                        } else if (void 0 !== j) {
                            if (Array.isArray(N))
                                for (let B = 0, k = Q.length; B < k; B++) {
                                    let k = Q[B],
                                        U = N[k.materialIndex],
                                        $ = Math.max(k.start, K.start),
                                        ee = Math.min(j.count, Math.min(k.start + k.count, K.start + K.count));
                                    for (let B = $; B < ee; B += 3)(F = Km(this, U, _, s$, G, Y, B, B + 1, B + 2)) && (F.faceIndex = Math.floor(B / 3), F.face.materialIndex = k.materialIndex, O.push(F))
                                } else {
                                    let B = Math.max(0, K.start),
                                        k = Math.min(j.count, K.start + K.count);
                                    for (let U = B; U < k; U += 3)(F = Km(this, N, _, s$, G, Y, U, U + 1, U + 2)) && (F.faceIndex = Math.floor(U / 3), O.push(F))
                                }
                        }
                    }
                };

            function Km(_, O, B, N, k, F, U, j, G) {
                _.getVertexPosition(U, s1), _.getVertexPosition(j, s2), _.getVertexPosition(G, s3);
                let Y = function(_, O, B, N, k, F, U, j) {
                    if (null === (1 === O.side ? N.intersectTriangle(U, F, k, !0, j) : N.intersectTriangle(k, F, U, 0 === O.side, j))) return null;
                    ae.copy(j), ae.applyMatrix4(_.matrixWorld);
                    let G = B.ray.origin.distanceTo(ae);
                    return G < B.near || G > B.far ? null : {
                        distance: G,
                        point: ae.clone(),
                        object: _
                    }
                }(_, O, B, N, s1, s2, s3, s7);
                if (Y) {
                    k && (s6.fromBufferAttribute(k, U), s8.fromBufferAttribute(k, j), s9.fromBufferAttribute(k, G), Y.uv = sO.getUV(s7, s1, s2, s3, s6, s8, s9, new iJ)), F && (s6.fromBufferAttribute(F, U), s8.fromBufferAttribute(F, j), s9.fromBufferAttribute(F, G), Y.uv2 = sO.getUV(s7, s1, s2, s3, s6, s8, s9, new iJ));
                    let _ = {
                        a: U,
                        b: j,
                        c: G,
                        normal: new rv,
                        materialIndex: 0
                    };
                    sO.getNormal(s1, s2, s3, _.normal), Y.face = _
                }
                return Y
            }
            var ai = class extends sK {
                constructor(_ = 1, O = 1, B = 1, N = 1, k = 1, F = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: _,
                        height: O,
                        depth: B,
                        widthSegments: N,
                        heightSegments: k,
                        depthSegments: F
                    };
                    let U = this;
                    N = Math.floor(N), k = Math.floor(k);
                    let j = [],
                        G = [],
                        Y = [],
                        Q = [],
                        K = 0,
                        $ = 0;

                    function p(_, O, B, N, k, F, ee, et, ei, er, ea) {
                        let en = F / ei,
                            eo = ee / er,
                            el = F / 2,
                            eh = ee / 2,
                            ec = et / 2,
                            eu = ei + 1,
                            ep = er + 1,
                            ef = 0,
                            em = 0,
                            eg = new rv;
                        for (let F = 0; F < ep; F++) {
                            let U = F * eo - eh;
                            for (let j = 0; j < eu; j++) {
                                let K = j * en - el;
                                eg[_] = K * N, eg[O] = U * k, eg[B] = ec, G.push(eg.x, eg.y, eg.z), eg[_] = 0, eg[O] = 0, eg[B] = et > 0 ? 1 : -1, Y.push(eg.x, eg.y, eg.z), Q.push(j / ei), Q.push(1 - F / er), ef += 1
                            }
                        }
                        for (let _ = 0; _ < er; _++)
                            for (let O = 0; O < ei; O++) {
                                let B = K + O + eu * _,
                                    N = K + O + eu * (_ + 1),
                                    k = K + (O + 1) + eu * (_ + 1),
                                    F = K + (O + 1) + eu * _;
                                j.push(B, N, F), j.push(N, k, F), em += 6
                            }
                        U.addGroup($, em, ea), $ += em, K += ef
                    }
                    p("z", "y", "x", -1, -1, B, O, _, F = Math.floor(F), k, 0), p("z", "y", "x", 1, -1, B, O, -_, F, k, 1), p("x", "z", "y", 1, 1, _, B, O, N, F, 2), p("x", "z", "y", 1, -1, _, B, -O, N, F, 3), p("x", "y", "z", 1, -1, _, O, B, N, k, 4), p("x", "y", "z", -1, -1, _, O, -B, N, k, 5), this.setIndex(j), this.setAttribute("position", new sG(G, 3)), this.setAttribute("normal", new sG(Y, 3)), this.setAttribute("uv", new sG(Q, 2))
                }
                static fromJSON(_) {
                    return new ai(_.width, _.height, _.depth, _.widthSegments, _.heightSegments, _.depthSegments)
                }
            };

            function ou(_) {
                let O = {};
                for (let B in _)
                    for (let N in O[B] = {}, _[B]) {
                        let k = _[B][N];
                        k && (k.isColor || k.isMatrix3 || k.isMatrix4 || k.isVector2 || k.isVector3 || k.isVector4 || k.isTexture || k.isQuaternion) ? O[B][N] = k.clone() : Array.isArray(k) ? O[B][N] = k.slice() : O[B][N] = k
                    }
                return O
            }

            function Jn(_) {
                let O = {};
                for (let B = 0; B < _.length; B++) {
                    let N = ou(_[B]);
                    for (let _ in N) O[_] = N[_]
                }
                return O
            }

            function sM(_) {
                return null === _.getRenderTarget() && 3001 === _.outputEncoding ? iG : iH
            }
            var ar = {
                    clone: ou,
                    merge: Jn
                },
                as = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
                aa = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
                an = class extends sB {
                    constructor(_) {
                        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = as, this.fragmentShader = aa, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1
                        }, this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv2: [0, 0]
                        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== _ && this.setValues(_)
                    }
                    copy(_) {
                        return super.copy(_), this.fragmentShader = _.fragmentShader, this.vertexShader = _.vertexShader, this.uniforms = ou(_.uniforms), this.uniformsGroups = function(_) {
                            let O = [];
                            for (let B = 0; B < _.length; B++) O.push(_[B].clone());
                            return O
                        }(_.uniformsGroups), this.defines = Object.assign({}, _.defines), this.wireframe = _.wireframe, this.wireframeLinewidth = _.wireframeLinewidth, this.fog = _.fog, this.lights = _.lights, this.clipping = _.clipping, this.extensions = Object.assign({}, _.extensions), this.glslVersion = _.glslVersion, this
                    }
                    toJSON(_) {
                        let O = super.toJSON(_);
                        for (let B in O.glslVersion = this.glslVersion, O.uniforms = {}, this.uniforms) {
                            let N = this.uniforms[B].value;
                            N && N.isTexture ? O.uniforms[B] = {
                                type: "t",
                                value: N.toJSON(_).uuid
                            } : N && N.isColor ? O.uniforms[B] = {
                                type: "c",
                                value: N.getHex()
                            } : N && N.isVector2 ? O.uniforms[B] = {
                                type: "v2",
                                value: N.toArray()
                            } : N && N.isVector3 ? O.uniforms[B] = {
                                type: "v3",
                                value: N.toArray()
                            } : N && N.isVector4 ? O.uniforms[B] = {
                                type: "v4",
                                value: N.toArray()
                            } : N && N.isMatrix3 ? O.uniforms[B] = {
                                type: "m3",
                                value: N.toArray()
                            } : N && N.isMatrix4 ? O.uniforms[B] = {
                                type: "m4",
                                value: N.toArray()
                            } : O.uniforms[B] = {
                                value: N
                            }
                        }
                        Object.keys(this.defines).length > 0 && (O.defines = this.defines), O.vertexShader = this.vertexShader, O.fragmentShader = this.fragmentShader;
                        let B = {};
                        for (let _ in this.extensions) !0 === this.extensions[_] && (B[_] = !0);
                        return Object.keys(B).length > 0 && (O.extensions = B), O
                    }
                },
                ao = class extends sv {
                    constructor() {
                        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new rJ, this.projectionMatrix = new rJ, this.projectionMatrixInverse = new rJ
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.matrixWorldInverse.copy(_.matrixWorldInverse), this.projectionMatrix.copy(_.projectionMatrix), this.projectionMatrixInverse.copy(_.projectionMatrixInverse), this
                    }
                    getWorldDirection(_) {
                        this.updateWorldMatrix(!0, !1);
                        let O = this.matrixWorld.elements;
                        return _.set(-O[8], -O[9], -O[10]).normalize()
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(_, O) {
                        super.updateWorldMatrix(_, O), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                },
                al = class extends ao {
                    constructor(_ = 50, O = 1, B = .1, N = 2e3) {
                        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = _, this.zoom = 1, this.near = B, this.far = N, this.focus = 10, this.aspect = O, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.fov = _.fov, this.zoom = _.zoom, this.near = _.near, this.far = _.far, this.focus = _.focus, this.aspect = _.aspect, this.view = null === _.view ? null : Object.assign({}, _.view), this.filmGauge = _.filmGauge, this.filmOffset = _.filmOffset, this
                    }
                    setFocalLength(_) {
                        let O = .5 * this.getFilmHeight() / _;
                        this.fov = 2 * iZ * Math.atan(O), this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        let _ = Math.tan(.5 * iQ * this.fov);
                        return .5 * this.getFilmHeight() / _
                    }
                    getEffectiveFOV() {
                        return 2 * iZ * Math.atan(Math.tan(.5 * iQ * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    setViewOffset(_, O, B, N, k, F) {
                        this.aspect = _ / O, null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = _, this.view.fullHeight = O, this.view.offsetX = B, this.view.offsetY = N, this.view.width = k, this.view.height = F, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        let _ = this.near,
                            O = _ * Math.tan(.5 * iQ * this.fov) / this.zoom,
                            B = 2 * O,
                            N = this.aspect * B,
                            k = -.5 * N,
                            F = this.view;
                        if (null !== this.view && this.view.enabled) {
                            let _ = F.fullWidth,
                                U = F.fullHeight;
                            k += F.offsetX * N / _, O -= F.offsetY * B / U, N *= F.width / _, B *= F.height / U
                        }
                        let U = this.filmOffset;
                        0 !== U && (k += _ * U / this.getFilmWidth()), this.projectionMatrix.makePerspective(k, k + N, O, O - B, _, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(_) {
                        let O = super.toJSON(_);
                        return O.object.fov = this.fov, O.object.zoom = this.zoom, O.object.near = this.near, O.object.far = this.far, O.object.focus = this.focus, O.object.aspect = this.aspect, null !== this.view && (O.object.view = Object.assign({}, this.view)), O.object.filmGauge = this.filmGauge, O.object.filmOffset = this.filmOffset, O
                    }
                },
                ah = class extends sv {
                    constructor(_, O, B) {
                        super(), this.type = "CubeCamera", this.renderTarget = B;
                        let N = new al(-90, 1, _, O);
                        N.layers = this.layers, N.up.set(0, 1, 0), N.lookAt(1, 0, 0), this.add(N);
                        let k = new al(-90, 1, _, O);
                        k.layers = this.layers, k.up.set(0, 1, 0), k.lookAt(-1, 0, 0), this.add(k);
                        let F = new al(-90, 1, _, O);
                        F.layers = this.layers, F.up.set(0, 0, -1), F.lookAt(0, 1, 0), this.add(F);
                        let U = new al(-90, 1, _, O);
                        U.layers = this.layers, U.up.set(0, 0, 1), U.lookAt(0, -1, 0), this.add(U);
                        let j = new al(-90, 1, _, O);
                        j.layers = this.layers, j.up.set(0, 1, 0), j.lookAt(0, 0, 1), this.add(j);
                        let G = new al(-90, 1, _, O);
                        G.layers = this.layers, G.up.set(0, 1, 0), G.lookAt(0, 0, -1), this.add(G)
                    }
                    update(_, O) {
                        null === this.parent && this.updateMatrixWorld();
                        let B = this.renderTarget,
                            [N, k, F, U, j, G] = this.children,
                            Y = _.getRenderTarget(),
                            Q = _.toneMapping,
                            K = _.xr.enabled;
                        _.toneMapping = 0, _.xr.enabled = !1;
                        let $ = B.texture.generateMipmaps;
                        B.texture.generateMipmaps = !1, _.setRenderTarget(B, 0), _.render(O, N), _.setRenderTarget(B, 1), _.render(O, k), _.setRenderTarget(B, 2), _.render(O, F), _.setRenderTarget(B, 3), _.render(O, U), _.setRenderTarget(B, 4), _.render(O, j), B.texture.generateMipmaps = $, _.setRenderTarget(B, 5), _.render(O, G), _.setRenderTarget(Y), _.toneMapping = Q, _.xr.enabled = K, B.texture.needsPMREMUpdate = !0
                    }
                },
                ac = class extends ro {
                    constructor(_, O, B, N, k, F, U, j, G, Y) {
                        super(_ = void 0 !== _ ? _ : [], O = void 0 !== O ? O : 301, B, N, k, F, U, j, G, Y), this.isCubeTexture = !0, this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(_) {
                        this.image = _
                    }
                },
                ad = class extends rh {
                    constructor(_ = 1, O = {}) {
                        super(_, _, O), this.isWebGLCubeRenderTarget = !0;
                        let B = {
                                width: _,
                                height: _,
                                depth: 1
                            },
                            N = [B, B, B, B, B, B];
                        this.texture = new ac(N, O.mapping, O.wrapS, O.wrapT, O.magFilter, O.minFilter, O.format, O.type, O.anisotropy, O.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== O.generateMipmaps && O.generateMipmaps, this.texture.minFilter = void 0 !== O.minFilter ? O.minFilter : 1006
                    }
                    fromEquirectangularTexture(_, O) {
                        this.texture.type = O.type, this.texture.encoding = O.encoding, this.texture.generateMipmaps = O.generateMipmaps, this.texture.minFilter = O.minFilter, this.texture.magFilter = O.magFilter;
                        let B = {
                                uniforms: {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                            },
                            N = new ai(5, 5, 5),
                            k = new an({
                                name: "CubemapFromEquirect",
                                uniforms: ou(B.uniforms),
                                vertexShader: B.vertexShader,
                                fragmentShader: B.fragmentShader,
                                side: 1,
                                blending: 0
                            });
                        k.uniforms.tEquirect.value = O;
                        let F = new at(N, k),
                            U = O.minFilter;
                        return 1008 === O.minFilter && (O.minFilter = 1006), new ah(1, 10, this).update(_, F), O.minFilter = U, F.geometry.dispose(), F.material.dispose(), this
                    }
                    clear(_, O, B, N) {
                        let k = _.getRenderTarget();
                        for (let k = 0; k < 6; k++) _.setRenderTarget(this, k), _.clear(O, B, N);
                        _.setRenderTarget(k)
                    }
                },
                au = new rv,
                am = new rv,
                ag = new i$,
                av = class {
                    constructor(_ = new rv(1, 0, 0), O = 0) {
                        this.isPlane = !0, this.normal = _, this.constant = O
                    }
                    set(_, O) {
                        return this.normal.copy(_), this.constant = O, this
                    }
                    setComponents(_, O, B, N) {
                        return this.normal.set(_, O, B), this.constant = N, this
                    }
                    setFromNormalAndCoplanarPoint(_, O) {
                        return this.normal.copy(_), this.constant = -O.dot(this.normal), this
                    }
                    setFromCoplanarPoints(_, O, B) {
                        let N = au.subVectors(B, O).cross(am.subVectors(_, O)).normalize();
                        return this.setFromNormalAndCoplanarPoint(N, _), this
                    }
                    copy(_) {
                        return this.normal.copy(_.normal), this.constant = _.constant, this
                    }
                    normalize() {
                        let _ = 1 / this.normal.length();
                        return this.normal.multiplyScalar(_), this.constant *= _, this
                    }
                    negate() {
                        return this.constant *= -1, this.normal.negate(), this
                    }
                    distanceToPoint(_) {
                        return this.normal.dot(_) + this.constant
                    }
                    distanceToSphere(_) {
                        return this.distanceToPoint(_.center) - _.radius
                    }
                    projectPoint(_, O) {
                        return O.copy(this.normal).multiplyScalar(-this.distanceToPoint(_)).add(_)
                    }
                    intersectLine(_, O) {
                        let B = _.delta(au),
                            N = this.normal.dot(B);
                        if (0 === N) return 0 === this.distanceToPoint(_.start) ? O.copy(_.start) : null;
                        let k = -(_.start.dot(this.normal) + this.constant) / N;
                        return k < 0 || k > 1 ? null : O.copy(B).multiplyScalar(k).add(_.start)
                    }
                    intersectsLine(_) {
                        let O = this.distanceToPoint(_.start),
                            B = this.distanceToPoint(_.end);
                        return O < 0 && B > 0 || B < 0 && O > 0
                    }
                    intersectsBox(_) {
                        return _.intersectsPlane(this)
                    }
                    intersectsSphere(_) {
                        return _.intersectsPlane(this)
                    }
                    coplanarPoint(_) {
                        return _.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(_, O) {
                        let B = O || ag.getNormalMatrix(_),
                            N = this.coplanarPoint(au).applyMatrix4(_),
                            k = this.normal.applyMatrix3(B).normalize();
                        return this.constant = -N.dot(k), this
                    }
                    translate(_) {
                        return this.constant -= _.dot(this.normal), this
                    }
                    equals(_) {
                        return _.normal.equals(this.normal) && _.constant === this.constant
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                },
                ax = new rG,
                ab = new rv,
                aw = class {
                    constructor(_ = new av, O = new av, B = new av, N = new av, k = new av, F = new av) {
                        this.planes = [_, O, B, N, k, F]
                    }
                    set(_, O, B, N, k, F) {
                        let U = this.planes;
                        return U[0].copy(_), U[1].copy(O), U[2].copy(B), U[3].copy(N), U[4].copy(k), U[5].copy(F), this
                    }
                    copy(_) {
                        let O = this.planes;
                        for (let B = 0; B < 6; B++) O[B].copy(_.planes[B]);
                        return this
                    }
                    setFromProjectionMatrix(_) {
                        let O = this.planes,
                            B = _.elements,
                            N = B[0],
                            k = B[1],
                            F = B[2],
                            U = B[3],
                            j = B[4],
                            G = B[5],
                            Y = B[6],
                            Q = B[7],
                            K = B[8],
                            $ = B[9],
                            ee = B[10],
                            et = B[11],
                            ei = B[12],
                            er = B[13],
                            ea = B[14],
                            en = B[15];
                        return O[0].setComponents(U - N, Q - j, et - K, en - ei).normalize(), O[1].setComponents(U + N, Q + j, et + K, en + ei).normalize(), O[2].setComponents(U + k, Q + G, et + $, en + er).normalize(), O[3].setComponents(U - k, Q - G, et - $, en - er).normalize(), O[4].setComponents(U - F, Q - Y, et - ee, en - ea).normalize(), O[5].setComponents(U + F, Q + Y, et + ee, en + ea).normalize(), this
                    }
                    intersectsObject(_) {
                        let O = _.geometry;
                        return null === O.boundingSphere && O.computeBoundingSphere(), ax.copy(O.boundingSphere).applyMatrix4(_.matrixWorld), this.intersectsSphere(ax)
                    }
                    intersectsSprite(_) {
                        return ax.center.set(0, 0, 0), ax.radius = .7071067811865476, ax.applyMatrix4(_.matrixWorld), this.intersectsSphere(ax)
                    }
                    intersectsSphere(_) {
                        let O = this.planes,
                            B = _.center,
                            N = -_.radius;
                        for (let _ = 0; _ < 6; _++)
                            if (O[_].distanceToPoint(B) < N) return !1;
                        return !0
                    }
                    intersectsBox(_) {
                        let O = this.planes;
                        for (let B = 0; B < 6; B++) {
                            let N = O[B];
                            if (ab.x = N.normal.x > 0 ? _.max.x : _.min.x, ab.y = N.normal.y > 0 ? _.max.y : _.min.y, ab.z = N.normal.z > 0 ? _.max.z : _.min.z, 0 > N.distanceToPoint(ab)) return !1
                        }
                        return !0
                    }
                    containsPoint(_) {
                        let O = this.planes;
                        for (let B = 0; B < 6; B++)
                            if (0 > O[B].distanceToPoint(_)) return !1;
                        return !0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                };

            function oM() {
                let _ = null,
                    O = !1,
                    B = null,
                    N = null;

                function n(O, k) {
                    B(O, k), N = _.requestAnimationFrame(n)
                }
                return {
                    start: function() {
                        !0 !== O && null !== B && (N = _.requestAnimationFrame(n), O = !0)
                    },
                    stop: function() {
                        _.cancelAnimationFrame(N), O = !1
                    },
                    setAnimationLoop: function(_) {
                        B = _
                    },
                    setContext: function(O) {
                        _ = O
                    }
                }
            }

            function JN(_, O) {
                let B = O.isWebGL2,
                    N = new WeakMap;
                return {
                    get: function(_) {
                        return _.isInterleavedBufferAttribute && (_ = _.data), N.get(_)
                    },
                    remove: function(O) {
                        O.isInterleavedBufferAttribute && (O = O.data);
                        let B = N.get(O);
                        B && (_.deleteBuffer(B.buffer), N.delete(O))
                    },
                    update: function(O, k) {
                        var F, U;
                        let j, G;
                        if (O.isGLBufferAttribute) {
                            let _ = N.get(O);
                            (!_ || _.version < O.version) && N.set(O, {
                                buffer: O.buffer,
                                type: O.type,
                                bytesPerElement: O.elementSize,
                                version: O.version
                            });
                            return
                        }
                        O.isInterleavedBufferAttribute && (O = O.data);
                        let Y = N.get(O);
                        void 0 === Y ? N.set(O, function(O, N) {
                            let k, F = O.array,
                                U = O.usage,
                                j = _.createBuffer();
                            if (_.bindBuffer(N, j), _.bufferData(N, F, U), O.onUploadCallback(), F instanceof Float32Array) k = 5126;
                            else if (F instanceof Uint16Array) {
                                if (O.isFloat16BufferAttribute) {
                                    if (B) k = 5131;
                                    else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")
                                } else k = 5123
                            } else if (F instanceof Int16Array) k = 5122;
                            else if (F instanceof Uint32Array) k = 5125;
                            else if (F instanceof Int32Array) k = 5124;
                            else if (F instanceof Int8Array) k = 5120;
                            else if (F instanceof Uint8Array) k = 5121;
                            else if (F instanceof Uint8ClampedArray) k = 5121;
                            else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: " + F);
                            return {
                                buffer: j,
                                type: k,
                                bytesPerElement: F.BYTES_PER_ELEMENT,
                                version: O.version
                            }
                        }(O, k)) : Y.version < O.version && (F = Y.buffer, j = (U = O).array, G = U.updateRange, _.bindBuffer(k, F), -1 === G.count ? _.bufferSubData(k, 0, j) : (B ? _.bufferSubData(k, G.offset * j.BYTES_PER_ELEMENT, j, G.offset, G.count) : _.bufferSubData(k, G.offset * j.BYTES_PER_ELEMENT, j.subarray(G.offset, G.offset + G.count)), G.count = -1), U.onUploadCallback(), Y.version = O.version)
                    }
                }
            }
            var a_ = class extends sK {
                    constructor(_ = 1, O = 1, B = 1, N = 1) {
                        super(), this.type = "PlaneGeometry", this.parameters = {
                            width: _,
                            height: O,
                            widthSegments: B,
                            heightSegments: N
                        };
                        let k = _ / 2,
                            F = O / 2,
                            U = Math.floor(B),
                            j = Math.floor(N),
                            G = U + 1,
                            Y = j + 1,
                            Q = _ / U,
                            K = O / j,
                            $ = [],
                            ee = [],
                            et = [],
                            ei = [];
                        for (let _ = 0; _ < Y; _++) {
                            let O = _ * K - F;
                            for (let B = 0; B < G; B++) {
                                let N = B * Q - k;
                                ee.push(N, -O, 0), et.push(0, 0, 1), ei.push(B / U), ei.push(1 - _ / j)
                            }
                        }
                        for (let _ = 0; _ < j; _++)
                            for (let O = 0; O < U; O++) {
                                let B = O + G * _,
                                    N = O + G * (_ + 1),
                                    k = O + 1 + G * (_ + 1),
                                    F = O + 1 + G * _;
                                $.push(B, N, F), $.push(N, k, F)
                            }
                        this.setIndex($), this.setAttribute("position", new sG(ee, 3)), this.setAttribute("normal", new sG(et, 3)), this.setAttribute("uv", new sG(ei, 2))
                    }
                    static fromJSON(_) {
                        return new a_(_.width, _.height, _.widthSegments, _.heightSegments)
                    }
                },
                aM = {
                    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
                    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    alphatest_fragment: `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
                    alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
                    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
                    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
                    bsdfs: `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
                    iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
                    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
                    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
                    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
                    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
                    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
                    color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
                    color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
                    color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
                    color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
                    common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
                    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
                    defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
                    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
                    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
                    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
                    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
                    envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
                    envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
                    envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
                    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
                    envmap_physical_pars_fragment: `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
                    envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
                    fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
                    fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
                    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
                    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
                    gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
                    lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
                    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
                    lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
                    lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
                    lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
                    lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
                    lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
                    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
                    lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
                    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
                    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
                    lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
                    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
                    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
                    logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
                    logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
                    logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
                    map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
                    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
                    map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
                    map_particle_pars_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
                    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
                    morphcolor_vertex: `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
                    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
                    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
                    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
                    normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
                    normal_fragment_maps: `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
                    normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
                    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
                    clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
                    clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
                    clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
                    iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
                    output_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
                    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
                    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
                    project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
                    dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
                    dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
                    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
                    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
                    shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
                    shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
                    shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
                    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
                    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
                    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
                    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
                    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
                    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
                    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
                    tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
                    tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
                    transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
                    transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
                    uv_pars_fragment: `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
                    uv_pars_vertex: `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
                    uv_vertex: `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
                    uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
                    uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
                    uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
                    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
                    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                    background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                    backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                    depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
                    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
                    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
                    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                    meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
                    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                    meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
                    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
                },
                aE = {
                    common: {
                        diffuse: {
                            value: new re(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new i$
                        },
                        uv2Transform: {
                            value: new i$
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new iJ(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new re(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new re(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new i$
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new re(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new iJ(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new i$
                        }
                    }
                },
                aC = {
                    basic: {
                        uniforms: Jn([aE.common, aE.specularmap, aE.envmap, aE.aomap, aE.lightmap, aE.fog]),
                        vertexShader: aM.meshbasic_vert,
                        fragmentShader: aM.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Jn([aE.common, aE.specularmap, aE.envmap, aE.aomap, aE.lightmap, aE.emissivemap, aE.bumpmap, aE.normalmap, aE.displacementmap, aE.fog, aE.lights, {
                            emissive: {
                                value: new re(0)
                            }
                        }]),
                        vertexShader: aM.meshlambert_vert,
                        fragmentShader: aM.meshlambert_frag
                    },
                    phong: {
                        uniforms: Jn([aE.common, aE.specularmap, aE.envmap, aE.aomap, aE.lightmap, aE.emissivemap, aE.bumpmap, aE.normalmap, aE.displacementmap, aE.fog, aE.lights, {
                            emissive: {
                                value: new re(0)
                            },
                            specular: {
                                value: new re(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: aM.meshphong_vert,
                        fragmentShader: aM.meshphong_frag
                    },
                    standard: {
                        uniforms: Jn([aE.common, aE.envmap, aE.aomap, aE.lightmap, aE.emissivemap, aE.bumpmap, aE.normalmap, aE.displacementmap, aE.roughnessmap, aE.metalnessmap, aE.fog, aE.lights, {
                            emissive: {
                                value: new re(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: aM.meshphysical_vert,
                        fragmentShader: aM.meshphysical_frag
                    },
                    toon: {
                        uniforms: Jn([aE.common, aE.aomap, aE.lightmap, aE.emissivemap, aE.bumpmap, aE.normalmap, aE.displacementmap, aE.gradientmap, aE.fog, aE.lights, {
                            emissive: {
                                value: new re(0)
                            }
                        }]),
                        vertexShader: aM.meshtoon_vert,
                        fragmentShader: aM.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Jn([aE.common, aE.bumpmap, aE.normalmap, aE.displacementmap, aE.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: aM.meshmatcap_vert,
                        fragmentShader: aM.meshmatcap_frag
                    },
                    points: {
                        uniforms: Jn([aE.points, aE.fog]),
                        vertexShader: aM.points_vert,
                        fragmentShader: aM.points_frag
                    },
                    dashed: {
                        uniforms: Jn([aE.common, aE.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: aM.linedashed_vert,
                        fragmentShader: aM.linedashed_frag
                    },
                    depth: {
                        uniforms: Jn([aE.common, aE.displacementmap]),
                        vertexShader: aM.depth_vert,
                        fragmentShader: aM.depth_frag
                    },
                    normal: {
                        uniforms: Jn([aE.common, aE.bumpmap, aE.normalmap, aE.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: aM.meshnormal_vert,
                        fragmentShader: aM.meshnormal_frag
                    },
                    sprite: {
                        uniforms: Jn([aE.sprite, aE.fog]),
                        vertexShader: aM.sprite_vert,
                        fragmentShader: aM.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new i$
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: aM.background_vert,
                        fragmentShader: aM.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: aM.backgroundCube_vert,
                        fragmentShader: aM.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: aM.cube_vert,
                        fragmentShader: aM.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: aM.equirect_vert,
                        fragmentShader: aM.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Jn([aE.common, aE.displacementmap, {
                            referencePosition: {
                                value: new rv
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: aM.distanceRGBA_vert,
                        fragmentShader: aM.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Jn([aE.lights, aE.fog, {
                            color: {
                                value: new re(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: aM.shadow_vert,
                        fragmentShader: aM.shadow_frag
                    }
                };
            aC.physical = {
                uniforms: Jn([aC.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new iJ(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new re(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new iJ
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new re(0)
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new re(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: aM.meshphysical_vert,
                fragmentShader: aM.meshphysical_frag
            };
            var aP = {
                r: 0,
                b: 0,
                g: 0
            };

            function Ik(_, O, B, N, k, F, U) {
                let j = new re(0),
                    G = !0 === F ? 0 : 1,
                    Y, Q, K = null,
                    $ = 0,
                    ee = null;

                function m(O, B) {
                    O.getRGB(aP, sM(_)), N.buffers.color.setClear(aP.r, aP.g, aP.b, B, U)
                }
                return {
                    getClearColor: function() {
                        return j
                    },
                    setClearColor: function(_, O = 1) {
                        j.set(_), m(j, G = O)
                    },
                    getClearAlpha: function() {
                        return G
                    },
                    setClearAlpha: function(_) {
                        m(j, G = _)
                    },
                    render: function(N, F) {
                        let U = !1,
                            et = !0 === F.isScene ? F.background : null;
                        et && et.isTexture && (et = (F.backgroundBlurriness > 0 ? B : O).get(et));
                        let ei = _.xr,
                            er = ei.getSession && ei.getSession();
                        er && "additive" === er.environmentBlendMode && (et = null), null === et ? m(j, G) : et && et.isColor && (m(et, 1), U = !0), (_.autoClear || U) && _.clear(_.autoClearColor, _.autoClearDepth, _.autoClearStencil), et && (et.isCubeTexture || 306 === et.mapping) ? (void 0 === Q && ((Q = new at(new ai(1, 1, 1), new an({
                            name: "BackgroundCubeMaterial",
                            uniforms: ou(aC.backgroundCube.uniforms),
                            vertexShader: aC.backgroundCube.vertexShader,
                            fragmentShader: aC.backgroundCube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Q.geometry.deleteAttribute("uv"), Q.onBeforeRender = function(_, O, B) {
                            this.matrixWorld.copyPosition(B.matrixWorld)
                        }, Object.defineProperty(Q.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), k.update(Q)), Q.material.uniforms.envMap.value = et, Q.material.uniforms.flipEnvMap.value = et.isCubeTexture && !1 === et.isRenderTargetTexture ? -1 : 1, Q.material.uniforms.backgroundBlurriness.value = F.backgroundBlurriness, Q.material.uniforms.backgroundIntensity.value = F.backgroundIntensity, Q.material.toneMapped = 3001 !== et.encoding, (K !== et || $ !== et.version || ee !== _.toneMapping) && (Q.material.needsUpdate = !0, K = et, $ = et.version, ee = _.toneMapping), Q.layers.enableAll(), N.unshift(Q, Q.geometry, Q.material, 0, 0, null)) : et && et.isTexture && (void 0 === Y && ((Y = new at(new a_(2, 2), new an({
                            name: "BackgroundMaterial",
                            uniforms: ou(aC.background.uniforms),
                            vertexShader: aC.background.vertexShader,
                            fragmentShader: aC.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(Y.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), k.update(Y)), Y.material.uniforms.t2D.value = et, Y.material.uniforms.backgroundIntensity.value = F.backgroundIntensity, Y.material.toneMapped = 3001 !== et.encoding, !0 === et.matrixAutoUpdate && et.updateMatrix(), Y.material.uniforms.uvTransform.value.copy(et.matrix), (K !== et || $ !== et.version || ee !== _.toneMapping) && (Y.material.needsUpdate = !0, K = et, $ = et.version, ee = _.toneMapping), Y.layers.enableAll(), N.unshift(Y, Y.geometry, Y.material, 0, 0, null))
                    }
                }
            }

            function Ok(_, O, B, N) {
                let k = _.getParameter(34921),
                    F = N.isWebGL2 ? null : O.get("OES_vertex_array_object"),
                    U = N.isWebGL2 || null !== F,
                    j = {},
                    G = g(null),
                    Y = G,
                    Q = !1;

                function f(O) {
                    return N.isWebGL2 ? _.bindVertexArray(O) : F.bindVertexArrayOES(O)
                }

                function p(O) {
                    return N.isWebGL2 ? _.deleteVertexArray(O) : F.deleteVertexArrayOES(O)
                }

                function g(_) {
                    let O = [],
                        B = [],
                        N = [];
                    for (let _ = 0; _ < k; _++) O[_] = 0, B[_] = 0, N[_] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: O,
                        enabledAttributes: B,
                        attributeDivisors: N,
                        object: _,
                        attributes: {},
                        index: null
                    }
                }

                function x() {
                    let _ = Y.newAttributes;
                    for (let O = 0, B = _.length; O < B; O++) _[O] = 0
                }

                function w(_) {
                    S(_, 0)
                }

                function S(B, k) {
                    let F = Y.newAttributes,
                        U = Y.enabledAttributes,
                        j = Y.attributeDivisors;
                    F[B] = 1, 0 === U[B] && (_.enableVertexAttribArray(B), U[B] = 1), j[B] !== k && ((N.isWebGL2 ? _ : O.get("ANGLE_instanced_arrays"))[N.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, k), j[B] = k)
                }

                function A() {
                    let O = Y.newAttributes,
                        B = Y.enabledAttributes;
                    for (let N = 0, k = B.length; N < k; N++) B[N] !== O[N] && (_.disableVertexAttribArray(N), B[N] = 0)
                }

                function E(O, B, k, F, U, j) {
                    !0 === N.isWebGL2 && (5124 === k || 5125 === k) ? _.vertexAttribIPointer(O, B, k, U, j) : _.vertexAttribPointer(O, B, k, F, U, j)
                }

                function P() {
                    D(), Q = !0, Y !== G && f((Y = G).object)
                }

                function D() {
                    G.geometry = null, G.program = null, G.wireframe = !1
                }
                return {
                    setup: function(k, G, K, $, ee) {
                        let et = !1;
                        if (U) {
                            let O, B, U, Q;
                            let ei = (O = !0 === G.wireframe, void 0 === (B = j[$.id]) && (B = {}, j[$.id] = B), void 0 === (U = B[K.id]) && (U = {}, B[K.id] = U), void 0 === (Q = U[O]) && (Q = g(N.isWebGL2 ? _.createVertexArray() : F.createVertexArrayOES()), U[O] = Q), Q);
                            Y !== ei && f((Y = ei).object), (et = function(_, O, B, N) {
                                let k = Y.attributes,
                                    F = O.attributes,
                                    U = 0,
                                    j = B.getAttributes();
                                for (let O in j)
                                    if (j[O].location >= 0) {
                                        let B = k[O],
                                            N = F[O];
                                        if (void 0 === N && ("instanceMatrix" === O && _.instanceMatrix && (N = _.instanceMatrix), "instanceColor" === O && _.instanceColor && (N = _.instanceColor)), void 0 === B || B.attribute !== N || N && B.data !== N.data) return !0;
                                        U++
                                    }
                                return Y.attributesNum !== U || Y.index !== N
                            }(k, $, K, ee)) && function(_, O, B, N) {
                                let k = {},
                                    F = O.attributes,
                                    U = 0,
                                    j = B.getAttributes();
                                for (let O in j)
                                    if (j[O].location >= 0) {
                                        let B = F[O];
                                        void 0 === B && ("instanceMatrix" === O && _.instanceMatrix && (B = _.instanceMatrix), "instanceColor" === O && _.instanceColor && (B = _.instanceColor));
                                        let N = {};
                                        N.attribute = B, B && B.data && (N.data = B.data), k[O] = N, U++
                                    }
                                Y.attributes = k, Y.attributesNum = U, Y.index = N
                            }(k, $, K, ee)
                        } else {
                            let _ = !0 === G.wireframe;
                            (Y.geometry !== $.id || Y.program !== K.id || Y.wireframe !== _) && (Y.geometry = $.id, Y.program = K.id, Y.wireframe = _, et = !0)
                        }
                        null !== ee && B.update(ee, 34963), (et || Q) && (Q = !1, function(k, F, U, j) {
                            if (!1 === N.isWebGL2 && (k.isInstancedMesh || j.isInstancedBufferGeometry) && null === O.get("ANGLE_instanced_arrays")) return;
                            x();
                            let G = j.attributes,
                                Y = U.getAttributes(),
                                Q = F.defaultAttributeValues;
                            for (let O in Y) {
                                let N = Y[O];
                                if (N.location >= 0) {
                                    let F = G[O];
                                    if (void 0 === F && ("instanceMatrix" === O && k.instanceMatrix && (F = k.instanceMatrix), "instanceColor" === O && k.instanceColor && (F = k.instanceColor)), void 0 !== F) {
                                        let O = F.normalized,
                                            U = F.itemSize,
                                            G = B.get(F);
                                        if (void 0 === G) continue;
                                        let Y = G.buffer,
                                            Q = G.type,
                                            K = G.bytesPerElement;
                                        if (F.isInterleavedBufferAttribute) {
                                            let B = F.data,
                                                G = B.stride,
                                                $ = F.offset;
                                            if (B.isInstancedInterleavedBuffer) {
                                                for (let _ = 0; _ < N.locationSize; _++) S(N.location + _, B.meshPerAttribute);
                                                !0 !== k.isInstancedMesh && void 0 === j._maxInstanceCount && (j._maxInstanceCount = B.meshPerAttribute * B.count)
                                            } else
                                                for (let _ = 0; _ < N.locationSize; _++) w(N.location + _);
                                            _.bindBuffer(34962, Y);
                                            for (let _ = 0; _ < N.locationSize; _++) E(N.location + _, U / N.locationSize, Q, O, G * K, ($ + U / N.locationSize * _) * K)
                                        } else {
                                            if (F.isInstancedBufferAttribute) {
                                                for (let _ = 0; _ < N.locationSize; _++) S(N.location + _, F.meshPerAttribute);
                                                !0 !== k.isInstancedMesh && void 0 === j._maxInstanceCount && (j._maxInstanceCount = F.meshPerAttribute * F.count)
                                            } else
                                                for (let _ = 0; _ < N.locationSize; _++) w(N.location + _);
                                            _.bindBuffer(34962, Y);
                                            for (let _ = 0; _ < N.locationSize; _++) E(N.location + _, U / N.locationSize, Q, O, U * K, U / N.locationSize * _ * K)
                                        }
                                    } else if (void 0 !== Q) {
                                        let B = Q[O];
                                        if (void 0 !== B) switch (B.length) {
                                            case 2:
                                                _.vertexAttrib2fv(N.location, B);
                                                break;
                                            case 3:
                                                _.vertexAttrib3fv(N.location, B);
                                                break;
                                            case 4:
                                                _.vertexAttrib4fv(N.location, B);
                                                break;
                                            default:
                                                _.vertexAttrib1fv(N.location, B)
                                        }
                                    }
                                }
                            }
                            A()
                        }(k, G, K, $), null !== ee && _.bindBuffer(34963, B.get(ee).buffer))
                    },
                    reset: P,
                    resetDefaultState: D,
                    dispose: function() {
                        for (let _ in P(), j) {
                            let O = j[_];
                            for (let _ in O) {
                                let B = O[_];
                                for (let _ in B) p(B[_].object), delete B[_];
                                delete O[_]
                            }
                            delete j[_]
                        }
                    },
                    releaseStatesOfGeometry: function(_) {
                        if (void 0 === j[_.id]) return;
                        let O = j[_.id];
                        for (let _ in O) {
                            let B = O[_];
                            for (let _ in B) p(B[_].object), delete B[_];
                            delete O[_]
                        }
                        delete j[_.id]
                    },
                    releaseStatesOfProgram: function(_) {
                        for (let O in j) {
                            let B = j[O];
                            if (void 0 === B[_.id]) continue;
                            let N = B[_.id];
                            for (let _ in N) p(N[_].object), delete N[_];
                            delete B[_.id]
                        }
                    },
                    initAttributes: x,
                    enableAttribute: w,
                    disableUnusedAttributes: A
                }
            }

            function Rk(_, O, B, N) {
                let k = N.isWebGL2,
                    F;
                this.setMode = function(_) {
                    F = _
                }, this.render = function(O, N) {
                    _.drawArrays(F, O, N), B.update(N, F, 1)
                }, this.renderInstances = function(N, U, j) {
                    let G, Y;
                    if (0 !== j) {
                        if (k) G = _, Y = "drawArraysInstanced";
                        else if (G = O.get("ANGLE_instanced_arrays"), Y = "drawArraysInstancedANGLE", null === G) {
                            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                        G[Y](F, N, U, j), B.update(U, F, j)
                    }
                }
            }

            function Lk(_, O, B) {
                let N;

                function s(O) {
                    if ("highp" === O) {
                        if (_.getShaderPrecisionFormat(35633, 36338).precision > 0 && _.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        O = "mediump"
                    }
                    return "mediump" === O && _.getShaderPrecisionFormat(35633, 36337).precision > 0 && _.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                let k = "u" > typeof WebGL2RenderingContext && _ instanceof WebGL2RenderingContext,
                    F = void 0 !== B.precision ? B.precision : "highp",
                    U = s(F);
                U !== F && (console.warn("THREE.WebGLRenderer:", F, "not supported, using", U, "instead."), F = U);
                let j = k || O.has("WEBGL_draw_buffers"),
                    G = !0 === B.logarithmicDepthBuffer,
                    Y = _.getParameter(34930),
                    Q = _.getParameter(35660),
                    K = _.getParameter(3379),
                    $ = _.getParameter(34076),
                    ee = _.getParameter(34921),
                    et = _.getParameter(36347),
                    ei = _.getParameter(36348),
                    er = _.getParameter(36349),
                    ea = Q > 0,
                    en = k || O.has("OES_texture_float"),
                    eo = k ? _.getParameter(36183) : 0;
                return {
                    isWebGL2: k,
                    drawBuffers: j,
                    getMaxAnisotropy: function() {
                        if (void 0 !== N) return N;
                        if (!0 === O.has("EXT_texture_filter_anisotropic")) {
                            let B = O.get("EXT_texture_filter_anisotropic");
                            N = _.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else N = 0;
                        return N
                    },
                    getMaxPrecision: s,
                    precision: F,
                    logarithmicDepthBuffer: G,
                    maxTextures: Y,
                    maxVertexTextures: Q,
                    maxTextureSize: K,
                    maxCubemapSize: $,
                    maxAttributes: ee,
                    maxVertexUniforms: et,
                    maxVaryings: ei,
                    maxFragmentUniforms: er,
                    vertexTextures: ea,
                    floatFragmentTextures: en,
                    floatVertexTextures: ea && en,
                    maxSamples: eo
                }
            }

            function Nk(_) {
                let O = this,
                    B = null,
                    N = 0,
                    k = !1,
                    F = !1,
                    U = new av,
                    j = new i$,
                    G = {
                        value: null,
                        needsUpdate: !1
                    };

                function c(_, B, N, k) {
                    let F = null !== _ ? _.length : 0,
                        Y = null;
                    if (0 !== F) {
                        if (Y = G.value, !0 !== k || null === Y) {
                            let O = N + 4 * F,
                                k = B.matrixWorldInverse;
                            j.getNormalMatrix(k), (null === Y || Y.length < O) && (Y = new Float32Array(O));
                            for (let O = 0, B = N; O !== F; ++O, B += 4) U.copy(_[O]).applyMatrix4(k, j), U.normal.toArray(Y, B), Y[B + 3] = U.constant
                        }
                        G.value = Y, G.needsUpdate = !0
                    }
                    return O.numPlanes = F, O.numIntersection = 0, Y
                }
                this.uniform = G, this.numPlanes = 0, this.numIntersection = 0, this.init = function(_, O) {
                    let B = 0 !== _.length || O || 0 !== N || k;
                    return k = O, N = _.length, B
                }, this.beginShadows = function() {
                    F = !0, c(null)
                }, this.endShadows = function() {
                    F = !1
                }, this.setGlobalState = function(_, O) {
                    B = c(_, O, 0)
                }, this.setState = function(U, j, Y) {
                    let Q = U.clippingPlanes,
                        K = U.clipIntersection,
                        $ = U.clipShadows,
                        ee = _.get(U);
                    if (k && null !== Q && 0 !== Q.length && (!F || $)) {
                        let _ = F ? 0 : N,
                            O = 4 * _,
                            k = ee.clippingState || null;
                        G.value = k, k = c(Q, j, O, Y);
                        for (let _ = 0; _ !== O; ++_) k[_] = B[_];
                        ee.clippingState = k, this.numIntersection = K ? this.numPlanes : 0, this.numPlanes += _
                    } else F ? c(null) : (G.value !== B && (G.value = B, G.needsUpdate = N > 0), O.numPlanes = N, O.numIntersection = 0)
                }
            }

            function Bk(_) {
                let O = new WeakMap;

                function e(_, O) {
                    return 303 === O ? _.mapping = 301 : 304 === O && (_.mapping = 302), _
                }

                function n(_) {
                    let B = _.target;
                    B.removeEventListener("dispose", n);
                    let N = O.get(B);
                    void 0 !== N && (O.delete(B), N.dispose())
                }
                return {
                    get: function(B) {
                        if (B && B.isTexture && !1 === B.isRenderTargetTexture) {
                            let N = B.mapping;
                            if (303 === N || 304 === N) {
                                if (O.has(B)) return e(O.get(B).texture, B.mapping); {
                                    let N = B.image;
                                    if (!N || !(N.height > 0)) return null; {
                                        let k = new ad(N.height / 2);
                                        return k.fromEquirectangularTexture(_, B), O.set(B, k), B.addEventListener("dispose", n), e(k.texture, B.mapping)
                                    }
                                }
                            }
                        }
                        return B
                    },
                    dispose: function() {
                        O = new WeakMap
                    }
                }
            }
            var aI = class extends ao {
                    constructor(_ = -1, O = 1, B = 1, N = -1, k = .1, F = 2e3) {
                        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = _, this.right = O, this.top = B, this.bottom = N, this.near = k, this.far = F, this.updateProjectionMatrix()
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.left = _.left, this.right = _.right, this.top = _.top, this.bottom = _.bottom, this.near = _.near, this.far = _.far, this.zoom = _.zoom, this.view = null === _.view ? null : Object.assign({}, _.view), this
                    }
                    setViewOffset(_, O, B, N, k, F) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = _, this.view.fullHeight = O, this.view.offsetX = B, this.view.offsetY = N, this.view.width = k, this.view.height = F, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        let _ = (this.right - this.left) / (2 * this.zoom),
                            O = (this.top - this.bottom) / (2 * this.zoom),
                            B = (this.right + this.left) / 2,
                            N = (this.top + this.bottom) / 2,
                            k = B - _,
                            F = B + _,
                            U = N + O,
                            j = N - O;
                        if (null !== this.view && this.view.enabled) {
                            let _ = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                O = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            k += _ * this.view.offsetX, F = k + _ * this.view.width, U -= O * this.view.offsetY, j = U - O * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(k, F, U, j, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(_) {
                        let O = super.toJSON(_);
                        return O.object.zoom = this.zoom, O.object.left = this.left, O.object.right = this.right, O.object.top = this.top, O.object.bottom = this.bottom, O.object.near = this.near, O.object.far = this.far, null !== this.view && (O.object.view = Object.assign({}, this.view)), O
                    }
                },
                aO = [.125, .215, .35, .446, .526, .582],
                aR = new aI,
                aB = new re,
                aN = null,
                ak = (1 + Math.sqrt(5)) / 2,
                aF = 1 / ak,
                aU = [new rv(1, 1, 1), new rv(-1, 1, 1), new rv(1, 1, -1), new rv(-1, 1, -1), new rv(0, ak, aF), new rv(0, ak, -aF), new rv(aF, 0, ak), new rv(-aF, 0, ak), new rv(ak, aF, 0), new rv(-ak, aF, 0)],
                aj = class {
                    constructor(_) {
                        this._renderer = _, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(_, O = 0, B = .1, N = 100) {
                        aN = this._renderer.getRenderTarget(), this._setSize(256);
                        let k = this._allocateTargets();
                        return k.depthBuffer = !0, this._sceneToCubeUV(_, B, N, k), O > 0 && this._blur(k, 0, 0, O), this._applyPMREM(k), this._cleanup(k), k
                    }
                    fromEquirectangular(_, O = null) {
                        return this._fromTexture(_, O)
                    }
                    fromCubemap(_, O = null) {
                        return this._fromTexture(_, O)
                    }
                    compileCubemapShader() {
                        null === this._cubemapMaterial && (this._cubemapMaterial = dE(), this._compileMaterial(this._cubemapMaterial))
                    }
                    compileEquirectangularShader() {
                        null === this._equirectMaterial && (this._equirectMaterial = hE(), this._compileMaterial(this._equirectMaterial))
                    }
                    dispose() {
                        this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                    }
                    _setSize(_) {
                        this._lodMax = Math.floor(Math.log2(_)), this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                        for (let _ = 0; _ < this._lodPlanes.length; _++) this._lodPlanes[_].dispose()
                    }
                    _cleanup(_) {
                        this._renderer.setRenderTarget(aN), _.scissorTest = !1, $m(_, 0, 0, _.width, _.height)
                    }
                    _fromTexture(_, O) {
                        301 === _.mapping || 302 === _.mapping ? this._setSize(0 === _.image.length ? 16 : _.image[0].width || _.image[0].image.width) : this._setSize(_.image.width / 4), aN = this._renderer.getRenderTarget();
                        let B = O || this._allocateTargets();
                        return this._textureToCubeUV(_, B), this._applyPMREM(B), this._cleanup(B), B
                    }
                    _allocateTargets() {
                        let _ = 3 * Math.max(this._cubeSize, 112),
                            O = 4 * this._cubeSize,
                            B = {
                                magFilter: 1006,
                                minFilter: 1006,
                                generateMipmaps: !1,
                                type: 1016,
                                format: 1023,
                                encoding: 3e3,
                                depthBuffer: !1
                            },
                            N = uE(_, O, B);
                        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== _ || this._pingPongRenderTarget.height !== O) {
                            let N, k;
                            null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = uE(_, O, B);
                            let {
                                _lodMax: F
                            } = this;
                            ({
                                sizeLods: this._sizeLods,
                                lodPlanes: this._lodPlanes,
                                sigmas: this._sigmas
                            } = function(_) {
                                let O = [],
                                    B = [],
                                    N = [],
                                    k = _,
                                    F = _ - 4 + 1 + aO.length;
                                for (let U = 0; U < F; U++) {
                                    let F = Math.pow(2, k);
                                    B.push(F);
                                    let j = 1 / F;
                                    U > _ - 4 ? j = aO[U - _ + 4 - 1] : 0 === U && (j = 0), N.push(j);
                                    let G = 1 / (F - 2),
                                        Y = -G,
                                        Q = 1 + G,
                                        K = [Y, Y, Q, Y, Q, Q, Y, Y, Q, Q, Y, Q],
                                        $ = new Float32Array(108),
                                        ee = new Float32Array(72),
                                        et = new Float32Array(36);
                                    for (let _ = 0; _ < 6; _++) {
                                        let O = _ % 3 * 2 / 3 - 1,
                                            B = _ > 2 ? 0 : -1,
                                            N = [O, B, 0, O + 2 / 3, B, 0, O + 2 / 3, B + 1, 0, O, B, 0, O + 2 / 3, B + 1, 0, O, B + 1, 0];
                                        $.set(N, 18 * _), ee.set(K, 12 * _);
                                        let k = [_, _, _, _, _, _];
                                        et.set(k, 6 * _)
                                    }
                                    let ei = new sK;
                                    ei.setAttribute("position", new sF($, 3)), ei.setAttribute("uv", new sF(ee, 2)), ei.setAttribute("faceIndex", new sF(et, 1)), O.push(ei), k > 4 && k--
                                }
                                return {
                                    lodPlanes: O,
                                    sizeLods: B,
                                    sigmas: N
                                }
                            }(F)), this._blurMaterial = (N = new Float32Array(20), k = new rv(0, 1, 0), new an({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: 20,
                                    CUBEUV_TEXEL_WIDTH: 1 / _,
                                    CUBEUV_TEXEL_HEIGHT: 1 / O,
                                    CUBEUV_MAX_MIP: `${F}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: N
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: k
                                    }
                                },
                                vertexShader: ew(),
                                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            }))
                        }
                        return N
                    }
                    _compileMaterial(_) {
                        let O = new at(this._lodPlanes[0], _);
                        this._renderer.compile(O, aR)
                    }
                    _sceneToCubeUV(_, O, B, N) {
                        let k = new al(90, 1, O, B),
                            F = [1, -1, 1, 1, 1, 1],
                            U = [1, 1, 1, -1, -1, -1],
                            j = this._renderer,
                            G = j.autoClear,
                            Y = j.toneMapping;
                        j.getClearColor(aB), j.toneMapping = 0, j.autoClear = !1;
                        let Q = new sz({
                                name: "PMREM.Background",
                                side: 1,
                                depthWrite: !1,
                                depthTest: !1
                            }),
                            K = new at(new ai, Q),
                            $ = !1,
                            ee = _.background;
                        ee ? ee.isColor && (Q.color.copy(ee), _.background = null, $ = !0) : (Q.color.copy(aB), $ = !0);
                        for (let O = 0; O < 6; O++) {
                            let B = O % 3;
                            0 === B ? (k.up.set(0, F[O], 0), k.lookAt(U[O], 0, 0)) : 1 === B ? (k.up.set(0, 0, F[O]), k.lookAt(0, U[O], 0)) : (k.up.set(0, F[O], 0), k.lookAt(0, 0, U[O]));
                            let G = this._cubeSize;
                            $m(N, B * G, O > 2 ? G : 0, G, G), j.setRenderTarget(N), $ && j.render(K, k), j.render(_, k)
                        }
                        K.geometry.dispose(), K.material.dispose(), j.toneMapping = Y, j.autoClear = G, _.background = ee
                    }
                    _textureToCubeUV(_, O) {
                        let B = this._renderer,
                            N = 301 === _.mapping || 302 === _.mapping;
                        N ? (null === this._cubemapMaterial && (this._cubemapMaterial = dE()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === _.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = hE());
                        let k = N ? this._cubemapMaterial : this._equirectMaterial,
                            F = new at(this._lodPlanes[0], k);
                        k.uniforms.envMap.value = _;
                        let U = this._cubeSize;
                        $m(O, 0, 0, 3 * U, 2 * U), B.setRenderTarget(O), B.render(F, aR)
                    }
                    _applyPMREM(_) {
                        let O = this._renderer,
                            B = O.autoClear;
                        O.autoClear = !1;
                        for (let O = 1; O < this._lodPlanes.length; O++) {
                            let B = Math.sqrt(this._sigmas[O] * this._sigmas[O] - this._sigmas[O - 1] * this._sigmas[O - 1]),
                                N = aU[(O - 1) % aU.length];
                            this._blur(_, O - 1, O, B, N)
                        }
                        O.autoClear = B
                    }
                    _blur(_, O, B, N, k) {
                        let F = this._pingPongRenderTarget;
                        this._halfBlur(_, F, O, B, N, "latitudinal", k), this._halfBlur(F, _, B, B, N, "longitudinal", k)
                    }
                    _halfBlur(_, O, B, N, k, F, U) {
                        let j = this._renderer,
                            G = this._blurMaterial;
                        "latitudinal" !== F && "longitudinal" !== F && console.error("blur direction must be either latitudinal or longitudinal!");
                        let Y = new at(this._lodPlanes[N], G),
                            Q = G.uniforms,
                            K = this._sizeLods[B] - 1,
                            $ = isFinite(k) ? Math.PI / (2 * K) : 2 * Math.PI / 39,
                            ee = k / $,
                            et = isFinite(k) ? 1 + Math.floor(3 * ee) : 20;
                        et > 20 && console.warn(`sigmaRadians, ${k}, is too large and will clip, as it requested ${et} samples when the maximum is set to 20`);
                        let ei = [],
                            er = 0;
                        for (let _ = 0; _ < 20; ++_) {
                            let O = _ / ee,
                                B = Math.exp(-O * O / 2);
                            ei.push(B), 0 === _ ? er += B : _ < et && (er += 2 * B)
                        }
                        for (let _ = 0; _ < ei.length; _++) ei[_] = ei[_] / er;
                        Q.envMap.value = _.texture, Q.samples.value = et, Q.weights.value = ei, Q.latitudinal.value = "latitudinal" === F, U && (Q.poleAxis.value = U);
                        let {
                            _lodMax: ea
                        } = this;
                        Q.dTheta.value = $, Q.mipInt.value = ea - B;
                        let en = this._sizeLods[N];
                        $m(O, 3 * en * (N > ea - 4 ? N - ea + 4 : 0), 4 * (this._cubeSize - en), 3 * en, 2 * en), j.setRenderTarget(O), j.render(Y, aR)
                    }
                };

            function uE(_, O, B) {
                let N = new rh(_, O, B);
                return N.texture.mapping = 306, N.texture.name = "PMREM.cubeUv", N.scissorTest = !0, N
            }

            function $m(_, O, B, N, k) {
                _.viewport.set(O, B, N, k), _.scissor.set(O, B, N, k)
            }

            function hE() {
                return new an({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: ew(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function dE() {
                return new an({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: ew(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function ew() {
                return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
            }

            function Vk(_) {
                let O = new WeakMap,
                    B = null;

                function s(_) {
                    let B = _.target;
                    B.removeEventListener("dispose", s);
                    let N = O.get(B);
                    void 0 !== N && (O.delete(B), N.dispose())
                }
                return {
                    get: function(N) {
                        if (N && N.isTexture) {
                            let k = N.mapping,
                                F = 303 === k || 304 === k,
                                U = 301 === k || 302 === k;
                            if (F || U) {
                                if (N.isRenderTargetTexture && !0 === N.needsPMREMUpdate) {
                                    N.needsPMREMUpdate = !1;
                                    let k = O.get(N);
                                    return null === B && (B = new aj(_)), k = F ? B.fromEquirectangular(N, k) : B.fromCubemap(N, k), O.set(N, k), k.texture
                                }
                                if (O.has(N)) return O.get(N).texture; {
                                    let k = N.image;
                                    if (!(F && k && k.height > 0 || U && k && function(_) {
                                            let O = 0;
                                            for (let B = 0; B < 6; B++) void 0 !== _[B] && O++;
                                            return 6 === O
                                        }(k))) return null; {
                                        null === B && (B = new aj(_));
                                        let k = F ? B.fromEquirectangular(N) : B.fromCubemap(N);
                                        return O.set(N, k), N.addEventListener("dispose", s), k.texture
                                    }
                                }
                            }
                        }
                        return N
                    },
                    dispose: function() {
                        O = new WeakMap, null !== B && (B.dispose(), B = null)
                    }
                }
            }

            function zk(_) {
                let O = {};

                function e(B) {
                    let N;
                    if (void 0 !== O[B]) return O[B];
                    switch (B) {
                        case "WEBGL_depth_texture":
                            N = _.getExtension("WEBGL_depth_texture") || _.getExtension("MOZ_WEBGL_depth_texture") || _.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            N = _.getExtension("EXT_texture_filter_anisotropic") || _.getExtension("MOZ_EXT_texture_filter_anisotropic") || _.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            N = _.getExtension("WEBGL_compressed_texture_s3tc") || _.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || _.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            N = _.getExtension("WEBGL_compressed_texture_pvrtc") || _.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            N = _.getExtension(B)
                    }
                    return O[B] = N, N
                }
                return {
                    has: function(_) {
                        return null !== e(_)
                    },
                    init: function(_) {
                        _.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(_) {
                        let O = e(_);
                        return null === O && console.warn("THREE.WebGLRenderer: " + _ + " extension not supported."), O
                    }
                }
            }

            function Uk(_, O, B, N) {
                let k = {},
                    F = new WeakMap;

                function o(_) {
                    let U = _.target;
                    for (let _ in null !== U.index && O.remove(U.index), U.attributes) O.remove(U.attributes[_]);
                    U.removeEventListener("dispose", o), delete k[U.id];
                    let j = F.get(U);
                    j && (O.remove(j), F.delete(U)), N.releaseStatesOfGeometry(U), !0 === U.isInstancedBufferGeometry && delete U._maxInstanceCount, B.memory.geometries--
                }

                function u(_) {
                    let B = [],
                        N = _.index,
                        k = _.attributes.position,
                        U = 0;
                    if (null !== N) {
                        let _ = N.array;
                        U = N.version;
                        for (let O = 0, N = _.length; O < N; O += 3) {
                            let N = _[O + 0],
                                k = _[O + 1],
                                F = _[O + 2];
                            B.push(N, k, k, F, F, N)
                        }
                    } else {
                        let _ = k.array;
                        U = k.version;
                        for (let O = 0, N = _.length / 3 - 1; O < N; O += 3) {
                            let _ = O + 0,
                                N = O + 1,
                                k = O + 2;
                            B.push(_, N, N, k, k, _)
                        }
                    }
                    let j = new(nM(B) ? sj : sU)(B, 1);
                    j.version = U;
                    let G = F.get(_);
                    G && O.remove(G), F.set(_, j)
                }
                return {
                    get: function(_, O) {
                        return !0 === k[O.id] || (O.addEventListener("dispose", o), k[O.id] = !0, B.memory.geometries++), O
                    },
                    update: function(_) {
                        let B = _.attributes;
                        for (let _ in B) O.update(B[_], 34962);
                        let N = _.morphAttributes;
                        for (let _ in N) {
                            let B = N[_];
                            for (let _ = 0, N = B.length; _ < N; _++) O.update(B[_], 34962)
                        }
                    },
                    getWireframeAttribute: function(_) {
                        let O = F.get(_);
                        if (O) {
                            let B = _.index;
                            null !== B && O.version < B.version && u(_)
                        } else u(_);
                        return F.get(_)
                    }
                }
            }

            function Gk(_, O, B, N) {
                let k, F, U = N.isWebGL2,
                    j;
                this.setMode = function(_) {
                    j = _
                }, this.setIndex = function(_) {
                    k = _.type, F = _.bytesPerElement
                }, this.render = function(O, N) {
                    _.drawElements(j, N, k, O * F), B.update(N, j, 1)
                }, this.renderInstances = function(N, G, Y) {
                    let Q, K;
                    if (0 !== Y) {
                        if (U) Q = _, K = "drawElementsInstanced";
                        else if (Q = O.get("ANGLE_instanced_arrays"), K = "drawElementsInstancedANGLE", null === Q) {
                            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                        Q[K](j, G, k, N * F, Y), B.update(G, j, Y)
                    }
                }
            }

            function Hk(_) {
                let O = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: O,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        O.frame++, O.calls = 0, O.triangles = 0, O.points = 0, O.lines = 0
                    },
                    update: function(_, B, N) {
                        switch (O.calls++, B) {
                            case 4:
                                O.triangles += N * (_ / 3);
                                break;
                            case 1:
                                O.lines += N * (_ / 2);
                                break;
                            case 3:
                                O.lines += N * (_ - 1);
                                break;
                            case 2:
                                O.lines += N * _;
                                break;
                            case 0:
                                O.points += N * _;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", B)
                        }
                    }
                }
            }

            function jk(_, O) {
                return _[0] - O[0]
            }

            function Wk(_, O) {
                return Math.abs(O[1]) - Math.abs(_[1])
            }

            function qk(_, O, B) {
                let N = {},
                    k = new Float32Array(8),
                    F = new WeakMap,
                    U = new rl,
                    j = [];
                for (let _ = 0; _ < 8; _++) j[_] = [_, 0];
                return {
                    update: function(G, Y, Q, K) {
                        let $ = G.morphTargetInfluences;
                        if (!0 === O.isWebGL2) {
                            let N = Y.morphAttributes.position || Y.morphAttributes.normal || Y.morphAttributes.color,
                                k = void 0 !== N ? N.length : 0,
                                j = F.get(Y);
                            if (void 0 === j || j.count !== k) {
                                let R = function() {
                                    er.dispose(), F.delete(Y), Y.removeEventListener("dispose", R)
                                };
                                void 0 !== j && j.texture.dispose();
                                let _ = void 0 !== Y.morphAttributes.position,
                                    B = void 0 !== Y.morphAttributes.normal,
                                    N = void 0 !== Y.morphAttributes.color,
                                    G = Y.morphAttributes.position || [],
                                    Q = Y.morphAttributes.normal || [],
                                    K = Y.morphAttributes.color || [],
                                    $ = 0;
                                !0 === _ && ($ = 1), !0 === B && ($ = 2), !0 === N && ($ = 3);
                                let ee = Y.attributes.position.count * $,
                                    et = 1;
                                ee > O.maxTextureSize && (et = Math.ceil(ee / O.maxTextureSize), ee = O.maxTextureSize);
                                let ei = new Float32Array(ee * et * 4 * k),
                                    er = new rd(ei, ee, et, k);
                                er.type = 1015, er.needsUpdate = !0;
                                let ea = 4 * $;
                                for (let O = 0; O < k; O++) {
                                    let k = G[O],
                                        F = Q[O],
                                        j = K[O],
                                        Y = ee * et * 4 * O;
                                    for (let O = 0; O < k.count; O++) {
                                        let G = O * ea;
                                        !0 === _ && (U.fromBufferAttribute(k, O), ei[Y + G + 0] = U.x, ei[Y + G + 1] = U.y, ei[Y + G + 2] = U.z, ei[Y + G + 3] = 0), !0 === B && (U.fromBufferAttribute(F, O), ei[Y + G + 4] = U.x, ei[Y + G + 5] = U.y, ei[Y + G + 6] = U.z, ei[Y + G + 7] = 0), !0 === N && (U.fromBufferAttribute(j, O), ei[Y + G + 8] = U.x, ei[Y + G + 9] = U.y, ei[Y + G + 10] = U.z, ei[Y + G + 11] = 4 === j.itemSize ? U.w : 1)
                                    }
                                }
                                j = {
                                    count: k,
                                    texture: er,
                                    size: new iJ(ee, et)
                                }, F.set(Y, j), Y.addEventListener("dispose", R)
                            }
                            let G = 0;
                            for (let _ = 0; _ < $.length; _++) G += $[_];
                            let Q = Y.morphTargetsRelative ? 1 : 1 - G;
                            K.getUniforms().setValue(_, "morphTargetBaseInfluence", Q), K.getUniforms().setValue(_, "morphTargetInfluences", $), K.getUniforms().setValue(_, "morphTargetsTexture", j.texture, B), K.getUniforms().setValue(_, "morphTargetsTextureSize", j.size)
                        } else {
                            let O = void 0 === $ ? 0 : $.length,
                                B = N[Y.id];
                            if (void 0 === B || B.length !== O) {
                                B = [];
                                for (let _ = 0; _ < O; _++) B[_] = [_, 0];
                                N[Y.id] = B
                            }
                            for (let _ = 0; _ < O; _++) {
                                let O = B[_];
                                O[0] = _, O[1] = $[_]
                            }
                            B.sort(Wk);
                            for (let _ = 0; _ < 8; _++) _ < O && B[_][1] ? (j[_][0] = B[_][0], j[_][1] = B[_][1]) : (j[_][0] = Number.MAX_SAFE_INTEGER, j[_][1] = 0);
                            j.sort(jk);
                            let F = Y.morphAttributes.position,
                                U = Y.morphAttributes.normal,
                                G = 0;
                            for (let _ = 0; _ < 8; _++) {
                                let O = j[_],
                                    B = O[0],
                                    N = O[1];
                                B !== Number.MAX_SAFE_INTEGER && N ? (F && Y.getAttribute("morphTarget" + _) !== F[B] && Y.setAttribute("morphTarget" + _, F[B]), U && Y.getAttribute("morphNormal" + _) !== U[B] && Y.setAttribute("morphNormal" + _, U[B]), k[_] = N, G += N) : (F && !0 === Y.hasAttribute("morphTarget" + _) && Y.deleteAttribute("morphTarget" + _), U && !0 === Y.hasAttribute("morphNormal" + _) && Y.deleteAttribute("morphNormal" + _), k[_] = 0)
                            }
                            let Q = Y.morphTargetsRelative ? 1 : 1 - G;
                            K.getUniforms().setValue(_, "morphTargetBaseInfluence", Q), K.getUniforms().setValue(_, "morphTargetInfluences", k)
                        }
                    }
                }
            }

            function Yk(_, O, B, N) {
                let k = new WeakMap;

                function a(_) {
                    let O = _.target;
                    O.removeEventListener("dispose", a), B.remove(O.instanceMatrix), null !== O.instanceColor && B.remove(O.instanceColor)
                }
                return {
                    update: function(_) {
                        let F = N.render.frame,
                            U = _.geometry,
                            j = O.get(_, U);
                        return k.get(j) !== F && (O.update(j), k.set(j, F)), _.isInstancedMesh && (!1 === _.hasEventListener("dispose", a) && _.addEventListener("dispose", a), B.update(_.instanceMatrix, 34962), null !== _.instanceColor && B.update(_.instanceColor, 34962)), j
                    },
                    dispose: function() {
                        k = new WeakMap
                    }
                }
            }
            var aG = new ro,
                aH = new rd,
                aW = new ru,
                aq = new ac,
                aY = [],
                aX = [],
                aZ = new Float32Array(16),
                aK = new Float32Array(9),
                aJ = new Float32Array(4);

            function Du(_, O, B) {
                let N = _[0];
                if (N <= 0 || N > 0) return _;
                let k = O * B,
                    F = aY[k];
                if (void 0 === F && (F = new Float32Array(k), aY[k] = F), 0 !== O) {
                    N.toArray(F, 0);
                    for (let N = 1, k = 0; N !== O; ++N) k += B, _[N].toArray(F, k)
                }
                return F
            }

            function tn(_, O) {
                if (_.length !== O.length) return !1;
                for (let B = 0, N = _.length; B < N; B++)
                    if (_[B] !== O[B]) return !1;
                return !0
            }

            function rn(_, O) {
                for (let B = 0, N = O.length; B < N; B++) _[B] = O[B]
            }

            function Bg(_, O) {
                let B = aX[O];
                void 0 === B && (B = new Int32Array(O), aX[O] = B);
                for (let N = 0; N !== O; ++N) B[N] = _.allocateTextureUnit();
                return B
            }

            function Xk(_, O) {
                let B = this.cache;
                B[0] !== O && (_.uniform1f(this.addr, O), B[0] = O)
            }

            function Qk(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y) && (_.uniform2f(this.addr, O.x, O.y), B[0] = O.x, B[1] = O.y);
                else {
                    if (tn(B, O)) return;
                    _.uniform2fv(this.addr, O), rn(B, O)
                }
            }

            function Kk(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y || B[2] !== O.z) && (_.uniform3f(this.addr, O.x, O.y, O.z), B[0] = O.x, B[1] = O.y, B[2] = O.z);
                else if (void 0 !== O.r)(B[0] !== O.r || B[1] !== O.g || B[2] !== O.b) && (_.uniform3f(this.addr, O.r, O.g, O.b), B[0] = O.r, B[1] = O.g, B[2] = O.b);
                else {
                    if (tn(B, O)) return;
                    _.uniform3fv(this.addr, O), rn(B, O)
                }
            }

            function Zk(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y || B[2] !== O.z || B[3] !== O.w) && (_.uniform4f(this.addr, O.x, O.y, O.z, O.w), B[0] = O.x, B[1] = O.y, B[2] = O.z, B[3] = O.w);
                else {
                    if (tn(B, O)) return;
                    _.uniform4fv(this.addr, O), rn(B, O)
                }
            }

            function Jk(_, O) {
                let B = this.cache,
                    N = O.elements;
                if (void 0 === N) {
                    if (tn(B, O)) return;
                    _.uniformMatrix2fv(this.addr, !1, O), rn(B, O)
                } else {
                    if (tn(B, N)) return;
                    aJ.set(N), _.uniformMatrix2fv(this.addr, !1, aJ), rn(B, N)
                }
            }

            function $k(_, O) {
                let B = this.cache,
                    N = O.elements;
                if (void 0 === N) {
                    if (tn(B, O)) return;
                    _.uniformMatrix3fv(this.addr, !1, O), rn(B, O)
                } else {
                    if (tn(B, N)) return;
                    aK.set(N), _.uniformMatrix3fv(this.addr, !1, aK), rn(B, N)
                }
            }

            function eV(_, O) {
                let B = this.cache,
                    N = O.elements;
                if (void 0 === N) {
                    if (tn(B, O)) return;
                    _.uniformMatrix4fv(this.addr, !1, O), rn(B, O)
                } else {
                    if (tn(B, N)) return;
                    aZ.set(N), _.uniformMatrix4fv(this.addr, !1, aZ), rn(B, N)
                }
            }

            function tV(_, O) {
                let B = this.cache;
                B[0] !== O && (_.uniform1i(this.addr, O), B[0] = O)
            }

            function rV(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y) && (_.uniform2i(this.addr, O.x, O.y), B[0] = O.x, B[1] = O.y);
                else {
                    if (tn(B, O)) return;
                    _.uniform2iv(this.addr, O), rn(B, O)
                }
            }

            function nV(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y || B[2] !== O.z) && (_.uniform3i(this.addr, O.x, O.y, O.z), B[0] = O.x, B[1] = O.y, B[2] = O.z);
                else {
                    if (tn(B, O)) return;
                    _.uniform3iv(this.addr, O), rn(B, O)
                }
            }

            function iV(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y || B[2] !== O.z || B[3] !== O.w) && (_.uniform4i(this.addr, O.x, O.y, O.z, O.w), B[0] = O.x, B[1] = O.y, B[2] = O.z, B[3] = O.w);
                else {
                    if (tn(B, O)) return;
                    _.uniform4iv(this.addr, O), rn(B, O)
                }
            }

            function sV(_, O) {
                let B = this.cache;
                B[0] !== O && (_.uniform1ui(this.addr, O), B[0] = O)
            }

            function oV(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y) && (_.uniform2ui(this.addr, O.x, O.y), B[0] = O.x, B[1] = O.y);
                else {
                    if (tn(B, O)) return;
                    _.uniform2uiv(this.addr, O), rn(B, O)
                }
            }

            function aV(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y || B[2] !== O.z) && (_.uniform3ui(this.addr, O.x, O.y, O.z), B[0] = O.x, B[1] = O.y, B[2] = O.z);
                else {
                    if (tn(B, O)) return;
                    _.uniform3uiv(this.addr, O), rn(B, O)
                }
            }

            function lV(_, O) {
                let B = this.cache;
                if (void 0 !== O.x)(B[0] !== O.x || B[1] !== O.y || B[2] !== O.z || B[3] !== O.w) && (_.uniform4ui(this.addr, O.x, O.y, O.z, O.w), B[0] = O.x, B[1] = O.y, B[2] = O.z, B[3] = O.w);
                else {
                    if (tn(B, O)) return;
                    _.uniform4uiv(this.addr, O), rn(B, O)
                }
            }

            function cV(_, O, B) {
                let N = this.cache,
                    k = B.allocateTextureUnit();
                N[0] !== k && (_.uniform1i(this.addr, k), N[0] = k), B.setTexture2D(O || aG, k)
            }

            function uV(_, O, B) {
                let N = this.cache,
                    k = B.allocateTextureUnit();
                N[0] !== k && (_.uniform1i(this.addr, k), N[0] = k), B.setTexture3D(O || aW, k)
            }

            function hV(_, O, B) {
                let N = this.cache,
                    k = B.allocateTextureUnit();
                N[0] !== k && (_.uniform1i(this.addr, k), N[0] = k), B.setTextureCube(O || aq, k)
            }

            function dV(_, O, B) {
                let N = this.cache,
                    k = B.allocateTextureUnit();
                N[0] !== k && (_.uniform1i(this.addr, k), N[0] = k), B.setTexture2DArray(O || aH, k)
            }

            function pV(_, O) {
                _.uniform1fv(this.addr, O)
            }

            function mV(_, O) {
                let B = Du(O, this.size, 2);
                _.uniform2fv(this.addr, B)
            }

            function gV(_, O) {
                let B = Du(O, this.size, 3);
                _.uniform3fv(this.addr, B)
            }

            function yV(_, O) {
                let B = Du(O, this.size, 4);
                _.uniform4fv(this.addr, B)
            }

            function vV(_, O) {
                let B = Du(O, this.size, 4);
                _.uniformMatrix2fv(this.addr, !1, B)
            }

            function xV(_, O) {
                let B = Du(O, this.size, 9);
                _.uniformMatrix3fv(this.addr, !1, B)
            }

            function bV(_, O) {
                let B = Du(O, this.size, 16);
                _.uniformMatrix4fv(this.addr, !1, B)
            }

            function wV(_, O) {
                _.uniform1iv(this.addr, O)
            }

            function SV(_, O) {
                _.uniform2iv(this.addr, O)
            }

            function AV(_, O) {
                _.uniform3iv(this.addr, O)
            }

            function _V(_, O) {
                _.uniform4iv(this.addr, O)
            }

            function EV(_, O) {
                _.uniform1uiv(this.addr, O)
            }

            function MV(_, O) {
                _.uniform2uiv(this.addr, O)
            }

            function TV(_, O) {
                _.uniform3uiv(this.addr, O)
            }

            function CV(_, O) {
                _.uniform4uiv(this.addr, O)
            }

            function PV(_, O, B) {
                let N = this.cache,
                    k = O.length,
                    F = Bg(B, k);
                tn(N, F) || (_.uniform1iv(this.addr, F), rn(N, F));
                for (let _ = 0; _ !== k; ++_) B.setTexture2D(O[_] || aG, F[_])
            }

            function DV(_, O, B) {
                let N = this.cache,
                    k = O.length,
                    F = Bg(B, k);
                tn(N, F) || (_.uniform1iv(this.addr, F), rn(N, F));
                for (let _ = 0; _ !== k; ++_) B.setTexture3D(O[_] || aW, F[_])
            }

            function IV(_, O, B) {
                let N = this.cache,
                    k = O.length,
                    F = Bg(B, k);
                tn(N, F) || (_.uniform1iv(this.addr, F), rn(N, F));
                for (let _ = 0; _ !== k; ++_) B.setTextureCube(O[_] || aq, F[_])
            }

            function OV(_, O, B) {
                let N = this.cache,
                    k = O.length,
                    F = Bg(B, k);
                tn(N, F) || (_.uniform1iv(this.addr, F), rn(N, F));
                for (let _ = 0; _ !== k; ++_) B.setTexture2DArray(O[_] || aH, F[_])
            }
            var a$ = class {
                    constructor(_, O, B) {
                        this.id = _, this.addr = B, this.cache = [], this.setValue = function(_) {
                            switch (_) {
                                case 5126:
                                    return Xk;
                                case 35664:
                                    return Qk;
                                case 35665:
                                    return Kk;
                                case 35666:
                                    return Zk;
                                case 35674:
                                    return Jk;
                                case 35675:
                                    return $k;
                                case 35676:
                                    return eV;
                                case 5124:
                                case 35670:
                                    return tV;
                                case 35667:
                                case 35671:
                                    return rV;
                                case 35668:
                                case 35672:
                                    return nV;
                                case 35669:
                                case 35673:
                                    return iV;
                                case 5125:
                                    return sV;
                                case 36294:
                                    return oV;
                                case 36295:
                                    return aV;
                                case 36296:
                                    return lV;
                                case 35678:
                                case 36198:
                                case 36298:
                                case 36306:
                                case 35682:
                                    return cV;
                                case 35679:
                                case 36299:
                                case 36307:
                                    return uV;
                                case 35680:
                                case 36300:
                                case 36308:
                                case 36293:
                                    return hV;
                                case 36289:
                                case 36303:
                                case 36311:
                                case 36292:
                                    return dV
                            }
                        }(O.type)
                    }
                },
                a0 = class {
                    constructor(_, O, B) {
                        this.id = _, this.addr = B, this.cache = [], this.size = O.size, this.setValue = function(_) {
                            switch (_) {
                                case 5126:
                                    return pV;
                                case 35664:
                                    return mV;
                                case 35665:
                                    return gV;
                                case 35666:
                                    return yV;
                                case 35674:
                                    return vV;
                                case 35675:
                                    return xV;
                                case 35676:
                                    return bV;
                                case 5124:
                                case 35670:
                                    return wV;
                                case 35667:
                                case 35671:
                                    return SV;
                                case 35668:
                                case 35672:
                                    return AV;
                                case 35669:
                                case 35673:
                                    return _V;
                                case 5125:
                                    return EV;
                                case 36294:
                                    return MV;
                                case 36295:
                                    return TV;
                                case 36296:
                                    return CV;
                                case 35678:
                                case 36198:
                                case 36298:
                                case 36306:
                                case 35682:
                                    return PV;
                                case 35679:
                                case 36299:
                                case 36307:
                                    return DV;
                                case 35680:
                                case 36300:
                                case 36308:
                                case 36293:
                                    return IV;
                                case 36289:
                                case 36303:
                                case 36311:
                                case 36292:
                                    return OV
                            }
                        }(O.type)
                    }
                },
                a3 = class {
                    constructor(_) {
                        this.id = _, this.seq = [], this.map = {}
                    }
                    setValue(_, O, B) {
                        let N = this.seq;
                        for (let k = 0, F = N.length; k !== F; ++k) {
                            let F = N[k];
                            F.setValue(_, O[F.id], B)
                        }
                    }
                },
                a4 = /(\w+)(\])?(\[|\.)?/g;

            function vE(_, O) {
                _.seq.push(O), _.map[O.id] = O
            }
            var a5 = class {
                constructor(_, O) {
                    this.seq = [], this.map = {};
                    let B = _.getProgramParameter(O, 35718);
                    for (let N = 0; N < B; ++N) {
                        let B = _.getActiveUniform(O, N),
                            k = _.getUniformLocation(O, B.name);
                        ! function(_, O, B) {
                            let N = _.name,
                                k = N.length;
                            for (a4.lastIndex = 0;;) {
                                let F = a4.exec(N),
                                    U = a4.lastIndex,
                                    j = F[1],
                                    G = "]" === F[2],
                                    Y = F[3];
                                if (G && (j |= 0), void 0 === Y || "[" === Y && U + 2 === k) {
                                    vE(B, void 0 === Y ? new a$(j, _, O) : new a0(j, _, O));
                                    break
                                } {
                                    let _ = B.map[j];
                                    void 0 === _ && vE(B, _ = new a3(j)), B = _
                                }
                            }
                        }(B, k, this)
                    }
                }
                setValue(_, O, B, N) {
                    let k = this.map[O];
                    void 0 !== k && k.setValue(_, B, N)
                }
                setOptional(_, O, B) {
                    let N = O[B];
                    void 0 !== N && this.setValue(_, B, N)
                }
                static upload(_, O, B, N) {
                    for (let k = 0, F = O.length; k !== F; ++k) {
                        let F = O[k],
                            U = B[F.id];
                        !1 !== U.needsUpdate && F.setValue(_, U.value, N)
                    }
                }
                static seqWithValue(_, O) {
                    let B = [];
                    for (let N = 0, k = _.length; N !== k; ++N) {
                        let k = _[N];
                        k.id in O && B.push(k)
                    }
                    return B
                }
            };

            function xE(_, O, B) {
                let N = _.createShader(O);
                return _.shaderSource(N, B), _.compileShader(N), N
            }
            var a6 = 0;

            function bE(_, O, B) {
                let N = _.getShaderParameter(O, 35713),
                    k = _.getShaderInfoLog(O).trim();
                if (N && "" === k) return "";
                let F = /ERROR: 0:(\d+)/.exec(k);
                if (!F) return k; {
                    let N = parseInt(F[1]);
                    return B.toUpperCase() + `

` + k + `

` + function(_, O) {
                        let B = _.split(`
`),
                            N = [],
                            k = Math.max(O - 6, 0),
                            F = Math.min(O + 6, B.length);
                        for (let _ = k; _ < F; _++) {
                            let k = _ + 1;
                            N.push(`${k===O?">":" "} ${k}: ${B[_]}`)
                        }
                        return N.join(`
`)
                    }(_.getShaderSource(O), N)
                }
            }

            function Mf(_) {
                return "" !== _
            }

            function wE(_, O) {
                let B = O.numSpotLightShadows + O.numSpotLightMaps - O.numSpotLightShadowsWithMaps;
                return _.replace(/NUM_DIR_LIGHTS/g, O.numDirLights).replace(/NUM_SPOT_LIGHTS/g, O.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, O.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, B).replace(/NUM_RECT_AREA_LIGHTS/g, O.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, O.numPointLights).replace(/NUM_HEMI_LIGHTS/g, O.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, O.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, O.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, O.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, O.numPointLightShadows)
            }

            function SE(_, O) {
                return _.replace(/NUM_CLIPPING_PLANES/g, O.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, O.numClippingPlanes - O.numClipIntersection)
            }
            var a8 = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Eb(_) {
                return _.replace(a8, jV)
            }

            function jV(_, O) {
                let B = aM[O];
                if (void 0 === B) throw Error("Can not resolve #include <" + O + ">");
                return Eb(B)
            }
            var a9 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function AE(_) {
                return _.replace(a9, qV)
            }

            function qV(_, O, B, N) {
                let k = "";
                for (let _ = parseInt(O); _ < parseInt(B); _++) k += N.replace(/\[\s*i\s*\]/g, "[ " + _ + " ]").replace(/UNROLLED_LOOP_INDEX/g, _);
                return k
            }

            function _E(_) {
                let O = "precision " + _.precision + ` float;
precision ` + _.precision + " int;";
                return "highp" === _.precision ? O += `
#define HIGH_PRECISION` : "mediump" === _.precision ? O += `
#define MEDIUM_PRECISION` : "lowp" === _.precision && (O += `
#define LOW_PRECISION`), O
            }

            function JV(_, O, B, N) {
                let k, F, U;
                let j, G, Y = _.getContext(),
                    Q = B.defines,
                    K = B.vertexShader,
                    $ = B.fragmentShader,
                    ee = (k = "SHADOWMAP_TYPE_BASIC", 1 === B.shadowMapType ? k = "SHADOWMAP_TYPE_PCF" : 2 === B.shadowMapType ? k = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === B.shadowMapType && (k = "SHADOWMAP_TYPE_VSM"), k),
                    et = function(_) {
                        let O = "ENVMAP_TYPE_CUBE";
                        if (_.envMap) switch (_.envMapMode) {
                            case 301:
                            case 302:
                                O = "ENVMAP_TYPE_CUBE";
                                break;
                            case 306:
                                O = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return O
                    }(B),
                    ei = (F = "ENVMAP_MODE_REFLECTION", B.envMap && 302 === B.envMapMode && (F = "ENVMAP_MODE_REFRACTION"), F),
                    er = function(_) {
                        let O = "ENVMAP_BLENDING_NONE";
                        if (_.envMap) switch (_.combine) {
                            case 0:
                                O = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                O = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                O = "ENVMAP_BLENDING_ADD"
                        }
                        return O
                    }(B),
                    ea = function(_) {
                        let O = _.envMapCubeUVHeight;
                        if (null === O) return null;
                        let B = Math.log2(O) - 2;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, B), 112)),
                            texelHeight: 1 / O,
                            maxMip: B
                        }
                    }(B),
                    en = B.isWebGL2 ? "" : [B.extensionDerivatives || B.envMapCubeUVHeight || B.bumpMap || B.tangentSpaceNormalMap || B.clearcoatNormalMap || B.flatShading || "physical" === B.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (B.extensionFragDepth || B.logarithmicDepthBuffer) && B.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", B.extensionDrawBuffers && B.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (B.extensionShaderTextureLOD || B.envMap || B.transmission) && B.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mf).join(`
`),
                    eo = function(_) {
                        let O = [];
                        for (let B in _) {
                            let N = _[B];
                            !1 !== N && O.push("#define " + B + " " + N)
                        }
                        return O.join(`
`)
                    }(Q),
                    el = Y.createProgram(),
                    eh, ec, eu = B.glslVersion ? "#version " + B.glslVersion + `
` : "";
                B.isRawShaderMaterial ? ((eh = [eo].filter(Mf).join(`
`)).length > 0 && (eh += `
`), (ec = [en, eo].filter(Mf).join(`
`)).length > 0 && (ec += `
`)) : (eh = [_E(B), "#define SHADER_NAME " + B.shaderName, eo, B.instancing ? "#define USE_INSTANCING" : "", B.instancingColor ? "#define USE_INSTANCING_COLOR" : "", B.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", B.useFog && B.fog ? "#define USE_FOG" : "", B.useFog && B.fogExp2 ? "#define FOG_EXP2" : "", B.map ? "#define USE_MAP" : "", B.envMap ? "#define USE_ENVMAP" : "", B.envMap ? "#define " + ei : "", B.lightMap ? "#define USE_LIGHTMAP" : "", B.aoMap ? "#define USE_AOMAP" : "", B.emissiveMap ? "#define USE_EMISSIVEMAP" : "", B.bumpMap ? "#define USE_BUMPMAP" : "", B.normalMap ? "#define USE_NORMALMAP" : "", B.normalMap && B.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", B.normalMap && B.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", B.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", B.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", B.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", B.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", B.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", B.displacementMap && B.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", B.specularMap ? "#define USE_SPECULARMAP" : "", B.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", B.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", B.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", B.metalnessMap ? "#define USE_METALNESSMAP" : "", B.alphaMap ? "#define USE_ALPHAMAP" : "", B.transmission ? "#define USE_TRANSMISSION" : "", B.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", B.thicknessMap ? "#define USE_THICKNESSMAP" : "", B.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", B.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", B.vertexTangents ? "#define USE_TANGENT" : "", B.vertexColors ? "#define USE_COLOR" : "", B.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", B.vertexUvs ? "#define USE_UV" : "", B.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", B.flatShading ? "#define FLAT_SHADED" : "", B.skinning ? "#define USE_SKINNING" : "", B.morphTargets ? "#define USE_MORPHTARGETS" : "", B.morphNormals && !1 === B.flatShading ? "#define USE_MORPHNORMALS" : "", B.morphColors && B.isWebGL2 ? "#define USE_MORPHCOLORS" : "", B.morphTargetsCount > 0 && B.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", B.morphTargetsCount > 0 && B.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + B.morphTextureStride : "", B.morphTargetsCount > 0 && B.isWebGL2 ? "#define MORPHTARGETS_COUNT " + B.morphTargetsCount : "", B.doubleSided ? "#define DOUBLE_SIDED" : "", B.flipSided ? "#define FLIP_SIDED" : "", B.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", B.shadowMapEnabled ? "#define " + ee : "", B.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", B.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", B.logarithmicDepthBuffer && B.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Mf).join(`
`), ec = [en, _E(B), "#define SHADER_NAME " + B.shaderName, eo, B.useFog && B.fog ? "#define USE_FOG" : "", B.useFog && B.fogExp2 ? "#define FOG_EXP2" : "", B.map ? "#define USE_MAP" : "", B.matcap ? "#define USE_MATCAP" : "", B.envMap ? "#define USE_ENVMAP" : "", B.envMap ? "#define " + et : "", B.envMap ? "#define " + ei : "", B.envMap ? "#define " + er : "", ea ? "#define CUBEUV_TEXEL_WIDTH " + ea.texelWidth : "", ea ? "#define CUBEUV_TEXEL_HEIGHT " + ea.texelHeight : "", ea ? "#define CUBEUV_MAX_MIP " + ea.maxMip + ".0" : "", B.lightMap ? "#define USE_LIGHTMAP" : "", B.aoMap ? "#define USE_AOMAP" : "", B.emissiveMap ? "#define USE_EMISSIVEMAP" : "", B.bumpMap ? "#define USE_BUMPMAP" : "", B.normalMap ? "#define USE_NORMALMAP" : "", B.normalMap && B.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", B.normalMap && B.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", B.clearcoat ? "#define USE_CLEARCOAT" : "", B.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", B.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", B.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", B.iridescence ? "#define USE_IRIDESCENCE" : "", B.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", B.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", B.specularMap ? "#define USE_SPECULARMAP" : "", B.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", B.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", B.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", B.metalnessMap ? "#define USE_METALNESSMAP" : "", B.alphaMap ? "#define USE_ALPHAMAP" : "", B.alphaTest ? "#define USE_ALPHATEST" : "", B.sheen ? "#define USE_SHEEN" : "", B.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", B.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", B.transmission ? "#define USE_TRANSMISSION" : "", B.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", B.thicknessMap ? "#define USE_THICKNESSMAP" : "", B.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", B.vertexTangents ? "#define USE_TANGENT" : "", B.vertexColors || B.instancingColor ? "#define USE_COLOR" : "", B.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", B.vertexUvs ? "#define USE_UV" : "", B.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", B.gradientMap ? "#define USE_GRADIENTMAP" : "", B.flatShading ? "#define FLAT_SHADED" : "", B.doubleSided ? "#define DOUBLE_SIDED" : "", B.flipSided ? "#define FLIP_SIDED" : "", B.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", B.shadowMapEnabled ? "#define " + ee : "", B.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", B.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", B.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", B.logarithmicDepthBuffer && B.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== B.toneMapping ? "#define TONE_MAPPING" : "", 0 !== B.toneMapping ? aM.tonemapping_pars_fragment : "", 0 !== B.toneMapping ? function(_, O) {
                    let B;
                    switch (O) {
                        case 1:
                            B = "Linear";
                            break;
                        case 2:
                            B = "Reinhard";
                            break;
                        case 3:
                            B = "OptimizedCineon";
                            break;
                        case 4:
                            B = "ACESFilmic";
                            break;
                        case 5:
                            B = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", O), B = "Linear"
                    }
                    return "vec3 " + _ + "( vec3 color ) { return " + B + "ToneMapping( color ); }"
                }("toneMapping", B.toneMapping) : "", B.dithering ? "#define DITHERING" : "", B.opaque ? "#define OPAQUE" : "", aM.encodings_pars_fragment, "vec4 linearToOutputTexel( vec4 value ) { return LinearTo" + (U = function(_) {
                    switch (_) {
                        case 3e3:
                            return ["Linear", "( value )"];
                        case 3001:
                            return ["sRGB", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", _), ["Linear", "( value )"]
                    }
                }(B.outputEncoding))[0] + U[1] + "; }", B.useDepthPacking ? "#define DEPTH_PACKING " + B.depthPacking : "", `
`].filter(Mf).join(`
`)), K = SE(K = wE(K = Eb(K), B), B), $ = SE($ = wE($ = Eb($), B), B), K = AE(K), $ = AE($), B.isWebGL2 && !0 !== B.isRawShaderMaterial && (eu = `#version 300 es
`, eh = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + eh, ec = ["#define varying in", B.glslVersion === iW ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", B.glslVersion === iW ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + ec);
                let ep = eu + eh + K,
                    ef = eu + ec + $,
                    em = xE(Y, 35633, ep),
                    eg = xE(Y, 35632, ef);
                if (Y.attachShader(el, em), Y.attachShader(el, eg), void 0 !== B.index0AttributeName ? Y.bindAttribLocation(el, 0, B.index0AttributeName) : !0 === B.morphTargets && Y.bindAttribLocation(el, 0, "position"), Y.linkProgram(el), _.debug.checkShaderErrors) {
                    let _ = Y.getProgramInfoLog(el).trim(),
                        O = Y.getShaderInfoLog(em).trim(),
                        B = Y.getShaderInfoLog(eg).trim(),
                        N = !0,
                        k = !0;
                    if (!1 === Y.getProgramParameter(el, 35714)) {
                        N = !1;
                        let O = bE(Y, em, "vertex"),
                            B = bE(Y, eg, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + Y.getError() + " - VALIDATE_STATUS " + Y.getProgramParameter(el, 35715) + `

Program Info Log: ` + _ + `
` + O + `
` + B)
                    } else "" !== _ ? console.warn("THREE.WebGLProgram: Program Info Log:", _) : ("" === O || "" === B) && (k = !1);
                    k && (this.diagnostics = {
                        runnable: N,
                        programLog: _,
                        vertexShader: {
                            log: O,
                            prefix: eh
                        },
                        fragmentShader: {
                            log: B,
                            prefix: ec
                        }
                    })
                }
                return Y.deleteShader(em), Y.deleteShader(eg), this.getUniforms = function() {
                    return void 0 === j && (j = new a5(Y, el)), j
                }, this.getAttributes = function() {
                    return void 0 === G && (G = function(_, O) {
                        let B = {},
                            N = _.getProgramParameter(O, 35721);
                        for (let k = 0; k < N; k++) {
                            let N = _.getActiveAttrib(O, k),
                                F = N.name,
                                U = 1;
                            35674 === N.type && (U = 2), 35675 === N.type && (U = 3), 35676 === N.type && (U = 4), B[F] = {
                                type: N.type,
                                location: _.getAttribLocation(O, F),
                                locationSize: U
                            }
                        }
                        return B
                    }(Y, el)), G
                }, this.destroy = function() {
                    N.releaseStatesOfProgram(this), Y.deleteProgram(el), this.program = void 0
                }, this.name = B.shaderName, this.id = a6++, this.cacheKey = O, this.usedTimes = 1, this.program = el, this.vertexShader = em, this.fragmentShader = eg, this
            }
            var ne = 0,
                ni = class {
                    constructor() {
                        this.shaderCache = new Map, this.materialCache = new Map
                    }
                    update(_) {
                        let O = _.vertexShader,
                            B = _.fragmentShader,
                            N = this._getShaderStage(O),
                            k = this._getShaderStage(B),
                            F = this._getShaderCacheForMaterial(_);
                        return !1 === F.has(N) && (F.add(N), N.usedTimes++), !1 === F.has(k) && (F.add(k), k.usedTimes++), this
                    }
                    remove(_) {
                        for (let O of this.materialCache.get(_)) O.usedTimes--, 0 === O.usedTimes && this.shaderCache.delete(O.code);
                        return this.materialCache.delete(_), this
                    }
                    getVertexShaderID(_) {
                        return this._getShaderStage(_.vertexShader).id
                    }
                    getFragmentShaderID(_) {
                        return this._getShaderStage(_.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear(), this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(_) {
                        let O = this.materialCache,
                            B = O.get(_);
                        return void 0 === B && (B = new Set, O.set(_, B)), B
                    }
                    _getShaderStage(_) {
                        let O = this.shaderCache,
                            B = O.get(_);
                        return void 0 === B && (B = new ns(_), O.set(_, B)), B
                    }
                },
                ns = class {
                    constructor(_) {
                        this.id = ne++, this.code = _, this.usedTimes = 0
                    }
                };

            function ez(_, O, B, N, k, F, U) {
                let j = new r7,
                    G = new ni,
                    Y = [],
                    Q = k.isWebGL2,
                    K = k.logarithmicDepthBuffer,
                    $ = k.vertexTextures,
                    ee = k.precision,
                    et = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                return {
                    getParameters: function(F, j, Y, ei, er) {
                        let ea, en, eo, el, eh = ei.fog,
                            ec = er.geometry,
                            eu = F.isMeshStandardMaterial ? ei.environment : null,
                            ep = (F.isMeshStandardMaterial ? B : O).get(F.envMap || eu),
                            ef = ep && 306 === ep.mapping ? ep.image.height : null,
                            em = et[F.type];
                        null !== F.precision && (ee = k.getMaxPrecision(F.precision)) !== F.precision && console.warn("THREE.WebGLProgram.getParameters:", F.precision, "not supported, using", ee, "instead.");
                        let eg = ec.morphAttributes.position || ec.morphAttributes.normal || ec.morphAttributes.color,
                            ev = void 0 !== eg ? eg.length : 0,
                            ex = 0;
                        if (void 0 !== ec.morphAttributes.position && (ex = 1), void 0 !== ec.morphAttributes.normal && (ex = 2), void 0 !== ec.morphAttributes.color && (ex = 3), em) {
                            let _ = aC[em];
                            ea = _.vertexShader, en = _.fragmentShader
                        } else ea = F.vertexShader, en = F.fragmentShader, G.update(F), eo = G.getVertexShaderID(F), el = G.getFragmentShaderID(F);
                        let eb = _.getRenderTarget(),
                            e_ = F.alphaTest > 0,
                            eS = F.clearcoat > 0,
                            eA = F.iridescence > 0;
                        return {
                            isWebGL2: Q,
                            shaderID: em,
                            shaderName: F.type,
                            vertexShader: ea,
                            fragmentShader: en,
                            defines: F.defines,
                            customVertexShaderID: eo,
                            customFragmentShaderID: el,
                            isRawShaderMaterial: !0 === F.isRawShaderMaterial,
                            glslVersion: F.glslVersion,
                            precision: ee,
                            instancing: !0 === er.isInstancedMesh,
                            instancingColor: !0 === er.isInstancedMesh && null !== er.instanceColor,
                            supportsVertexTextures: $,
                            outputEncoding: null === eb ? _.outputEncoding : !0 === eb.isXRRenderTarget ? eb.texture.encoding : 3e3,
                            map: !!F.map,
                            matcap: !!F.matcap,
                            envMap: !!ep,
                            envMapMode: ep && ep.mapping,
                            envMapCubeUVHeight: ef,
                            lightMap: !!F.lightMap,
                            aoMap: !!F.aoMap,
                            emissiveMap: !!F.emissiveMap,
                            bumpMap: !!F.bumpMap,
                            normalMap: !!F.normalMap,
                            objectSpaceNormalMap: 1 === F.normalMapType,
                            tangentSpaceNormalMap: 0 === F.normalMapType,
                            decodeVideoTexture: !!F.map && !0 === F.map.isVideoTexture && 3001 === F.map.encoding,
                            clearcoat: eS,
                            clearcoatMap: eS && !!F.clearcoatMap,
                            clearcoatRoughnessMap: eS && !!F.clearcoatRoughnessMap,
                            clearcoatNormalMap: eS && !!F.clearcoatNormalMap,
                            iridescence: eA,
                            iridescenceMap: eA && !!F.iridescenceMap,
                            iridescenceThicknessMap: eA && !!F.iridescenceThicknessMap,
                            displacementMap: !!F.displacementMap,
                            roughnessMap: !!F.roughnessMap,
                            metalnessMap: !!F.metalnessMap,
                            specularMap: !!F.specularMap,
                            specularIntensityMap: !!F.specularIntensityMap,
                            specularColorMap: !!F.specularColorMap,
                            opaque: !1 === F.transparent && 1 === F.blending,
                            alphaMap: !!F.alphaMap,
                            alphaTest: e_,
                            gradientMap: !!F.gradientMap,
                            sheen: F.sheen > 0,
                            sheenColorMap: !!F.sheenColorMap,
                            sheenRoughnessMap: !!F.sheenRoughnessMap,
                            transmission: F.transmission > 0,
                            transmissionMap: !!F.transmissionMap,
                            thicknessMap: !!F.thicknessMap,
                            combine: F.combine,
                            vertexTangents: !!F.normalMap && !!ec.attributes.tangent,
                            vertexColors: F.vertexColors,
                            vertexAlphas: !0 === F.vertexColors && !!ec.attributes.color && 4 === ec.attributes.color.itemSize,
                            vertexUvs: !!F.map || !!F.bumpMap || !!F.normalMap || !!F.specularMap || !!F.alphaMap || !!F.emissiveMap || !!F.roughnessMap || !!F.metalnessMap || !!F.clearcoatMap || !!F.clearcoatRoughnessMap || !!F.clearcoatNormalMap || !!F.iridescenceMap || !!F.iridescenceThicknessMap || !!F.displacementMap || !!F.transmissionMap || !!F.thicknessMap || !!F.specularIntensityMap || !!F.specularColorMap || !!F.sheenColorMap || !!F.sheenRoughnessMap,
                            uvsVertexOnly: !(F.map || F.bumpMap || F.normalMap || F.specularMap || F.alphaMap || F.emissiveMap || F.roughnessMap || F.metalnessMap || F.clearcoatNormalMap || F.iridescenceMap || F.iridescenceThicknessMap || F.transmission > 0 || F.transmissionMap || F.thicknessMap || F.specularIntensityMap || F.specularColorMap || F.sheen > 0 || F.sheenColorMap || F.sheenRoughnessMap) && !!F.displacementMap,
                            fog: !!eh,
                            useFog: !0 === F.fog,
                            fogExp2: eh && eh.isFogExp2,
                            flatShading: !!F.flatShading,
                            sizeAttenuation: F.sizeAttenuation,
                            logarithmicDepthBuffer: K,
                            skinning: !0 === er.isSkinnedMesh,
                            morphTargets: void 0 !== ec.morphAttributes.position,
                            morphNormals: void 0 !== ec.morphAttributes.normal,
                            morphColors: void 0 !== ec.morphAttributes.color,
                            morphTargetsCount: ev,
                            morphTextureStride: ex,
                            numDirLights: j.directional.length,
                            numPointLights: j.point.length,
                            numSpotLights: j.spot.length,
                            numSpotLightMaps: j.spotLightMap.length,
                            numRectAreaLights: j.rectArea.length,
                            numHemiLights: j.hemi.length,
                            numDirLightShadows: j.directionalShadowMap.length,
                            numPointLightShadows: j.pointShadowMap.length,
                            numSpotLightShadows: j.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: j.numSpotLightShadowsWithMaps,
                            numClippingPlanes: U.numPlanes,
                            numClipIntersection: U.numIntersection,
                            dithering: F.dithering,
                            shadowMapEnabled: _.shadowMap.enabled && Y.length > 0,
                            shadowMapType: _.shadowMap.type,
                            toneMapping: F.toneMapped ? _.toneMapping : 0,
                            physicallyCorrectLights: _.physicallyCorrectLights,
                            premultipliedAlpha: F.premultipliedAlpha,
                            doubleSided: 2 === F.side,
                            flipSided: 1 === F.side,
                            useDepthPacking: !!F.depthPacking,
                            depthPacking: F.depthPacking || 0,
                            index0AttributeName: F.index0AttributeName,
                            extensionDerivatives: F.extensions && F.extensions.derivatives,
                            extensionFragDepth: F.extensions && F.extensions.fragDepth,
                            extensionDrawBuffers: F.extensions && F.extensions.drawBuffers,
                            extensionShaderTextureLOD: F.extensions && F.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: Q || N.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: Q || N.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: Q || N.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: F.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(O) {
                        let B = [];
                        if (O.shaderID ? B.push(O.shaderID) : (B.push(O.customVertexShaderID), B.push(O.customFragmentShaderID)), void 0 !== O.defines)
                            for (let _ in O.defines) B.push(_), B.push(O.defines[_]);
                        return !1 === O.isRawShaderMaterial && (B.push(O.precision), B.push(O.outputEncoding), B.push(O.envMapMode), B.push(O.envMapCubeUVHeight), B.push(O.combine), B.push(O.vertexUvs), B.push(O.fogExp2), B.push(O.sizeAttenuation), B.push(O.morphTargetsCount), B.push(O.morphAttributeCount), B.push(O.numDirLights), B.push(O.numPointLights), B.push(O.numSpotLights), B.push(O.numSpotLightMaps), B.push(O.numHemiLights), B.push(O.numRectAreaLights), B.push(O.numDirLightShadows), B.push(O.numPointLightShadows), B.push(O.numSpotLightShadows), B.push(O.numSpotLightShadowsWithMaps), B.push(O.shadowMapType), B.push(O.toneMapping), B.push(O.numClippingPlanes), B.push(O.numClipIntersection), B.push(O.depthPacking), j.disableAll(), O.isWebGL2 && j.enable(0), O.supportsVertexTextures && j.enable(1), O.instancing && j.enable(2), O.instancingColor && j.enable(3), O.map && j.enable(4), O.matcap && j.enable(5), O.envMap && j.enable(6), O.lightMap && j.enable(7), O.aoMap && j.enable(8), O.emissiveMap && j.enable(9), O.bumpMap && j.enable(10), O.normalMap && j.enable(11), O.objectSpaceNormalMap && j.enable(12), O.tangentSpaceNormalMap && j.enable(13), O.clearcoat && j.enable(14), O.clearcoatMap && j.enable(15), O.clearcoatRoughnessMap && j.enable(16), O.clearcoatNormalMap && j.enable(17), O.iridescence && j.enable(18), O.iridescenceMap && j.enable(19), O.iridescenceThicknessMap && j.enable(20), O.displacementMap && j.enable(21), O.specularMap && j.enable(22), O.roughnessMap && j.enable(23), O.metalnessMap && j.enable(24), O.gradientMap && j.enable(25), O.alphaMap && j.enable(26), O.alphaTest && j.enable(27), O.vertexColors && j.enable(28), O.vertexAlphas && j.enable(29), O.vertexUvs && j.enable(30), O.vertexTangents && j.enable(31), O.uvsVertexOnly && j.enable(32), B.push(j.mask), j.disableAll(), O.fog && j.enable(0), O.useFog && j.enable(1), O.flatShading && j.enable(2), O.logarithmicDepthBuffer && j.enable(3), O.skinning && j.enable(4), O.morphTargets && j.enable(5), O.morphNormals && j.enable(6), O.morphColors && j.enable(7), O.premultipliedAlpha && j.enable(8), O.shadowMapEnabled && j.enable(9), O.physicallyCorrectLights && j.enable(10), O.doubleSided && j.enable(11), O.flipSided && j.enable(12), O.useDepthPacking && j.enable(13), O.dithering && j.enable(14), O.specularIntensityMap && j.enable(15), O.specularColorMap && j.enable(16), O.transmission && j.enable(17), O.transmissionMap && j.enable(18), O.thicknessMap && j.enable(19), O.sheen && j.enable(20), O.sheenColorMap && j.enable(21), O.sheenRoughnessMap && j.enable(22), O.decodeVideoTexture && j.enable(23), O.opaque && j.enable(24), B.push(j.mask), B.push(_.outputEncoding)), B.push(O.customProgramCacheKey), B.join()
                    },
                    getUniforms: function(_) {
                        let O = et[_.type],
                            B;
                        if (O) {
                            let _ = aC[O];
                            B = ar.clone(_.uniforms)
                        } else B = _.uniforms;
                        return B
                    },
                    acquireProgram: function(O, B) {
                        let N;
                        for (let _ = 0, O = Y.length; _ < O; _++) {
                            let O = Y[_];
                            if (O.cacheKey === B) {
                                N = O, ++N.usedTimes;
                                break
                            }
                        }
                        return void 0 === N && (N = new JV(_, B, O, F), Y.push(N)), N
                    },
                    releaseProgram: function(_) {
                        if (0 == --_.usedTimes) {
                            let O = Y.indexOf(_);
                            Y[O] = Y[Y.length - 1], Y.pop(), _.destroy()
                        }
                    },
                    releaseShaderCache: function(_) {
                        G.remove(_)
                    },
                    programs: Y,
                    dispose: function() {
                        G.dispose()
                    }
                }
            }

            function tz() {
                let _ = new WeakMap;
                return {
                    get: function(O) {
                        let B = _.get(O);
                        return void 0 === B && (B = {}, _.set(O, B)), B
                    },
                    remove: function(O) {
                        _.delete(O)
                    },
                    update: function(O, B, N) {
                        _.get(O)[B] = N
                    },
                    dispose: function() {
                        _ = new WeakMap
                    }
                }
            }

            function rz(_, O) {
                return _.groupOrder !== O.groupOrder ? _.groupOrder - O.groupOrder : _.renderOrder !== O.renderOrder ? _.renderOrder - O.renderOrder : _.material.id !== O.material.id ? _.material.id - O.material.id : _.z !== O.z ? _.z - O.z : _.id - O.id
            }

            function EE(_, O) {
                return _.groupOrder !== O.groupOrder ? _.groupOrder - O.groupOrder : _.renderOrder !== O.renderOrder ? _.renderOrder - O.renderOrder : _.z !== O.z ? O.z - _.z : _.id - O.id
            }

            function ME() {
                let _ = [],
                    O = 0,
                    B = [],
                    N = [],
                    k = [];

                function o(B, N, k, F, U, j) {
                    let G = _[O];
                    return void 0 === G ? (G = {
                        id: B.id,
                        object: B,
                        geometry: N,
                        material: k,
                        groupOrder: F,
                        renderOrder: B.renderOrder,
                        z: U,
                        group: j
                    }, _[O] = G) : (G.id = B.id, G.object = B, G.geometry = N, G.material = k, G.groupOrder = F, G.renderOrder = B.renderOrder, G.z = U, G.group = j), O++, G
                }
                return {
                    opaque: B,
                    transmissive: N,
                    transparent: k,
                    init: function() {
                        O = 0, B.length = 0, N.length = 0, k.length = 0
                    },
                    push: function(_, O, F, U, j, G) {
                        let Y = o(_, O, F, U, j, G);
                        F.transmission > 0 ? N.push(Y) : !0 === F.transparent ? k.push(Y) : B.push(Y)
                    },
                    unshift: function(_, O, F, U, j, G) {
                        let Y = o(_, O, F, U, j, G);
                        F.transmission > 0 ? N.unshift(Y) : !0 === F.transparent ? k.unshift(Y) : B.unshift(Y)
                    },
                    finish: function() {
                        for (let B = O, N = _.length; B < N; B++) {
                            let O = _[B];
                            if (null === O.id) break;
                            O.id = null, O.object = null, O.geometry = null, O.material = null, O.group = null
                        }
                    },
                    sort: function(_, O) {
                        B.length > 1 && B.sort(_ || rz), N.length > 1 && N.sort(O || EE), k.length > 1 && k.sort(O || EE)
                    }
                }
            }

            function nz() {
                let _ = new WeakMap;
                return {
                    get: function(O, B) {
                        let N = _.get(O),
                            k;
                        return void 0 === N ? (k = new ME, _.set(O, [k])) : B >= N.length ? (k = new ME, N.push(k)) : k = N[B], k
                    },
                    dispose: function() {
                        _ = new WeakMap
                    }
                }
            }

            function iz() {
                let _ = {};
                return {
                    get: function(O) {
                        let B;
                        if (void 0 !== _[O.id]) return _[O.id];
                        switch (O.type) {
                            case "DirectionalLight":
                                B = {
                                    direction: new rv,
                                    color: new re
                                };
                                break;
                            case "SpotLight":
                                B = {
                                    position: new rv,
                                    direction: new rv,
                                    color: new re,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                B = {
                                    position: new rv,
                                    color: new re,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                B = {
                                    direction: new rv,
                                    skyColor: new re,
                                    groundColor: new re
                                };
                                break;
                            case "RectAreaLight":
                                B = {
                                    color: new re,
                                    position: new rv,
                                    halfWidth: new rv,
                                    halfHeight: new rv
                                }
                        }
                        return _[O.id] = B, B
                    }
                }
            }
            var nn = 0;

            function az(_, O) {
                return (O.castShadow ? 2 : 0) - (_.castShadow ? 2 : 0) + (O.map ? 1 : 0) - (_.map ? 1 : 0)
            }

            function lz(_, O) {
                let B;
                let N = new iz,
                    k = (B = {}, {
                        get: function(_) {
                            let O;
                            if (void 0 !== B[_.id]) return B[_.id];
                            switch (_.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    O = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new iJ
                                    };
                                    break;
                                case "PointLight":
                                    O = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new iJ,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return B[_.id] = O, O
                        }
                    }),
                    F = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0
                    };
                for (let _ = 0; _ < 9; _++) F.probe.push(new rv);
                let U = new rv,
                    j = new rJ,
                    G = new rJ;
                return {
                    setup: function(B, U) {
                        let j = 0,
                            G = 0,
                            Y = 0;
                        for (let _ = 0; _ < 9; _++) F.probe[_].set(0, 0, 0);
                        let Q = 0,
                            K = 0,
                            $ = 0,
                            ee = 0,
                            et = 0,
                            ei = 0,
                            er = 0,
                            ea = 0,
                            en = 0,
                            eo = 0;
                        B.sort(az);
                        let el = !0 !== U ? Math.PI : 1;
                        for (let _ = 0, O = B.length; _ < O; _++) {
                            let O = B[_],
                                U = O.color,
                                eh = O.intensity,
                                ec = O.distance,
                                eu = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
                            if (O.isAmbientLight) j += U.r * eh * el, G += U.g * eh * el, Y += U.b * eh * el;
                            else if (O.isLightProbe)
                                for (let _ = 0; _ < 9; _++) F.probe[_].addScaledVector(O.sh.coefficients[_], eh);
                            else if (O.isDirectionalLight) {
                                let _ = N.get(O);
                                if (_.color.copy(O.color).multiplyScalar(O.intensity * el), O.castShadow) {
                                    let _ = O.shadow,
                                        B = k.get(O);
                                    B.shadowBias = _.bias, B.shadowNormalBias = _.normalBias, B.shadowRadius = _.radius, B.shadowMapSize = _.mapSize, F.directionalShadow[Q] = B, F.directionalShadowMap[Q] = eu, F.directionalShadowMatrix[Q] = O.shadow.matrix, ei++
                                }
                                F.directional[Q] = _, Q++
                            } else if (O.isSpotLight) {
                                let _ = N.get(O);
                                _.position.setFromMatrixPosition(O.matrixWorld), _.color.copy(U).multiplyScalar(eh * el), _.distance = ec, _.coneCos = Math.cos(O.angle), _.penumbraCos = Math.cos(O.angle * (1 - O.penumbra)), _.decay = O.decay, F.spot[$] = _;
                                let B = O.shadow;
                                if (O.map && (F.spotLightMap[en] = O.map, en++, B.updateMatrices(O), O.castShadow && eo++), F.spotLightMatrix[$] = B.matrix, O.castShadow) {
                                    let _ = k.get(O);
                                    _.shadowBias = B.bias, _.shadowNormalBias = B.normalBias, _.shadowRadius = B.radius, _.shadowMapSize = B.mapSize, F.spotShadow[$] = _, F.spotShadowMap[$] = eu, ea++
                                }
                                $++
                            } else if (O.isRectAreaLight) {
                                let _ = N.get(O);
                                _.color.copy(U).multiplyScalar(eh), _.halfWidth.set(.5 * O.width, 0, 0), _.halfHeight.set(0, .5 * O.height, 0), F.rectArea[ee] = _, ee++
                            } else if (O.isPointLight) {
                                let _ = N.get(O);
                                if (_.color.copy(O.color).multiplyScalar(O.intensity * el), _.distance = O.distance, _.decay = O.decay, O.castShadow) {
                                    let _ = O.shadow,
                                        B = k.get(O);
                                    B.shadowBias = _.bias, B.shadowNormalBias = _.normalBias, B.shadowRadius = _.radius, B.shadowMapSize = _.mapSize, B.shadowCameraNear = _.camera.near, B.shadowCameraFar = _.camera.far, F.pointShadow[K] = B, F.pointShadowMap[K] = eu, F.pointShadowMatrix[K] = O.shadow.matrix, er++
                                }
                                F.point[K] = _, K++
                            } else if (O.isHemisphereLight) {
                                let _ = N.get(O);
                                _.skyColor.copy(O.color).multiplyScalar(eh * el), _.groundColor.copy(O.groundColor).multiplyScalar(eh * el), F.hemi[et] = _, et++
                            }
                        }
                        ee > 0 && (O.isWebGL2 || !0 === _.has("OES_texture_float_linear") ? (F.rectAreaLTC1 = aE.LTC_FLOAT_1, F.rectAreaLTC2 = aE.LTC_FLOAT_2) : !0 === _.has("OES_texture_half_float_linear") ? (F.rectAreaLTC1 = aE.LTC_HALF_1, F.rectAreaLTC2 = aE.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), F.ambient[0] = j, F.ambient[1] = G, F.ambient[2] = Y;
                        let eh = F.hash;
                        (eh.directionalLength !== Q || eh.pointLength !== K || eh.spotLength !== $ || eh.rectAreaLength !== ee || eh.hemiLength !== et || eh.numDirectionalShadows !== ei || eh.numPointShadows !== er || eh.numSpotShadows !== ea || eh.numSpotMaps !== en) && (F.directional.length = Q, F.spot.length = $, F.rectArea.length = ee, F.point.length = K, F.hemi.length = et, F.directionalShadow.length = ei, F.directionalShadowMap.length = ei, F.pointShadow.length = er, F.pointShadowMap.length = er, F.spotShadow.length = ea, F.spotShadowMap.length = ea, F.directionalShadowMatrix.length = ei, F.pointShadowMatrix.length = er, F.spotLightMatrix.length = ea + en - eo, F.spotLightMap.length = en, F.numSpotLightShadowsWithMaps = eo, eh.directionalLength = Q, eh.pointLength = K, eh.spotLength = $, eh.rectAreaLength = ee, eh.hemiLength = et, eh.numDirectionalShadows = ei, eh.numPointShadows = er, eh.numSpotShadows = ea, eh.numSpotMaps = en, F.version = nn++)
                    },
                    setupView: function(_, O) {
                        let B = 0,
                            N = 0,
                            k = 0,
                            Y = 0,
                            Q = 0,
                            K = O.matrixWorldInverse;
                        for (let O = 0, $ = _.length; O < $; O++) {
                            let $ = _[O];
                            if ($.isDirectionalLight) {
                                let _ = F.directional[B];
                                _.direction.setFromMatrixPosition($.matrixWorld), U.setFromMatrixPosition($.target.matrixWorld), _.direction.sub(U), _.direction.transformDirection(K), B++
                            } else if ($.isSpotLight) {
                                let _ = F.spot[k];
                                _.position.setFromMatrixPosition($.matrixWorld), _.position.applyMatrix4(K), _.direction.setFromMatrixPosition($.matrixWorld), U.setFromMatrixPosition($.target.matrixWorld), _.direction.sub(U), _.direction.transformDirection(K), k++
                            } else if ($.isRectAreaLight) {
                                let _ = F.rectArea[Y];
                                _.position.setFromMatrixPosition($.matrixWorld), _.position.applyMatrix4(K), G.identity(), j.copy($.matrixWorld), j.premultiply(K), G.extractRotation(j), _.halfWidth.set(.5 * $.width, 0, 0), _.halfHeight.set(0, .5 * $.height, 0), _.halfWidth.applyMatrix4(G), _.halfHeight.applyMatrix4(G), Y++
                            } else if ($.isPointLight) {
                                let _ = F.point[N];
                                _.position.setFromMatrixPosition($.matrixWorld), _.position.applyMatrix4(K), N++
                            } else if ($.isHemisphereLight) {
                                let _ = F.hemi[Q];
                                _.direction.setFromMatrixPosition($.matrixWorld), _.direction.transformDirection(K), Q++
                            }
                        }
                    },
                    state: F
                }
            }

            function TE(_, O) {
                let B = new lz(_, O),
                    N = [],
                    k = [];
                return {
                    init: function() {
                        N.length = 0, k.length = 0
                    },
                    state: {
                        lightsArray: N,
                        shadowsArray: k,
                        lights: B
                    },
                    setupLights: function(_) {
                        B.setup(N, _)
                    },
                    setupLightsView: function(_) {
                        B.setupView(N, _)
                    },
                    pushLight: function(_) {
                        N.push(_)
                    },
                    pushShadow: function(_) {
                        k.push(_)
                    }
                }
            }

            function cz(_, O) {
                let B = new WeakMap;
                return {
                    get: function(N, k = 0) {
                        let F = B.get(N),
                            U;
                        return void 0 === F ? (U = new TE(_, O), B.set(N, [U])) : k >= F.length ? (U = new TE(_, O), F.push(U)) : U = F[k], U
                    },
                    dispose: function() {
                        B = new WeakMap
                    }
                }
            }
            var no = class extends sB {
                    constructor(_) {
                        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(_)
                    }
                    copy(_) {
                        return super.copy(_), this.depthPacking = _.depthPacking, this.map = _.map, this.alphaMap = _.alphaMap, this.displacementMap = _.displacementMap, this.displacementScale = _.displacementScale, this.displacementBias = _.displacementBias, this.wireframe = _.wireframe, this.wireframeLinewidth = _.wireframeLinewidth, this
                    }
                },
                nl = class extends sB {
                    constructor(_) {
                        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new rv, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(_)
                    }
                    copy(_) {
                        return super.copy(_), this.referencePosition.copy(_.referencePosition), this.nearDistance = _.nearDistance, this.farDistance = _.farDistance, this.map = _.map, this.alphaMap = _.alphaMap, this.displacementMap = _.displacementMap, this.displacementScale = _.displacementScale, this.displacementBias = _.displacementBias, this
                    }
                },
                nc = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
                nd = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

            function dz(_, O, B) {
                let N = new aw,
                    k = new iJ,
                    F = new iJ,
                    U = new rl,
                    j = new no({
                        depthPacking: 3201
                    }),
                    G = new nl,
                    Y = {},
                    Q = B.maxTextureSize,
                    K = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    $ = new an({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new iJ
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: nc,
                        fragmentShader: nd
                    }),
                    ee = $.clone();
                ee.defines.HORIZONTAL_PASS = 1;
                let et = new sK;
                et.setAttribute("position", new sF(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                let ei = new at(et, $),
                    er = this;

                function v(O, B, N, k, F, U) {
                    let Q = null,
                        $ = !0 === N.isPointLight ? O.customDistanceMaterial : O.customDepthMaterial;
                    if (void 0 !== $) Q = $;
                    else if (Q = !0 === N.isPointLight ? G : j, _.localClippingEnabled && !0 === B.clipShadows && Array.isArray(B.clippingPlanes) && 0 !== B.clippingPlanes.length || B.displacementMap && 0 !== B.displacementScale || B.alphaMap && B.alphaTest > 0 || B.map && B.alphaTest > 0) {
                        let _ = Q.uuid,
                            O = B.uuid,
                            N = Y[_];
                        void 0 === N && (N = {}, Y[_] = N);
                        let k = N[O];
                        void 0 === k && (k = Q.clone(), N[O] = k), Q = k
                    }
                    return Q.visible = B.visible, Q.wireframe = B.wireframe, 3 === U ? Q.side = null !== B.shadowSide ? B.shadowSide : B.side : Q.side = null !== B.shadowSide ? B.shadowSide : K[B.side], Q.alphaMap = B.alphaMap, Q.alphaTest = B.alphaTest, Q.map = B.map, Q.clipShadows = B.clipShadows, Q.clippingPlanes = B.clippingPlanes, Q.clipIntersection = B.clipIntersection, Q.displacementMap = B.displacementMap, Q.displacementScale = B.displacementScale, Q.displacementBias = B.displacementBias, Q.wireframeLinewidth = B.wireframeLinewidth, Q.linewidth = B.linewidth, !0 === N.isPointLight && !0 === Q.isMeshDistanceMaterial && (Q.referencePosition.setFromMatrixPosition(N.matrixWorld), Q.nearDistance = k, Q.farDistance = F), Q
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(B, j, G) {
                    if (!1 === er.enabled || !1 === er.autoUpdate && !1 === er.needsUpdate || 0 === B.length) return;
                    let Y = _.getRenderTarget(),
                        K = _.getActiveCubeFace(),
                        et = _.getActiveMipmapLevel(),
                        ea = _.state;
                    ea.setBlending(0), ea.buffers.color.setClear(1, 1, 1, 1), ea.buffers.depth.setTest(!0), ea.setScissorTest(!1);
                    for (let Y = 0, K = B.length; Y < K; Y++) {
                        let K = B[Y],
                            et = K.shadow;
                        if (void 0 === et) {
                            console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
                            continue
                        }
                        if (!1 === et.autoUpdate && !1 === et.needsUpdate) continue;
                        k.copy(et.mapSize);
                        let er = et.getFrameExtents();
                        if (k.multiply(er), F.copy(et.mapSize), (k.x > Q || k.y > Q) && (k.x > Q && (F.x = Math.floor(Q / er.x), k.x = F.x * er.x, et.mapSize.x = F.x), k.y > Q && (F.y = Math.floor(Q / er.y), k.y = F.y * er.y, et.mapSize.y = F.y)), null === et.map) {
                            let _ = 3 !== this.type ? {
                                minFilter: 1003,
                                magFilter: 1003
                            } : {};
                            et.map = new rh(k.x, k.y, _), et.map.texture.name = K.name + ".shadowMap", et.camera.updateProjectionMatrix()
                        }
                        _.setRenderTarget(et.map), _.clear();
                        let en = et.getViewportCount();
                        for (let B = 0; B < en; B++) {
                            let k = et.getViewport(B);
                            U.set(F.x * k.x, F.y * k.y, F.x * k.z, F.y * k.w), ea.viewport(U), et.updateMatrices(K, B), N = et.getFrustum(),
                                function x(B, k, F, U, j) {
                                    if (!1 === B.visible) return;
                                    if (B.layers.test(k.layers) && (B.isMesh || B.isLine || B.isPoints) && (B.castShadow || B.receiveShadow && 3 === j) && (!B.frustumCulled || N.intersectsObject(B))) {
                                        B.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, B.matrixWorld);
                                        let N = O.update(B),
                                            k = B.material;
                                        if (Array.isArray(k)) {
                                            let O = N.groups;
                                            for (let G = 0, Y = O.length; G < Y; G++) {
                                                let Y = O[G],
                                                    Q = k[Y.materialIndex];
                                                if (Q && Q.visible) {
                                                    let O = v(B, Q, U, F.near, F.far, j);
                                                    _.renderBufferDirect(F, null, N, O, B, Y)
                                                }
                                            }
                                        } else if (k.visible) {
                                            let O = v(B, k, U, F.near, F.far, j);
                                            _.renderBufferDirect(F, null, N, O, B, null)
                                        }
                                    }
                                    let G = B.children;
                                    for (let _ = 0, O = G.length; _ < O; _++) x(G[_], k, F, U, j)
                                }(j, G, et.camera, K, this.type)
                        }!0 !== et.isPointLightShadow && 3 === this.type && function(B, N) {
                            let F = O.update(ei);
                            $.defines.VSM_SAMPLES !== B.blurSamples && ($.defines.VSM_SAMPLES = B.blurSamples, ee.defines.VSM_SAMPLES = B.blurSamples, $.needsUpdate = !0, ee.needsUpdate = !0), null === B.mapPass && (B.mapPass = new rh(k.x, k.y)), $.uniforms.shadow_pass.value = B.map.texture, $.uniforms.resolution.value = B.mapSize, $.uniforms.radius.value = B.radius, _.setRenderTarget(B.mapPass), _.clear(), _.renderBufferDirect(N, null, F, $, ei, null), ee.uniforms.shadow_pass.value = B.mapPass.texture, ee.uniforms.resolution.value = B.mapSize, ee.uniforms.radius.value = B.radius, _.setRenderTarget(B.map), _.clear(), _.renderBufferDirect(N, null, F, ee, ei, null)
                        }(et, G), et.needsUpdate = !1
                    }
                    er.needsUpdate = !1, _.setRenderTarget(Y, K, et)
                }
            }

            function fz(_, O, B) {
                let N = B.isWebGL2,
                    k = new function() {
                        let O = !1,
                            B = new rl,
                            N = null,
                            k = new rl(0, 0, 0, 0);
                        return {
                            setMask: function(B) {
                                N === B || O || (_.colorMask(B, B, B, B), N = B)
                            },
                            setLocked: function(_) {
                                O = _
                            },
                            setClear: function(O, N, F, U, j) {
                                !0 === j && (O *= U, N *= U, F *= U), B.set(O, N, F, U), !1 === k.equals(B) && (_.clearColor(O, N, F, U), k.copy(B))
                            },
                            reset: function() {
                                O = !1, N = null, k.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    F = new function() {
                        let O = !1,
                            B = null,
                            N = null,
                            k = null;
                        return {
                            setTest: function(_) {
                                _ ? J(2929) : Z(2929)
                            },
                            setMask: function(N) {
                                B === N || O || (_.depthMask(N), B = N)
                            },
                            setFunc: function(O) {
                                if (N !== O) {
                                    switch (O) {
                                        case 0:
                                            _.depthFunc(512);
                                            break;
                                        case 1:
                                            _.depthFunc(519);
                                            break;
                                        case 2:
                                            _.depthFunc(513);
                                            break;
                                        case 3:
                                        default:
                                            _.depthFunc(515);
                                            break;
                                        case 4:
                                            _.depthFunc(514);
                                            break;
                                        case 5:
                                            _.depthFunc(518);
                                            break;
                                        case 6:
                                            _.depthFunc(516);
                                            break;
                                        case 7:
                                            _.depthFunc(517)
                                    }
                                    N = O
                                }
                            },
                            setLocked: function(_) {
                                O = _
                            },
                            setClear: function(O) {
                                k !== O && (_.clearDepth(O), k = O)
                            },
                            reset: function() {
                                O = !1, B = null, N = null, k = null
                            }
                        }
                    },
                    U = new function() {
                        let O = !1,
                            B = null,
                            N = null,
                            k = null,
                            F = null,
                            U = null,
                            j = null,
                            G = null,
                            Y = null;
                        return {
                            setTest: function(_) {
                                O || (_ ? J(2960) : Z(2960))
                            },
                            setMask: function(N) {
                                B === N || O || (_.stencilMask(N), B = N)
                            },
                            setFunc: function(O, B, U) {
                                (N !== O || k !== B || F !== U) && (_.stencilFunc(O, B, U), N = O, k = B, F = U)
                            },
                            setOp: function(O, B, N) {
                                (U !== O || j !== B || G !== N) && (_.stencilOp(O, B, N), U = O, j = B, G = N)
                            },
                            setLocked: function(_) {
                                O = _
                            },
                            setClear: function(O) {
                                Y !== O && (_.clearStencil(O), Y = O)
                            },
                            reset: function() {
                                O = !1, B = null, N = null, k = null, F = null, U = null, j = null, G = null, Y = null
                            }
                        }
                    },
                    j = new WeakMap,
                    G = new WeakMap,
                    Y = {},
                    Q = {},
                    K = new WeakMap,
                    $ = [],
                    ee = null,
                    et = !1,
                    ei = null,
                    er = null,
                    ea = null,
                    en = null,
                    eo = null,
                    el = null,
                    eh = null,
                    ec = !1,
                    eu = null,
                    ep = null,
                    ef = null,
                    em = null,
                    eg = null,
                    ev = _.getParameter(35661),
                    ex = !1,
                    eb = _.getParameter(7938); - 1 !== eb.indexOf("WebGL") ? ex = parseFloat(/^WebGL (\d)/.exec(eb)[1]) >= 1 : -1 !== eb.indexOf("OpenGL ES") && (ex = parseFloat(/^OpenGL ES (\d)/.exec(eb)[1]) >= 2);
                let e_ = null,
                    eS = {},
                    eA = _.getParameter(3088),
                    eM = _.getParameter(2978),
                    eE = new rl().fromArray(eA),
                    eC = new rl().fromArray(eM);

                function q(O, B, N) {
                    let k = new Uint8Array(4),
                        F = _.createTexture();
                    _.bindTexture(O, F), _.texParameteri(O, 10241, 9728), _.texParameteri(O, 10240, 9728);
                    for (let O = 0; O < N; O++) _.texImage2D(B + O, 0, 6408, 1, 1, 0, 6408, 5121, k);
                    return F
                }
                let eT = {};

                function J(O) {
                    !0 !== Y[O] && (_.enable(O), Y[O] = !0)
                }

                function Z(O) {
                    !1 !== Y[O] && (_.disable(O), Y[O] = !1)
                }
                eT[3553] = q(3553, 3553, 1), eT[34067] = q(34067, 34069, 6), k.setClear(0, 0, 0, 1), F.setClear(1), U.setClear(0), J(2929), F.setFunc(3), Oe(!1), Ie(1), J(2884), _e(0);
                let eD = {
                    100: 32774,
                    101: 32778,
                    102: 32779
                };
                if (N) eD[103] = 32775, eD[104] = 32776;
                else {
                    let _ = O.get("EXT_blend_minmax");
                    null !== _ && (eD[103] = _.MIN_EXT, eD[104] = _.MAX_EXT)
                }
                let eP = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773
                };

                function _e(O, B, N, k, F, U, j, G) {
                    if (0 === O) {
                        !0 === et && (Z(3042), et = !1);
                        return
                    }
                    if (!1 === et && (J(3042), et = !0), 5 !== O) {
                        if (O !== ei || G !== ec) {
                            if ((100 !== er || 100 !== eo) && (_.blendEquation(32774), er = 100, eo = 100), G) switch (O) {
                                case 1:
                                    _.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case 2:
                                    _.blendFunc(1, 1);
                                    break;
                                case 3:
                                    _.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case 4:
                                    _.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", O)
                            } else switch (O) {
                                case 1:
                                    _.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case 2:
                                    _.blendFunc(770, 1);
                                    break;
                                case 3:
                                    _.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case 4:
                                    _.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", O)
                            }
                            ea = null, en = null, el = null, eh = null, ei = O, ec = G
                        }
                        return
                    }
                    F = F || B, U = U || N, j = j || k, (B !== er || F !== eo) && (_.blendEquationSeparate(eD[B], eD[F]), er = B, eo = F), (N !== ea || k !== en || U !== el || j !== eh) && (_.blendFuncSeparate(eP[N], eP[k], eP[U], eP[j]), ea = N, en = k, el = U, eh = j), ei = O, ec = !1
                }

                function Oe(O) {
                    eu !== O && (O ? _.frontFace(2304) : _.frontFace(2305), eu = O)
                }

                function Ie(O) {
                    0 !== O ? (J(2884), O !== ep && (1 === O ? _.cullFace(1029) : 2 === O ? _.cullFace(1028) : _.cullFace(1032))) : Z(2884), ep = O
                }

                function Me(O, B, N) {
                    O ? (J(32823), (em !== B || eg !== N) && (_.polygonOffset(B, N), em = B, eg = N)) : Z(32823)
                }
                return {
                    buffers: {
                        color: k,
                        depth: F,
                        stencil: U
                    },
                    enable: J,
                    disable: Z,
                    bindFramebuffer: function(O, B) {
                        return Q[O] !== B && (_.bindFramebuffer(O, B), Q[O] = B, N && (36009 === O && (Q[36160] = B), 36160 === O && (Q[36009] = B)), !0)
                    },
                    drawBuffers: function(N, k) {
                        let F = $,
                            U = !1;
                        if (N) {
                            if (void 0 === (F = K.get(k)) && (F = [], K.set(k, F)), N.isWebGLMultipleRenderTargets) {
                                let _ = N.texture;
                                if (F.length !== _.length || 36064 !== F[0]) {
                                    for (let O = 0, B = _.length; O < B; O++) F[O] = 36064 + O;
                                    F.length = _.length, U = !0
                                }
                            } else 36064 !== F[0] && (F[0] = 36064, U = !0)
                        } else 1029 !== F[0] && (F[0] = 1029, U = !0);
                        U && (B.isWebGL2 ? _.drawBuffers(F) : O.get("WEBGL_draw_buffers").drawBuffersWEBGL(F))
                    },
                    useProgram: function(O) {
                        return ee !== O && (_.useProgram(O), ee = O, !0)
                    },
                    setBlending: _e,
                    setMaterial: function(_, O) {
                        2 === _.side ? Z(2884) : J(2884);
                        let B = 1 === _.side;
                        O && (B = !B), Oe(B), 1 === _.blending && !1 === _.transparent ? _e(0) : _e(_.blending, _.blendEquation, _.blendSrc, _.blendDst, _.blendEquationAlpha, _.blendSrcAlpha, _.blendDstAlpha, _.premultipliedAlpha), F.setFunc(_.depthFunc), F.setTest(_.depthTest), F.setMask(_.depthWrite), k.setMask(_.colorWrite);
                        let N = _.stencilWrite;
                        U.setTest(N), N && (U.setMask(_.stencilWriteMask), U.setFunc(_.stencilFunc, _.stencilRef, _.stencilFuncMask), U.setOp(_.stencilFail, _.stencilZFail, _.stencilZPass)), Me(_.polygonOffset, _.polygonOffsetFactor, _.polygonOffsetUnits), !0 === _.alphaToCoverage ? J(32926) : Z(32926)
                    },
                    setFlipSided: Oe,
                    setCullFace: Ie,
                    setLineWidth: function(O) {
                        O !== ef && (ex && _.lineWidth(O), ef = O)
                    },
                    setPolygonOffset: Me,
                    setScissorTest: function(_) {
                        _ ? J(3089) : Z(3089)
                    },
                    activeTexture: function(O) {
                        void 0 === O && (O = 33984 + ev - 1), e_ !== O && (_.activeTexture(O), e_ = O)
                    },
                    bindTexture: function(O, B, N) {
                        void 0 === N && (N = null === e_ ? 33984 + ev - 1 : e_);
                        let k = eS[N];
                        void 0 === k && (k = {
                            type: void 0,
                            texture: void 0
                        }, eS[N] = k), (k.type !== O || k.texture !== B) && (e_ !== N && (_.activeTexture(N), e_ = N), _.bindTexture(O, B || eT[O]), k.type = O, k.texture = B)
                    },
                    unbindTexture: function() {
                        let O = eS[e_];
                        void 0 !== O && void 0 !== O.type && (_.bindTexture(O.type, null), O.type = void 0, O.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            _.compressedTexImage2D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    compressedTexImage3D: function() {
                        try {
                            _.compressedTexImage3D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    texImage2D: function() {
                        try {
                            _.texImage2D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    texImage3D: function() {
                        try {
                            _.texImage3D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    updateUBOMapping: function(O, B) {
                        let N = G.get(B);
                        void 0 === N && (N = new WeakMap, G.set(B, N));
                        let k = N.get(O);
                        void 0 === k && (k = _.getUniformBlockIndex(B, O.name), N.set(O, k))
                    },
                    uniformBlockBinding: function(O, B) {
                        let N = G.get(B).get(O);
                        j.get(B) !== N && (_.uniformBlockBinding(B, N, O.__bindingPointIndex), j.set(B, N))
                    },
                    texStorage2D: function() {
                        try {
                            _.texStorage2D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            _.texStorage3D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            _.texSubImage2D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            _.texSubImage3D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            _.compressedTexSubImage2D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            _.compressedTexSubImage3D.apply(_, arguments)
                        } catch (_) {
                            console.error("THREE.WebGLState:", _)
                        }
                    },
                    scissor: function(O) {
                        !1 === eE.equals(O) && (_.scissor(O.x, O.y, O.z, O.w), eE.copy(O))
                    },
                    viewport: function(O) {
                        !1 === eC.equals(O) && (_.viewport(O.x, O.y, O.z, O.w), eC.copy(O))
                    },
                    reset: function() {
                        _.disable(3042), _.disable(2884), _.disable(2929), _.disable(32823), _.disable(3089), _.disable(2960), _.disable(32926), _.blendEquation(32774), _.blendFunc(1, 0), _.blendFuncSeparate(1, 0, 1, 0), _.colorMask(!0, !0, !0, !0), _.clearColor(0, 0, 0, 0), _.depthMask(!0), _.depthFunc(513), _.clearDepth(1), _.stencilMask(4294967295), _.stencilFunc(519, 0, 4294967295), _.stencilOp(7680, 7680, 7680), _.clearStencil(0), _.cullFace(1029), _.frontFace(2305), _.polygonOffset(0, 0), _.activeTexture(33984), _.bindFramebuffer(36160, null), !0 === N && (_.bindFramebuffer(36009, null), _.bindFramebuffer(36008, null)), _.useProgram(null), _.lineWidth(1), _.scissor(0, 0, _.canvas.width, _.canvas.height), _.viewport(0, 0, _.canvas.width, _.canvas.height), Y = {}, e_ = null, eS = {}, Q = {}, K = new WeakMap, $ = [], ee = null, et = !1, ei = null, er = null, ea = null, en = null, eo = null, el = null, eh = null, ec = !1, eu = null, ep = null, ef = null, em = null, eg = null, eE.set(0, 0, _.canvas.width, _.canvas.height), eC.set(0, 0, _.canvas.width, _.canvas.height), k.reset(), F.reset(), U.reset()
                    }
                }
            }

            function pz(_, O, B, N, k, F, U) {
                let j = k.isWebGL2,
                    G = k.maxTextures,
                    Y = k.maxCubemapSize,
                    Q = k.maxTextureSize,
                    K = k.maxSamples,
                    $ = O.has("WEBGL_multisampled_render_to_texture") ? O.get("WEBGL_multisampled_render_to_texture") : null,
                    ee = !(typeof navigator > "u") && /OculusBrowser/g.test(navigator.userAgent),
                    et = new WeakMap,
                    ei, er = new WeakMap,
                    ea = !1;
                try {
                    ea = "u" > typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch {}

                function v(_, O) {
                    return ea ? new OffscreenCanvas(_, O) : fg("canvas")
                }

                function x(_, O, B, N) {
                    let k = 1;
                    if ((_.width > N || _.height > N) && (k = N / Math.max(_.width, _.height)), k < 1 || !0 === O) {
                        if (!("u" > typeof HTMLImageElement && _ instanceof HTMLImageElement || "u" > typeof HTMLCanvasElement && _ instanceof HTMLCanvasElement || "u" > typeof ImageBitmap && _ instanceof ImageBitmap)) return "data" in _ && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + _.width + "x" + _.height + ")."), _; {
                            let N = O ? dg : Math.floor,
                                F = N(k * _.width),
                                U = N(k * _.height);
                            void 0 === ei && (ei = v(F, U));
                            let j = B ? v(F, U) : ei;
                            return j.width = F, j.height = U, j.getContext("2d").drawImage(_, 0, 0, F, U), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + _.width + "x" + _.height + ") to (" + F + "x" + U + ")."), j
                        }
                    }
                    return _
                }

                function w(_) {
                    return xb(_.width) && xb(_.height)
                }

                function A(_, O) {
                    return _.generateMipmaps && O && 1003 !== _.minFilter && 1006 !== _.minFilter
                }

                function E(O) {
                    _.generateMipmap(O)
                }

                function b(B, N, k, F, U = !1) {
                    if (!1 === j) return N;
                    if (null !== B) {
                        if (void 0 !== _[B]) return _[B];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + B + "'")
                    }
                    let G = N;
                    return 6403 === N && (5126 === k && (G = 33326), 5131 === k && (G = 33325), 5121 === k && (G = 33321)), 33319 === N && (5126 === k && (G = 33328), 5131 === k && (G = 33327), 5121 === k && (G = 33323)), 6408 === N && (5126 === k && (G = 34836), 5131 === k && (G = 34842), 5121 === k && (G = 3001 === F && !1 === U ? 35907 : 32856), 32819 === k && (G = 32854), 32820 === k && (G = 32855)), (33325 === G || 33326 === G || 33327 === G || 33328 === G || 34842 === G || 34836 === G) && O.get("EXT_color_buffer_float"), G
                }

                function M(_, O, B) {
                    return !0 === A(_, B) || _.isFramebufferTexture && 1003 !== _.minFilter && 1006 !== _.minFilter ? Math.log2(Math.max(O.width, O.height)) + 1 : void 0 !== _.mipmaps && _.mipmaps.length > 0 ? _.mipmaps.length : _.isCompressedTexture && Array.isArray(_.image) ? O.mipmaps.length : 1
                }

                function T(_) {
                    return 1003 === _ || 1004 === _ || 1005 === _ ? 9728 : 9729
                }

                function C(_) {
                    let O = _.target;
                    O.removeEventListener("dispose", C),
                        function(_) {
                            let O = N.get(_);
                            if (void 0 === O.__webglInit) return;
                            let B = _.source,
                                k = er.get(B);
                            if (k) {
                                let N = k[O.__cacheKey];
                                N.usedTimes--, 0 === N.usedTimes && I(_), 0 === Object.keys(k).length && er.delete(B)
                            }
                            N.remove(_)
                        }(O), O.isVideoTexture && et.delete(O)
                }

                function P(O) {
                    let B = O.target;
                    B.removeEventListener("dispose", P),
                        function(O) {
                            let B = O.texture,
                                k = N.get(O),
                                F = N.get(B);
                            if (void 0 !== F.__webglTexture && (_.deleteTexture(F.__webglTexture), U.memory.textures--), O.depthTexture && O.depthTexture.dispose(), O.isWebGLCubeRenderTarget)
                                for (let O = 0; O < 6; O++) _.deleteFramebuffer(k.__webglFramebuffer[O]), k.__webglDepthbuffer && _.deleteRenderbuffer(k.__webglDepthbuffer[O]);
                            else {
                                if (_.deleteFramebuffer(k.__webglFramebuffer), k.__webglDepthbuffer && _.deleteRenderbuffer(k.__webglDepthbuffer), k.__webglMultisampledFramebuffer && _.deleteFramebuffer(k.__webglMultisampledFramebuffer), k.__webglColorRenderbuffer)
                                    for (let O = 0; O < k.__webglColorRenderbuffer.length; O++) k.__webglColorRenderbuffer[O] && _.deleteRenderbuffer(k.__webglColorRenderbuffer[O]);
                                k.__webglDepthRenderbuffer && _.deleteRenderbuffer(k.__webglDepthRenderbuffer)
                            }
                            if (O.isWebGLMultipleRenderTargets)
                                for (let O = 0, k = B.length; O < k; O++) {
                                    let k = N.get(B[O]);
                                    k.__webglTexture && (_.deleteTexture(k.__webglTexture), U.memory.textures--), N.remove(B[O])
                                }
                            N.remove(B), N.remove(O)
                        }(B)
                }

                function I(O) {
                    let B = N.get(O);
                    _.deleteTexture(B.__webglTexture);
                    let k = O.source,
                        F = er.get(k);
                    delete F[B.__cacheKey], U.memory.textures--
                }
                let en = 0;

                function H(_, O) {
                    let k, F = N.get(_);
                    if (_.isVideoTexture && (k = U.render.frame, et.get(_) !== k && (et.set(_, k), _.update())), !1 === _.isRenderTargetTexture && _.version > 0 && F.__version !== _.version) {
                        let B = _.image;
                        if (null === B) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else if (!1 === B.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                        else {
                            Z(F, _, O);
                            return
                        }
                    }
                    B.bindTexture(3553, F.__webglTexture, 33984 + O)
                }
                let eo = {
                        1e3: 10497,
                        1001: 33071,
                        1002: 33648
                    },
                    el = {
                        1003: 9728,
                        1004: 9984,
                        1005: 9986,
                        1006: 9729,
                        1007: 9985,
                        1008: 9987
                    };

                function z(B, F, U) {
                    if (U ? (_.texParameteri(B, 10242, eo[F.wrapS]), _.texParameteri(B, 10243, eo[F.wrapT]), (32879 === B || 35866 === B) && _.texParameteri(B, 32882, eo[F.wrapR]), _.texParameteri(B, 10240, el[F.magFilter]), _.texParameteri(B, 10241, el[F.minFilter])) : (_.texParameteri(B, 10242, 33071), _.texParameteri(B, 10243, 33071), (32879 === B || 35866 === B) && _.texParameteri(B, 32882, 33071), (1001 !== F.wrapS || 1001 !== F.wrapT) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), _.texParameteri(B, 10240, T(F.magFilter)), _.texParameteri(B, 10241, T(F.minFilter)), 1003 !== F.minFilter && 1006 !== F.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === O.has("EXT_texture_filter_anisotropic")) {
                        let U = O.get("EXT_texture_filter_anisotropic");
                        1003 !== F.magFilter && (1005 === F.minFilter || 1008 === F.minFilter) && (1015 !== F.type || !1 !== O.has("OES_texture_float_linear")) && (!1 !== j || 1016 !== F.type || !1 !== O.has("OES_texture_half_float_linear")) && (F.anisotropy > 1 || N.get(F).__currentAnisotropy) && (_.texParameterf(B, U.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(F.anisotropy, k.getMaxAnisotropy())), N.get(F).__currentAnisotropy = F.anisotropy)
                    }
                }

                function J(O, B) {
                    let N, k = !1;
                    void 0 === O.__webglInit && (O.__webglInit = !0, B.addEventListener("dispose", C));
                    let F = B.source,
                        j = er.get(F);
                    void 0 === j && (j = {}, er.set(F, j));
                    let G = ((N = []).push(B.wrapS), N.push(B.wrapT), N.push(B.wrapR || 0), N.push(B.magFilter), N.push(B.minFilter), N.push(B.anisotropy), N.push(B.internalFormat), N.push(B.format), N.push(B.type), N.push(B.generateMipmaps), N.push(B.premultiplyAlpha), N.push(B.flipY), N.push(B.unpackAlignment), N.push(B.encoding), N.join());
                    if (G !== O.__cacheKey) {
                        void 0 === j[G] && (j[G] = {
                            texture: _.createTexture(),
                            usedTimes: 0
                        }, U.memory.textures++, k = !0), j[G].usedTimes++;
                        let N = j[O.__cacheKey];
                        void 0 !== N && (j[O.__cacheKey].usedTimes--, 0 === N.usedTimes && I(B)), O.__cacheKey = G, O.__webglTexture = j[G].texture
                    }
                    return k
                }

                function Z(O, k, U) {
                    let G = 3553;
                    (k.isDataArrayTexture || k.isCompressedArrayTexture) && (G = 35866), k.isData3DTexture && (G = 32879);
                    let Y = J(O, k),
                        K = k.source;
                    B.bindTexture(G, O.__webglTexture, 33984 + U);
                    let $ = N.get(K);
                    if (K.version !== $.__version || !0 === Y) {
                        B.activeTexture(33984 + U), _.pixelStorei(37440, k.flipY), _.pixelStorei(37441, k.premultiplyAlpha), _.pixelStorei(3317, k.unpackAlignment), _.pixelStorei(37443, 0);
                        let O = !j && (1001 !== k.wrapS || 1001 !== k.wrapT || 1003 !== k.minFilter && 1006 !== k.minFilter) && !1 === w(k.image),
                            N = x(k.image, O, !1, Q),
                            ee = w(N = Ue(k, N)) || j,
                            et = F.convert(k.format, k.encoding),
                            ei = F.convert(k.type),
                            er = b(k.internalFormat, et, ei, k.encoding, k.isVideoTexture);
                        z(G, k, ee);
                        let ea, en = k.mipmaps,
                            eo = j && !0 !== k.isVideoTexture,
                            el = void 0 === $.__version || !0 === Y,
                            eh = M(k, N, ee);
                        if (k.isDepthTexture) er = 6402, j ? er = 1015 === k.type ? 36012 : 1014 === k.type ? 33190 : 1020 === k.type ? 35056 : 33189 : 1015 === k.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === k.format && 6402 === er && 1012 !== k.type && 1014 !== k.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), k.type = 1014, ei = F.convert(k.type)), 1027 === k.format && 6402 === er && (er = 34041, 1020 !== k.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), k.type = 1020, ei = F.convert(k.type))), el && (eo ? B.texStorage2D(3553, 1, er, N.width, N.height) : B.texImage2D(3553, 0, er, N.width, N.height, 0, et, ei, null));
                        else if (k.isDataTexture) {
                            if (en.length > 0 && ee) {
                                eo && el && B.texStorage2D(3553, eh, er, en[0].width, en[0].height);
                                for (let _ = 0, O = en.length; _ < O; _++) ea = en[_], eo ? B.texSubImage2D(3553, _, 0, 0, ea.width, ea.height, et, ei, ea.data) : B.texImage2D(3553, _, er, ea.width, ea.height, 0, et, ei, ea.data);
                                k.generateMipmaps = !1
                            } else eo ? (el && B.texStorage2D(3553, eh, er, N.width, N.height), B.texSubImage2D(3553, 0, 0, 0, N.width, N.height, et, ei, N.data)) : B.texImage2D(3553, 0, er, N.width, N.height, 0, et, ei, N.data)
                        } else if (k.isCompressedTexture) {
                            if (k.isCompressedArrayTexture) {
                                eo && el && B.texStorage3D(35866, eh, er, en[0].width, en[0].height, N.depth);
                                for (let _ = 0, O = en.length; _ < O; _++) ea = en[_], 1023 !== k.format ? null !== et ? eo ? B.compressedTexSubImage3D(35866, _, 0, 0, 0, ea.width, ea.height, N.depth, et, ea.data, 0, 0) : B.compressedTexImage3D(35866, _, er, ea.width, ea.height, N.depth, 0, ea.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : eo ? B.texSubImage3D(35866, _, 0, 0, 0, ea.width, ea.height, N.depth, et, ei, ea.data) : B.texImage3D(35866, _, er, ea.width, ea.height, N.depth, 0, et, ei, ea.data)
                            } else {
                                eo && el && B.texStorage2D(3553, eh, er, en[0].width, en[0].height);
                                for (let _ = 0, O = en.length; _ < O; _++) ea = en[_], 1023 !== k.format ? null !== et ? eo ? B.compressedTexSubImage2D(3553, _, 0, 0, ea.width, ea.height, et, ea.data) : B.compressedTexImage2D(3553, _, er, ea.width, ea.height, 0, ea.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : eo ? B.texSubImage2D(3553, _, 0, 0, ea.width, ea.height, et, ei, ea.data) : B.texImage2D(3553, _, er, ea.width, ea.height, 0, et, ei, ea.data)
                            }
                        } else if (k.isDataArrayTexture) eo ? (el && B.texStorage3D(35866, eh, er, N.width, N.height, N.depth), B.texSubImage3D(35866, 0, 0, 0, 0, N.width, N.height, N.depth, et, ei, N.data)) : B.texImage3D(35866, 0, er, N.width, N.height, N.depth, 0, et, ei, N.data);
                        else if (k.isData3DTexture) eo ? (el && B.texStorage3D(32879, eh, er, N.width, N.height, N.depth), B.texSubImage3D(32879, 0, 0, 0, 0, N.width, N.height, N.depth, et, ei, N.data)) : B.texImage3D(32879, 0, er, N.width, N.height, N.depth, 0, et, ei, N.data);
                        else if (k.isFramebufferTexture) {
                            if (el) {
                                if (eo) B.texStorage2D(3553, eh, er, N.width, N.height);
                                else {
                                    let _ = N.width,
                                        O = N.height;
                                    for (let N = 0; N < eh; N++) B.texImage2D(3553, N, er, _, O, 0, et, ei, null), _ >>= 1, O >>= 1
                                }
                            }
                        } else if (en.length > 0 && ee) {
                            eo && el && B.texStorage2D(3553, eh, er, en[0].width, en[0].height);
                            for (let _ = 0, O = en.length; _ < O; _++) ea = en[_], eo ? B.texSubImage2D(3553, _, 0, 0, et, ei, ea) : B.texImage2D(3553, _, er, et, ei, ea);
                            k.generateMipmaps = !1
                        } else eo ? (el && B.texStorage2D(3553, eh, er, N.width, N.height), B.texSubImage2D(3553, 0, 0, 0, et, ei, N)) : B.texImage2D(3553, 0, er, et, ei, N);
                        A(k, ee) && E(G), $.__version = K.version, k.onUpdate && k.onUpdate(k)
                    }
                    O.__version = k.version
                }

                function W(O, k, U, j, G) {
                    let Y = F.convert(U.format, U.encoding),
                        Q = F.convert(U.type),
                        K = b(U.internalFormat, Y, Q, U.encoding);
                    N.get(k).__hasExternalTextures || (32879 === G || 35866 === G ? B.texImage3D(G, 0, K, k.width, k.height, k.depth, 0, Y, Q, null) : B.texImage2D(G, 0, K, k.width, k.height, 0, Y, Q, null)), B.bindFramebuffer(36160, O), Me(k) ? $.framebufferTexture2DMultisampleEXT(36160, j, G, N.get(U).__webglTexture, 0, Pe(k)) : (3553 === G || G >= 34069 && G <= 34074) && _.framebufferTexture2D(36160, j, G, N.get(U).__webglTexture, 0), B.bindFramebuffer(36160, null)
                }

                function ye(O, B, N) {
                    if (_.bindRenderbuffer(36161, O), B.depthBuffer && !B.stencilBuffer) {
                        let k = 33189;
                        if (N || Me(B)) {
                            let O = B.depthTexture;
                            O && O.isDepthTexture && (1015 === O.type ? k = 36012 : 1014 === O.type && (k = 33190));
                            let N = Pe(B);
                            Me(B) ? $.renderbufferStorageMultisampleEXT(36161, N, k, B.width, B.height) : _.renderbufferStorageMultisample(36161, N, k, B.width, B.height)
                        } else _.renderbufferStorage(36161, k, B.width, B.height);
                        _.framebufferRenderbuffer(36160, 36096, 36161, O)
                    } else if (B.depthBuffer && B.stencilBuffer) {
                        let k = Pe(B);
                        N && !1 === Me(B) ? _.renderbufferStorageMultisample(36161, k, 35056, B.width, B.height) : Me(B) ? $.renderbufferStorageMultisampleEXT(36161, k, 35056, B.width, B.height) : _.renderbufferStorage(36161, 34041, B.width, B.height), _.framebufferRenderbuffer(36160, 33306, 36161, O)
                    } else {
                        let O = !0 === B.isWebGLMultipleRenderTargets ? B.texture : [B.texture];
                        for (let k = 0; k < O.length; k++) {
                            let U = O[k],
                                j = F.convert(U.format, U.encoding),
                                G = F.convert(U.type),
                                Y = b(U.internalFormat, j, G, U.encoding),
                                Q = Pe(B);
                            N && !1 === Me(B) ? _.renderbufferStorageMultisample(36161, Q, Y, B.width, B.height) : Me(B) ? $.renderbufferStorageMultisampleEXT(36161, Q, Y, B.width, B.height) : _.renderbufferStorage(36161, Y, B.width, B.height)
                        }
                    }
                    _.bindRenderbuffer(36161, null)
                }

                function se(O) {
                    let k = N.get(O),
                        F = !0 === O.isWebGLCubeRenderTarget;
                    if (O.depthTexture && !k.__autoAllocateDepthBuffer) {
                        if (F) throw Error("target.depthTexture not supported in Cube render targets");
                        ! function(O, k) {
                            if (k && k.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
                            if (B.bindFramebuffer(36160, O), !(k.depthTexture && k.depthTexture.isDepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            N.get(k.depthTexture).__webglTexture && k.depthTexture.image.width === k.width && k.depthTexture.image.height === k.height || (k.depthTexture.image.width = k.width, k.depthTexture.image.height = k.height, k.depthTexture.needsUpdate = !0), H(k.depthTexture, 0);
                            let F = N.get(k.depthTexture).__webglTexture,
                                U = Pe(k);
                            if (1026 === k.depthTexture.format) Me(k) ? $.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, F, 0, U) : _.framebufferTexture2D(36160, 36096, 3553, F, 0);
                            else if (1027 === k.depthTexture.format) Me(k) ? $.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, F, 0, U) : _.framebufferTexture2D(36160, 33306, 3553, F, 0);
                            else throw Error("Unknown depthTexture format")
                        }(k.__webglFramebuffer, O)
                    } else if (F) {
                        k.__webglDepthbuffer = [];
                        for (let N = 0; N < 6; N++) B.bindFramebuffer(36160, k.__webglFramebuffer[N]), k.__webglDepthbuffer[N] = _.createRenderbuffer(), ye(k.__webglDepthbuffer[N], O, !1)
                    } else B.bindFramebuffer(36160, k.__webglFramebuffer), k.__webglDepthbuffer = _.createRenderbuffer(), ye(k.__webglDepthbuffer, O, !1);
                    B.bindFramebuffer(36160, null)
                }

                function Pe(_) {
                    return Math.min(K, _.samples)
                }

                function Me(_) {
                    let B = N.get(_);
                    return j && _.samples > 0 && !0 === O.has("WEBGL_multisampled_render_to_texture") && !1 !== B.__useRenderToTexture
                }

                function Ue(_, B) {
                    let N = _.encoding,
                        k = _.format,
                        F = _.type;
                    return !0 === _.isCompressedTexture || !0 === _.isVideoTexture || 1035 === _.format || 3e3 !== N && (3001 === N ? !1 === j ? !0 === O.has("EXT_sRGB") && 1023 === k ? (_.format = 1035, _.minFilter = 1006, _.generateMipmaps = !1) : B = ri.sRGBToLinear(B) : (1023 !== k || 1009 !== F) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", N)), B
                }
                this.allocateTextureUnit = function() {
                    let _ = en;
                    return _ >= G && console.warn("THREE.WebGLTextures: Trying to use " + _ + " texture units while this GPU supports only " + G), en += 1, _
                }, this.resetTextureUnits = function() {
                    en = 0
                }, this.setTexture2D = H, this.setTexture2DArray = function(_, O) {
                    let k = N.get(_);
                    if (_.version > 0 && k.__version !== _.version) {
                        Z(k, _, O);
                        return
                    }
                    B.bindTexture(35866, k.__webglTexture, 33984 + O)
                }, this.setTexture3D = function(_, O) {
                    let k = N.get(_);
                    if (_.version > 0 && k.__version !== _.version) {
                        Z(k, _, O);
                        return
                    }
                    B.bindTexture(32879, k.__webglTexture, 33984 + O)
                }, this.setTextureCube = function(O, k) {
                    let U = N.get(O);
                    if (O.version > 0 && U.__version !== O.version) {
                        (function(O, k, U) {
                            if (6 !== k.image.length) return;
                            let G = J(O, k),
                                Q = k.source;
                            B.bindTexture(34067, O.__webglTexture, 33984 + U);
                            let K = N.get(Q);
                            if (Q.version !== K.__version || !0 === G) {
                                let O;
                                B.activeTexture(33984 + U), _.pixelStorei(37440, k.flipY), _.pixelStorei(37441, k.premultiplyAlpha), _.pixelStorei(3317, k.unpackAlignment), _.pixelStorei(37443, 0);
                                let N = k.isCompressedTexture || k.image[0].isCompressedTexture,
                                    $ = k.image[0] && k.image[0].isDataTexture,
                                    ee = [];
                                for (let _ = 0; _ < 6; _++) N || $ ? ee[_] = $ ? k.image[_].image : k.image[_] : ee[_] = x(k.image[_], !1, !0, Y), ee[_] = Ue(k, ee[_]);
                                let et = ee[0],
                                    ei = w(et) || j,
                                    er = F.convert(k.format, k.encoding),
                                    ea = F.convert(k.type),
                                    en = b(k.internalFormat, er, ea, k.encoding),
                                    eo = j && !0 !== k.isVideoTexture,
                                    el = void 0 === K.__version || !0 === G,
                                    eh = M(k, et, ei);
                                if (z(34067, k, ei), N) {
                                    eo && el && B.texStorage2D(34067, eh, en, et.width, et.height);
                                    for (let _ = 0; _ < 6; _++) {
                                        O = ee[_].mipmaps;
                                        for (let N = 0; N < O.length; N++) {
                                            let F = O[N];
                                            1023 !== k.format ? null !== er ? eo ? B.compressedTexSubImage2D(34069 + _, N, 0, 0, F.width, F.height, er, F.data) : B.compressedTexImage2D(34069 + _, N, en, F.width, F.height, 0, F.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : eo ? B.texSubImage2D(34069 + _, N, 0, 0, F.width, F.height, er, ea, F.data) : B.texImage2D(34069 + _, N, en, F.width, F.height, 0, er, ea, F.data)
                                        }
                                    }
                                } else {
                                    O = k.mipmaps, eo && el && (O.length > 0 && eh++, B.texStorage2D(34067, eh, en, ee[0].width, ee[0].height));
                                    for (let _ = 0; _ < 6; _++)
                                        if ($) {
                                            eo ? B.texSubImage2D(34069 + _, 0, 0, 0, ee[_].width, ee[_].height, er, ea, ee[_].data) : B.texImage2D(34069 + _, 0, en, ee[_].width, ee[_].height, 0, er, ea, ee[_].data);
                                            for (let N = 0; N < O.length; N++) {
                                                let k = O[N].image[_].image;
                                                eo ? B.texSubImage2D(34069 + _, N + 1, 0, 0, k.width, k.height, er, ea, k.data) : B.texImage2D(34069 + _, N + 1, en, k.width, k.height, 0, er, ea, k.data)
                                            }
                                        } else {
                                            eo ? B.texSubImage2D(34069 + _, 0, 0, 0, er, ea, ee[_]) : B.texImage2D(34069 + _, 0, en, er, ea, ee[_]);
                                            for (let N = 0; N < O.length; N++) {
                                                let k = O[N];
                                                eo ? B.texSubImage2D(34069 + _, N + 1, 0, 0, er, ea, k.image[_]) : B.texImage2D(34069 + _, N + 1, en, er, ea, k.image[_])
                                            }
                                        }
                                }
                                A(k, ei) && E(34067), K.__version = Q.version, k.onUpdate && k.onUpdate(k)
                            }
                            O.__version = k.version
                        })(U, O, k);
                        return
                    }
                    B.bindTexture(34067, U.__webglTexture, 33984 + k)
                }, this.rebindTextures = function(_, O, B) {
                    let k = N.get(_);
                    void 0 !== O && W(k.__webglFramebuffer, _, _.texture, 36064, 3553), void 0 !== B && se(_)
                }, this.setupRenderTarget = function(O) {
                    let G = O.texture,
                        Y = N.get(O),
                        Q = N.get(G);
                    O.addEventListener("dispose", P), !0 !== O.isWebGLMultipleRenderTargets && (void 0 === Q.__webglTexture && (Q.__webglTexture = _.createTexture()), Q.__version = G.version, U.memory.textures++);
                    let K = !0 === O.isWebGLCubeRenderTarget,
                        $ = !0 === O.isWebGLMultipleRenderTargets,
                        ee = w(O) || j;
                    if (K) {
                        Y.__webglFramebuffer = [];
                        for (let O = 0; O < 6; O++) Y.__webglFramebuffer[O] = _.createFramebuffer()
                    } else {
                        if (Y.__webglFramebuffer = _.createFramebuffer(), $) {
                            if (k.drawBuffers) {
                                let B = O.texture;
                                for (let O = 0, k = B.length; O < k; O++) {
                                    let k = N.get(B[O]);
                                    void 0 === k.__webglTexture && (k.__webglTexture = _.createTexture(), U.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")
                        }
                        if (j && O.samples > 0 && !1 === Me(O)) {
                            let N = $ ? G : [G];
                            Y.__webglMultisampledFramebuffer = _.createFramebuffer(), Y.__webglColorRenderbuffer = [], B.bindFramebuffer(36160, Y.__webglMultisampledFramebuffer);
                            for (let B = 0; B < N.length; B++) {
                                let k = N[B];
                                Y.__webglColorRenderbuffer[B] = _.createRenderbuffer(), _.bindRenderbuffer(36161, Y.__webglColorRenderbuffer[B]);
                                let U = F.convert(k.format, k.encoding),
                                    j = F.convert(k.type),
                                    G = b(k.internalFormat, U, j, k.encoding, !0 === O.isXRRenderTarget),
                                    Q = Pe(O);
                                _.renderbufferStorageMultisample(36161, Q, G, O.width, O.height), _.framebufferRenderbuffer(36160, 36064 + B, 36161, Y.__webglColorRenderbuffer[B])
                            }
                            _.bindRenderbuffer(36161, null), O.depthBuffer && (Y.__webglDepthRenderbuffer = _.createRenderbuffer(), ye(Y.__webglDepthRenderbuffer, O, !0)), B.bindFramebuffer(36160, null)
                        }
                    }
                    if (K) {
                        B.bindTexture(34067, Q.__webglTexture), z(34067, G, ee);
                        for (let _ = 0; _ < 6; _++) W(Y.__webglFramebuffer[_], O, G, 36064, 34069 + _);
                        A(G, ee) && E(34067), B.unbindTexture()
                    } else if ($) {
                        let _ = O.texture;
                        for (let k = 0, F = _.length; k < F; k++) {
                            let F = _[k],
                                U = N.get(F);
                            B.bindTexture(3553, U.__webglTexture), z(3553, F, ee), W(Y.__webglFramebuffer, O, F, 36064 + k, 3553), A(F, ee) && E(3553)
                        }
                        B.unbindTexture()
                    } else {
                        let _ = 3553;
                        (O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (j ? _ = O.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), B.bindTexture(_, Q.__webglTexture), z(_, G, ee), W(Y.__webglFramebuffer, O, G, 36064, _), A(G, ee) && E(_), B.unbindTexture()
                    }
                    O.depthBuffer && se(O)
                }, this.updateRenderTargetMipmap = function(_) {
                    let O = w(_) || j,
                        k = !0 === _.isWebGLMultipleRenderTargets ? _.texture : [_.texture];
                    for (let F = 0, U = k.length; F < U; F++) {
                        let U = k[F];
                        if (A(U, O)) {
                            let O = _.isWebGLCubeRenderTarget ? 34067 : 3553,
                                k = N.get(U).__webglTexture;
                            B.bindTexture(O, k), E(O), B.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(O) {
                    if (j && O.samples > 0 && !1 === Me(O)) {
                        let k = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture],
                            F = O.width,
                            U = O.height,
                            j = 16384,
                            G = [],
                            Y = O.stencilBuffer ? 33306 : 36096,
                            Q = N.get(O),
                            K = !0 === O.isWebGLMultipleRenderTargets;
                        if (K)
                            for (let O = 0; O < k.length; O++) B.bindFramebuffer(36160, Q.__webglMultisampledFramebuffer), _.framebufferRenderbuffer(36160, 36064 + O, 36161, null), B.bindFramebuffer(36160, Q.__webglFramebuffer), _.framebufferTexture2D(36009, 36064 + O, 3553, null, 0);
                        B.bindFramebuffer(36008, Q.__webglMultisampledFramebuffer), B.bindFramebuffer(36009, Q.__webglFramebuffer);
                        for (let B = 0; B < k.length; B++) {
                            G.push(36064 + B), O.depthBuffer && G.push(Y);
                            let $ = void 0 !== Q.__ignoreDepthValues && Q.__ignoreDepthValues;
                            if (!1 === $ && (O.depthBuffer && (j |= 256), O.stencilBuffer && (j |= 1024)), K && _.framebufferRenderbuffer(36008, 36064, 36161, Q.__webglColorRenderbuffer[B]), !0 === $ && (_.invalidateFramebuffer(36008, [Y]), _.invalidateFramebuffer(36009, [Y])), K) {
                                let O = N.get(k[B]).__webglTexture;
                                _.framebufferTexture2D(36009, 36064, 3553, O, 0)
                            }
                            _.blitFramebuffer(0, 0, F, U, 0, 0, F, U, j, 9728), ee && _.invalidateFramebuffer(36008, G)
                        }
                        if (B.bindFramebuffer(36008, null), B.bindFramebuffer(36009, null), K)
                            for (let O = 0; O < k.length; O++) {
                                B.bindFramebuffer(36160, Q.__webglMultisampledFramebuffer), _.framebufferRenderbuffer(36160, 36064 + O, 36161, Q.__webglColorRenderbuffer[O]);
                                let F = N.get(k[O]).__webglTexture;
                                B.bindFramebuffer(36160, Q.__webglFramebuffer), _.framebufferTexture2D(36009, 36064 + O, 3553, F, 0)
                            }
                        B.bindFramebuffer(36009, Q.__webglMultisampledFramebuffer)
                    }
                }, this.setupDepthRenderbuffer = se, this.setupFrameBufferTexture = W, this.useMultisampledRTT = Me
            }

            function mz(_, O, B) {
                let N = B.isWebGL2;
                return {
                    convert: function(B, k = null) {
                        let F;
                        if (1009 === B) return 5121;
                        if (1017 === B) return 32819;
                        if (1018 === B) return 32820;
                        if (1010 === B) return 5120;
                        if (1011 === B) return 5122;
                        if (1012 === B) return 5123;
                        if (1013 === B) return 5124;
                        if (1014 === B) return 5125;
                        if (1015 === B) return 5126;
                        if (1016 === B) return N ? 5131 : null !== (F = O.get("OES_texture_half_float")) ? F.HALF_FLOAT_OES : null;
                        if (1021 === B) return 6406;
                        if (1023 === B) return 6408;
                        if (1024 === B) return 6409;
                        if (1025 === B) return 6410;
                        if (1026 === B) return 6402;
                        if (1027 === B) return 34041;
                        if (1035 === B) return null !== (F = O.get("EXT_sRGB")) ? F.SRGB_ALPHA_EXT : null;
                        if (1028 === B) return 6403;
                        if (1029 === B) return 36244;
                        if (1030 === B) return 33319;
                        if (1031 === B) return 33320;
                        if (1033 === B) return 36249;
                        if (33776 === B || 33777 === B || 33778 === B || 33779 === B) {
                            if (3001 === k) {
                                if (null === (F = O.get("WEBGL_compressed_texture_s3tc_srgb"))) return null;
                                if (33776 === B) return F.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (33777 === B) return F.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (33778 === B) return F.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (33779 === B) return F.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (null === (F = O.get("WEBGL_compressed_texture_s3tc"))) return null;
                                if (33776 === B) return F.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (33777 === B) return F.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (33778 === B) return F.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (33779 === B) return F.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        }
                        if (35840 === B || 35841 === B || 35842 === B || 35843 === B) {
                            if (null === (F = O.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (35840 === B) return F.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === B) return F.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === B) return F.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === B) return F.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === B) return null !== (F = O.get("WEBGL_compressed_texture_etc1")) ? F.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (37492 === B || 37496 === B) {
                            if (null === (F = O.get("WEBGL_compressed_texture_etc"))) return null;
                            if (37492 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ETC2 : F.COMPRESSED_RGB8_ETC2;
                            if (37496 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : F.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (37808 === B || 37809 === B || 37810 === B || 37811 === B || 37812 === B || 37813 === B || 37814 === B || 37815 === B || 37816 === B || 37817 === B || 37818 === B || 37819 === B || 37820 === B || 37821 === B) {
                            if (null === (F = O.get("WEBGL_compressed_texture_astc"))) return null;
                            if (37808 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : F.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (37809 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : F.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (37810 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : F.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (37811 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : F.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (37812 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : F.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (37813 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : F.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (37814 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : F.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (37815 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : F.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (37816 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : F.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (37817 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : F.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (37818 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : F.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (37819 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : F.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (37820 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : F.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (37821 === B) return 3001 === k ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : F.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (36492 === B) {
                            if (null === (F = O.get("EXT_texture_compression_bptc"))) return null;
                            if (36492 === B) return 3001 === k ? F.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : F.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        if (36283 === B || 36284 === B || 36285 === B || 36286 === B) {
                            if (null === (F = O.get("EXT_texture_compression_rgtc"))) return null;
                            if (36492 === B) return F.COMPRESSED_RED_RGTC1_EXT;
                            if (36284 === B) return F.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                            if (36285 === B) return F.COMPRESSED_RED_GREEN_RGTC2_EXT;
                            if (36286 === B) return F.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                        }
                        return 1020 === B ? N ? 34042 : null !== (F = O.get("WEBGL_depth_texture")) ? F.UNSIGNED_INT_24_8_WEBGL : null : void 0 !== _[B] ? _[B] : null
                    }
                }
            }
            var nu = class extends al {
                    constructor(_ = []) {
                        super(), this.isArrayCamera = !0, this.cameras = _
                    }
                },
                nv = class extends sv {
                    constructor() {
                        super(), this.isGroup = !0, this.type = "Group"
                    }
                },
                ny = {
                    type: "move"
                },
                nx = class {
                    constructor() {
                        this._targetRay = null, this._grip = null, this._hand = null
                    }
                    getHandSpace() {
                        return null === this._hand && (this._hand = new nv, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                            pinching: !1
                        }), this._hand
                    }
                    getTargetRaySpace() {
                        return null === this._targetRay && (this._targetRay = new nv, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new rv, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new rv), this._targetRay
                    }
                    getGripSpace() {
                        return null === this._grip && (this._grip = new nv, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new rv, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new rv), this._grip
                    }
                    dispatchEvent(_) {
                        return null !== this._targetRay && this._targetRay.dispatchEvent(_), null !== this._grip && this._grip.dispatchEvent(_), null !== this._hand && this._hand.dispatchEvent(_), this
                    }
                    connect(_) {
                        if (_ && _.hand) {
                            let O = this._hand;
                            if (O)
                                for (let B of _.hand.values()) this._getHandJoint(O, B)
                        }
                        return this.dispatchEvent({
                            type: "connected",
                            data: _
                        }), this
                    }
                    disconnect(_) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: _
                        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                    }
                    update(_, O, B) {
                        let N = null,
                            k = null,
                            F = null,
                            U = this._targetRay,
                            j = this._grip,
                            G = this._hand;
                        if (_ && "visible-blurred" !== O.session.visibilityState) {
                            if (G && _.hand) {
                                for (let N of (F = !0, _.hand.values())) {
                                    let _ = O.getJointPose(N, B),
                                        k = this._getHandJoint(G, N);
                                    null !== _ && (k.matrix.fromArray(_.transform.matrix), k.matrix.decompose(k.position, k.rotation, k.scale), k.jointRadius = _.radius), k.visible = null !== _
                                }
                                let N = G.joints["index-finger-tip"],
                                    k = G.joints["thumb-tip"],
                                    U = N.position.distanceTo(k.position);
                                G.inputState.pinching && U > .025 ? (G.inputState.pinching = !1, this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: _.handedness,
                                    target: this
                                })) : !G.inputState.pinching && U <= .015 && (G.inputState.pinching = !0, this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: _.handedness,
                                    target: this
                                }))
                            } else null !== j && _.gripSpace && null !== (k = O.getPose(_.gripSpace, B)) && (j.matrix.fromArray(k.transform.matrix), j.matrix.decompose(j.position, j.rotation, j.scale), k.linearVelocity ? (j.hasLinearVelocity = !0, j.linearVelocity.copy(k.linearVelocity)) : j.hasLinearVelocity = !1, k.angularVelocity ? (j.hasAngularVelocity = !0, j.angularVelocity.copy(k.angularVelocity)) : j.hasAngularVelocity = !1);
                            null !== U && (null === (N = O.getPose(_.targetRaySpace, B)) && null !== k && (N = k), null !== N && (U.matrix.fromArray(N.transform.matrix), U.matrix.decompose(U.position, U.rotation, U.scale), N.linearVelocity ? (U.hasLinearVelocity = !0, U.linearVelocity.copy(N.linearVelocity)) : U.hasLinearVelocity = !1, N.angularVelocity ? (U.hasAngularVelocity = !0, U.angularVelocity.copy(N.angularVelocity)) : U.hasAngularVelocity = !1, this.dispatchEvent(ny)))
                        }
                        return null !== U && (U.visible = null !== N), null !== j && (j.visible = null !== k), null !== G && (G.visible = null !== F), this
                    }
                    _getHandJoint(_, O) {
                        if (void 0 === _.joints[O.jointName]) {
                            let B = new nv;
                            B.matrixAutoUpdate = !1, B.visible = !1, _.joints[O.jointName] = B, _.add(B)
                        }
                        return _.joints[O.jointName]
                    }
                },
                nb = class extends ro {
                    constructor(_, O, B, N, k, F, U, j, G, Y) {
                        if (1026 !== (Y = void 0 !== Y ? Y : 1026) && 1027 !== Y) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === B && 1026 === Y && (B = 1014), void 0 === B && 1027 === Y && (B = 1020), super(null, N, k, F, U, j, Y, B, G), this.isDepthTexture = !0, this.image = {
                            width: _,
                            height: O
                        }, this.magFilter = void 0 !== U ? U : 1003, this.minFilter = void 0 !== j ? j : 1003, this.flipY = !1, this.generateMipmaps = !1
                    }
                },
                nw = class extends iq {
                    constructor(_, O) {
                        super();
                        let B = this,
                            N = null,
                            k = 1,
                            F = null,
                            U = "local-floor",
                            j = 1,
                            G = null,
                            Y = null,
                            Q = null,
                            K = null,
                            $ = null,
                            ee = null,
                            et = O.getContextAttributes(),
                            ei = null,
                            er = null,
                            ea = [],
                            en = [],
                            eo = new Set,
                            el = new Map,
                            eh = new al;
                        eh.layers.enable(1), eh.viewport = new rl;
                        let ec = new al;
                        ec.layers.enable(2), ec.viewport = new rl;
                        let eu = [eh, ec],
                            ep = new nu;
                        ep.layers.enable(1), ep.layers.enable(2);
                        let ef = null,
                            em = null;

                        function P(_) {
                            let O = en.indexOf(_.inputSource);
                            if (-1 === O) return;
                            let B = ea[O];
                            void 0 !== B && B.dispatchEvent({
                                type: _.type,
                                data: _.inputSource
                            })
                        }

                        function D() {
                            N.removeEventListener("select", P), N.removeEventListener("selectstart", P), N.removeEventListener("selectend", P), N.removeEventListener("squeeze", P), N.removeEventListener("squeezestart", P), N.removeEventListener("squeezeend", P), N.removeEventListener("end", D), N.removeEventListener("inputsourceschange", I);
                            for (let _ = 0; _ < ea.length; _++) {
                                let O = en[_];
                                null !== O && (en[_] = null, ea[_].disconnect(O))
                            }
                            ef = null, em = null, _.setRenderTarget(ei), $ = null, K = null, Q = null, N = null, er = null, eb.stop(), B.isPresenting = !1, B.dispatchEvent({
                                type: "sessionend"
                            })
                        }

                        function I(_) {
                            for (let O = 0; O < _.removed.length; O++) {
                                let B = _.removed[O],
                                    N = en.indexOf(B);
                                N >= 0 && (en[N] = null, ea[N].disconnect(B))
                            }
                            for (let O = 0; O < _.added.length; O++) {
                                let B = _.added[O],
                                    N = en.indexOf(B);
                                if (-1 === N) {
                                    for (let _ = 0; _ < ea.length; _++)
                                        if (_ >= en.length) {
                                            en.push(B), N = _;
                                            break
                                        } else if (null === en[_]) {
                                        en[_] = B, N = _;
                                        break
                                    }
                                    if (-1 === N) break
                                }
                                let k = ea[N];
                                k && k.connect(B)
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(_) {
                            let O = ea[_];
                            return void 0 === O && (O = new nx, ea[_] = O), O.getTargetRaySpace()
                        }, this.getControllerGrip = function(_) {
                            let O = ea[_];
                            return void 0 === O && (O = new nx, ea[_] = O), O.getGripSpace()
                        }, this.getHand = function(_) {
                            let O = ea[_];
                            return void 0 === O && (O = new nx, ea[_] = O), O.getHandSpace()
                        }, this.setFramebufferScaleFactor = function(_) {
                            k = _, !0 === B.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }, this.setReferenceSpaceType = function(_) {
                            U = _, !0 === B.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }, this.getReferenceSpace = function() {
                            return G || F
                        }, this.setReferenceSpace = function(_) {
                            G = _
                        }, this.getBaseLayer = function() {
                            return null !== K ? K : $
                        }, this.getBinding = function() {
                            return Q
                        }, this.getFrame = function() {
                            return ee
                        }, this.getSession = function() {
                            return N
                        }, this.setSession = async function(Y) {
                            if (null !== (N = Y)) {
                                if (ei = _.getRenderTarget(), N.addEventListener("select", P), N.addEventListener("selectstart", P), N.addEventListener("selectend", P), N.addEventListener("squeeze", P), N.addEventListener("squeezestart", P), N.addEventListener("squeezeend", P), N.addEventListener("end", D), N.addEventListener("inputsourceschange", I), !0 !== et.xrCompatible && await O.makeXRCompatible(), void 0 === N.renderState.layers || !1 === _.capabilities.isWebGL2) {
                                    let B = {
                                        antialias: void 0 !== N.renderState.layers || et.antialias,
                                        alpha: et.alpha,
                                        depth: et.depth,
                                        stencil: et.stencil,
                                        framebufferScaleFactor: k
                                    };
                                    $ = new XRWebGLLayer(N, O, B), N.updateRenderState({
                                        baseLayer: $
                                    }), er = new rh($.framebufferWidth, $.framebufferHeight, {
                                        format: 1023,
                                        type: 1009,
                                        encoding: _.outputEncoding,
                                        stencilBuffer: et.stencil
                                    })
                                } else {
                                    let B = null,
                                        F = null,
                                        U = null;
                                    et.depth && (U = et.stencil ? 35056 : 33190, B = et.stencil ? 1027 : 1026, F = et.stencil ? 1020 : 1014);
                                    let j = {
                                        colorFormat: 32856,
                                        depthFormat: U,
                                        scaleFactor: k
                                    };
                                    K = (Q = new XRWebGLBinding(N, O)).createProjectionLayer(j), N.updateRenderState({
                                        layers: [K]
                                    }), er = new rh(K.textureWidth, K.textureHeight, {
                                        format: 1023,
                                        type: 1009,
                                        depthTexture: new nb(K.textureWidth, K.textureHeight, F, void 0, void 0, void 0, void 0, void 0, void 0, B),
                                        stencilBuffer: et.stencil,
                                        encoding: _.outputEncoding,
                                        samples: et.antialias ? 4 : 0
                                    }), _.properties.get(er).__ignoreDepthValues = K.ignoreDepthValues
                                }
                                er.isXRRenderTarget = !0, this.setFoveation(j), G = null, F = await N.requestReferenceSpace(U), eb.setContext(N), eb.start(), B.isPresenting = !0, B.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        };
                        let eg = new rv,
                            ev = new rv;

                        function V(_, O) {
                            null === O ? _.matrixWorld.copy(_.matrix) : _.matrixWorld.multiplyMatrices(O.matrixWorld, _.matrix), _.matrixWorldInverse.copy(_.matrixWorld).invert()
                        }
                        this.updateCamera = function(_) {
                            if (null === N) return;
                            ep.near = ec.near = eh.near = _.near, ep.far = ec.far = eh.far = _.far, (ef !== ep.near || em !== ep.far) && (N.updateRenderState({
                                depthNear: ep.near,
                                depthFar: ep.far
                            }), ef = ep.near, em = ep.far);
                            let O = _.parent,
                                B = ep.cameras;
                            V(ep, O);
                            for (let _ = 0; _ < B.length; _++) V(B[_], O);
                            ep.matrixWorld.decompose(ep.position, ep.quaternion, ep.scale), _.matrix.copy(ep.matrix), _.matrix.decompose(_.position, _.quaternion, _.scale);
                            let k = _.children;
                            for (let _ = 0, O = k.length; _ < O; _++) k[_].updateMatrixWorld(!0);
                            2 === B.length ? function(_, O, B) {
                                eg.setFromMatrixPosition(O.matrixWorld), ev.setFromMatrixPosition(B.matrixWorld);
                                let N = eg.distanceTo(ev),
                                    k = O.projectionMatrix.elements,
                                    F = B.projectionMatrix.elements,
                                    U = k[14] / (k[10] - 1),
                                    j = k[14] / (k[10] + 1),
                                    G = (k[9] + 1) / k[5],
                                    Y = (k[9] - 1) / k[5],
                                    Q = (k[8] - 1) / k[0],
                                    K = (F[8] + 1) / F[0],
                                    $ = N / (-Q + K),
                                    ee = -($ * Q);
                                O.matrixWorld.decompose(_.position, _.quaternion, _.scale), _.translateX(ee), _.translateZ($), _.matrixWorld.compose(_.position, _.quaternion, _.scale), _.matrixWorldInverse.copy(_.matrixWorld).invert();
                                let et = U + $,
                                    ei = j + $,
                                    er = U * Q - ee,
                                    ea = U * K + (N - ee),
                                    en = G * j / ei * et,
                                    eo = Y * j / ei * et;
                                _.projectionMatrix.makePerspective(er, ea, en, eo, et, ei)
                            }(ep, eh, ec) : ep.projectionMatrix.copy(eh.projectionMatrix)
                        }, this.getCamera = function() {
                            return ep
                        }, this.getFoveation = function() {
                            if (!(null === K && null === $)) return j
                        }, this.setFoveation = function(_) {
                            j = _, null !== K && (K.fixedFoveation = _), null !== $ && void 0 !== $.fixedFoveation && ($.fixedFoveation = _)
                        }, this.getPlanes = function() {
                            return eo
                        };
                        let ex = null,
                            eb = new oM;
                        eb.setAnimationLoop(function(O, N) {
                            if (Y = N.getViewerPose(G || F), ee = N, null !== Y) {
                                let O = Y.views;
                                null !== $ && (_.setRenderTargetFramebuffer(er, $.framebuffer), _.setRenderTarget(er));
                                let B = !1;
                                O.length !== ep.cameras.length && (ep.cameras.length = 0, B = !0);
                                for (let N = 0; N < O.length; N++) {
                                    let k = O[N],
                                        F = null;
                                    if (null !== $) F = $.getViewport(k);
                                    else {
                                        let O = Q.getViewSubImage(K, k);
                                        F = O.viewport, 0 === N && (_.setRenderTargetTextures(er, O.colorTexture, K.ignoreDepthValues ? void 0 : O.depthStencilTexture), _.setRenderTarget(er))
                                    }
                                    let U = eu[N];
                                    void 0 === U && ((U = new al).layers.enable(N), U.viewport = new rl, eu[N] = U), U.matrix.fromArray(k.transform.matrix), U.projectionMatrix.fromArray(k.projectionMatrix), U.viewport.set(F.x, F.y, F.width, F.height), 0 === N && ep.matrix.copy(U.matrix), !0 === B && ep.cameras.push(U)
                                }
                            }
                            for (let _ = 0; _ < ea.length; _++) {
                                let O = en[_],
                                    B = ea[_];
                                null !== O && void 0 !== B && B.update(O, N, G || F)
                            }
                            if (ex && ex(O, N), N.detectedPlanes) {
                                B.dispatchEvent({
                                    type: "planesdetected",
                                    data: N.detectedPlanes
                                });
                                let _ = null;
                                for (let O of eo) N.detectedPlanes.has(O) || (null === _ && (_ = []), _.push(O));
                                if (null !== _)
                                    for (let O of _) eo.delete(O), el.delete(O), B.dispatchEvent({
                                        type: "planeremoved",
                                        data: O
                                    });
                                for (let _ of N.detectedPlanes)
                                    if (eo.has(_)) {
                                        let O = el.get(_);
                                        _.lastChangedTime > O && (el.set(_, _.lastChangedTime), B.dispatchEvent({
                                            type: "planechanged",
                                            data: _
                                        }))
                                    } else eo.add(_), el.set(_, N.lastChangedTime), B.dispatchEvent({
                                        type: "planeadded",
                                        data: _
                                    })
                            }
                            ee = null
                        }), this.setAnimationLoop = function(_) {
                            ex = _
                        }, this.dispose = function() {}
                    }
                };

            function yz(_, O) {
                function n(B, N) {
                    let k, F;
                    B.opacity.value = N.opacity, N.color && B.diffuse.value.copy(N.color), N.emissive && B.emissive.value.copy(N.emissive).multiplyScalar(N.emissiveIntensity), N.map && (B.map.value = N.map), N.alphaMap && (B.alphaMap.value = N.alphaMap), N.bumpMap && (B.bumpMap.value = N.bumpMap, B.bumpScale.value = N.bumpScale, 1 === N.side && (B.bumpScale.value *= -1)), N.displacementMap && (B.displacementMap.value = N.displacementMap, B.displacementScale.value = N.displacementScale, B.displacementBias.value = N.displacementBias), N.emissiveMap && (B.emissiveMap.value = N.emissiveMap), N.normalMap && (B.normalMap.value = N.normalMap, B.normalScale.value.copy(N.normalScale), 1 === N.side && B.normalScale.value.negate()), N.specularMap && (B.specularMap.value = N.specularMap), N.alphaTest > 0 && (B.alphaTest.value = N.alphaTest);
                    let U = O.get(N).envMap;
                    if (U && (B.envMap.value = U, B.flipEnvMap.value = U.isCubeTexture && !1 === U.isRenderTargetTexture ? -1 : 1, B.reflectivity.value = N.reflectivity, B.ior.value = N.ior, B.refractionRatio.value = N.refractionRatio), N.lightMap) {
                        B.lightMap.value = N.lightMap;
                        let O = !0 !== _.physicallyCorrectLights ? Math.PI : 1;
                        B.lightMapIntensity.value = N.lightMapIntensity * O
                    }
                    N.aoMap && (B.aoMap.value = N.aoMap, B.aoMapIntensity.value = N.aoMapIntensity), N.map ? k = N.map : N.specularMap ? k = N.specularMap : N.displacementMap ? k = N.displacementMap : N.normalMap ? k = N.normalMap : N.bumpMap ? k = N.bumpMap : N.roughnessMap ? k = N.roughnessMap : N.metalnessMap ? k = N.metalnessMap : N.alphaMap ? k = N.alphaMap : N.emissiveMap ? k = N.emissiveMap : N.clearcoatMap ? k = N.clearcoatMap : N.clearcoatNormalMap ? k = N.clearcoatNormalMap : N.clearcoatRoughnessMap ? k = N.clearcoatRoughnessMap : N.iridescenceMap ? k = N.iridescenceMap : N.iridescenceThicknessMap ? k = N.iridescenceThicknessMap : N.specularIntensityMap ? k = N.specularIntensityMap : N.specularColorMap ? k = N.specularColorMap : N.transmissionMap ? k = N.transmissionMap : N.thicknessMap ? k = N.thicknessMap : N.sheenColorMap ? k = N.sheenColorMap : N.sheenRoughnessMap && (k = N.sheenRoughnessMap), void 0 !== k && (k.isWebGLRenderTarget && (k = k.texture), !0 === k.matrixAutoUpdate && k.updateMatrix(), B.uvTransform.value.copy(k.matrix)), N.aoMap ? F = N.aoMap : N.lightMap && (F = N.lightMap), void 0 !== F && (F.isWebGLRenderTarget && (F = F.texture), !0 === F.matrixAutoUpdate && F.updateMatrix(), B.uv2Transform.value.copy(F.matrix))
                }
                return {
                    refreshFogUniforms: function(O, B) {
                        B.color.getRGB(O.fogColor.value, sM(_)), B.isFog ? (O.fogNear.value = B.near, O.fogFar.value = B.far) : B.isFogExp2 && (O.fogDensity.value = B.density)
                    },
                    refreshMaterialUniforms: function(_, B, N, k, F) {
                        let U, j;
                        B.isMeshBasicMaterial || B.isMeshLambertMaterial ? n(_, B) : B.isMeshToonMaterial ? (n(_, B), B.gradientMap && (_.gradientMap.value = B.gradientMap)) : B.isMeshPhongMaterial ? (n(_, B), _.specular.value.copy(B.specular), _.shininess.value = Math.max(B.shininess, 1e-4)) : B.isMeshStandardMaterial ? (n(_, B), _.roughness.value = B.roughness, _.metalness.value = B.metalness, B.roughnessMap && (_.roughnessMap.value = B.roughnessMap), B.metalnessMap && (_.metalnessMap.value = B.metalnessMap), O.get(B).envMap && (_.envMapIntensity.value = B.envMapIntensity), B.isMeshPhysicalMaterial && (_.ior.value = B.ior, B.sheen > 0 && (_.sheenColor.value.copy(B.sheenColor).multiplyScalar(B.sheen), _.sheenRoughness.value = B.sheenRoughness, B.sheenColorMap && (_.sheenColorMap.value = B.sheenColorMap), B.sheenRoughnessMap && (_.sheenRoughnessMap.value = B.sheenRoughnessMap)), B.clearcoat > 0 && (_.clearcoat.value = B.clearcoat, _.clearcoatRoughness.value = B.clearcoatRoughness, B.clearcoatMap && (_.clearcoatMap.value = B.clearcoatMap), B.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = B.clearcoatRoughnessMap), B.clearcoatNormalMap && (_.clearcoatNormalScale.value.copy(B.clearcoatNormalScale), _.clearcoatNormalMap.value = B.clearcoatNormalMap, 1 === B.side && _.clearcoatNormalScale.value.negate())), B.iridescence > 0 && (_.iridescence.value = B.iridescence, _.iridescenceIOR.value = B.iridescenceIOR, _.iridescenceThicknessMinimum.value = B.iridescenceThicknessRange[0], _.iridescenceThicknessMaximum.value = B.iridescenceThicknessRange[1], B.iridescenceMap && (_.iridescenceMap.value = B.iridescenceMap), B.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = B.iridescenceThicknessMap)), B.transmission > 0 && (_.transmission.value = B.transmission, _.transmissionSamplerMap.value = F.texture, _.transmissionSamplerSize.value.set(F.width, F.height), B.transmissionMap && (_.transmissionMap.value = B.transmissionMap), _.thickness.value = B.thickness, B.thicknessMap && (_.thicknessMap.value = B.thicknessMap), _.attenuationDistance.value = B.attenuationDistance, _.attenuationColor.value.copy(B.attenuationColor)), _.specularIntensity.value = B.specularIntensity, _.specularColor.value.copy(B.specularColor), B.specularIntensityMap && (_.specularIntensityMap.value = B.specularIntensityMap), B.specularColorMap && (_.specularColorMap.value = B.specularColorMap))) : B.isMeshMatcapMaterial ? (n(_, B), B.matcap && (_.matcap.value = B.matcap)) : B.isMeshDepthMaterial ? n(_, B) : B.isMeshDistanceMaterial ? (n(_, B), _.referencePosition.value.copy(B.referencePosition), _.nearDistance.value = B.nearDistance, _.farDistance.value = B.farDistance) : B.isMeshNormalMaterial ? n(_, B) : B.isLineBasicMaterial ? (_.diffuse.value.copy(B.color), _.opacity.value = B.opacity, B.isLineDashedMaterial && (_.dashSize.value = B.dashSize, _.totalSize.value = B.dashSize + B.gapSize, _.scale.value = B.scale)) : B.isPointsMaterial ? (_.diffuse.value.copy(B.color), _.opacity.value = B.opacity, _.size.value = B.size * N, _.scale.value = .5 * k, B.map && (_.map.value = B.map), B.alphaMap && (_.alphaMap.value = B.alphaMap), B.alphaTest > 0 && (_.alphaTest.value = B.alphaTest), B.map ? U = B.map : B.alphaMap && (U = B.alphaMap), void 0 !== U && (!0 === U.matrixAutoUpdate && U.updateMatrix(), _.uvTransform.value.copy(U.matrix))) : B.isSpriteMaterial ? (_.diffuse.value.copy(B.color), _.opacity.value = B.opacity, _.rotation.value = B.rotation, B.map && (_.map.value = B.map), B.alphaMap && (_.alphaMap.value = B.alphaMap), B.alphaTest > 0 && (_.alphaTest.value = B.alphaTest), B.map ? j = B.map : B.alphaMap && (j = B.alphaMap), void 0 !== j && (!0 === j.matrixAutoUpdate && j.updateMatrix(), _.uvTransform.value.copy(j.matrix))) : B.isShadowMaterial ? (_.color.value.copy(B.color), _.opacity.value = B.opacity) : B.isShaderMaterial && (B.uniformsNeedUpdate = !1)
                    }
                }
            }

            function vz(_, O, B, N) {
                let k = {},
                    F = {},
                    U = [],
                    j = B.isWebGL2 ? _.getParameter(35375) : 0;

                function m(_) {
                    let O = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof _ ? (O.boundary = 4, O.storage = 4) : _.isVector2 ? (O.boundary = 8, O.storage = 8) : _.isVector3 || _.isColor ? (O.boundary = 16, O.storage = 12) : _.isVector4 ? (O.boundary = 16, O.storage = 16) : _.isMatrix3 ? (O.boundary = 48, O.storage = 48) : _.isMatrix4 ? (O.boundary = 64, O.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), O
                }

                function g(O) {
                    let B = O.target;
                    B.removeEventListener("dispose", g);
                    let N = U.indexOf(B.__bindingPointIndex);
                    U.splice(N, 1), _.deleteBuffer(k[B.id]), delete k[B.id], delete F[B.id]
                }
                return {
                    bind: function(_, O) {
                        let B = O.program;
                        N.uniformBlockBinding(_, B)
                    },
                    update: function(B, G) {
                        let Y, Q, K, $, ee = k[B.id];
                        void 0 === ee && (function(_) {
                            let O = _.uniforms,
                                B = 0,
                                N = 0;
                            for (let _ = 0, k = O.length; _ < k; _++) {
                                let k = O[_],
                                    F = {
                                        boundary: 0,
                                        storage: 0
                                    },
                                    U = Array.isArray(k.value) ? k.value : [k.value];
                                for (let _ = 0, O = U.length; _ < O; _++) {
                                    let O = m(U[_]);
                                    F.boundary += O.boundary, F.storage += O.storage
                                }
                                if (k.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT), k.__offset = B, _ > 0) {
                                    let _ = 16 - (N = B % 16);
                                    0 !== N && _ - F.boundary < 0 && (B += 16 - N, k.__offset = B)
                                }
                                B += F.storage
                            }(N = B % 16) > 0 && (B += 16 - N), _.__size = B, _.__cache = {}
                        }(B), Y = function() {
                            for (let _ = 0; _ < j; _++)
                                if (-1 === U.indexOf(_)) return U.push(_), _;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }(), B.__bindingPointIndex = Y, Q = _.createBuffer(), K = B.__size, $ = B.usage, _.bindBuffer(35345, Q), _.bufferData(35345, K, $), _.bindBuffer(35345, null), _.bindBufferBase(35345, Y, Q), ee = Q, k[B.id] = ee, B.addEventListener("dispose", g));
                        let et = G.program;
                        N.updateUBOMapping(B, et);
                        let ei = O.render.frame;
                        F[B.id] !== ei && (function(O) {
                            let B = k[O.id],
                                N = O.uniforms,
                                F = O.__cache;
                            _.bindBuffer(35345, B);
                            for (let O = 0, B = N.length; O < B; O++) {
                                let B = N[O];
                                if (!0 === function(_, O, B) {
                                        let N = _.value;
                                        if (void 0 === B[O]) {
                                            if ("number" == typeof N) B[O] = N;
                                            else {
                                                let _ = Array.isArray(N) ? N : [N],
                                                    k = [];
                                                for (let O = 0; O < _.length; O++) k.push(_[O].clone());
                                                B[O] = k
                                            }
                                            return !0
                                        }
                                        if ("number" == typeof N) {
                                            if (B[O] !== N) return B[O] = N, !0
                                        } else {
                                            let _ = Array.isArray(B[O]) ? B[O] : [B[O]],
                                                k = Array.isArray(N) ? N : [N];
                                            for (let O = 0; O < _.length; O++) {
                                                let B = _[O];
                                                if (!1 === B.equals(k[O])) return B.copy(k[O]), !0
                                            }
                                        }
                                        return !1
                                    }(B, O, F)) {
                                    let O = B.__offset,
                                        N = Array.isArray(B.value) ? B.value : [B.value],
                                        k = 0;
                                    for (let F = 0; F < N.length; F++) {
                                        let U = N[F],
                                            j = m(U);
                                        "number" == typeof U ? (B.__data[0] = U, _.bufferSubData(35345, O + k, B.__data)) : U.isMatrix3 ? (B.__data[0] = U.elements[0], B.__data[1] = U.elements[1], B.__data[2] = U.elements[2], B.__data[3] = U.elements[0], B.__data[4] = U.elements[3], B.__data[5] = U.elements[4], B.__data[6] = U.elements[5], B.__data[7] = U.elements[0], B.__data[8] = U.elements[6], B.__data[9] = U.elements[7], B.__data[10] = U.elements[8], B.__data[11] = U.elements[0]) : (U.toArray(B.__data, k), k += j.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    _.bufferSubData(35345, O, B.__data)
                                }
                            }
                            _.bindBuffer(35345, null)
                        }(B), F[B.id] = ei)
                    },
                    dispose: function() {
                        for (let O in k) _.deleteBuffer(k[O]);
                        U = [], k = {}, F = {}
                    }
                }
            }

            function tw(_ = {}) {
                let O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei, er, ea, en, eo, el, eh, ec, eu, ep, ef;
                this.isWebGLRenderer = !0;
                let em = void 0 !== _.canvas ? _.canvas : ((ef = fg("canvas")).style.display = "block", ef),
                    eg = void 0 !== _.context ? _.context : null,
                    ev = void 0 === _.depth || _.depth,
                    ex = void 0 === _.stencil || _.stencil,
                    eb = void 0 !== _.antialias && _.antialias,
                    e_ = void 0 === _.premultipliedAlpha || _.premultipliedAlpha,
                    eS = void 0 !== _.preserveDrawingBuffer && _.preserveDrawingBuffer,
                    eA = void 0 !== _.powerPreference ? _.powerPreference : "default",
                    eM = void 0 !== _.failIfMajorPerformanceCaveat && _.failIfMajorPerformanceCaveat,
                    eE;
                eE = null !== eg ? eg.getContextAttributes().alpha : void 0 !== _.alpha && _.alpha;
                let eC = null,
                    eT = null,
                    eD = [],
                    eP = [];
                this.domElement = em, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                let eI = this,
                    eO = !1,
                    eL = 0,
                    eR = 0,
                    eB = null,
                    eN = -1,
                    ek = null,
                    eF = new rl,
                    eU = new rl,
                    ej = null,
                    eG = em.width,
                    eH = em.height,
                    eW = 1,
                    eq = null,
                    eY = null,
                    eX = new rl(0, 0, eG, eH),
                    eQ = new rl(0, 0, eG, eH),
                    eZ = !1,
                    eK = new aw,
                    eJ = !1,
                    e$ = !1,
                    e0 = null,
                    e1 = new rJ,
                    e2 = new iJ,
                    e3 = new rv,
                    e4 = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function q() {
                    return null === eB ? eW : 1
                }
                let e5 = eg;

                function J(_, O) {
                    for (let B = 0; B < _.length; B++) {
                        let N = _[B],
                            k = em.getContext(N, O);
                        if (null !== k) return k
                    }
                    return null
                }
                try {
                    if ("setAttribute" in em && em.setAttribute("data-engine", "three.js r149"), em.addEventListener("webglcontextlost", We, !1), em.addEventListener("webglcontextrestored", $e, !1), em.addEventListener("webglcontextcreationerror", _t, !1), null === e5) {
                        let _ = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === eI.isWebGL1Renderer && _.shift(), e5 = J(_, {
                                alpha: !0,
                                depth: ev,
                                stencil: ex,
                                antialias: eb,
                                premultipliedAlpha: e_,
                                preserveDrawingBuffer: eS,
                                powerPreference: eA,
                                failIfMajorPerformanceCaveat: eM
                            }), null === e5) throw J(_) ? Error("Error creating WebGL context with your selected attributes.") : Error("Error creating WebGL context.")
                    }
                    void 0 === e5.getShaderPrecisionFormat && (e5.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (_) {
                    throw console.error("THREE.WebGLRenderer: " + _.message), _
                }

                function ke() {
                    O = new zk(e5), B = new Lk(e5, O, _), O.init(B), ec = new mz(e5, O, B), N = new fz(e5, O, B), k = new Hk, F = new tz, U = new pz(e5, O, N, F, B, ec, k), j = new Bk(eI), G = new Vk(eI), Y = new JN(e5, B), eu = new Ok(e5, O, Y, B), Q = new Uk(e5, Y, k, eu), K = new Yk(e5, Q, Y, k), eo = new qk(e5, B, U), er = new Nk(F), $ = new ez(eI, j, G, O, B, eu, er), ee = new yz(eI, F), et = new nz, ei = new cz(O, B), en = new Ik(eI, j, G, N, K, eE, e_), ea = new dz(eI, K, B), ep = new vz(e5, k, B, N), el = new Rk(e5, O, k, B), eh = new Gk(e5, O, k, B), k.programs = $.programs, eI.capabilities = B, eI.extensions = O, eI.properties = F, eI.renderLists = et, eI.shadowMap = ea, eI.state = N, eI.info = k
                }
                ke();
                let e6 = new nw(eI, e5);

                function We(_) {
                    _.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), eO = !0
                }

                function $e() {
                    console.log("THREE.WebGLRenderer: Context Restored."), eO = !1;
                    let _ = k.autoReset,
                        O = ea.enabled,
                        B = ea.autoUpdate,
                        N = ea.needsUpdate,
                        F = ea.type;
                    ke(), k.autoReset = _, ea.enabled = O, ea.autoUpdate = B, ea.needsUpdate = N, ea.type = F
                }

                function _t(_) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", _.statusMessage)
                }

                function ir(_) {
                    let O, B = _.target;
                    B.removeEventListener("dispose", ir), void 0 !== (O = F.get(B).programs) && (O.forEach(function(_) {
                        $.releaseProgram(_)
                    }), B.isShaderMaterial && $.releaseShaderCache(B)), F.remove(B)
                }
                this.xr = e6, this.getContext = function() {
                    return e5
                }, this.getContextAttributes = function() {
                    return e5.getContextAttributes()
                }, this.forceContextLoss = function() {
                    let _ = O.get("WEBGL_lose_context");
                    _ && _.loseContext()
                }, this.forceContextRestore = function() {
                    let _ = O.get("WEBGL_lose_context");
                    _ && _.restoreContext()
                }, this.getPixelRatio = function() {
                    return eW
                }, this.setPixelRatio = function(_) {
                    void 0 !== _ && (eW = _, this.setSize(eG, eH, !1))
                }, this.getSize = function(_) {
                    return _.set(eG, eH)
                }, this.setSize = function(_, O, B) {
                    if (e6.isPresenting) {
                        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                        return
                    }
                    eG = _, eH = O, em.width = Math.floor(_ * eW), em.height = Math.floor(O * eW), !1 !== B && (em.style.width = _ + "px", em.style.height = O + "px"), this.setViewport(0, 0, _, O)
                }, this.getDrawingBufferSize = function(_) {
                    return _.set(eG * eW, eH * eW).floor()
                }, this.setDrawingBufferSize = function(_, O, B) {
                    eG = _, eH = O, eW = B, em.width = Math.floor(_ * B), em.height = Math.floor(O * B), this.setViewport(0, 0, _, O)
                }, this.getCurrentViewport = function(_) {
                    return _.copy(eF)
                }, this.getViewport = function(_) {
                    return _.copy(eX)
                }, this.setViewport = function(_, O, B, k) {
                    _.isVector4 ? eX.set(_.x, _.y, _.z, _.w) : eX.set(_, O, B, k), N.viewport(eF.copy(eX).multiplyScalar(eW).floor())
                }, this.getScissor = function(_) {
                    return _.copy(eQ)
                }, this.setScissor = function(_, O, B, k) {
                    _.isVector4 ? eQ.set(_.x, _.y, _.z, _.w) : eQ.set(_, O, B, k), N.scissor(eU.copy(eQ).multiplyScalar(eW).floor())
                }, this.getScissorTest = function() {
                    return eZ
                }, this.setScissorTest = function(_) {
                    N.setScissorTest(eZ = _)
                }, this.setOpaqueSort = function(_) {
                    eq = _
                }, this.setTransparentSort = function(_) {
                    eY = _
                }, this.getClearColor = function(_) {
                    return _.copy(en.getClearColor())
                }, this.setClearColor = function() {
                    en.setClearColor.apply(en, arguments)
                }, this.getClearAlpha = function() {
                    return en.getClearAlpha()
                }, this.setClearAlpha = function() {
                    en.setClearAlpha.apply(en, arguments)
                }, this.clear = function(_ = !0, O = !0, B = !0) {
                    let N = 0;
                    _ && (N |= 16384), O && (N |= 256), B && (N |= 1024), e5.clear(N)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    em.removeEventListener("webglcontextlost", We, !1), em.removeEventListener("webglcontextrestored", $e, !1), em.removeEventListener("webglcontextcreationerror", _t, !1), et.dispose(), ei.dispose(), F.dispose(), j.dispose(), G.dispose(), K.dispose(), eu.dispose(), ep.dispose(), $.dispose(), e6.dispose(), e6.removeEventListener("sessionstart", Ve), e6.removeEventListener("sessionend", Fe), e0 && (e0.dispose(), e0 = null), e9.stop()
                }, this.renderBufferDirect = function(_, O, k, K, $, et) {
                    null === O && (O = e4);
                    let ei = $.isMesh && 0 > $.matrixWorld.determinant(),
                        ea = function(_, O, k, Y, Q) {
                            var K;
                            !0 !== O.isScene && (O = e4), U.resetTextureUnits();
                            let $ = O.fog,
                                et = Y.isMeshStandardMaterial ? O.environment : null,
                                ei = null === eB ? eI.outputEncoding : !0 === eB.isXRRenderTarget ? eB.texture.encoding : 3e3,
                                ea = (Y.isMeshStandardMaterial ? G : j).get(Y.envMap || et),
                                en = !0 === Y.vertexColors && !!k.attributes.color && 4 === k.attributes.color.itemSize,
                                el = !!Y.normalMap && !!k.attributes.tangent,
                                eh = !!k.morphAttributes.position,
                                ec = !!k.morphAttributes.normal,
                                eu = !!k.morphAttributes.color,
                                ef = Y.toneMapped ? eI.toneMapping : 0,
                                em = k.morphAttributes.position || k.morphAttributes.normal || k.morphAttributes.color,
                                eg = void 0 !== em ? em.length : 0,
                                ev = F.get(Y),
                                ex = eT.state.lights;
                            if (!0 === eJ && (!0 === e$ || _ !== ek)) {
                                let O = _ === ek && Y.id === eN;
                                er.setState(Y, _, O)
                            }
                            let eb = !1;
                            Y.version === ev.__version ? (ev.needsLights && ev.lightsStateVersion !== ex.state.version || ev.outputEncoding !== ei || Q.isInstancedMesh && !1 === ev.instancing || !Q.isInstancedMesh && !0 === ev.instancing || Q.isSkinnedMesh && !1 === ev.skinning || !Q.isSkinnedMesh && !0 === ev.skinning || ev.envMap !== ea || !0 === Y.fog && ev.fog !== $ || void 0 !== ev.numClippingPlanes && (ev.numClippingPlanes !== er.numPlanes || ev.numIntersection !== er.numIntersection) || ev.vertexAlphas !== en || ev.vertexTangents !== el || ev.morphTargets !== eh || ev.morphNormals !== ec || ev.morphColors !== eu || ev.toneMapping !== ef || !0 === B.isWebGL2 && ev.morphTargetsCount !== eg) && (eb = !0) : (eb = !0, ev.__version = Y.version);
                            let e_ = ev.currentProgram;
                            !0 === eb && (e_ = Vi(Y, O, Q));
                            let eS = !1,
                                eA = !1,
                                eM = !1,
                                eE = e_.getUniforms(),
                                eC = ev.uniforms;
                            if (N.useProgram(e_.program) && (eS = !0, eA = !0, eM = !0), Y.id !== eN && (eN = Y.id, eA = !0), eS || ek !== _) {
                                if (eE.setValue(e5, "projectionMatrix", _.projectionMatrix), B.logarithmicDepthBuffer && eE.setValue(e5, "logDepthBufFC", 2 / (Math.log(_.far + 1) / Math.LN2)), ek !== _ && (ek = _, eA = !0, eM = !0), Y.isShaderMaterial || Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshStandardMaterial || Y.envMap) {
                                    let O = eE.map.cameraPosition;
                                    void 0 !== O && O.setValue(e5, e3.setFromMatrixPosition(_.matrixWorld))
                                }(Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && eE.setValue(e5, "isOrthographic", !0 === _.isOrthographicCamera), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial || Y.isShadowMaterial || Q.isSkinnedMesh) && eE.setValue(e5, "viewMatrix", _.matrixWorldInverse)
                            }
                            if (Q.isSkinnedMesh) {
                                eE.setOptional(e5, Q, "bindMatrix"), eE.setOptional(e5, Q, "bindMatrixInverse");
                                let _ = Q.skeleton;
                                _ && (B.floatVertexTextures ? (null === _.boneTexture && _.computeBoneTexture(), eE.setValue(e5, "boneTexture", _.boneTexture, U), eE.setValue(e5, "boneTextureSize", _.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            let eD = k.morphAttributes;
                            if ((void 0 !== eD.position || void 0 !== eD.normal || void 0 !== eD.color && !0 === B.isWebGL2) && eo.update(Q, k, Y, e_), (eA || ev.receiveShadow !== Q.receiveShadow) && (ev.receiveShadow = Q.receiveShadow, eE.setValue(e5, "receiveShadow", Q.receiveShadow)), Y.isMeshGouraudMaterial && null !== Y.envMap && (eC.envMap.value = ea, eC.flipEnvMap.value = ea.isCubeTexture && !1 === ea.isRenderTargetTexture ? -1 : 1), eA && (eE.setValue(e5, "toneMappingExposure", eI.toneMappingExposure), ev.needsLights && (K = eM, eC.ambientLightColor.needsUpdate = K, eC.lightProbe.needsUpdate = K, eC.directionalLights.needsUpdate = K, eC.directionalLightShadows.needsUpdate = K, eC.pointLights.needsUpdate = K, eC.pointLightShadows.needsUpdate = K, eC.spotLights.needsUpdate = K, eC.spotLightShadows.needsUpdate = K, eC.rectAreaLights.needsUpdate = K, eC.hemisphereLights.needsUpdate = K), $ && !0 === Y.fog && ee.refreshFogUniforms(eC, $), ee.refreshMaterialUniforms(eC, Y, eW, eH, e0), a5.upload(e5, ev.uniformsList, eC, U)), Y.isShaderMaterial && !0 === Y.uniformsNeedUpdate && (a5.upload(e5, ev.uniformsList, eC, U), Y.uniformsNeedUpdate = !1), Y.isSpriteMaterial && eE.setValue(e5, "center", Q.center), eE.setValue(e5, "modelViewMatrix", Q.modelViewMatrix), eE.setValue(e5, "normalMatrix", Q.normalMatrix), eE.setValue(e5, "modelMatrix", Q.matrixWorld), Q.previousModelViewMatrix && eE.setValue(e5, "previousModelViewMatrix", Q.previousModelViewMatrix), _.previousProjectionMatrix && eE.setValue(e5, "previousProjectionMatrix", _.previousProjectionMatrix), Y.isShaderMaterial || Y.isRawShaderMaterial) {
                                let _ = Y.uniformsGroups;
                                for (let O = 0, N = _.length; O < N; O++)
                                    if (B.isWebGL2) {
                                        let B = _[O];
                                        ep.update(B, e_), ep.bind(B, e_)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return e_
                        }(_, O, k, K, $);
                    N.setMaterial(K, ei);
                    let en = k.index,
                        ec = 1;
                    !0 === K.wireframe && (en = Q.getWireframeAttribute(k), ec = 2);
                    let ef = k.drawRange,
                        em = k.attributes.position,
                        eg = ef.start * ec,
                        ev = (ef.start + ef.count) * ec;
                    null !== et && (eg = Math.max(eg, et.start * ec), ev = Math.min(ev, (et.start + et.count) * ec)), null !== en ? (eg = Math.max(eg, 0), ev = Math.min(ev, en.count)) : null != em && (eg = Math.max(eg, 0), ev = Math.min(ev, em.count));
                    let ex = ev - eg;
                    if (ex < 0 || ex === 1 / 0) return;
                    eu.setup($, K, ea, k, en);
                    let eb, e_ = el;
                    if (null !== en && (eb = Y.get(en), (e_ = eh).setIndex(eb)), $.isMesh) !0 === K.wireframe ? (N.setLineWidth(K.wireframeLinewidth * q()), e_.setMode(1)) : e_.setMode(4);
                    else if ($.isLine) {
                        let _ = K.linewidth;
                        void 0 === _ && (_ = 1), N.setLineWidth(_ * q()), $.isLineSegments ? e_.setMode(1) : $.isLineLoop ? e_.setMode(2) : e_.setMode(3)
                    } else $.isPoints ? e_.setMode(0) : $.isSprite && e_.setMode(4);
                    if ($.isInstancedMesh) e_.renderInstances(eg, ex, $.count);
                    else if (k.isInstancedBufferGeometry) {
                        let _ = void 0 !== k._maxInstanceCount ? k._maxInstanceCount : 1 / 0,
                            O = Math.min(k.instanceCount, _);
                        e_.renderInstances(eg, ex, O)
                    } else e_.render(eg, ex)
                }, this.compile = function(_, O) {
                    function he(_, O, B) {
                        !0 === _.transparent && 2 === _.side && !1 === _.forceSinglePass ? (_.side = 1, _.needsUpdate = !0, Vi(_, O, B), _.side = 0, _.needsUpdate = !0, Vi(_, O, B), _.side = 2) : Vi(_, O, B)
                    }(eT = ei.get(_)).init(), eP.push(eT), _.traverseVisible(function(_) {
                        _.isLight && _.layers.test(O.layers) && (eT.pushLight(_), _.castShadow && eT.pushShadow(_))
                    }), eT.setupLights(eI.physicallyCorrectLights), _.traverse(function(O) {
                        let B = O.material;
                        if (B) {
                            if (Array.isArray(B))
                                for (let N = 0; N < B.length; N++) he(B[N], _, O);
                            else he(B, _, O)
                        }
                    }), eP.pop(), eT = null
                };
                let e8 = null;

                function Ve() {
                    e9.stop()
                }

                function Fe() {
                    e9.start()
                }
                let e9 = new oM;

                function Pr(_, k, F, j) {
                    let G, Y, Q, K = _.opaque,
                        $ = _.transmissive,
                        ee = _.transparent;
                    eT.setupLightsView(F), !0 === eJ && er.setGlobalState(eI.clippingPlanes, F), $.length > 0 && (G = B.isWebGL2, null === e0 && (e0 = new rh(1, 1, {
                        generateMipmaps: !0,
                        type: O.has("EXT_color_buffer_half_float") ? 1016 : 1009,
                        minFilter: 1008,
                        samples: G && !0 === eb ? 4 : 0
                    })), eI.getDrawingBufferSize(e2), G ? e0.setSize(e2.x, e2.y) : e0.setSize(dg(e2.x), dg(e2.y)), Y = eI.getRenderTarget(), eI.setRenderTarget(e0), eI.clear(), Q = eI.toneMapping, eI.toneMapping = 0, hr(K, k, F), eI.toneMapping = Q, U.updateMultisampleRenderTarget(e0), U.updateRenderTargetMipmap(e0), eI.setRenderTarget(Y)), j && N.viewport(eF.copy(j)), K.length > 0 && hr(K, k, F), $.length > 0 && hr($, k, F), ee.length > 0 && hr(ee, k, F), N.buffers.depth.setTest(!0), N.buffers.depth.setMask(!0), N.buffers.color.setMask(!0), N.setPolygonOffset(!1)
                }

                function hr(_, O, B) {
                    let N = !0 === O.isScene ? O.overrideMaterial : null;
                    for (let k = 0, F = _.length; k < F; k++) {
                        let F = _[k],
                            U = F.object,
                            j = F.geometry,
                            G = null === N ? F.material : N,
                            Y = F.group;
                        U.layers.test(B.layers) && (U.onBeforeRender(eI, O, B, j, G, Y), U.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, U.matrixWorld), U.normalMatrix.getNormalMatrix(U.modelViewMatrix), G.onBeforeRender(eI, O, B, j, U, Y), !0 === G.transparent && 2 === G.side && !1 === G.forceSinglePass ? (G.side = 1, G.needsUpdate = !0, eI.renderBufferDirect(B, O, j, G, U, Y), G.side = 0, G.needsUpdate = !0, eI.renderBufferDirect(B, O, j, G, U, Y), G.side = 2) : eI.renderBufferDirect(B, O, j, G, U, Y), U.onAfterRender(eI, O, B, j, G, Y))
                    }
                }

                function Vi(_, O, B) {
                    !0 !== O.isScene && (O = e4);
                    let N = F.get(_),
                        k = eT.state.lights,
                        U = eT.state.shadowsArray,
                        Y = k.state.version,
                        Q = $.getParameters(_, k.state, U, O, B),
                        K = $.getProgramCacheKey(Q),
                        ee = N.programs;
                    N.environment = _.isMeshStandardMaterial ? O.environment : null, N.fog = O.fog, N.envMap = (_.isMeshStandardMaterial ? G : j).get(_.envMap || N.environment), void 0 === ee && (_.addEventListener("dispose", ir), ee = new Map, N.programs = ee);
                    let et = ee.get(K);
                    if (void 0 !== et) {
                        if (N.currentProgram === et && N.lightsStateVersion === Y) return g_(_, Q), et
                    } else Q.uniforms = $.getUniforms(_), _.onBuild(B, Q, eI), _.onBeforeCompile(Q, eI), et = $.acquireProgram(Q, K), ee.set(K, et), N.uniforms = Q.uniforms;
                    let ei = N.uniforms;
                    (_.isShaderMaterial || _.isRawShaderMaterial) && !0 !== _.clipping || (ei.clippingPlanes = er.uniform), g_(_, Q), N.needsLights = _.isMeshLambertMaterial || _.isMeshToonMaterial || _.isMeshPhongMaterial || _.isMeshStandardMaterial || _.isShadowMaterial || _.isShaderMaterial && !0 === _.lights, N.lightsStateVersion = Y, N.needsLights && (ei.ambientLightColor.value = k.state.ambient, ei.lightProbe.value = k.state.probe, ei.directionalLights.value = k.state.directional, ei.directionalLightShadows.value = k.state.directionalShadow, ei.spotLights.value = k.state.spot, ei.spotLightShadows.value = k.state.spotShadow, ei.rectAreaLights.value = k.state.rectArea, ei.ltc_1.value = k.state.rectAreaLTC1, ei.ltc_2.value = k.state.rectAreaLTC2, ei.pointLights.value = k.state.point, ei.pointLightShadows.value = k.state.pointShadow, ei.hemisphereLights.value = k.state.hemi, ei.directionalShadowMap.value = k.state.directionalShadowMap, ei.directionalShadowMatrix.value = k.state.directionalShadowMatrix, ei.spotShadowMap.value = k.state.spotShadowMap, ei.spotLightMatrix.value = k.state.spotLightMatrix, ei.spotLightMap.value = k.state.spotLightMap, ei.pointShadowMap.value = k.state.pointShadowMap, ei.pointShadowMatrix.value = k.state.pointShadowMatrix);
                    let ea = et.getUniforms(),
                        en = a5.seqWithValue(ea.seq, ei);
                    return N.currentProgram = et, N.uniformsList = en, et
                }

                function g_(_, O) {
                    let B = F.get(_);
                    B.outputEncoding = O.outputEncoding, B.instancing = O.instancing, B.skinning = O.skinning, B.morphTargets = O.morphTargets, B.morphNormals = O.morphNormals, B.morphColors = O.morphColors, B.morphTargetsCount = O.morphTargetsCount, B.numClippingPlanes = O.numClippingPlanes, B.numIntersection = O.numClipIntersection, B.vertexAlphas = O.vertexAlphas, B.vertexTangents = O.vertexTangents, B.toneMapping = O.toneMapping
                }
                e9.setAnimationLoop(function(_) {
                    e8 && e8(_)
                }), "u" > typeof self && e9.setContext(self), this.setAnimationLoop = function(_) {
                    e8 = _, e6.setAnimationLoop(_), null === _ ? e9.stop() : e9.start()
                }, e6.addEventListener("sessionstart", Ve), e6.addEventListener("sessionend", Fe), this.render = function(_, O) {
                    if (void 0 !== O && !0 !== O.isCamera) {
                        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        return
                    }
                    if (!0 === eO) return;
                    !0 === _.matrixWorldAutoUpdate && _.updateMatrixWorld(), null === O.parent && !0 === O.matrixWorldAutoUpdate && O.updateMatrixWorld(), !0 === e6.enabled && !0 === e6.isPresenting && (!0 === e6.cameraAutoUpdate && e6.updateCamera(O), O = e6.getCamera()), !0 === _.isScene && _.onBeforeRender(eI, _, O, eB), (eT = ei.get(_, eP.length)).init(), eP.push(eT), e1.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), eK.setFromProjectionMatrix(e1), e$ = this.localClippingEnabled, eJ = er.init(this.clippingPlanes, e$), (eC = et.get(_, eD.length)).init(), eD.push(eC),
                        function Hr(_, O, B, N) {
                            if (!1 === _.visible) return;
                            if (_.layers.test(O.layers)) {
                                if (_.isGroup) B = _.renderOrder;
                                else if (_.isLOD) !0 === _.autoUpdate && _.update(O);
                                else if (_.isLight) eT.pushLight(_), _.castShadow && eT.pushShadow(_);
                                else if (_.isSprite) {
                                    if (!_.frustumCulled || eK.intersectsSprite(_)) {
                                        N && e3.setFromMatrixPosition(_.matrixWorld).applyMatrix4(e1);
                                        let O = K.update(_),
                                            k = _.material;
                                        k.visible && eC.push(_, O, k, B, e3.z, null)
                                    }
                                } else if ((_.isMesh || _.isLine || _.isPoints) && (_.isSkinnedMesh && _.skeleton.frame !== k.render.frame && (_.skeleton.update(), _.skeleton.frame = k.render.frame), !_.frustumCulled || eK.intersectsObject(_))) {
                                    N && e3.setFromMatrixPosition(_.matrixWorld).applyMatrix4(e1);
                                    let O = K.update(_),
                                        k = _.material;
                                    if (Array.isArray(k)) {
                                        let N = O.groups;
                                        for (let F = 0, U = N.length; F < U; F++) {
                                            let U = N[F],
                                                j = k[U.materialIndex];
                                            j && j.visible && eC.push(_, O, j, B, e3.z, U)
                                        }
                                    } else k.visible && eC.push(_, O, k, B, e3.z, null)
                                }
                            }
                            let F = _.children;
                            for (let _ = 0, k = F.length; _ < k; _++) Hr(F[_], O, B, N)
                        }(_, O, 0, eI.sortObjects), eC.finish(), !0 === eI.sortObjects && eC.sort(eq, eY), !0 === eJ && er.beginShadows();
                    let B = eT.state.shadowsArray;
                    if (ea.render(B, _, O), !0 === eJ && er.endShadows(), !0 === this.info.autoReset && this.info.reset(), en.render(eC, _), eT.setupLights(eI.physicallyCorrectLights), O.isArrayCamera) {
                        let B = O.cameras;
                        for (let O = 0, N = B.length; O < N; O++) {
                            let N = B[O];
                            Pr(eC, _, N, N.viewport)
                        }
                    } else Pr(eC, _, O);
                    null !== eB && (U.updateMultisampleRenderTarget(eB), U.updateRenderTargetMipmap(eB)), !0 === _.isScene && _.onAfterRender(eI, _, O), eu.resetDefaultState(), eN = -1, ek = null, eP.pop(), eT = eP.length > 0 ? eP[eP.length - 1] : null, eD.pop(), eC = eD.length > 0 ? eD[eD.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return eL
                }, this.getActiveMipmapLevel = function() {
                    return eR
                }, this.getRenderTarget = function() {
                    return eB
                }, this.setRenderTargetTextures = function(_, B, N) {
                    F.get(_.texture).__webglTexture = B, F.get(_.depthTexture).__webglTexture = N;
                    let k = F.get(_);
                    k.__hasExternalTextures = !0, k.__hasExternalTextures && (k.__autoAllocateDepthBuffer = void 0 === N, k.__autoAllocateDepthBuffer || !0 === O.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), k.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function(_, O) {
                    let B = F.get(_);
                    B.__webglFramebuffer = O, B.__useDefaultFramebuffer = void 0 === O
                }, this.setRenderTarget = function(_, O = 0, k = 0) {
                    eB = _, eL = O, eR = k;
                    let j = !0,
                        G = null,
                        Y = !1,
                        Q = !1;
                    if (_) {
                        let k = F.get(_);
                        void 0 !== k.__useDefaultFramebuffer ? (N.bindFramebuffer(36160, null), j = !1) : void 0 === k.__webglFramebuffer ? U.setupRenderTarget(_) : k.__hasExternalTextures && U.rebindTextures(_, F.get(_.texture).__webglTexture, F.get(_.depthTexture).__webglTexture);
                        let K = _.texture;
                        (K.isData3DTexture || K.isDataArrayTexture || K.isCompressedArrayTexture) && (Q = !0);
                        let $ = F.get(_).__webglFramebuffer;
                        _.isWebGLCubeRenderTarget ? (G = $[O], Y = !0) : G = B.isWebGL2 && _.samples > 0 && !1 === U.useMultisampledRTT(_) ? F.get(_).__webglMultisampledFramebuffer : $, eF.copy(_.viewport), eU.copy(_.scissor), ej = _.scissorTest
                    } else eF.copy(eX).multiplyScalar(eW).floor(), eU.copy(eQ).multiplyScalar(eW).floor(), ej = eZ;
                    if (N.bindFramebuffer(36160, G) && B.drawBuffers && j && N.drawBuffers(_, G), N.viewport(eF), N.scissor(eU), N.setScissorTest(ej), Y) {
                        let B = F.get(_.texture);
                        e5.framebufferTexture2D(36160, 36064, 34069 + O, B.__webglTexture, k)
                    } else if (Q) {
                        let B = F.get(_.texture),
                            N = O || 0;
                        e5.framebufferTextureLayer(36160, 36064, B.__webglTexture, k || 0, N)
                    }
                    eN = -1
                }, this.readRenderTargetPixels = function(_, k, U, j, G, Y, Q) {
                    if (!(_ && _.isWebGLRenderTarget)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        return
                    }
                    let K = F.get(_).__webglFramebuffer;
                    if (_.isWebGLCubeRenderTarget && void 0 !== Q && (K = K[Q]), K) {
                        N.bindFramebuffer(36160, K);
                        try {
                            let N = _.texture,
                                F = N.format,
                                Q = N.type;
                            if (1023 !== F && ec.convert(F) !== e5.getParameter(35739)) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                return
                            }
                            let K = 1016 === Q && (O.has("EXT_color_buffer_half_float") || B.isWebGL2 && O.has("EXT_color_buffer_float"));
                            if (1009 !== Q && ec.convert(Q) !== e5.getParameter(35738) && !(1015 === Q && (B.isWebGL2 || O.has("OES_texture_float") || O.has("WEBGL_color_buffer_float"))) && !K) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                return
                            }
                            k >= 0 && k <= _.width - j && U >= 0 && U <= _.height - G && e5.readPixels(k, U, j, G, ec.convert(F), ec.convert(Q), Y)
                        } finally {
                            let _ = null !== eB ? F.get(eB).__webglFramebuffer : null;
                            N.bindFramebuffer(36160, _)
                        }
                    }
                }, this.copyFramebufferToTexture = function(_, O, B = 0) {
                    let k = Math.pow(2, -B),
                        F = Math.floor(O.image.width * k),
                        j = Math.floor(O.image.height * k);
                    U.setTexture2D(O, 0), e5.copyTexSubImage2D(3553, B, 0, 0, _.x, _.y, F, j), N.unbindTexture()
                }, this.copyTextureToTexture = function(_, O, B, k = 0) {
                    let F = O.image.width,
                        j = O.image.height,
                        G = ec.convert(B.format),
                        Y = ec.convert(B.type);
                    U.setTexture2D(B, 0), e5.pixelStorei(37440, B.flipY), e5.pixelStorei(37441, B.premultiplyAlpha), e5.pixelStorei(3317, B.unpackAlignment), O.isDataTexture ? e5.texSubImage2D(3553, k, _.x, _.y, F, j, G, Y, O.image.data) : O.isCompressedTexture ? e5.compressedTexSubImage2D(3553, k, _.x, _.y, O.mipmaps[0].width, O.mipmaps[0].height, G, O.mipmaps[0].data) : e5.texSubImage2D(3553, k, _.x, _.y, G, Y, O.image), 0 === k && B.generateMipmaps && e5.generateMipmap(3553), N.unbindTexture()
                }, this.copyTextureToTexture3D = function(_, O, B, k, F = 0) {
                    if (eI.isWebGL1Renderer) {
                        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        return
                    }
                    let j = _.max.x - _.min.x + 1,
                        G = _.max.y - _.min.y + 1,
                        Y = _.max.z - _.min.z + 1,
                        Q = ec.convert(k.format),
                        K = ec.convert(k.type),
                        $;
                    if (k.isData3DTexture) U.setTexture3D(k, 0), $ = 32879;
                    else if (k.isDataArrayTexture) U.setTexture2DArray(k, 0), $ = 35866;
                    else {
                        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        return
                    }
                    e5.pixelStorei(37440, k.flipY), e5.pixelStorei(37441, k.premultiplyAlpha), e5.pixelStorei(3317, k.unpackAlignment);
                    let ee = e5.getParameter(3314),
                        et = e5.getParameter(32878),
                        ei = e5.getParameter(3316),
                        er = e5.getParameter(3315),
                        ea = e5.getParameter(32877),
                        en = B.isCompressedTexture ? B.mipmaps[0] : B.image;
                    e5.pixelStorei(3314, en.width), e5.pixelStorei(32878, en.height), e5.pixelStorei(3316, _.min.x), e5.pixelStorei(3315, _.min.y), e5.pixelStorei(32877, _.min.z), B.isDataTexture || B.isData3DTexture ? e5.texSubImage3D($, F, O.x, O.y, O.z, j, G, Y, Q, K, en.data) : B.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), e5.compressedTexSubImage3D($, F, O.x, O.y, O.z, j, G, Y, Q, en.data)) : e5.texSubImage3D($, F, O.x, O.y, O.z, j, G, Y, Q, K, en), e5.pixelStorei(3314, ee), e5.pixelStorei(32878, et), e5.pixelStorei(3316, ei), e5.pixelStorei(3315, er), e5.pixelStorei(32877, ea), 0 === F && k.generateMipmaps && e5.generateMipmap($), N.unbindTexture()
                }, this.initTexture = function(_) {
                    _.isCubeTexture ? U.setTextureCube(_, 0) : _.isData3DTexture ? U.setTexture3D(_, 0) : _.isDataArrayTexture || _.isCompressedArrayTexture ? U.setTexture2DArray(_, 0) : U.setTexture2D(_, 0), N.unbindTexture()
                }, this.resetState = function() {
                    eL = 0, eR = 0, eB = null, N.reset(), eu.reset()
                }, "u" > typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }(class extends tw {}).prototype.isWebGL1Renderer = !0;
            var n_ = class {
                    constructor(_, O = 1, B = 1e3) {
                        this.isFog = !0, this.name = "", this.color = new re(_), this.near = O, this.far = B
                    }
                    clone() {
                        return new n_(this.color, this.near, this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                },
                nS = class extends sv {
                    constructor() {
                        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "u" > typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: this
                        }))
                    }
                    copy(_, O) {
                        return super.copy(_, O), null !== _.background && (this.background = _.background.clone()), null !== _.environment && (this.environment = _.environment.clone()), null !== _.fog && (this.fog = _.fog.clone()), this.backgroundBlurriness = _.backgroundBlurriness, this.backgroundIntensity = _.backgroundIntensity, null !== _.overrideMaterial && (this.overrideMaterial = _.overrideMaterial.clone()), this.matrixAutoUpdate = _.matrixAutoUpdate, this
                    }
                    toJSON(_) {
                        let O = super.toJSON(_);
                        return null !== this.fog && (O.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (O.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (O.object.backgroundIntensity = this.backgroundIntensity), O
                    }
                    get autoUpdate() {
                        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
                    }
                    set autoUpdate(_) {
                        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = _
                    }
                },
                nE = class {
                    constructor(_, O) {
                        this.isInterleavedBuffer = !0, this.array = _, this.stride = O, this.count = void 0 !== _ ? _.length / O : 0, this.usage = 35044, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0, this.uuid = Ui()
                    }
                    onUploadCallback() {}
                    set needsUpdate(_) {
                        !0 === _ && this.version++
                    }
                    setUsage(_) {
                        return this.usage = _, this
                    }
                    copy(_) {
                        return this.array = new _.array.constructor(_.array), this.count = _.count, this.stride = _.stride, this.usage = _.usage, this
                    }
                    copyAt(_, O, B) {
                        _ *= this.stride, B *= O.stride;
                        for (let N = 0, k = this.stride; N < k; N++) this.array[_ + N] = O.array[B + N];
                        return this
                    }
                    set(_, O = 0) {
                        return this.array.set(_, O), this
                    }
                    clone(_) {
                        void 0 === _.arrayBuffers && (_.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ui()), void 0 === _.arrayBuffers[this.array.buffer._uuid] && (_.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        let O = new this.array.constructor(_.arrayBuffers[this.array.buffer._uuid]),
                            B = new this.constructor(O, this.stride);
                        return B.setUsage(this.usage), B
                    }
                    onUpload(_) {
                        return this.onUploadCallback = _, this
                    }
                    toJSON(_) {
                        return void 0 === _.arrayBuffers && (_.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ui()), void 0 === _.arrayBuffers[this.array.buffer._uuid] && (_.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                },
                nT = new rv,
                nD = class {
                    constructor(_, O, B, N = !1) {
                        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = _, this.itemSize = O, this.offset = B, this.normalized = N
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(_) {
                        this.data.needsUpdate = _
                    }
                    applyMatrix4(_) {
                        for (let O = 0, B = this.data.count; O < B; O++) nT.fromBufferAttribute(this, O), nT.applyMatrix4(_), this.setXYZ(O, nT.x, nT.y, nT.z);
                        return this
                    }
                    applyNormalMatrix(_) {
                        for (let O = 0, B = this.count; O < B; O++) nT.fromBufferAttribute(this, O), nT.applyNormalMatrix(_), this.setXYZ(O, nT.x, nT.y, nT.z);
                        return this
                    }
                    transformDirection(_) {
                        for (let O = 0, B = this.count; O < B; O++) nT.fromBufferAttribute(this, O), nT.transformDirection(_), this.setXYZ(O, nT.x, nT.y, nT.z);
                        return this
                    }
                    setX(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.data.array[_ * this.data.stride + this.offset] = O, this
                    }
                    setY(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.data.array[_ * this.data.stride + this.offset + 1] = O, this
                    }
                    setZ(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.data.array[_ * this.data.stride + this.offset + 2] = O, this
                    }
                    setW(_, O) {
                        return this.normalized && (O = Kt(O, this.array)), this.data.array[_ * this.data.stride + this.offset + 3] = O, this
                    }
                    getX(_) {
                        let O = this.data.array[_ * this.data.stride + this.offset];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    getY(_) {
                        let O = this.data.array[_ * this.data.stride + this.offset + 1];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    getZ(_) {
                        let O = this.data.array[_ * this.data.stride + this.offset + 2];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    getW(_) {
                        let O = this.data.array[_ * this.data.stride + this.offset + 3];
                        return this.normalized && (O = zo(O, this.array)), O
                    }
                    setXY(_, O, B) {
                        return _ = _ * this.data.stride + this.offset, this.normalized && (O = Kt(O, this.array), B = Kt(B, this.array)), this.data.array[_ + 0] = O, this.data.array[_ + 1] = B, this
                    }
                    setXYZ(_, O, B, N) {
                        return _ = _ * this.data.stride + this.offset, this.normalized && (O = Kt(O, this.array), B = Kt(B, this.array), N = Kt(N, this.array)), this.data.array[_ + 0] = O, this.data.array[_ + 1] = B, this.data.array[_ + 2] = N, this
                    }
                    setXYZW(_, O, B, N, k) {
                        return _ = _ * this.data.stride + this.offset, this.normalized && (O = Kt(O, this.array), B = Kt(B, this.array), N = Kt(N, this.array), k = Kt(k, this.array)), this.data.array[_ + 0] = O, this.data.array[_ + 1] = B, this.data.array[_ + 2] = N, this.data.array[_ + 3] = k, this
                    }
                    clone(_) {
                        if (void 0 !== _) return void 0 === _.interleavedBuffers && (_.interleavedBuffers = {}), void 0 === _.interleavedBuffers[this.data.uuid] && (_.interleavedBuffers[this.data.uuid] = this.data.clone(_)), new nD(_.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                            let _ = [];
                            for (let O = 0; O < this.count; O++) {
                                let B = O * this.data.stride + this.offset;
                                for (let O = 0; O < this.itemSize; O++) _.push(this.data.array[B + O])
                            }
                            return new sF(new this.array.constructor(_), this.itemSize, this.normalized)
                        }
                    }
                    toJSON(_) {
                        if (void 0 !== _) return void 0 === _.interleavedBuffers && (_.interleavedBuffers = {}), void 0 === _.interleavedBuffers[this.data.uuid] && (_.interleavedBuffers[this.data.uuid] = this.data.toJSON(_)), {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized
                        }; {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                            let _ = [];
                            for (let O = 0; O < this.count; O++) {
                                let B = O * this.data.stride + this.offset;
                                for (let O = 0; O < this.itemSize; O++) _.push(this.data.array[B + O])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: _,
                                normalized: this.normalized
                            }
                        }
                    }
                },
                nP = class extends sv {
                    constructor() {
                        super(), this.isBone = !0, this.type = "Bone"
                    }
                },
                nI = class extends ro {
                    constructor(_ = null, O = 1, B = 1, N, k, F, U, j, G = 1003, Y = 1003, Q, K) {
                        super(null, F, U, j, G, Y, N, k, Q, K), this.isDataTexture = !0, this.image = {
                            data: _,
                            width: O,
                            height: B
                        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                },
                nO = new rJ,
                nR = new rJ,
                nB = class {
                    constructor(_ = [], O = []) {
                        this.uuid = Ui(), this.bones = _.slice(0), this.boneInverses = O, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                    }
                    init() {
                        let _ = this.bones,
                            O = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * _.length), 0 === O.length) this.calculateInverses();
                        else if (_.length !== O.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                            for (let _ = 0, O = this.bones.length; _ < O; _++) this.boneInverses.push(new rJ)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let _ = 0, O = this.bones.length; _ < O; _++) {
                            let O = new rJ;
                            this.bones[_] && O.copy(this.bones[_].matrixWorld).invert(), this.boneInverses.push(O)
                        }
                    }
                    pose() {
                        for (let _ = 0, O = this.bones.length; _ < O; _++) {
                            let O = this.bones[_];
                            O && O.matrixWorld.copy(this.boneInverses[_]).invert()
                        }
                        for (let _ = 0, O = this.bones.length; _ < O; _++) {
                            let O = this.bones[_];
                            O && (O.parent && O.parent.isBone ? (O.matrix.copy(O.parent.matrixWorld).invert(), O.matrix.multiply(O.matrixWorld)) : O.matrix.copy(O.matrixWorld), O.matrix.decompose(O.position, O.quaternion, O.scale))
                        }
                    }
                    update() {
                        let _ = this.bones,
                            O = this.boneInverses,
                            B = this.boneMatrices,
                            N = this.boneTexture;
                        for (let N = 0, k = _.length; N < k; N++) {
                            let k = _[N] ? _[N].matrixWorld : nR;
                            nO.multiplyMatrices(k, O[N]), nO.toArray(B, 16 * N)
                        }
                        null !== N && (N.needsUpdate = !0)
                    }
                    clone() {
                        return new nB(this.bones, this.boneInverses)
                    }
                    computeBoneTexture() {
                        let _ = Math.sqrt(4 * this.bones.length);
                        _ = Math.max(_ = rM(_), 4);
                        let O = new Float32Array(_ * _ * 4);
                        O.set(this.boneMatrices);
                        let B = new nI(O, _, _, 1023, 1015);
                        return B.needsUpdate = !0, this.boneMatrices = O, this.boneTexture = B, this.boneTextureSize = _, this
                    }
                    getBoneByName(_) {
                        for (let O = 0, B = this.bones.length; O < B; O++) {
                            let B = this.bones[O];
                            if (B.name === _) return B
                        }
                    }
                    dispose() {
                        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                    }
                    fromJSON(_, O) {
                        this.uuid = _.uuid;
                        for (let B = 0, N = _.bones.length; B < N; B++) {
                            let N = _.bones[B],
                                k = O[N];
                            void 0 === k && (console.warn("THREE.Skeleton: No bone found with UUID:", N), k = new nP), this.bones.push(k), this.boneInverses.push(new rJ().fromArray(_.boneInverses[B]))
                        }
                        return this.init(), this
                    }
                    toJSON() {
                        let _ = {
                            metadata: {
                                version: 4.5,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        _.uuid = this.uuid;
                        let O = this.bones,
                            B = this.boneInverses;
                        for (let N = 0, k = O.length; N < k; N++) {
                            let k = O[N];
                            _.bones.push(k.uuid);
                            let F = B[N];
                            _.boneInverses.push(F.toArray())
                        }
                        return _
                    }
                },
                nN = class extends sF {
                    constructor(_, O, B, N = 1) {
                        super(_, O, B), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = N
                    }
                    copy(_) {
                        return super.copy(_), this.meshPerAttribute = _.meshPerAttribute, this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.meshPerAttribute = this.meshPerAttribute, _.isInstancedBufferAttribute = !0, _
                    }
                },
                nk = class extends sB {
                    constructor(_) {
                        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new re(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(_)
                    }
                    copy(_) {
                        return super.copy(_), this.color.copy(_.color), this.linewidth = _.linewidth, this.linecap = _.linecap, this.linejoin = _.linejoin, this.fog = _.fog, this
                    }
                },
                nF = new rv,
                nU = new rv,
                nj = new rJ,
                nG = new rK,
                nH = new rG,
                nW = class extends sv {
                    constructor(_ = new sK, O = new nk) {
                        super(), this.isLine = !0, this.type = "Line", this.geometry = _, this.material = O, this.updateMorphTargets()
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.material = _.material, this.geometry = _.geometry, this
                    }
                    computeLineDistances() {
                        let _ = this.geometry;
                        if (null === _.index) {
                            let O = _.attributes.position,
                                B = [0];
                            for (let _ = 1, N = O.count; _ < N; _++) nF.fromBufferAttribute(O, _ - 1), nU.fromBufferAttribute(O, _), B[_] = B[_ - 1], B[_] += nF.distanceTo(nU);
                            _.setAttribute("lineDistance", new sG(B, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                    raycast(_, O) {
                        let B = this.geometry,
                            N = this.matrixWorld,
                            k = _.params.Line.threshold,
                            F = B.drawRange;
                        if (null === B.boundingSphere && B.computeBoundingSphere(), nH.copy(B.boundingSphere), nH.applyMatrix4(N), nH.radius += k, !1 === _.ray.intersectsSphere(nH)) return;
                        nj.copy(N).invert(), nG.copy(_.ray).applyMatrix4(nj);
                        let U = k / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            j = U * U,
                            G = new rv,
                            Y = new rv,
                            Q = new rv,
                            K = new rv,
                            $ = this.isLineSegments ? 2 : 1,
                            ee = B.index,
                            et = B.attributes.position;
                        if (null !== ee) {
                            let B = Math.max(0, F.start),
                                N = Math.min(ee.count, F.start + F.count);
                            for (let k = B, F = N - 1; k < F; k += $) {
                                let B = ee.getX(k),
                                    N = ee.getX(k + 1);
                                if (G.fromBufferAttribute(et, B), Y.fromBufferAttribute(et, N), nG.distanceSqToSegment(G, Y, K, Q) > j) continue;
                                K.applyMatrix4(this.matrixWorld);
                                let F = _.ray.origin.distanceTo(K);
                                F < _.near || F > _.far || O.push({
                                    distance: F,
                                    point: Q.clone().applyMatrix4(this.matrixWorld),
                                    index: k,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else {
                            let B = Math.max(0, F.start),
                                N = Math.min(et.count, F.start + F.count);
                            for (let k = B, F = N - 1; k < F; k += $) {
                                if (G.fromBufferAttribute(et, k), Y.fromBufferAttribute(et, k + 1), nG.distanceSqToSegment(G, Y, K, Q) > j) continue;
                                K.applyMatrix4(this.matrixWorld);
                                let B = _.ray.origin.distanceTo(K);
                                B < _.near || B > _.far || O.push({
                                    distance: B,
                                    point: Q.clone().applyMatrix4(this.matrixWorld),
                                    index: k,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    }
                    updateMorphTargets() {
                        let _ = this.geometry.morphAttributes,
                            O = Object.keys(_);
                        if (O.length > 0) {
                            let B = _[O[0]];
                            if (void 0 !== B) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let _ = 0, O = B.length; _ < O; _++) {
                                    let O = B[_].name || String(_);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[O] = _
                                }
                            }
                        }
                    }
                },
                nq = new rv,
                nY = new rv,
                nX = class extends nW {
                    constructor(_, O) {
                        super(_, O), this.isLineSegments = !0, this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        let _ = this.geometry;
                        if (null === _.index) {
                            let O = _.attributes.position,
                                B = [];
                            for (let _ = 0, N = O.count; _ < N; _ += 2) nq.fromBufferAttribute(O, _), nY.fromBufferAttribute(O, _ + 1), B[_] = 0 === _ ? 0 : B[_ - 1], B[_ + 1] = B[_] + nq.distanceTo(nY);
                            _.setAttribute("lineDistance", new sG(B, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                },
                nQ = class extends ro {
                    constructor(_, O, B, N, k, F, U, j, G) {
                        super(_, O, B, N, k, F, U, j, G), this.isVideoTexture = !0, this.minFilter = void 0 !== F ? F : 1006, this.magFilter = void 0 !== k ? k : 1006, this.generateMipmaps = !1;
                        let Y = this;
                        "requestVideoFrameCallback" in _ && _.requestVideoFrameCallback(function h() {
                            Y.needsUpdate = !0, _.requestVideoFrameCallback(h)
                        })
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        let _ = this.image;
                        "requestVideoFrameCallback" in _ == !1 && _.readyState >= _.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                },
                nZ = class {
                    constructor() {
                        this.type = "Curve", this.arcLengthDivisions = 200
                    }
                    getPoint() {
                        return console.warn("THREE.Curve: .getPoint() not implemented."), null
                    }
                    getPointAt(_, O) {
                        let B = this.getUtoTmapping(_);
                        return this.getPoint(B, O)
                    }
                    getPoints(_ = 5) {
                        let O = [];
                        for (let B = 0; B <= _; B++) O.push(this.getPoint(B / _));
                        return O
                    }
                    getSpacedPoints(_ = 5) {
                        let O = [];
                        for (let B = 0; B <= _; B++) O.push(this.getPointAt(B / _));
                        return O
                    }
                    getLength() {
                        let _ = this.getLengths();
                        return _[_.length - 1]
                    }
                    getLengths(_ = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === _ + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        let O = [],
                            B, N = this.getPoint(0),
                            k = 0;
                        O.push(0);
                        for (let F = 1; F <= _; F++) O.push(k += (B = this.getPoint(F / _)).distanceTo(N)), N = B;
                        return this.cacheArcLengths = O, O
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.getLengths()
                    }
                    getUtoTmapping(_, O) {
                        let B = this.getLengths(),
                            N = 0,
                            k = B.length,
                            F;
                        F = O || _ * B[k - 1];
                        let U = 0,
                            j = k - 1,
                            G;
                        for (; U <= j;)
                            if ((G = B[N = Math.floor(U + (j - U) / 2)] - F) < 0) U = N + 1;
                            else if (G > 0) j = N - 1;
                        else {
                            j = N;
                            break
                        }
                        if (B[N = j] === F) return N / (k - 1);
                        let Y = B[N],
                            Q = B[N + 1] - Y;
                        return (N + (F - Y) / Q) / (k - 1)
                    }
                    getTangent(_, O) {
                        let B = _ - 1e-4,
                            N = _ + 1e-4;
                        B < 0 && (B = 0), N > 1 && (N = 1);
                        let k = this.getPoint(B),
                            F = this.getPoint(N),
                            U = O || (k.isVector2 ? new iJ : new rv);
                        return U.copy(F).sub(k).normalize(), U
                    }
                    getTangentAt(_, O) {
                        let B = this.getUtoTmapping(_);
                        return this.getTangent(B, O)
                    }
                    computeFrenetFrames(_, O) {
                        let B = new rv,
                            N = [],
                            k = [],
                            F = [],
                            U = new rv,
                            j = new rJ;
                        for (let O = 0; O <= _; O++) {
                            let B = O / _;
                            N[O] = this.getTangentAt(B, new rv)
                        }
                        k[0] = new rv, F[0] = new rv;
                        let G = Number.MAX_VALUE,
                            Y = Math.abs(N[0].x),
                            Q = Math.abs(N[0].y),
                            K = Math.abs(N[0].z);
                        Y <= G && (G = Y, B.set(1, 0, 0)), Q <= G && (G = Q, B.set(0, 1, 0)), K <= G && B.set(0, 0, 1), U.crossVectors(N[0], B).normalize(), k[0].crossVectors(N[0], U), F[0].crossVectors(N[0], k[0]);
                        for (let O = 1; O <= _; O++) {
                            if (k[O] = k[O - 1].clone(), F[O] = F[O - 1].clone(), U.crossVectors(N[O - 1], N[O]), U.length() > Number.EPSILON) {
                                U.normalize();
                                let _ = Math.acos(Yr(N[O - 1].dot(N[O]), -1, 1));
                                k[O].applyMatrix4(j.makeRotationAxis(U, _))
                            }
                            F[O].crossVectors(N[O], k[O])
                        }
                        if (!0 === O) {
                            let O = Math.acos(Yr(k[0].dot(k[_]), -1, 1));
                            O /= _, N[0].dot(U.crossVectors(k[0], k[_])) > 0 && (O = -O);
                            for (let B = 1; B <= _; B++) k[B].applyMatrix4(j.makeRotationAxis(N[B], O * B)), F[B].crossVectors(N[B], k[B])
                        }
                        return {
                            tangents: N,
                            normals: k,
                            binormals: F
                        }
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        return this.arcLengthDivisions = _.arcLengthDivisions, this
                    }
                    toJSON() {
                        let _ = {
                            metadata: {
                                version: 4.5,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return _.arcLengthDivisions = this.arcLengthDivisions, _.type = this.type, _
                    }
                    fromJSON(_) {
                        return this.arcLengthDivisions = _.arcLengthDivisions, this
                    }
                },
                nK = class extends nZ {
                    constructor(_ = 0, O = 0, B = 1, N = 1, k = 0, F = 2 * Math.PI, U = !1, j = 0) {
                        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = _, this.aY = O, this.xRadius = B, this.yRadius = N, this.aStartAngle = k, this.aEndAngle = F, this.aClockwise = U, this.aRotation = j
                    }
                    getPoint(_, O) {
                        let B = O || new iJ,
                            N = 2 * Math.PI,
                            k = this.aEndAngle - this.aStartAngle,
                            F = Math.abs(k) < Number.EPSILON;
                        for (; k < 0;) k += N;
                        for (; k > N;) k -= N;
                        k < Number.EPSILON && (k = F ? 0 : N), !0 !== this.aClockwise || F || (k === N ? k = -N : k -= N);
                        let U = this.aStartAngle + _ * k,
                            j = this.aX + this.xRadius * Math.cos(U),
                            G = this.aY + this.yRadius * Math.sin(U);
                        if (0 !== this.aRotation) {
                            let _ = Math.cos(this.aRotation),
                                O = Math.sin(this.aRotation),
                                B = j - this.aX,
                                N = G - this.aY;
                            j = B * _ - N * O + this.aX, G = B * O + N * _ + this.aY
                        }
                        return B.set(j, G)
                    }
                    copy(_) {
                        return super.copy(_), this.aX = _.aX, this.aY = _.aY, this.xRadius = _.xRadius, this.yRadius = _.yRadius, this.aStartAngle = _.aStartAngle, this.aEndAngle = _.aEndAngle, this.aClockwise = _.aClockwise, this.aRotation = _.aRotation, this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.aX = this.aX, _.aY = this.aY, _.xRadius = this.xRadius, _.yRadius = this.yRadius, _.aStartAngle = this.aStartAngle, _.aEndAngle = this.aEndAngle, _.aClockwise = this.aClockwise, _.aRotation = this.aRotation, _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.aX = _.aX, this.aY = _.aY, this.xRadius = _.xRadius, this.yRadius = _.yRadius, this.aStartAngle = _.aStartAngle, this.aEndAngle = _.aEndAngle, this.aClockwise = _.aClockwise, this.aRotation = _.aRotation, this
                    }
                },
                nJ = class extends nK {
                    constructor(_, O, B, N, k, F) {
                        super(_, O, B, B, N, k, F), this.isArcCurve = !0, this.type = "ArcCurve"
                    }
                };

            function rw() {
                let _ = 0,
                    O = 0,
                    B = 0,
                    N = 0;

                function n(k, F, U, j) {
                    _ = k, O = U, B = -3 * k + 3 * F - 2 * U - j, N = 2 * k - 2 * F + U + j
                }
                return {
                    initCatmullRom: function(_, O, B, N, k) {
                        n(O, B, k * (B - _), k * (N - O))
                    },
                    initNonuniformCatmullRom: function(_, O, B, N, k, F, U) {
                        let j = (O - _) / k - (B - _) / (k + F) + (B - O) / F,
                            G = (B - O) / F - (N - O) / (F + U) + (N - B) / U;
                        n(O, B, j *= F, G *= F)
                    },
                    calc: function(k) {
                        let F = k * k;
                        return _ + O * k + B * F + N * (F * k)
                    }
                }
            }
            var n$ = new rv,
                n0 = new rw,
                n1 = new rw,
                n2 = new rw,
                n3 = class extends nZ {
                    constructor(_ = [], O = !1, B = "centripetal", N = .5) {
                        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = _, this.closed = O, this.curveType = B, this.tension = N
                    }
                    getPoint(_, O = new rv) {
                        let B, N, k = this.points,
                            F = k.length,
                            U = (F - (this.closed ? 0 : 1)) * _,
                            j = Math.floor(U),
                            G = U - j;
                        this.closed ? j += j > 0 ? 0 : (Math.floor(Math.abs(j) / F) + 1) * F : 0 === G && j === F - 1 && (j = F - 2, G = 1), this.closed || j > 0 ? B = k[(j - 1) % F] : (n$.subVectors(k[0], k[1]).add(k[0]), B = n$);
                        let Y = k[j % F],
                            Q = k[(j + 1) % F];
                        if (this.closed || j + 2 < F ? N = k[(j + 2) % F] : (n$.subVectors(k[F - 1], k[F - 2]).add(k[F - 1]), N = n$), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            let _ = "chordal" === this.curveType ? .5 : .25,
                                O = Math.pow(B.distanceToSquared(Y), _),
                                k = Math.pow(Y.distanceToSquared(Q), _),
                                F = Math.pow(Q.distanceToSquared(N), _);
                            k < 1e-4 && (k = 1), O < 1e-4 && (O = k), F < 1e-4 && (F = k), n0.initNonuniformCatmullRom(B.x, Y.x, Q.x, N.x, O, k, F), n1.initNonuniformCatmullRom(B.y, Y.y, Q.y, N.y, O, k, F), n2.initNonuniformCatmullRom(B.z, Y.z, Q.z, N.z, O, k, F)
                        } else "catmullrom" === this.curveType && (n0.initCatmullRom(B.x, Y.x, Q.x, N.x, this.tension), n1.initCatmullRom(B.y, Y.y, Q.y, N.y, this.tension), n2.initCatmullRom(B.z, Y.z, Q.z, N.z, this.tension));
                        return O.set(n0.calc(G), n1.calc(G), n2.calc(G)), O
                    }
                    copy(_) {
                        super.copy(_), this.points = [];
                        for (let O = 0, B = _.points.length; O < B; O++) {
                            let B = _.points[O];
                            this.points.push(B.clone())
                        }
                        return this.closed = _.closed, this.curveType = _.curveType, this.tension = _.tension, this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        _.points = [];
                        for (let O = 0, B = this.points.length; O < B; O++) {
                            let B = this.points[O];
                            _.points.push(B.toArray())
                        }
                        return _.closed = this.closed, _.curveType = this.curveType, _.tension = this.tension, _
                    }
                    fromJSON(_) {
                        super.fromJSON(_), this.points = [];
                        for (let O = 0, B = _.points.length; O < B; O++) {
                            let B = _.points[O];
                            this.points.push(new rv().fromArray(B))
                        }
                        return this.closed = _.closed, this.curveType = _.curveType, this.tension = _.tension, this
                    }
                };

            function LE(_, O, B, N, k) {
                let F = (N - O) * .5,
                    U = (k - B) * .5,
                    j = _ * _;
                return (2 * B - 2 * N + F + U) * (_ * j) + (-3 * B + 3 * N - 2 * F - U) * j + F * _ + B
            }

            function Df(_, O, B, N) {
                let k;
                return (k = 1 - _) * k * O + 2 * (1 - _) * _ * B + _ * _ * N
            }

            function If(_, O, B, N, k) {
                let F, U;
                return (F = 1 - _) * F * F * O + 3 * (U = 1 - _) * U * _ * B + 3 * (1 - _) * _ * _ * N + _ * _ * _ * k
            }
            var n4 = class extends nZ {
                    constructor(_ = new iJ, O = new iJ, B = new iJ, N = new iJ) {
                        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = _, this.v1 = O, this.v2 = B, this.v3 = N
                    }
                    getPoint(_, O = new iJ) {
                        let B = this.v0,
                            N = this.v1,
                            k = this.v2,
                            F = this.v3;
                        return O.set(If(_, B.x, N.x, k.x, F.x), If(_, B.y, N.y, k.y, F.y)), O
                    }
                    copy(_) {
                        return super.copy(_), this.v0.copy(_.v0), this.v1.copy(_.v1), this.v2.copy(_.v2), this.v3.copy(_.v3), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.v0 = this.v0.toArray(), _.v1 = this.v1.toArray(), _.v2 = this.v2.toArray(), _.v3 = this.v3.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.v0.fromArray(_.v0), this.v1.fromArray(_.v1), this.v2.fromArray(_.v2), this.v3.fromArray(_.v3), this
                    }
                },
                n5 = class extends nZ {
                    constructor(_ = new rv, O = new rv, B = new rv, N = new rv) {
                        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = _, this.v1 = O, this.v2 = B, this.v3 = N
                    }
                    getPoint(_, O = new rv) {
                        let B = this.v0,
                            N = this.v1,
                            k = this.v2,
                            F = this.v3;
                        return O.set(If(_, B.x, N.x, k.x, F.x), If(_, B.y, N.y, k.y, F.y), If(_, B.z, N.z, k.z, F.z)), O
                    }
                    copy(_) {
                        return super.copy(_), this.v0.copy(_.v0), this.v1.copy(_.v1), this.v2.copy(_.v2), this.v3.copy(_.v3), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.v0 = this.v0.toArray(), _.v1 = this.v1.toArray(), _.v2 = this.v2.toArray(), _.v3 = this.v3.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.v0.fromArray(_.v0), this.v1.fromArray(_.v1), this.v2.fromArray(_.v2), this.v3.fromArray(_.v3), this
                    }
                },
                n6 = class extends nZ {
                    constructor(_ = new iJ, O = new iJ) {
                        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = _, this.v2 = O
                    }
                    getPoint(_, O = new iJ) {
                        return 1 === _ ? O.copy(this.v2) : (O.copy(this.v2).sub(this.v1), O.multiplyScalar(_).add(this.v1)), O
                    }
                    getPointAt(_, O) {
                        return this.getPoint(_, O)
                    }
                    getTangent(_, O) {
                        let B = O || new iJ;
                        return B.copy(this.v2).sub(this.v1).normalize(), B
                    }
                    copy(_) {
                        return super.copy(_), this.v1.copy(_.v1), this.v2.copy(_.v2), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.v1 = this.v1.toArray(), _.v2 = this.v2.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.v1.fromArray(_.v1), this.v2.fromArray(_.v2), this
                    }
                },
                n8 = class extends nZ {
                    constructor(_ = new rv, O = new rv) {
                        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = _, this.v2 = O
                    }
                    getPoint(_, O = new rv) {
                        return 1 === _ ? O.copy(this.v2) : (O.copy(this.v2).sub(this.v1), O.multiplyScalar(_).add(this.v1)), O
                    }
                    getPointAt(_, O) {
                        return this.getPoint(_, O)
                    }
                    copy(_) {
                        return super.copy(_), this.v1.copy(_.v1), this.v2.copy(_.v2), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.v1 = this.v1.toArray(), _.v2 = this.v2.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.v1.fromArray(_.v1), this.v2.fromArray(_.v2), this
                    }
                },
                n9 = class extends nZ {
                    constructor(_ = new iJ, O = new iJ, B = new iJ) {
                        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = _, this.v1 = O, this.v2 = B
                    }
                    getPoint(_, O = new iJ) {
                        let B = this.v0,
                            N = this.v1,
                            k = this.v2;
                        return O.set(Df(_, B.x, N.x, k.x), Df(_, B.y, N.y, k.y)), O
                    }
                    copy(_) {
                        return super.copy(_), this.v0.copy(_.v0), this.v1.copy(_.v1), this.v2.copy(_.v2), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.v0 = this.v0.toArray(), _.v1 = this.v1.toArray(), _.v2 = this.v2.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.v0.fromArray(_.v0), this.v1.fromArray(_.v1), this.v2.fromArray(_.v2), this
                    }
                },
                oe = class extends nZ {
                    constructor(_ = new rv, O = new rv, B = new rv) {
                        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = _, this.v1 = O, this.v2 = B
                    }
                    getPoint(_, O = new rv) {
                        let B = this.v0,
                            N = this.v1,
                            k = this.v2;
                        return O.set(Df(_, B.x, N.x, k.x), Df(_, B.y, N.y, k.y), Df(_, B.z, N.z, k.z)), O
                    }
                    copy(_) {
                        return super.copy(_), this.v0.copy(_.v0), this.v1.copy(_.v1), this.v2.copy(_.v2), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.v0 = this.v0.toArray(), _.v1 = this.v1.toArray(), _.v2 = this.v2.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.v0.fromArray(_.v0), this.v1.fromArray(_.v1), this.v2.fromArray(_.v2), this
                    }
                },
                ot = class extends nZ {
                    constructor(_ = []) {
                        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = _
                    }
                    getPoint(_, O = new iJ) {
                        let B = this.points,
                            N = (B.length - 1) * _,
                            k = Math.floor(N),
                            F = N - k,
                            U = B[0 === k ? k : k - 1],
                            j = B[k],
                            G = B[k > B.length - 2 ? B.length - 1 : k + 1],
                            Y = B[k > B.length - 3 ? B.length - 1 : k + 2];
                        return O.set(LE(F, U.x, j.x, G.x, Y.x), LE(F, U.y, j.y, G.y, Y.y)), O
                    }
                    copy(_) {
                        super.copy(_), this.points = [];
                        for (let O = 0, B = _.points.length; O < B; O++) {
                            let B = _.points[O];
                            this.points.push(B.clone())
                        }
                        return this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        _.points = [];
                        for (let O = 0, B = this.points.length; O < B; O++) {
                            let B = this.points[O];
                            _.points.push(B.toArray())
                        }
                        return _
                    }
                    fromJSON(_) {
                        super.fromJSON(_), this.points = [];
                        for (let O = 0, B = _.points.length; O < B; O++) {
                            let B = _.points[O];
                            this.points.push(new iJ().fromArray(B))
                        }
                        return this
                    }
                },
                oi = Object.freeze({
                    __proto__: null,
                    ArcCurve: nJ,
                    CatmullRomCurve3: n3,
                    CubicBezierCurve: n4,
                    CubicBezierCurve3: n5,
                    EllipseCurve: nK,
                    LineCurve: n6,
                    LineCurve3: n8,
                    QuadraticBezierCurve: n9,
                    QuadraticBezierCurve3: oe,
                    SplineCurve: ot
                }),
                or = class extends nZ {
                    constructor() {
                        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                    }
                    add(_) {
                        this.curves.push(_)
                    }
                    closePath() {
                        let _ = this.curves[0].getPoint(0),
                            O = this.curves[this.curves.length - 1].getPoint(1);
                        _.equals(O) || this.curves.push(new n6(O, _))
                    }
                    getPoint(_, O) {
                        let B = _ * this.getLength(),
                            N = this.getCurveLengths(),
                            k = 0;
                        for (; k < N.length;) {
                            if (N[k] >= B) {
                                let _ = N[k] - B,
                                    F = this.curves[k],
                                    U = F.getLength(),
                                    j = 0 === U ? 0 : 1 - _ / U;
                                return F.getPointAt(j, O)
                            }
                            k++
                        }
                        return null
                    }
                    getLength() {
                        let _ = this.getCurveLengths();
                        return _[_.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                        let _ = [],
                            O = 0;
                        for (let B = 0, N = this.curves.length; B < N; B++) _.push(O += this.curves[B].getLength());
                        return this.cacheLengths = _, _
                    }
                    getSpacedPoints(_ = 40) {
                        let O = [];
                        for (let B = 0; B <= _; B++) O.push(this.getPoint(B / _));
                        return this.autoClose && O.push(O[0]), O
                    }
                    getPoints(_ = 12) {
                        let O = [],
                            B;
                        for (let N = 0, k = this.curves; N < k.length; N++) {
                            let F = k[N],
                                U = F.isEllipseCurve ? 2 * _ : F.isLineCurve || F.isLineCurve3 ? 1 : F.isSplineCurve ? _ * F.points.length : _,
                                j = F.getPoints(U);
                            for (let _ = 0; _ < j.length; _++) {
                                let N = j[_];
                                B && B.equals(N) || (O.push(N), B = N)
                            }
                        }
                        return this.autoClose && O.length > 1 && !O[O.length - 1].equals(O[0]) && O.push(O[0]), O
                    }
                    copy(_) {
                        super.copy(_), this.curves = [];
                        for (let O = 0, B = _.curves.length; O < B; O++) {
                            let B = _.curves[O];
                            this.curves.push(B.clone())
                        }
                        return this.autoClose = _.autoClose, this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        _.autoClose = this.autoClose, _.curves = [];
                        for (let O = 0, B = this.curves.length; O < B; O++) {
                            let B = this.curves[O];
                            _.curves.push(B.toJSON())
                        }
                        return _
                    }
                    fromJSON(_) {
                        super.fromJSON(_), this.autoClose = _.autoClose, this.curves = [];
                        for (let O = 0, B = _.curves.length; O < B; O++) {
                            let B = _.curves[O];
                            this.curves.push(new oi[B.type]().fromJSON(B))
                        }
                        return this
                    }
                },
                os = class extends or {
                    constructor(_) {
                        super(), this.type = "Path", this.currentPoint = new iJ, _ && this.setFromPoints(_)
                    }
                    setFromPoints(_) {
                        this.moveTo(_[0].x, _[0].y);
                        for (let O = 1, B = _.length; O < B; O++) this.lineTo(_[O].x, _[O].y);
                        return this
                    }
                    moveTo(_, O) {
                        return this.currentPoint.set(_, O), this
                    }
                    lineTo(_, O) {
                        let B = new n6(this.currentPoint.clone(), new iJ(_, O));
                        return this.curves.push(B), this.currentPoint.set(_, O), this
                    }
                    quadraticCurveTo(_, O, B, N) {
                        let k = new n9(this.currentPoint.clone(), new iJ(_, O), new iJ(B, N));
                        return this.curves.push(k), this.currentPoint.set(B, N), this
                    }
                    bezierCurveTo(_, O, B, N, k, F) {
                        let U = new n4(this.currentPoint.clone(), new iJ(_, O), new iJ(B, N), new iJ(k, F));
                        return this.curves.push(U), this.currentPoint.set(k, F), this
                    }
                    splineThru(_) {
                        let O = [this.currentPoint.clone()].concat(_),
                            B = new ot(O);
                        return this.curves.push(B), this.currentPoint.copy(_[_.length - 1]), this
                    }
                    arc(_, O, B, N, k, F) {
                        let U = this.currentPoint.x,
                            j = this.currentPoint.y;
                        return this.absarc(_ + U, O + j, B, N, k, F), this
                    }
                    absarc(_, O, B, N, k, F) {
                        return this.absellipse(_, O, B, B, N, k, F), this
                    }
                    ellipse(_, O, B, N, k, F, U, j) {
                        let G = this.currentPoint.x,
                            Y = this.currentPoint.y;
                        return this.absellipse(_ + G, O + Y, B, N, k, F, U, j), this
                    }
                    absellipse(_, O, B, N, k, F, U, j) {
                        let G = new nK(_, O, B, N, k, F, U, j);
                        if (this.curves.length > 0) {
                            let _ = G.getPoint(0);
                            _.equals(this.currentPoint) || this.lineTo(_.x, _.y)
                        }
                        this.curves.push(G);
                        let Y = G.getPoint(1);
                        return this.currentPoint.copy(Y), this
                    }
                    copy(_) {
                        return super.copy(_), this.currentPoint.copy(_.currentPoint), this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.currentPoint = this.currentPoint.toArray(), _
                    }
                    fromJSON(_) {
                        return super.fromJSON(_), this.currentPoint.fromArray(_.currentPoint), this
                    }
                },
                on = class extends sK {
                    constructor(_ = [new iJ(0, -.5), new iJ(.5, 0), new iJ(0, .5)], O = 12, B = 0, N = 2 * Math.PI) {
                        super(), this.type = "LatheGeometry", this.parameters = {
                            points: _,
                            segments: O,
                            phiStart: B,
                            phiLength: N
                        }, O = Math.floor(O), N = Yr(N, 0, 2 * Math.PI);
                        let k = [],
                            F = [],
                            U = [],
                            j = [],
                            G = [],
                            Y = 1 / O,
                            Q = new rv,
                            K = new iJ,
                            $ = new rv,
                            ee = new rv,
                            et = new rv,
                            ei = 0,
                            er = 0;
                        for (let O = 0; O <= _.length - 1; O++) switch (O) {
                            case 0:
                                ei = _[O + 1].x - _[O].x, er = _[O + 1].y - _[O].y, $.x = 1 * er, $.y = -ei, $.z = 0 * er, et.copy($), $.normalize(), j.push($.x, $.y, $.z);
                                break;
                            case _.length - 1:
                                j.push(et.x, et.y, et.z);
                                break;
                            default:
                                ei = _[O + 1].x - _[O].x, er = _[O + 1].y - _[O].y, $.x = 1 * er, $.y = -ei, $.z = 0 * er, ee.copy($), $.x += et.x, $.y += et.y, $.z += et.z, $.normalize(), j.push($.x, $.y, $.z), et.copy(ee)
                        }
                        for (let k = 0; k <= O; k++) {
                            let $ = B + k * Y * N,
                                ee = Math.sin($),
                                et = Math.cos($);
                            for (let B = 0; B <= _.length - 1; B++) {
                                Q.x = _[B].x * ee, Q.y = _[B].y, Q.z = _[B].x * et, F.push(Q.x, Q.y, Q.z), K.x = k / O, K.y = B / (_.length - 1), U.push(K.x, K.y);
                                let N = j[3 * B + 0] * ee,
                                    Y = j[3 * B + 1],
                                    $ = j[3 * B + 0] * et;
                                G.push(N, Y, $)
                            }
                        }
                        for (let B = 0; B < O; B++)
                            for (let O = 0; O < _.length - 1; O++) {
                                let N = O + B * _.length,
                                    F = N + _.length,
                                    U = N + _.length + 1,
                                    j = N + 1;
                                k.push(N, F, j), k.push(U, j, F)
                            }
                        this.setIndex(k), this.setAttribute("position", new sG(F, 3)), this.setAttribute("uv", new sG(U, 2)), this.setAttribute("normal", new sG(G, 3))
                    }
                    static fromJSON(_) {
                        return new on(_.points, _.segments, _.phiStart, _.phiLength)
                    }
                },
                oc = class extends sK {
                    constructor(_ = 1, O = 1, B = 1, N = 32, k = 1, F = !1, U = 0, j = 2 * Math.PI) {
                        super(), this.type = "CylinderGeometry", this.parameters = {
                            radiusTop: _,
                            radiusBottom: O,
                            height: B,
                            radialSegments: N,
                            heightSegments: k,
                            openEnded: F,
                            thetaStart: U,
                            thetaLength: j
                        };
                        let G = this;
                        N = Math.floor(N), k = Math.floor(k);
                        let Y = [],
                            Q = [],
                            K = [],
                            $ = [],
                            ee = 0,
                            et = [],
                            ei = B / 2,
                            er = 0;

                        function x(B) {
                            let k = ee,
                                F = new iJ,
                                et = new rv,
                                ea = 0,
                                en = !0 === B ? _ : O,
                                eo = !0 === B ? 1 : -1;
                            for (let _ = 1; _ <= N; _++) Q.push(0, ei * eo, 0), K.push(0, eo, 0), $.push(.5, .5), ee++;
                            let el = ee;
                            for (let _ = 0; _ <= N; _++) {
                                let O = _ / N * j + U,
                                    B = Math.cos(O),
                                    k = Math.sin(O);
                                et.x = en * k, et.y = ei * eo, et.z = en * B, Q.push(et.x, et.y, et.z), K.push(0, eo, 0), F.x = .5 * B + .5, F.y = .5 * k * eo + .5, $.push(F.x, F.y), ee++
                            }
                            for (let _ = 0; _ < N; _++) {
                                let O = k + _,
                                    N = el + _;
                                !0 === B ? Y.push(N, N + 1, O) : Y.push(N + 1, N, O), ea += 3
                            }
                            G.addGroup(er, ea, !0 === B ? 1 : 2), er += ea
                        }(function() {
                            let F = new rv,
                                ea = new rv,
                                en = 0,
                                eo = (O - _) / B;
                            for (let G = 0; G <= k; G++) {
                                let Y = [],
                                    er = G / k,
                                    en = er * (O - _) + _;
                                for (let _ = 0; _ <= N; _++) {
                                    let O = _ / N,
                                        k = O * j + U,
                                        G = Math.sin(k),
                                        et = Math.cos(k);
                                    ea.x = en * G, ea.y = -er * B + ei, ea.z = en * et, Q.push(ea.x, ea.y, ea.z), F.set(G, eo, et).normalize(), K.push(F.x, F.y, F.z), $.push(O, 1 - er), Y.push(ee++)
                                }
                                et.push(Y)
                            }
                            for (let _ = 0; _ < N; _++)
                                for (let O = 0; O < k; O++) {
                                    let B = et[O][_],
                                        N = et[O + 1][_],
                                        k = et[O + 1][_ + 1],
                                        F = et[O][_ + 1];
                                    Y.push(B, N, F), Y.push(N, k, F), en += 6
                                }
                            G.addGroup(er, en, 0), er += en
                        })(), !1 === F && (_ > 0 && x(!0), O > 0 && x(!1)), this.setIndex(Y), this.setAttribute("position", new sG(Q, 3)), this.setAttribute("normal", new sG(K, 3)), this.setAttribute("uv", new sG($, 2))
                    }
                    static fromJSON(_) {
                        return new oc(_.radiusTop, _.radiusBottom, _.height, _.radialSegments, _.heightSegments, _.openEnded, _.thetaStart, _.thetaLength)
                    }
                },
                od = class extends oc {
                    constructor(_ = 1, O = 1, B = 32, N = 1, k = !1, F = 0, U = 2 * Math.PI) {
                        super(0, _, O, B, N, k, F, U), this.type = "ConeGeometry", this.parameters = {
                            radius: _,
                            height: O,
                            radialSegments: B,
                            heightSegments: N,
                            openEnded: k,
                            thetaStart: F,
                            thetaLength: U
                        }
                    }
                    static fromJSON(_) {
                        return new od(_.radius, _.height, _.radialSegments, _.heightSegments, _.openEnded, _.thetaStart, _.thetaLength)
                    }
                },
                og = class extends sK {
                    constructor(_ = [], O = [], B = 1, N = 0) {
                        super(), this.type = "PolyhedronGeometry", this.parameters = {
                            vertices: _,
                            indices: O,
                            radius: B,
                            detail: N
                        };
                        let k = [],
                            F = [];

                        function d(_) {
                            k.push(_.x, _.y, _.z)
                        }

                        function f(O, B) {
                            let N = 3 * O;
                            B.x = _[N + 0], B.y = _[N + 1], B.z = _[N + 2]
                        }

                        function m(_, O, B, N) {
                            N < 0 && 1 === _.x && (F[O] = _.x - 1), 0 === B.x && 0 === B.z && (F[O] = N / 2 / Math.PI + .5)
                        }

                        function g(_) {
                            return Math.atan2(_.z, -_.x)
                        }(function(_) {
                            let B = new rv,
                                N = new rv,
                                k = new rv;
                            for (let F = 0; F < O.length; F += 3) f(O[F + 0], B), f(O[F + 1], N), f(O[F + 2], k),
                                function(_, O, B, N) {
                                    let k = N + 1,
                                        F = [];
                                    for (let N = 0; N <= k; N++) {
                                        F[N] = [];
                                        let U = _.clone().lerp(B, N / k),
                                            j = O.clone().lerp(B, N / k),
                                            G = k - N;
                                        for (let _ = 0; _ <= G; _++) 0 === _ && N === k ? F[N][_] = U : F[N][_] = U.clone().lerp(j, _ / G)
                                    }
                                    for (let _ = 0; _ < k; _++)
                                        for (let O = 0; O < 2 * (k - _) - 1; O++) {
                                            let B = Math.floor(O / 2);
                                            O % 2 == 0 ? (d(F[_][B + 1]), d(F[_ + 1][B]), d(F[_][B])) : (d(F[_][B + 1]), d(F[_ + 1][B + 1]), d(F[_ + 1][B]))
                                        }
                                }(B, N, k, _)
                        })(N),
                        function(_) {
                            let O = new rv;
                            for (let B = 0; B < k.length; B += 3) O.x = k[B + 0], O.y = k[B + 1], O.z = k[B + 2], O.normalize().multiplyScalar(_), k[B + 0] = O.x, k[B + 1] = O.y, k[B + 2] = O.z
                        }(B),
                        function() {
                            let _ = new rv;
                            for (let O = 0; O < k.length; O += 3) {
                                _.x = k[O + 0], _.y = k[O + 1], _.z = k[O + 2];
                                let B = g(_) / 2 / Math.PI + .5,
                                    N = Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) / Math.PI + .5;
                                F.push(B, 1 - N)
                            }(function() {
                                let _ = new rv,
                                    O = new rv,
                                    B = new rv,
                                    N = new rv,
                                    U = new iJ,
                                    j = new iJ,
                                    G = new iJ;
                                for (let Y = 0, Q = 0; Y < k.length; Y += 9, Q += 6) {
                                    _.set(k[Y + 0], k[Y + 1], k[Y + 2]), O.set(k[Y + 3], k[Y + 4], k[Y + 5]), B.set(k[Y + 6], k[Y + 7], k[Y + 8]), U.set(F[Q + 0], F[Q + 1]), j.set(F[Q + 2], F[Q + 3]), G.set(F[Q + 4], F[Q + 5]), N.copy(_).add(O).add(B).divideScalar(3);
                                    let K = g(N);
                                    m(U, Q + 0, _, K), m(j, Q + 2, O, K), m(G, Q + 4, B, K)
                                }
                            })(),
                            function() {
                                for (let _ = 0; _ < F.length; _ += 6) {
                                    let O = F[_ + 0],
                                        B = F[_ + 2],
                                        N = F[_ + 4],
                                        k = Math.max(O, B, N),
                                        U = Math.min(O, B, N);
                                    k > .9 && U < .1 && (O < .2 && (F[_ + 0] += 1), B < .2 && (F[_ + 2] += 1), N < .2 && (F[_ + 4] += 1))
                                }
                            }()
                        }(), this.setAttribute("position", new sG(k, 3)), this.setAttribute("normal", new sG(k.slice(), 3)), this.setAttribute("uv", new sG(F, 2)), 0 === N ? this.computeVertexNormals() : this.normalizeNormals()
                    }
                    static fromJSON(_) {
                        return new og(_.vertices, _.indices, _.radius, _.details)
                    }
                },
                ov = class extends og {
                    constructor(_ = 1, O = 0) {
                        let B = (1 + Math.sqrt(5)) / 2,
                            N = 1 / B;
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -N, -B, 0, -N, B, 0, N, -B, 0, N, B, -N, -B, 0, -N, B, 0, N, -B, 0, N, B, 0, -B, 0, -N, B, 0, -N, -B, 0, N, B, 0, N], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], _, O), this.type = "DodecahedronGeometry", this.parameters = {
                            radius: _,
                            detail: O
                        }
                    }
                    static fromJSON(_) {
                        return new ov(_.radius, _.detail)
                    }
                },
                ox = class extends os {
                    constructor(_) {
                        super(_), this.uuid = Ui(), this.type = "Shape", this.holes = []
                    }
                    getPointsHoles(_) {
                        let O = [];
                        for (let B = 0, N = this.holes.length; B < N; B++) O[B] = this.holes[B].getPoints(_);
                        return O
                    }
                    extractPoints(_) {
                        return {
                            shape: this.getPoints(_),
                            holes: this.getPointsHoles(_)
                        }
                    }
                    copy(_) {
                        super.copy(_), this.holes = [];
                        for (let O = 0, B = _.holes.length; O < B; O++) {
                            let B = _.holes[O];
                            this.holes.push(B.clone())
                        }
                        return this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        _.uuid = this.uuid, _.holes = [];
                        for (let O = 0, B = this.holes.length; O < B; O++) {
                            let B = this.holes[O];
                            _.holes.push(B.toJSON())
                        }
                        return _
                    }
                    fromJSON(_) {
                        super.fromJSON(_), this.uuid = _.uuid, this.holes = [];
                        for (let O = 0, B = _.holes.length; O < B; O++) {
                            let B = _.holes[O];
                            this.holes.push(new os().fromJSON(B))
                        }
                        return this
                    }
                },
                ob = {
                    triangulate: function(_, O, B = 2) {
                        let N, k, F, U, j, G, Y, Q = O && O.length,
                            K = Q ? O[0] * B : _.length,
                            $ = hM(_, 0, K, B, !0),
                            ee = [];
                        if (!$ || $.next === $.prev) return ee;
                        if (Q && ($ = function(_, O, B, N) {
                                let k = [],
                                    F, U, j, G, Y;
                                for (F = 0, U = O.length; F < U; F++) j = O[F] * N, G = F < U - 1 ? O[F + 1] * N : _.length, (Y = hM(_, j, G, N, !1)) === Y.next && (Y.steiner = !0), k.push(function(_) {
                                    let O = _,
                                        B = _;
                                    do(O.x < B.x || O.x === B.x && O.y < B.y) && (B = O), O = O.next; while (O !== _);
                                    return B
                                }(Y));
                                for (k.sort(Nz), F = 0; F < k.length; F++) B = function(_, O) {
                                    let B = function(_, O) {
                                        let B = O,
                                            N = -1 / 0,
                                            k, F = _.x,
                                            U = _.y;
                                        do {
                                            if (U <= B.y && U >= B.next.y && B.next.y !== B.y) {
                                                let _ = B.x + (U - B.y) * (B.next.x - B.x) / (B.next.y - B.y);
                                                if (_ <= F && _ > N && (N = _, k = B.x < B.next.x ? B : B.next, _ === F)) return k
                                            }
                                            B = B.next
                                        } while (B !== O);
                                        if (!k) return null;
                                        let j = k,
                                            G = k.x,
                                            Y = k.y,
                                            Q = 1 / 0,
                                            K;
                                        B = k;
                                        do {
                                            var $, ee;
                                            F >= B.x && B.x >= G && F !== B.x && iu(U < Y ? F : N, U, G, Y, U < Y ? N : F, U, B.x, B.y) && (K = Math.abs(U - B.y) / (F - B.x), Uf(B, _) && (K < Q || K === Q && (B.x > k.x || B.x === k.x && ($ = k, ee = B, 0 > vr($.prev, $, ee.prev) && 0 > vr(ee.next, $, $.next)))) && (k = B, Q = K)), B = B.next
                                        } while (B !== j);
                                        return k
                                    }(_, O);
                                    if (!B) return O;
                                    let N = fM(B, _);
                                    return Ql(N, N.next), Ql(B, B.next)
                                }(k[F], B);
                                return B
                            }(_, O, $, B)), _.length > 80 * B) {
                            N = F = _[0], k = U = _[1];
                            for (let O = B; O < K; O += B) j = _[O], G = _[O + 1], j < N && (N = j), G < k && (k = G), j > F && (F = j), G > U && (U = G);
                            Y = 0 !== (Y = Math.max(F - N, U - k)) ? 32767 / Y : 0
                        }
                        return function zf(_, O, B, N, k, F, U) {
                            if (!_) return;
                            !U && F && function(_, O, B, N) {
                                let k = _;
                                do 0 === k.z && (k.z = Nb(k.x, k.y, O, B, N)), k.prevZ = k.prev, k.nextZ = k.next, k = k.next; while (k !== _);
                                k.prevZ.nextZ = null, k.prevZ = null,
                                    function(_) {
                                        let O, B, N, k, F, U, j, G, Y = 1;
                                        do {
                                            for (B = _, _ = null, F = null, U = 0; B;) {
                                                for (U++, N = B, j = 0, O = 0; O < Y && (j++, N = N.nextZ); O++);
                                                for (G = Y; j > 0 || G > 0 && N;) 0 !== j && (0 === G || !N || B.z <= N.z) ? (k = B, B = B.nextZ, j--) : (k = N, N = N.nextZ, G--), F ? F.nextZ = k : _ = k, k.prevZ = F, F = k;
                                                B = N
                                            }
                                            F.nextZ = null, Y *= 2
                                        } while (U > 1)
                                    }(k)
                            }(_, N, k, F);
                            let j = _,
                                G, Y;
                            for (; _.prev !== _.next;) {
                                if (G = _.prev, Y = _.next, F ? function(_, O, B, N) {
                                        let k = _.prev,
                                            F = _.next;
                                        if (vr(k, _, F) >= 0) return !1;
                                        let U = k.x,
                                            j = _.x,
                                            G = F.x,
                                            Y = k.y,
                                            Q = _.y,
                                            K = F.y,
                                            $ = U < j ? U < G ? U : G : j < G ? j : G,
                                            ee = Y < Q ? Y < K ? Y : K : Q < K ? Q : K,
                                            et = U > j ? U > G ? U : G : j > G ? j : G,
                                            ei = Y > Q ? Y > K ? Y : K : Q > K ? Q : K,
                                            er = Nb($, ee, O, B, N),
                                            ea = Nb(et, ei, O, B, N),
                                            en = _.prevZ,
                                            eo = _.nextZ;
                                        for (; en && en.z >= er && eo && eo.z <= ea;) {
                                            if (en.x >= $ && en.x <= et && en.y >= ee && en.y <= ei && en !== k && en !== F && iu(U, Y, j, Q, G, K, en.x, en.y) && vr(en.prev, en, en.next) >= 0 || (en = en.prevZ, eo.x >= $ && eo.x <= et && eo.y >= ee && eo.y <= ei && eo !== k && eo !== F && iu(U, Y, j, Q, G, K, eo.x, eo.y) && vr(eo.prev, eo, eo.next) >= 0)) return !1;
                                            eo = eo.nextZ
                                        }
                                        for (; en && en.z >= er;) {
                                            if (en.x >= $ && en.x <= et && en.y >= ee && en.y <= ei && en !== k && en !== F && iu(U, Y, j, Q, G, K, en.x, en.y) && vr(en.prev, en, en.next) >= 0) return !1;
                                            en = en.prevZ
                                        }
                                        for (; eo && eo.z <= ea;) {
                                            if (eo.x >= $ && eo.x <= et && eo.y >= ee && eo.y <= ei && eo !== k && eo !== F && iu(U, Y, j, Q, G, K, eo.x, eo.y) && vr(eo.prev, eo, eo.next) >= 0) return !1;
                                            eo = eo.nextZ
                                        }
                                        return !0
                                    }(_, N, k, F) : function(_) {
                                        let O = _.prev,
                                            B = _.next;
                                        if (vr(O, _, B) >= 0) return !1;
                                        let N = O.x,
                                            k = _.x,
                                            F = B.x,
                                            U = O.y,
                                            j = _.y,
                                            G = B.y,
                                            Y = N < k ? N < F ? N : F : k < F ? k : F,
                                            Q = U < j ? U < G ? U : G : j < G ? j : G,
                                            K = N > k ? N > F ? N : F : k > F ? k : F,
                                            $ = U > j ? U > G ? U : G : j > G ? j : G,
                                            ee = B.next;
                                        for (; ee !== O;) {
                                            if (ee.x >= Y && ee.x <= K && ee.y >= Q && ee.y <= $ && iu(N, U, k, j, F, G, ee.x, ee.y) && vr(ee.prev, ee, ee.next) >= 0) return !1;
                                            ee = ee.next
                                        }
                                        return !0
                                    }(_)) {
                                    O.push(G.i / B | 0), O.push(_.i / B | 0), O.push(Y.i / B | 0), Gf(_), _ = Y.next, j = Y.next;
                                    continue
                                }
                                if ((_ = Y) === j) {
                                    U ? 1 === U ? zf(_ = function(_, O, B) {
                                        let N = _;
                                        do {
                                            let k = N.prev,
                                                F = N.next.next;
                                            !Fg(k, F) && dM(k, N, N.next, F) && Uf(k, F) && Uf(F, k) && (O.push(k.i / B | 0), O.push(N.i / B | 0), O.push(F.i / B | 0), Gf(N), Gf(N.next), N = _ = F), N = N.next
                                        } while (N !== _);
                                        return Ql(N)
                                    }(Ql(_), O, B), O, B, N, k, F, 2) : 2 === U && function(_, O, B, N, k, F) {
                                        let U = _;
                                        do {
                                            let _ = U.next.next;
                                            for (; _ !== U.prev;) {
                                                var j, G;
                                                if (U.i !== _.i && (j = U, G = _, j.next.i !== G.i && j.prev.i !== G.i && ! function(_, O) {
                                                        let B = _;
                                                        do {
                                                            if (B.i !== _.i && B.next.i !== _.i && B.i !== O.i && B.next.i !== O.i && dM(B, B.next, _, O)) return !0;
                                                            B = B.next
                                                        } while (B !== _);
                                                        return !1
                                                    }(j, G) && (Uf(j, G) && Uf(G, j) && function(_, O) {
                                                        let B = _,
                                                            N = !1,
                                                            k = (_.x + O.x) / 2,
                                                            F = (_.y + O.y) / 2;
                                                        do B.y > F != B.next.y > F && B.next.y !== B.y && k < (B.next.x - B.x) * (F - B.y) / (B.next.y - B.y) + B.x && (N = !N), B = B.next; while (B !== _);
                                                        return N
                                                    }(j, G) && (vr(j.prev, j, G.prev) || vr(j, G.prev, G)) || Fg(j, G) && vr(j.prev, j, j.next) > 0 && vr(G.prev, G, G.next) > 0))) {
                                                    let j = fM(U, _);
                                                    U = Ql(U, U.next), j = Ql(j, j.next), zf(U, O, B, N, k, F, 0), zf(j, O, B, N, k, F, 0);
                                                    return
                                                }
                                                _ = _.next
                                            }
                                            U = U.next
                                        } while (U !== _)
                                    }(_, O, B, N, k, F) : zf(Ql(_), O, B, N, k, F, 1);
                                    break
                                }
                            }
                        }($, ee, B, N, k, Y, 0), ee
                    }
                };

            function hM(_, O, B, N, k) {
                let F, U;
                if (k === function(_, O, B, N) {
                        let k = 0;
                        for (let F = O, U = B - N; F < B; F += N) k += (_[U] - _[F]) * (_[F + 1] + _[U + 1]), U = F;
                        return k
                    }(_, O, B, N) > 0)
                    for (F = O; F < B; F += N) U = NE(F, _[F], _[F + 1], U);
                else
                    for (F = B - N; F >= O; F -= N) U = NE(F, _[F], _[F + 1], U);
                return U && Fg(U, U.next) && (Gf(U), U = U.next), U
            }

            function Ql(_, O) {
                if (!_) return _;
                O || (O = _);
                let B = _,
                    N;
                do
                    if (N = !1, !B.steiner && (Fg(B, B.next) || 0 === vr(B.prev, B, B.next))) {
                        if (Gf(B), (B = O = B.prev) === B.next) break;
                        N = !0
                    } else B = B.next; while (N || B !== O);
                return O
            }

            function Nz(_, O) {
                return _.x - O.x
            }

            function Nb(_, O, B, N, k) {
                return (_ = ((_ = ((_ = ((_ = ((_ = (_ - B) * k | 0) | _ << 8) & 16711935) | _ << 4) & 252645135) | _ << 2) & 858993459) | _ << 1) & 1431655765) | (O = ((O = ((O = ((O = ((O = (O - N) * k | 0) | O << 8) & 16711935) | O << 4) & 252645135) | O << 2) & 858993459) | O << 1) & 1431655765) << 1
            }

            function iu(_, O, B, N, k, F, U, j) {
                return (k - U) * (O - j) >= (_ - U) * (F - j) && (_ - U) * (N - j) >= (B - U) * (O - j) && (B - U) * (F - j) >= (k - U) * (N - j)
            }

            function vr(_, O, B) {
                return (O.y - _.y) * (B.x - O.x) - (O.x - _.x) * (B.y - O.y)
            }

            function Fg(_, O) {
                return _.x === O.x && _.y === O.y
            }

            function dM(_, O, B, N) {
                let k = ng(vr(_, O, B)),
                    F = ng(vr(_, O, N)),
                    U = ng(vr(B, N, _)),
                    j = ng(vr(B, N, O));
                return !!(k !== F && U !== j || 0 === k && rg(_, B, O) || 0 === F && rg(_, N, O) || 0 === U && rg(B, _, N) || 0 === j && rg(B, O, N))
            }

            function rg(_, O, B) {
                return O.x <= Math.max(_.x, B.x) && O.x >= Math.min(_.x, B.x) && O.y <= Math.max(_.y, B.y) && O.y >= Math.min(_.y, B.y)
            }

            function ng(_) {
                return _ > 0 ? 1 : _ < 0 ? -1 : 0
            }

            function Uf(_, O) {
                return 0 > vr(_.prev, _, _.next) ? vr(_, O, _.next) >= 0 && vr(_, _.prev, O) >= 0 : 0 > vr(_, O, _.prev) || 0 > vr(_, _.next, O)
            }

            function fM(_, O) {
                let B = new Bb(_.i, _.x, _.y),
                    N = new Bb(O.i, O.x, O.y),
                    k = _.next,
                    F = O.prev;
                return _.next = O, O.prev = _, B.next = k, k.prev = B, N.next = B, B.prev = N, F.next = N, N.prev = F, N
            }

            function NE(_, O, B, N) {
                let k = new Bb(_, O, B);
                return N ? (k.next = N.next, k.prev = N, N.next.prev = k, N.next = k) : (k.prev = k, k.next = k), k
            }

            function Gf(_) {
                _.next.prev = _.prev, _.prev.next = _.next, _.prevZ && (_.prevZ.nextZ = _.nextZ), _.nextZ && (_.nextZ.prevZ = _.prevZ)
            }

            function Bb(_, O, B) {
                this.i = _, this.x = O, this.y = B, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var ow = class {
                static area(_) {
                    let O = _.length,
                        B = 0;
                    for (let N = O - 1, k = 0; k < O; N = k++) B += _[N].x * _[k].y - _[k].x * _[N].y;
                    return .5 * B
                }
                static isClockWise(_) {
                    return 0 > ow.area(_)
                }
                static triangulateShape(_, O) {
                    let B = [],
                        N = [],
                        k = [];
                    BE(_), FE(B, _);
                    let F = _.length;
                    O.forEach(BE);
                    for (let _ = 0; _ < O.length; _++) N.push(F), F += O[_].length, FE(B, O[_]);
                    let U = ob.triangulate(B, N);
                    for (let _ = 0; _ < U.length; _ += 3) k.push(U.slice(_, _ + 3));
                    return k
                }
            };

            function BE(_) {
                let O = _.length;
                O > 2 && _[O - 1].equals(_[0]) && _.pop()
            }

            function FE(_, O) {
                for (let B = 0; B < O.length; B++) _.push(O[B].x), _.push(O[B].y)
            }
            var o_ = class extends og {
                    constructor(_ = 1, O = 0) {
                        let B = (1 + Math.sqrt(5)) / 2;
                        super([-1, B, 0, 1, B, 0, -1, -B, 0, 1, -B, 0, 0, -1, B, 0, 1, B, 0, -1, -B, 0, 1, -B, B, 0, -1, B, 0, 1, -B, 0, -1, -B, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], _, O), this.type = "IcosahedronGeometry", this.parameters = {
                            radius: _,
                            detail: O
                        }
                    }
                    static fromJSON(_) {
                        return new o_(_.radius, _.detail)
                    }
                },
                oS = class extends sK {
                    constructor(_ = 1, O = 32, B = 16, N = 0, k = 2 * Math.PI, F = 0, U = Math.PI) {
                        super(), this.type = "SphereGeometry", this.parameters = {
                            radius: _,
                            widthSegments: O,
                            heightSegments: B,
                            phiStart: N,
                            phiLength: k,
                            thetaStart: F,
                            thetaLength: U
                        }, O = Math.max(3, Math.floor(O)), B = Math.max(2, Math.floor(B));
                        let j = Math.min(F + U, Math.PI),
                            G = 0,
                            Y = [],
                            Q = new rv,
                            K = new rv,
                            $ = [],
                            ee = [],
                            et = [],
                            ei = [];
                        for (let $ = 0; $ <= B; $++) {
                            let er = [],
                                ea = $ / B,
                                en = 0;
                            0 == $ && 0 == F ? en = .5 / O : $ == B && j == Math.PI && (en = -.5 / O);
                            for (let B = 0; B <= O; B++) {
                                let j = B / O;
                                Q.x = -_ * Math.cos(N + j * k) * Math.sin(F + ea * U), Q.y = _ * Math.cos(F + ea * U), Q.z = _ * Math.sin(N + j * k) * Math.sin(F + ea * U), ee.push(Q.x, Q.y, Q.z), K.copy(Q).normalize(), et.push(K.x, K.y, K.z), ei.push(j + en, 1 - ea), er.push(G++)
                            }
                            Y.push(er)
                        }
                        for (let _ = 0; _ < B; _++)
                            for (let N = 0; N < O; N++) {
                                let O = Y[_][N + 1],
                                    k = Y[_][N],
                                    U = Y[_ + 1][N],
                                    G = Y[_ + 1][N + 1];
                                (0 !== _ || F > 0) && $.push(O, k, G), (_ !== B - 1 || j < Math.PI) && $.push(k, U, G)
                            }
                        this.setIndex($), this.setAttribute("position", new sG(ee, 3)), this.setAttribute("normal", new sG(et, 3)), this.setAttribute("uv", new sG(ei, 2))
                    }
                    static fromJSON(_) {
                        return new oS(_.radius, _.widthSegments, _.heightSegments, _.phiStart, _.phiLength, _.thetaStart, _.thetaLength)
                    }
                },
                oA = class extends sK {
                    constructor(_ = 1, O = .4, B = 64, N = 8, k = 2, F = 3) {
                        super(), this.type = "TorusKnotGeometry", this.parameters = {
                            radius: _,
                            tube: O,
                            tubularSegments: B,
                            radialSegments: N,
                            p: k,
                            q: F
                        }, B = Math.floor(B), N = Math.floor(N);
                        let U = [],
                            j = [],
                            G = [],
                            Y = [],
                            Q = new rv,
                            K = new rv,
                            $ = new rv,
                            ee = new rv,
                            et = new rv,
                            ei = new rv,
                            er = new rv;
                        for (let U = 0; U <= B; ++U) {
                            let ea = U / B * k * Math.PI * 2;
                            v(ea, k, F, _, $), v(ea + .01, k, F, _, ee), ei.subVectors(ee, $), er.addVectors(ee, $), et.crossVectors(ei, er), er.crossVectors(et, ei), et.normalize(), er.normalize();
                            for (let _ = 0; _ <= N; ++_) {
                                let k = _ / N * Math.PI * 2,
                                    F = -O * Math.cos(k),
                                    ee = O * Math.sin(k);
                                Q.x = $.x + (F * er.x + ee * et.x), Q.y = $.y + (F * er.y + ee * et.y), Q.z = $.z + (F * er.z + ee * et.z), j.push(Q.x, Q.y, Q.z), K.subVectors(Q, $).normalize(), G.push(K.x, K.y, K.z), Y.push(U / B), Y.push(_ / N)
                            }
                        }
                        for (let _ = 1; _ <= B; _++)
                            for (let O = 1; O <= N; O++) {
                                let B = (N + 1) * (_ - 1) + (O - 1),
                                    k = (N + 1) * _ + (O - 1),
                                    F = (N + 1) * _ + O,
                                    j = (N + 1) * (_ - 1) + O;
                                U.push(B, k, j), U.push(k, F, j)
                            }

                        function v(_, O, B, N, k) {
                            let F = Math.cos(_),
                                U = Math.sin(_),
                                j = B / O * _,
                                G = Math.cos(j);
                            k.x = N * (2 + G) * .5 * F, k.y = N * (2 + G) * U * .5, k.z = N * Math.sin(j) * .5
                        }
                        this.setIndex(U), this.setAttribute("position", new sG(j, 3)), this.setAttribute("normal", new sG(G, 3)), this.setAttribute("uv", new sG(Y, 2))
                    }
                    static fromJSON(_) {
                        return new oA(_.radius, _.tube, _.tubularSegments, _.radialSegments, _.p, _.q)
                    }
                };

            function Aa(_, O, B) {
                return pM(_) ? new _.constructor(_.subarray(O, void 0 !== B ? B : _.length)) : _.slice(O, B)
            }

            function ig(_, O, B) {
                return _ && (B || _.constructor !== O) ? "number" == typeof O.BYTES_PER_ELEMENT ? new O(_) : Array.prototype.slice.call(_) : _
            }

            function pM(_) {
                return ArrayBuffer.isView(_) && !(_ instanceof DataView)
            }

            function kE(_, O, B) {
                let N = _.length,
                    k = new _.constructor(N);
                for (let F = 0, U = 0; U !== N; ++F) {
                    let N = B[F] * O;
                    for (let B = 0; B !== O; ++B) k[U++] = _[N + B]
                }
                return k
            }

            function mM(_, O, B, N) {
                let k = 1,
                    F = _[0];
                for (; void 0 !== F && void 0 === F[N];) F = _[k++];
                if (void 0 === F) return;
                let U = F[N];
                if (void 0 !== U) {
                    if (Array.isArray(U))
                        do void 0 !== (U = F[N]) && (O.push(F.time), B.push.apply(B, U)), F = _[k++]; while (void 0 !== F);
                    else if (void 0 !== U.toArray)
                        do void 0 !== (U = F[N]) && (O.push(F.time), U.toArray(B, B.length)), F = _[k++]; while (void 0 !== F);
                    else
                        do void 0 !== (U = F[N]) && (O.push(F.time), B.push(U)), F = _[k++]; while (void 0 !== F)
                }
            }
            var oE = class {
                    constructor(_, O, B, N) {
                        this.parameterPositions = _, this._cachedIndex = 0, this.resultBuffer = void 0 !== N ? N : new O.constructor(B), this.sampleValues = O, this.valueSize = B, this.settings = null, this.DefaultSettings_ = {}
                    }
                    evaluate(_) {
                        let O = this.parameterPositions,
                            B = this._cachedIndex,
                            N = O[B],
                            k = O[B - 1];
                        e: {
                            t: {
                                let F;i: {
                                    r: if (!(_ < N)) {
                                        for (let F = B + 2;;) {
                                            if (void 0 === N) {
                                                if (_ < k) break r;
                                                return B = O.length, this._cachedIndex = B, this.copySampleValue_(B - 1)
                                            }
                                            if (B === F) break;
                                            if (k = N, _ < (N = O[++B])) break t
                                        }
                                        F = O.length;
                                        break i
                                    }if (!(_ >= k)) {
                                        let U = O[1];
                                        _ < U && (B = 2, k = U);
                                        for (let F = B - 2;;) {
                                            if (void 0 === k) return this._cachedIndex = 0, this.copySampleValue_(0);
                                            if (B === F) break;
                                            if (N = k, _ >= (k = O[--B - 1])) break t
                                        }
                                        F = B, B = 0;
                                        break i
                                    }
                                    break e
                                }
                                for (; B < F;) {
                                    let N = B + F >>> 1;
                                    _ < O[N] ? F = N : B = N + 1
                                }
                                if (N = O[B], void 0 === (k = O[B - 1])) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (void 0 === N) return B = O.length, this._cachedIndex = B, this.copySampleValue_(B - 1)
                            }
                            this._cachedIndex = B,
                            this.intervalChanged_(B, k, N)
                        }
                        return this.interpolate_(B, k, _, N)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(_) {
                        let O = this.resultBuffer,
                            B = this.sampleValues,
                            N = this.valueSize,
                            k = _ * N;
                        for (let _ = 0; _ !== N; ++_) O[_] = B[k + _];
                        return O
                    }
                    interpolate_() {
                        throw Error("call to abstract method")
                    }
                    intervalChanged_() {}
                },
                oC = class extends oE {
                    constructor(_, O, B, N) {
                        super(_, O, B, N), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                            endingStart: 2400,
                            endingEnd: 2400
                        }
                    }
                    intervalChanged_(_, O, B) {
                        let N = this.parameterPositions,
                            k = _ - 2,
                            F = _ + 1,
                            U = N[k],
                            j = N[F];
                        if (void 0 === U) switch (this.getSettings_().endingStart) {
                            case 2401:
                                k = _, U = 2 * O - B;
                                break;
                            case 2402:
                                k = N.length - 2, U = O + N[k] - N[k + 1];
                                break;
                            default:
                                k = _, U = B
                        }
                        if (void 0 === j) switch (this.getSettings_().endingEnd) {
                            case 2401:
                                F = _, j = 2 * B - O;
                                break;
                            case 2402:
                                F = 1, j = B + N[1] - N[0];
                                break;
                            default:
                                F = _ - 1, j = O
                        }
                        let G = (B - O) * .5,
                            Y = this.valueSize;
                        this._weightPrev = G / (O - U), this._weightNext = G / (j - B), this._offsetPrev = k * Y, this._offsetNext = F * Y
                    }
                    interpolate_(_, O, B, N) {
                        let k = this.resultBuffer,
                            F = this.sampleValues,
                            U = this.valueSize,
                            j = _ * U,
                            G = j - U,
                            Y = this._offsetPrev,
                            Q = this._offsetNext,
                            K = this._weightPrev,
                            $ = this._weightNext,
                            ee = (B - O) / (N - O),
                            et = ee * ee,
                            ei = et * ee,
                            er = -K * ei + 2 * K * et - K * ee,
                            ea = (1 + K) * ei + (-1.5 - 2 * K) * et + (-.5 + K) * ee + 1,
                            en = (-1 - $) * ei + (1.5 + $) * et + .5 * ee,
                            eo = $ * ei - $ * et;
                        for (let _ = 0; _ !== U; ++_) k[_] = er * F[Y + _] + ea * F[G + _] + en * F[j + _] + eo * F[Q + _];
                        return k
                    }
                },
                oD = class extends oE {
                    constructor(_, O, B, N) {
                        super(_, O, B, N)
                    }
                    interpolate_(_, O, B, N) {
                        let k = this.resultBuffer,
                            F = this.sampleValues,
                            U = this.valueSize,
                            j = _ * U,
                            G = j - U,
                            Y = (B - O) / (N - O),
                            Q = 1 - Y;
                        for (let _ = 0; _ !== U; ++_) k[_] = F[G + _] * Q + F[j + _] * Y;
                        return k
                    }
                },
                oP = class extends oE {
                    constructor(_, O, B, N) {
                        super(_, O, B, N)
                    }
                    interpolate_(_) {
                        return this.copySampleValue_(_ - 1)
                    }
                },
                oI = class {
                    constructor(_, O, B, N) {
                        if (void 0 === _) throw Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === O || 0 === O.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + _);
                        this.name = _, this.times = ig(O, this.TimeBufferType), this.values = ig(B, this.ValueBufferType), this.setInterpolation(N || this.DefaultInterpolation)
                    }
                    static toJSON(_) {
                        let O = _.constructor,
                            B;
                        if (O.toJSON !== this.toJSON) B = O.toJSON(_);
                        else {
                            B = {
                                name: _.name,
                                times: ig(_.times, Array),
                                values: ig(_.values, Array)
                            };
                            let O = _.getInterpolation();
                            O !== _.DefaultInterpolation && (B.interpolation = O)
                        }
                        return B.type = _.ValueTypeName, B
                    }
                    InterpolantFactoryMethodDiscrete(_) {
                        return new oP(this.times, this.values, this.getValueSize(), _)
                    }
                    InterpolantFactoryMethodLinear(_) {
                        return new oD(this.times, this.values, this.getValueSize(), _)
                    }
                    InterpolantFactoryMethodSmooth(_) {
                        return new oC(this.times, this.values, this.getValueSize(), _)
                    }
                    setInterpolation(_) {
                        let O;
                        switch (_) {
                            case 2300:
                                O = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case 2301:
                                O = this.InterpolantFactoryMethodLinear;
                                break;
                            case 2302:
                                O = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === O) {
                            let O = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (_ !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                                else throw Error(O)
                            }
                            return console.warn("THREE.KeyframeTrack:", O), this
                        }
                        return this.createInterpolant = O, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return 2300;
                            case this.InterpolantFactoryMethodLinear:
                                return 2301;
                            case this.InterpolantFactoryMethodSmooth:
                                return 2302
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(_) {
                        if (0 !== _) {
                            let O = this.times;
                            for (let B = 0, N = O.length; B !== N; ++B) O[B] += _
                        }
                        return this
                    }
                    scale(_) {
                        if (1 !== _) {
                            let O = this.times;
                            for (let B = 0, N = O.length; B !== N; ++B) O[B] *= _
                        }
                        return this
                    }
                    trim(_, O) {
                        let B = this.times,
                            N = B.length,
                            k = 0,
                            F = N - 1;
                        for (; k !== N && B[k] < _;) ++k;
                        for (; - 1 !== F && B[F] > O;) --F;
                        if (++F, 0 !== k || F !== N) {
                            k >= F && (k = (F = Math.max(F, 1)) - 1);
                            let _ = this.getValueSize();
                            this.times = Aa(B, k, F), this.values = Aa(this.values, k * _, F * _)
                        }
                        return this
                    }
                    validate() {
                        let _ = !0,
                            O = this.getValueSize();
                        O - Math.floor(O) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), _ = !1);
                        let B = this.times,
                            N = this.values,
                            k = B.length;
                        0 === k && (console.error("THREE.KeyframeTrack: Track is empty.", this), _ = !1);
                        let F = null;
                        for (let O = 0; O !== k; O++) {
                            let N = B[O];
                            if ("number" == typeof N && isNaN(N)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, O, N), _ = !1;
                                break
                            }
                            if (null !== F && F > N) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, O, N, F), _ = !1;
                                break
                            }
                            F = N
                        }
                        if (void 0 !== N && pM(N))
                            for (let O = 0, B = N.length; O !== B; ++O) {
                                let B = N[O];
                                if (isNaN(B)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, O, B), _ = !1;
                                    break
                                }
                            }
                        return _
                    }
                    optimize() {
                        let _ = Aa(this.times),
                            O = Aa(this.values),
                            B = this.getValueSize(),
                            N = 2302 === this.getInterpolation(),
                            k = _.length - 1,
                            F = 1;
                        for (let U = 1; U < k; ++U) {
                            let k = !1,
                                j = _[U];
                            if (j !== _[U + 1] && (1 !== U || j !== _[0])) {
                                if (N) k = !0;
                                else {
                                    let _ = U * B,
                                        N = _ - B,
                                        F = _ + B;
                                    for (let U = 0; U !== B; ++U) {
                                        let B = O[_ + U];
                                        if (B !== O[N + U] || B !== O[F + U]) {
                                            k = !0;
                                            break
                                        }
                                    }
                                }
                            }
                            if (k) {
                                if (U !== F) {
                                    _[F] = _[U];
                                    let N = U * B,
                                        k = F * B;
                                    for (let _ = 0; _ !== B; ++_) O[k + _] = O[N + _]
                                }++F
                            }
                        }
                        if (k > 0) {
                            _[F] = _[k];
                            for (let _ = k * B, N = F * B, U = 0; U !== B; ++U) O[N + U] = O[_ + U];
                            ++F
                        }
                        return F !== _.length ? (this.times = Aa(_, 0, F), this.values = Aa(O, 0, F * B)) : (this.times = _, this.values = O), this
                    }
                    clone() {
                        let _ = Aa(this.times, 0),
                            O = Aa(this.values, 0),
                            B = new this.constructor(this.name, _, O);
                        return B.createInterpolant = this.createInterpolant, B
                    }
                };
            oI.prototype.TimeBufferType = Float32Array, oI.prototype.ValueBufferType = Float32Array, oI.prototype.DefaultInterpolation = 2301;
            var oR = class extends oI {};
            oR.prototype.ValueTypeName = "bool", oR.prototype.ValueBufferType = Array, oR.prototype.DefaultInterpolation = 2300, oR.prototype.InterpolantFactoryMethodLinear = void 0, oR.prototype.InterpolantFactoryMethodSmooth = void 0;
            var oB = class extends oI {};
            oB.prototype.ValueTypeName = "color";
            var oz = class extends oI {};
            oz.prototype.ValueTypeName = "number";
            var oN = class extends oE {
                    constructor(_, O, B, N) {
                        super(_, O, B, N)
                    }
                    interpolate_(_, O, B, N) {
                        let k = this.resultBuffer,
                            F = this.sampleValues,
                            U = this.valueSize,
                            j = (B - O) / (N - O),
                            G = _ * U;
                        for (let _ = G + U; G !== _; G += 4) rm.slerpFlat(k, 0, F, G - U, F, G, j);
                        return k
                    }
                },
                ok = class extends oI {
                    InterpolantFactoryMethodLinear(_) {
                        return new oN(this.times, this.values, this.getValueSize(), _)
                    }
                };
            ok.prototype.ValueTypeName = "quaternion", ok.prototype.DefaultInterpolation = 2301, ok.prototype.InterpolantFactoryMethodSmooth = void 0;
            var oF = class extends oI {};
            oF.prototype.ValueTypeName = "string", oF.prototype.ValueBufferType = Array, oF.prototype.DefaultInterpolation = 2300, oF.prototype.InterpolantFactoryMethodLinear = void 0, oF.prototype.InterpolantFactoryMethodSmooth = void 0;
            var oU = class extends oI {};
            oU.prototype.ValueTypeName = "vector";
            var oj = class {
                    constructor(_, O = -1, B, N = 2500) {
                        this.name = _, this.tracks = B, this.duration = O, this.blendMode = N, this.uuid = Ui(), this.duration < 0 && this.resetDuration()
                    }
                    static parse(_) {
                        let O = [],
                            B = _.tracks,
                            N = 1 / (_.fps || 1);
                        for (let _ = 0, k = B.length; _ !== k; ++_) O.push((function(_) {
                            if (void 0 === _.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                            let O = function(_) {
                                switch (_.toLowerCase()) {
                                    case "scalar":
                                    case "double":
                                    case "float":
                                    case "number":
                                    case "integer":
                                        return oz;
                                    case "vector":
                                    case "vector2":
                                    case "vector3":
                                    case "vector4":
                                        return oU;
                                    case "color":
                                        return oB;
                                    case "quaternion":
                                        return ok;
                                    case "bool":
                                    case "boolean":
                                        return oR;
                                    case "string":
                                        return oF
                                }
                                throw Error("THREE.KeyframeTrack: Unsupported typeName: " + _)
                            }(_.type);
                            if (void 0 === _.times) {
                                let O = [],
                                    B = [];
                                mM(_.keys, O, B, "value"), _.times = O, _.values = B
                            }
                            return void 0 !== O.parse ? O.parse(_) : new O(_.name, _.times, _.values, _.interpolation)
                        })(B[_]).scale(N));
                        let k = new this(_.name, _.duration, O, _.blendMode);
                        return k.uuid = _.uuid, k
                    }
                    static toJSON(_) {
                        let O = [],
                            B = _.tracks,
                            N = {
                                name: _.name,
                                duration: _.duration,
                                tracks: O,
                                uuid: _.uuid,
                                blendMode: _.blendMode
                            };
                        for (let _ = 0, N = B.length; _ !== N; ++_) O.push(oI.toJSON(B[_]));
                        return N
                    }
                    static CreateFromMorphTargetSequence(_, O, B, N) {
                        let k = O.length,
                            F = [];
                        for (let _ = 0; _ < k; _++) {
                            let U = [],
                                j = [];
                            U.push((_ + k - 1) % k, _, (_ + 1) % k), j.push(0, 1, 0);
                            let G = function(_) {
                                let O = _.length,
                                    B = Array(O);
                                for (let _ = 0; _ !== O; ++_) B[_] = _;
                                return B.sort(function(O, B) {
                                    return _[O] - _[B]
                                }), B
                            }(U);
                            U = kE(U, 1, G), j = kE(j, 1, G), N || 0 !== U[0] || (U.push(k), j.push(j[0])), F.push(new oz(".morphTargetInfluences[" + O[_].name + "]", U, j).scale(1 / B))
                        }
                        return new this(_, -1, F)
                    }
                    static findByName(_, O) {
                        let B = _;
                        Array.isArray(_) || (B = _.geometry && _.geometry.animations || _.animations);
                        for (let _ = 0; _ < B.length; _++)
                            if (B[_].name === O) return B[_];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(_, O, B) {
                        let N = {},
                            k = /^([\w-]*?)([\d]+)$/;
                        for (let O = 0, B = _.length; O < B; O++) {
                            let B = _[O],
                                F = B.name.match(k);
                            if (F && F.length > 1) {
                                let _ = F[1],
                                    O = N[_];
                                O || (N[_] = O = []), O.push(B)
                            }
                        }
                        let F = [];
                        for (let _ in N) F.push(this.CreateFromMorphTargetSequence(_, N[_], O, B));
                        return F
                    }
                    static parseAnimation(_, O) {
                        if (!_) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        let r = function(_, O, B, N, k) {
                                if (0 !== B.length) {
                                    let F = [],
                                        U = [];
                                    mM(B, F, U, N), 0 !== F.length && k.push(new _(O, F, U))
                                }
                            },
                            B = [],
                            N = _.name || "default",
                            k = _.fps || 30,
                            F = _.blendMode,
                            U = _.length || -1,
                            j = _.hierarchy || [];
                        for (let _ = 0; _ < j.length; _++) {
                            let N = j[_].keys;
                            if (!(!N || 0 === N.length)) {
                                if (N[0].morphTargets) {
                                    let _ = {},
                                        O;
                                    for (O = 0; O < N.length; O++)
                                        if (N[O].morphTargets)
                                            for (let B = 0; B < N[O].morphTargets.length; B++) _[N[O].morphTargets[B]] = -1;
                                    for (let k in _) {
                                        let _ = [],
                                            F = [];
                                        for (let B = 0; B !== N[O].morphTargets.length; ++B) {
                                            let B = N[O];
                                            _.push(B.time), F.push(B.morphTarget === k ? 1 : 0)
                                        }
                                        B.push(new oz(".morphTargetInfluence[" + k + "]", _, F))
                                    }
                                    U = _.length * k
                                } else {
                                    let k = ".bones[" + O[_].name + "]";
                                    r(oU, k + ".position", N, "pos", B), r(ok, k + ".quaternion", N, "rot", B), r(oU, k + ".scale", N, "scl", B)
                                }
                            }
                        }
                        return 0 === B.length ? null : new this(N, U, B, F)
                    }
                    resetDuration() {
                        let _ = this.tracks,
                            O = 0;
                        for (let B = 0, N = _.length; B !== N; ++B) {
                            let _ = this.tracks[B];
                            O = Math.max(O, _.times[_.times.length - 1])
                        }
                        return this.duration = O, this
                    }
                    trim() {
                        for (let _ = 0; _ < this.tracks.length; _++) this.tracks[_].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let _ = !0;
                        for (let O = 0; O < this.tracks.length; O++) _ = _ && this.tracks[O].validate();
                        return _
                    }
                    optimize() {
                        for (let _ = 0; _ < this.tracks.length; _++) this.tracks[_].optimize();
                        return this
                    }
                    clone() {
                        let _ = [];
                        for (let O = 0; O < this.tracks.length; O++) _.push(this.tracks[O].clone());
                        return new this.constructor(this.name, this.duration, _, this.blendMode)
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                },
                oG = {
                    enabled: !1,
                    files: {},
                    add: function(_, O) {
                        !1 !== this.enabled && (this.files[_] = O)
                    },
                    get: function(_) {
                        if (!1 !== this.enabled) return this.files[_]
                    },
                    remove: function(_) {
                        delete this.files[_]
                    },
                    clear: function() {
                        this.files = {}
                    }
                },
                oH = class {
                    constructor(_, O, B) {
                        let N = this,
                            k = !1,
                            F = 0,
                            U = 0,
                            j, G = [];
                        this.onStart = void 0, this.onLoad = _, this.onProgress = O, this.onError = B, this.itemStart = function(_) {
                            U++, !1 === k && void 0 !== N.onStart && N.onStart(_, F, U), k = !0
                        }, this.itemEnd = function(_) {
                            F++, void 0 !== N.onProgress && N.onProgress(_, F, U), F === U && (k = !1, void 0 !== N.onLoad && N.onLoad())
                        }, this.itemError = function(_) {
                            void 0 !== N.onError && N.onError(_)
                        }, this.resolveURL = function(_) {
                            return j ? j(_) : _
                        }, this.setURLModifier = function(_) {
                            return j = _, this
                        }, this.addHandler = function(_, O) {
                            return G.push(_, O), this
                        }, this.removeHandler = function(_) {
                            let O = G.indexOf(_);
                            return -1 !== O && G.splice(O, 2), this
                        }, this.getHandler = function(_) {
                            for (let O = 0, B = G.length; O < B; O += 2) {
                                let B = G[O],
                                    N = G[O + 1];
                                if (B.global && (B.lastIndex = 0), B.test(_)) return N
                            }
                            return null
                        }
                    }
                },
                oW = new oH,
                oq = class {
                    constructor(_) {
                        this.manager = void 0 !== _ ? _ : oW, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(_, O) {
                        let B = this;
                        return new Promise(function(N, k) {
                            B.load(_, N, O, k)
                        })
                    }
                    parse() {}
                    setCrossOrigin(_) {
                        return this.crossOrigin = _, this
                    }
                    setWithCredentials(_) {
                        return this.withCredentials = _, this
                    }
                    setPath(_) {
                        return this.path = _, this
                    }
                    setResourcePath(_) {
                        return this.resourcePath = _, this
                    }
                    setRequestHeader(_) {
                        return this.requestHeader = _, this
                    }
                },
                oY = {},
                oX = class extends Error {
                    constructor(_, O) {
                        super(_), this.response = O
                    }
                },
                oQ = class extends oq {
                    constructor(_) {
                        super(_)
                    }
                    load(_, O, B, N) {
                        void 0 === _ && (_ = ""), void 0 !== this.path && (_ = this.path + _), _ = this.manager.resolveURL(_);
                        let k = oG.get(_);
                        if (void 0 !== k) return this.manager.itemStart(_), setTimeout(() => {
                            O && O(k), this.manager.itemEnd(_)
                        }, 0), k;
                        if (void 0 !== oY[_]) {
                            oY[_].push({
                                onLoad: O,
                                onProgress: B,
                                onError: N
                            });
                            return
                        }
                        oY[_] = [], oY[_].push({
                            onLoad: O,
                            onProgress: B,
                            onError: N
                        });
                        let F = new Request(_, {
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials ? "include" : "same-origin"
                            }),
                            U = this.mimeType,
                            j = this.responseType;
                        fetch(F).then(O => {
                            if (200 === O.status || 0 === O.status) {
                                if (0 === O.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || void 0 === O.body || void 0 === O.body.getReader) return O;
                                let B = oY[_],
                                    N = O.body.getReader(),
                                    k = O.headers.get("Content-Length") || O.headers.get("X-File-Size"),
                                    F = k ? parseInt(k) : 0,
                                    U = 0 !== F,
                                    j = 0,
                                    G = new ReadableStream({
                                        start(_) {
                                            (function v() {
                                                N.read().then(({
                                                    done: O,
                                                    value: N
                                                }) => {
                                                    if (O) _.close();
                                                    else {
                                                        j += N.byteLength;
                                                        let O = new ProgressEvent("progress", {
                                                            lengthComputable: U,
                                                            loaded: j,
                                                            total: F
                                                        });
                                                        for (let _ = 0, N = B.length; _ < N; _++) {
                                                            let N = B[_];
                                                            N.onProgress && N.onProgress(O)
                                                        }
                                                        _.enqueue(N), v()
                                                    }
                                                })
                                            })()
                                        }
                                    });
                                return new Response(G)
                            }
                            throw new oX(`fetch for "${O.url}" responded with ${O.status}: ${O.statusText}`, O)
                        }).then(_ => {
                            switch (j) {
                                case "arraybuffer":
                                    return _.arrayBuffer();
                                case "blob":
                                    return _.blob();
                                case "document":
                                    return _.text().then(_ => new DOMParser().parseFromString(_, U));
                                case "json":
                                    return _.json();
                                default:
                                    if (void 0 === U) return _.text(); {
                                        let O = /charset="?([^;"\s]*)"?/i.exec(U),
                                            B = O && O[1] ? O[1].toLowerCase() : void 0,
                                            N = new TextDecoder(B);
                                        return _.arrayBuffer().then(_ => N.decode(_))
                                    }
                            }
                        }).then(O => {
                            oG.add(_, O);
                            let B = oY[_];
                            delete oY[_];
                            for (let _ = 0, N = B.length; _ < N; _++) {
                                let N = B[_];
                                N.onLoad && N.onLoad(O)
                            }
                        }).catch(O => {
                            let B = oY[_];
                            if (void 0 === B) throw this.manager.itemError(_), O;
                            delete oY[_];
                            for (let _ = 0, N = B.length; _ < N; _++) {
                                let N = B[_];
                                N.onError && N.onError(O)
                            }
                            this.manager.itemError(_)
                        }).finally(() => {
                            this.manager.itemEnd(_)
                        }), this.manager.itemStart(_)
                    }
                    setResponseType(_) {
                        return this.responseType = _, this
                    }
                    setMimeType(_) {
                        return this.mimeType = _, this
                    }
                },
                oZ = class extends sv {
                    constructor(_, O = 1) {
                        super(), this.isLight = !0, this.type = "Light", this.color = new re(_), this.intensity = O
                    }
                    dispose() {}
                    copy(_, O) {
                        return super.copy(_, O), this.color.copy(_.color), this.intensity = _.intensity, this
                    }
                    toJSON(_) {
                        let O = super.toJSON(_);
                        return O.object.color = this.color.getHex(), O.object.intensity = this.intensity, void 0 !== this.groundColor && (O.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (O.object.distance = this.distance), void 0 !== this.angle && (O.object.angle = this.angle), void 0 !== this.decay && (O.object.decay = this.decay), void 0 !== this.penumbra && (O.object.penumbra = this.penumbra), void 0 !== this.shadow && (O.object.shadow = this.shadow.toJSON()), O
                    }
                },
                oK = class extends oZ {
                    constructor(_, O, B) {
                        super(_, B), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(sv.DEFAULT_UP), this.updateMatrix(), this.groundColor = new re(O)
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.groundColor.copy(_.groundColor), this
                    }
                },
                oJ = new rJ,
                o$ = new rv,
                o0 = new rv,
                o1 = class {
                    constructor(_) {
                        this.camera = _, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new iJ(512, 512), this.map = null, this.mapPass = null, this.matrix = new rJ, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new aw, this._frameExtents = new iJ(1, 1), this._viewportCount = 1, this._viewports = [new rl(0, 0, 1, 1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(_) {
                        let O = this.camera,
                            B = this.matrix;
                        o$.setFromMatrixPosition(_.matrixWorld), O.position.copy(o$), o0.setFromMatrixPosition(_.target.matrixWorld), O.lookAt(o0), O.updateMatrixWorld(), oJ.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), this._frustum.setFromProjectionMatrix(oJ), B.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), B.multiply(oJ)
                    }
                    getViewport(_) {
                        return this._viewports[_]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                    }
                    copy(_) {
                        return this.camera = _.camera.clone(), this.bias = _.bias, this.radius = _.radius, this.mapSize.copy(_.mapSize), this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        let _ = {};
                        return 0 !== this.bias && (_.bias = this.bias), 0 !== this.normalBias && (_.normalBias = this.normalBias), 1 !== this.radius && (_.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (_.mapSize = this.mapSize.toArray()), _.camera = this.camera.toJSON(!1).object, delete _.camera.matrix, _
                    }
                },
                o3 = class extends o1 {
                    constructor() {
                        super(new al(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                    }
                    updateMatrices(_) {
                        let O = this.camera,
                            B = 2 * iZ * _.angle * this.focus,
                            N = this.mapSize.width / this.mapSize.height,
                            k = _.distance || O.far;
                        (B !== O.fov || N !== O.aspect || k !== O.far) && (O.fov = B, O.aspect = N, O.far = k, O.updateProjectionMatrix()), super.updateMatrices(_)
                    }
                    copy(_) {
                        return super.copy(_), this.focus = _.focus, this
                    }
                },
                o4 = class extends oZ {
                    constructor(_, O, B = 0, N = Math.PI / 3, k = 0, F = 2) {
                        super(_, O), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(sv.DEFAULT_UP), this.updateMatrix(), this.target = new sv, this.distance = B, this.angle = N, this.penumbra = k, this.decay = F, this.map = null, this.shadow = new o3
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(_) {
                        this.intensity = _ / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.distance = _.distance, this.angle = _.angle, this.penumbra = _.penumbra, this.decay = _.decay, this.target = _.target.clone(), this.shadow = _.shadow.clone(), this
                    }
                },
                o5 = new rJ,
                o6 = new rv,
                o8 = new rv,
                o9 = class extends o1 {
                    constructor() {
                        super(new al(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new iJ(4, 2), this._viewportCount = 6, this._viewports = [new rl(2, 1, 1, 1), new rl(0, 1, 1, 1), new rl(3, 1, 1, 1), new rl(1, 1, 1, 1), new rl(3, 0, 1, 1), new rl(1, 0, 1, 1)], this._cubeDirections = [new rv(1, 0, 0), new rv(-1, 0, 0), new rv(0, 0, 1), new rv(0, 0, -1), new rv(0, 1, 0), new rv(0, -1, 0)], this._cubeUps = [new rv(0, 1, 0), new rv(0, 1, 0), new rv(0, 1, 0), new rv(0, 1, 0), new rv(0, 0, 1), new rv(0, 0, -1)]
                    }
                    updateMatrices(_, O = 0) {
                        let B = this.camera,
                            N = this.matrix,
                            k = _.distance || B.far;
                        k !== B.far && (B.far = k, B.updateProjectionMatrix()), o6.setFromMatrixPosition(_.matrixWorld), B.position.copy(o6), o8.copy(B.position), o8.add(this._cubeDirections[O]), B.up.copy(this._cubeUps[O]), B.lookAt(o8), B.updateMatrixWorld(), N.makeTranslation(-o6.x, -o6.y, -o6.z), o5.multiplyMatrices(B.projectionMatrix, B.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o5)
                    }
                },
                o7 = class extends oZ {
                    constructor(_, O, B = 0, N = 2) {
                        super(_, O), this.isPointLight = !0, this.type = "PointLight", this.distance = B, this.decay = N, this.shadow = new o9
                    }
                    get power() {
                        return 4 * this.intensity * Math.PI
                    }
                    set power(_) {
                        this.intensity = _ / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.distance = _.distance, this.decay = _.decay, this.shadow = _.shadow.clone(), this
                    }
                },
                le = class extends o1 {
                    constructor() {
                        super(new aI(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                    }
                },
                lt = class extends oZ {
                    constructor(_, O) {
                        super(_, O), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(sv.DEFAULT_UP), this.updateMatrix(), this.target = new sv, this.shadow = new le
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(_) {
                        return super.copy(_), this.target = _.target.clone(), this.shadow = _.shadow.clone(), this
                    }
                },
                li = class extends sK {
                    constructor() {
                        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                    }
                    copy(_) {
                        return super.copy(_), this.instanceCount = _.instanceCount, this
                    }
                    toJSON() {
                        let _ = super.toJSON();
                        return _.instanceCount = this.instanceCount, _.isInstancedBufferGeometry = !0, _
                    }
                },
                lr = class extends oq {
                    constructor(_) {
                        super(_)
                    }
                    load(_, O, B, N) {
                        let k = this,
                            F = new oQ(k.manager);
                        F.setPath(k.path), F.setRequestHeader(k.requestHeader), F.setWithCredentials(k.withCredentials), F.load(_, function(B) {
                            try {
                                O(k.parse(JSON.parse(B)))
                            } catch (O) {
                                N ? N(O) : console.error(O), k.manager.itemError(_)
                            }
                        }, B, N)
                    }
                    parse(_) {
                        let O = {},
                            B = {};

                        function n(_, N) {
                            if (void 0 !== O[N]) return O[N];
                            let k = _.interleavedBuffers[N],
                                F = function(_, O) {
                                    if (void 0 !== B[O]) return B[O];
                                    let N = _.arrayBuffers[O],
                                        k = new Uint32Array(N).buffer;
                                    return B[O] = k, k
                                }(_, k.buffer),
                                U = Nm(k.type, F),
                                j = new nE(U, k.stride);
                            return j.uuid = k.uuid, O[N] = j, j
                        }
                        let N = _.isInstancedBufferGeometry ? new li : new sK,
                            k = _.data.index;
                        if (void 0 !== k) {
                            let _ = Nm(k.type, k.array);
                            N.setIndex(new sF(_, 1))
                        }
                        let F = _.data.attributes;
                        for (let O in F) {
                            let B = F[O],
                                k;
                            if (B.isInterleavedBufferAttribute) {
                                let O = n(_.data, B.data);
                                k = new nD(O, B.itemSize, B.offset, B.normalized)
                            } else {
                                let _ = Nm(B.type, B.array);
                                k = new(B.isInstancedBufferAttribute ? nN : sF)(_, B.itemSize, B.normalized)
                            }
                            void 0 !== B.name && (k.name = B.name), void 0 !== B.usage && k.setUsage(B.usage), void 0 !== B.updateRange && (k.updateRange.offset = B.updateRange.offset, k.updateRange.count = B.updateRange.count), N.setAttribute(O, k)
                        }
                        let U = _.data.morphAttributes;
                        if (U)
                            for (let O in U) {
                                let B = U[O],
                                    k = [];
                                for (let O = 0, N = B.length; O < N; O++) {
                                    let N = B[O],
                                        F;
                                    if (N.isInterleavedBufferAttribute) {
                                        let O = n(_.data, N.data);
                                        F = new nD(O, N.itemSize, N.offset, N.normalized)
                                    } else {
                                        let _ = Nm(N.type, N.array);
                                        F = new sF(_, N.itemSize, N.normalized)
                                    }
                                    void 0 !== N.name && (F.name = N.name), k.push(F)
                                }
                                N.morphAttributes[O] = k
                            }
                        _.data.morphTargetsRelative && (N.morphTargetsRelative = !0);
                        let j = _.data.groups || _.data.drawcalls || _.data.offsets;
                        if (void 0 !== j)
                            for (let _ = 0, O = j.length; _ !== O; ++_) {
                                let O = j[_];
                                N.addGroup(O.start, O.count, O.materialIndex)
                            }
                        let G = _.data.boundingSphere;
                        if (void 0 !== G) {
                            let _ = new rv;
                            void 0 !== G.center && _.fromArray(G.center), N.boundingSphere = new rG(_, G.radius)
                        }
                        return _.name && (N.name = _.name), _.userData && (N.userData = _.userData), N
                    }
                },
                ls = class {
                    constructor(_ = !0) {
                        this.autoStart = _, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                    }
                    start() {
                        this.startTime = HE(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(), this.running = !1, this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(), this.elapsedTime
                    }
                    getDelta() {
                        let _ = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            let O = HE();
                            _ = (O - this.oldTime) / 1e3, this.oldTime = O, this.elapsedTime += _
                        }
                        return _
                    }
                };

            function HE() {
                return (typeof performance > "u" ? Date : performance).now()
            }
            var la = class {
                    constructor(_, O, B) {
                        let N, k, F;
                        switch (this.binding = _, this.valueSize = B, O) {
                            case "quaternion":
                                N = this._slerp, k = this._slerpAdditive, F = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * B), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                N = this._select, k = this._select, F = this._setAdditiveIdentityOther, this.buffer = Array(5 * B);
                                break;
                            default:
                                N = this._lerp, k = this._lerpAdditive, F = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * B)
                        }
                        this._mixBufferRegion = N, this._mixBufferRegionAdditive = k, this._setIdentity = F, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(_, O) {
                        let B = this.buffer,
                            N = this.valueSize,
                            k = _ * N + N,
                            F = this.cumulativeWeight;
                        if (0 === F) {
                            for (let _ = 0; _ !== N; ++_) B[k + _] = B[_];
                            F = O
                        } else {
                            F += O;
                            let _ = O / F;
                            this._mixBufferRegion(B, k, 0, _, N)
                        }
                        this.cumulativeWeight = F
                    }
                    accumulateAdditive(_) {
                        let O = this.buffer,
                            B = this.valueSize,
                            N = B * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(O, N, 0, _, B), this.cumulativeWeightAdditive += _
                    }
                    apply(_) {
                        let O = this.valueSize,
                            B = this.buffer,
                            N = _ * O + O,
                            k = this.cumulativeWeight,
                            F = this.cumulativeWeightAdditive,
                            U = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, k < 1) {
                            let _ = O * this._origIndex;
                            this._mixBufferRegion(B, N, _, 1 - k, O)
                        }
                        F > 0 && this._mixBufferRegionAdditive(B, N, this._addIndex * O, 1, O);
                        for (let _ = O, k = O + O; _ !== k; ++_)
                            if (B[_] !== B[_ + O]) {
                                U.setValue(B, N);
                                break
                            }
                    }
                    saveOriginalState() {
                        let _ = this.binding,
                            O = this.buffer,
                            B = this.valueSize,
                            N = B * this._origIndex;
                        _.getValue(O, N);
                        for (let _ = B; _ !== N; ++_) O[_] = O[N + _ % B];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        let _ = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, _)
                    }
                    _setAdditiveIdentityNumeric() {
                        let _ = this._addIndex * this.valueSize,
                            O = _ + this.valueSize;
                        for (let B = _; B < O; B++) this.buffer[B] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        let _ = this._origIndex * this.valueSize,
                            O = this._addIndex * this.valueSize;
                        for (let B = 0; B < this.valueSize; B++) this.buffer[O + B] = this.buffer[_ + B]
                    }
                    _select(_, O, B, N, k) {
                        if (N >= .5)
                            for (let N = 0; N !== k; ++N) _[O + N] = _[B + N]
                    }
                    _slerp(_, O, B, N) {
                        rm.slerpFlat(_, O, _, O, _, B, N)
                    }
                    _slerpAdditive(_, O, B, N, k) {
                        let F = this._workIndex * k;
                        rm.multiplyQuaternionsFlat(_, F, _, O, _, B), rm.slerpFlat(_, O, _, O, _, F, N)
                    }
                    _lerp(_, O, B, N, k) {
                        let F = 1 - N;
                        for (let U = 0; U !== k; ++U) {
                            let k = O + U;
                            _[k] = _[k] * F + _[B + U] * N
                        }
                    }
                    _lerpAdditive(_, O, B, N, k) {
                        for (let F = 0; F !== k; ++F) {
                            let k = O + F;
                            _[k] = _[k] + _[B + F] * N
                        }
                    }
                },
                ln = "\\[\\]\\.:\\/",
                lo = RegExp("[" + ln + "]", "g"),
                lc = "[^" + ln + "]",
                ld = "[^" + ln.replace("\\.", "") + "]",
                lu = RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", lc) + /(WCOD+)?/.source.replace("WCOD", ld) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", lc) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", lc) + "$"),
                lf = ["material", "materials", "bones", "map"],
                lm = class {
                    constructor(_, O, B) {
                        let N = B || lv.parseTrackName(O);
                        this._targetGroup = _, this._bindings = _.subscribe_(O, N)
                    }
                    getValue(_, O) {
                        this.bind();
                        let B = this._targetGroup.nCachedObjects_,
                            N = this._bindings[B];
                        void 0 !== N && N.getValue(_, O)
                    }
                    setValue(_, O) {
                        let B = this._bindings;
                        for (let N = this._targetGroup.nCachedObjects_, k = B.length; N !== k; ++N) B[N].setValue(_, O)
                    }
                    bind() {
                        let _ = this._bindings;
                        for (let O = this._targetGroup.nCachedObjects_, B = _.length; O !== B; ++O) _[O].bind()
                    }
                    unbind() {
                        let _ = this._bindings;
                        for (let O = this._targetGroup.nCachedObjects_, B = _.length; O !== B; ++O) _[O].unbind()
                    }
                },
                lv = class {
                    constructor(_, O, B) {
                        this.path = O, this.parsedPath = B || lv.parseTrackName(O), this.node = lv.findNode(_, this.parsedPath.nodeName) || _, this.rootNode = _, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                    static create(_, O, B) {
                        return _ && _.isAnimationObjectGroup ? new lv.Composite(_, O, B) : new lv(_, O, B)
                    }
                    static sanitizeNodeName(_) {
                        return _.replace(/\s/g, "_").replace(lo, "")
                    }
                    static parseTrackName(_) {
                        let O = lu.exec(_);
                        if (null === O) throw Error("PropertyBinding: Cannot parse trackName: " + _);
                        let B = {
                                nodeName: O[2],
                                objectName: O[3],
                                objectIndex: O[4],
                                propertyName: O[5],
                                propertyIndex: O[6]
                            },
                            N = B.nodeName && B.nodeName.lastIndexOf(".");
                        if (void 0 !== N && -1 !== N) {
                            let _ = B.nodeName.substring(N + 1); - 1 !== lf.indexOf(_) && (B.nodeName = B.nodeName.substring(0, N), B.objectName = _)
                        }
                        if (null === B.propertyName || 0 === B.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + _);
                        return B
                    }
                    static findNode(_, O) {
                        if (void 0 === O || "" === O || "." === O || -1 === O || O === _.name || O === _.uuid) return _;
                        if (_.skeleton) {
                            let B = _.skeleton.getBoneByName(O);
                            if (void 0 !== B) return B
                        }
                        if (_.children) {
                            let r = function(_) {
                                    for (let B = 0; B < _.length; B++) {
                                        let N = _[B];
                                        if (N.name === O || N.uuid === O) return N;
                                        let k = r(N.children);
                                        if (k) return k
                                    }
                                    return null
                                },
                                B = r(_.children);
                            if (B) return B
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(_, O) {
                        _[O] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(_, O) {
                        let B = this.resolvedProperty;
                        for (let N = 0, k = B.length; N !== k; ++N) _[O++] = B[N]
                    }
                    _getValue_arrayElement(_, O) {
                        _[O] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(_, O) {
                        this.resolvedProperty.toArray(_, O)
                    }
                    _setValue_direct(_, O) {
                        this.targetObject[this.propertyName] = _[O]
                    }
                    _setValue_direct_setNeedsUpdate(_, O) {
                        this.targetObject[this.propertyName] = _[O], this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(_, O) {
                        this.targetObject[this.propertyName] = _[O], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(_, O) {
                        let B = this.resolvedProperty;
                        for (let N = 0, k = B.length; N !== k; ++N) B[N] = _[O++]
                    }
                    _setValue_array_setNeedsUpdate(_, O) {
                        let B = this.resolvedProperty;
                        for (let N = 0, k = B.length; N !== k; ++N) B[N] = _[O++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(_, O) {
                        let B = this.resolvedProperty;
                        for (let N = 0, k = B.length; N !== k; ++N) B[N] = _[O++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(_, O) {
                        this.resolvedProperty[this.propertyIndex] = _[O]
                    }
                    _setValue_arrayElement_setNeedsUpdate(_, O) {
                        this.resolvedProperty[this.propertyIndex] = _[O], this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(_, O) {
                        this.resolvedProperty[this.propertyIndex] = _[O], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(_, O) {
                        this.resolvedProperty.fromArray(_, O)
                    }
                    _setValue_fromArray_setNeedsUpdate(_, O) {
                        this.resolvedProperty.fromArray(_, O), this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(_, O) {
                        this.resolvedProperty.fromArray(_, O), this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(_, O) {
                        this.bind(), this.getValue(_, O)
                    }
                    _setValue_unbound(_, O) {
                        this.bind(), this.setValue(_, O)
                    }
                    bind() {
                        let _ = this.node,
                            O = this.parsedPath,
                            B = O.objectName,
                            N = O.propertyName,
                            k = O.propertyIndex;
                        if (_ || (_ = lv.findNode(this.rootNode, O.nodeName) || this.rootNode, this.node = _), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !_) {
                            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                            return
                        }
                        if (B) {
                            let N = O.objectIndex;
                            switch (B) {
                                case "materials":
                                    if (!_.material) {
                                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        return
                                    }
                                    if (!_.material.materials) {
                                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        return
                                    }
                                    _ = _.material.materials;
                                    break;
                                case "bones":
                                    if (!_.skeleton) {
                                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        return
                                    }
                                    _ = _.skeleton.bones;
                                    for (let O = 0; O < _.length; O++)
                                        if (_[O].name === N) {
                                            N = O;
                                            break
                                        }
                                    break;
                                case "map":
                                    if ("map" in _) {
                                        _ = _.map;
                                        break
                                    }
                                    if (!_.material) {
                                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        return
                                    }
                                    if (!_.material.map) {
                                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                        return
                                    }
                                    _ = _.material.map;
                                    break;
                                default:
                                    if (void 0 === _[B]) {
                                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        return
                                    }
                                    _ = _[B]
                            }
                            if (void 0 !== N) {
                                if (void 0 === _[N]) {
                                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, _);
                                    return
                                }
                                _ = _[N]
                            }
                        }
                        let F = _[N];
                        if (void 0 === F) {
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + O.nodeName + "." + N + " but it wasn't found.", _);
                            return
                        }
                        let U = this.Versioning.None;
                        this.targetObject = _, void 0 !== _.needsUpdate ? U = this.Versioning.NeedsUpdate : void 0 !== _.matrixWorldNeedsUpdate && (U = this.Versioning.MatrixWorldNeedsUpdate);
                        let j = this.BindingType.Direct;
                        if (void 0 !== k) {
                            if ("morphTargetInfluences" === N) {
                                if (!_.geometry) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    return
                                }
                                if (!_.geometry.morphAttributes) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                void 0 !== _.morphTargetDictionary[k] && (k = _.morphTargetDictionary[k])
                            }
                            j = this.BindingType.ArrayElement, this.resolvedProperty = F, this.propertyIndex = k
                        } else void 0 !== F.fromArray && void 0 !== F.toArray ? (j = this.BindingType.HasFromToArray, this.resolvedProperty = F) : Array.isArray(F) ? (j = this.BindingType.EntireArray, this.resolvedProperty = F) : this.propertyName = N;
                        this.getValue = this.GetterByBindingType[j], this.setValue = this.SetterByBindingTypeAndVersioning[j][U]
                    }
                    unbind() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                };
            lv.Composite = lm, lv.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, lv.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, lv.prototype.GetterByBindingType = [lv.prototype._getValue_direct, lv.prototype._getValue_array, lv.prototype._getValue_arrayElement, lv.prototype._getValue_toArray], lv.prototype.SetterByBindingTypeAndVersioning = [
                [lv.prototype._setValue_direct, lv.prototype._setValue_direct_setNeedsUpdate, lv.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [lv.prototype._setValue_array, lv.prototype._setValue_array_setNeedsUpdate, lv.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [lv.prototype._setValue_arrayElement, lv.prototype._setValue_arrayElement_setNeedsUpdate, lv.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [lv.prototype._setValue_fromArray, lv.prototype._setValue_fromArray_setNeedsUpdate, lv.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            var lx = class {
                    constructor(_, O, B = null, N = O.blendMode) {
                        this._mixer = _, this._clip = O, this._localRoot = B, this.blendMode = N;
                        let k = O.tracks,
                            F = k.length,
                            U = Array(F),
                            j = {
                                endingStart: 2400,
                                endingEnd: 2400
                            };
                        for (let _ = 0; _ !== F; ++_) {
                            let O = k[_].createInterpolant(null);
                            U[_] = O, O.settings = j
                        }
                        this._interpolantSettings = j, this._interpolants = U, this._propertyBindings = Array(F), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this), this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this), this.reset()
                    }
                    reset() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(_) {
                        return this._startTime = _, this
                    }
                    setLoop(_, O) {
                        return this.loop = _, this.repetitions = O, this
                    }
                    setEffectiveWeight(_) {
                        return this.weight = _, this._effectiveWeight = this.enabled ? _ : 0, this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(_) {
                        return this._scheduleFading(_, 0, 1)
                    }
                    fadeOut(_) {
                        return this._scheduleFading(_, 1, 0)
                    }
                    crossFadeFrom(_, O, B) {
                        if (_.fadeOut(O), this.fadeIn(O), B) {
                            let B = this._clip.duration,
                                N = _._clip.duration;
                            _.warp(1, N / B, O), this.warp(B / N, 1, O)
                        }
                        return this
                    }
                    crossFadeTo(_, O, B) {
                        return _.crossFadeFrom(this, O, B)
                    }
                    stopFading() {
                        let _ = this._weightInterpolant;
                        return null !== _ && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(_)), this
                    }
                    setEffectiveTimeScale(_) {
                        return this.timeScale = _, this._effectiveTimeScale = this.paused ? 0 : _, this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(_) {
                        return this.timeScale = this._clip.duration / _, this.stopWarping()
                    }
                    syncWith(_) {
                        return this.time = _.time, this.timeScale = _.timeScale, this.stopWarping()
                    }
                    halt(_) {
                        return this.warp(this._effectiveTimeScale, 0, _)
                    }
                    warp(_, O, B) {
                        let N = this._mixer,
                            k = N.time,
                            F = this.timeScale,
                            U = this._timeScaleInterpolant;
                        null === U && (U = N._lendControlInterpolant(), this._timeScaleInterpolant = U);
                        let j = U.parameterPositions,
                            G = U.sampleValues;
                        return j[0] = k, j[1] = k + B, G[0] = _ / F, G[1] = O / F, this
                    }
                    stopWarping() {
                        let _ = this._timeScaleInterpolant;
                        return null !== _ && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(_)), this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(_, O, B, N) {
                        if (!this.enabled) {
                            this._updateWeight(_);
                            return
                        }
                        let k = this._startTime;
                        if (null !== k) {
                            let N = (_ - k) * B;
                            N < 0 || 0 === B ? O = 0 : (this._startTime = null, O = B * N)
                        }
                        O *= this._updateTimeScale(_);
                        let F = this._updateTime(O),
                            U = this._updateWeight(_);
                        if (U > 0) {
                            let _ = this._interpolants,
                                O = this._propertyBindings;
                            if (2501 === this.blendMode)
                                for (let B = 0, N = _.length; B !== N; ++B) _[B].evaluate(F), O[B].accumulateAdditive(U);
                            else
                                for (let B = 0, k = _.length; B !== k; ++B) _[B].evaluate(F), O[B].accumulate(N, U)
                        }
                    }
                    _updateWeight(_) {
                        let O = 0;
                        if (this.enabled) {
                            O = this.weight;
                            let B = this._weightInterpolant;
                            if (null !== B) {
                                let N = B.evaluate(_)[0];
                                O *= N, _ > B.parameterPositions[1] && (this.stopFading(), 0 === N && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = O, O
                    }
                    _updateTimeScale(_) {
                        let O = 0;
                        if (!this.paused) {
                            O = this.timeScale;
                            let B = this._timeScaleInterpolant;
                            null !== B && (O *= B.evaluate(_)[0], _ > B.parameterPositions[1] && (this.stopWarping(), 0 === O ? this.paused = !0 : this.timeScale = O))
                        }
                        return this._effectiveTimeScale = O, O
                    }
                    _updateTime(_) {
                        let O = this._clip.duration,
                            B = this.loop,
                            N = this.time + _,
                            k = this._loopCount,
                            F = 2202 === B;
                        if (0 === _) return -1 === k ? N : F && (1 & k) == 1 ? O - N : N;
                        if (2200 === B) {
                            -1 === k && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            e: {
                                if (N >= O) N = O;
                                else if (N < 0) N = 0;
                                else {
                                    this.time = N;
                                    break e
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = N,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: _ < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === k && (_ >= 0 ? (k = 0, this._setEndings(!0, 0 === this.repetitions, F)) : this._setEndings(0 === this.repetitions, !0, F)), N >= O || N < 0) {
                                let B = Math.floor(N / O);
                                N -= O * B, k += Math.abs(B);
                                let U = this.repetitions - k;
                                if (U <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, N = _ > 0 ? O : 0, this.time = N, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: _ > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === U) {
                                        let O = _ < 0;
                                        this._setEndings(O, !O, F)
                                    } else this._setEndings(!1, !1, F);
                                    this._loopCount = k, this.time = N, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: B
                                    })
                                }
                            } else this.time = N;
                            if (F && (1 & k) == 1) return O - N
                        }
                        return N
                    }
                    _setEndings(_, O, B) {
                        let N = this._interpolantSettings;
                        B ? (N.endingStart = 2401, N.endingEnd = 2401) : (_ ? N.endingStart = this.zeroSlopeAtStart ? 2401 : 2400 : N.endingStart = 2402, O ? N.endingEnd = this.zeroSlopeAtEnd ? 2401 : 2400 : N.endingEnd = 2402)
                    }
                    _scheduleFading(_, O, B) {
                        let N = this._mixer,
                            k = N.time,
                            F = this._weightInterpolant;
                        null === F && (F = N._lendControlInterpolant(), this._weightInterpolant = F);
                        let U = F.parameterPositions,
                            j = F.sampleValues;
                        return U[0] = k, j[0] = O, U[1] = k + _, j[1] = B, this
                    }
                },
                lb = new Float32Array(1),
                lw = class extends iq {
                    constructor(_) {
                        super(), this._root = _, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                    }
                    _bindAction(_, O) {
                        let B = _._localRoot || this._root,
                            N = _._clip.tracks,
                            k = N.length,
                            F = _._propertyBindings,
                            U = _._interpolants,
                            j = B.uuid,
                            G = this._bindingsByRootAndName,
                            Y = G[j];
                        void 0 === Y && (Y = {}, G[j] = Y);
                        for (let _ = 0; _ !== k; ++_) {
                            let k = N[_],
                                G = k.name,
                                Q = Y[G];
                            if (void 0 !== Q) ++Q.referenceCount, F[_] = Q;
                            else {
                                if (void 0 !== (Q = F[_])) {
                                    null === Q._cacheIndex && (++Q.referenceCount, this._addInactiveBinding(Q, j, G));
                                    continue
                                }
                                let N = O && O._propertyBindings[_].binding.parsedPath;
                                Q = new la(lv.create(B, G, N), k.ValueTypeName, k.getValueSize()), ++Q.referenceCount, this._addInactiveBinding(Q, j, G), F[_] = Q
                            }
                            U[_].resultBuffer = Q.buffer
                        }
                    }
                    _activateAction(_) {
                        if (!this._isActiveAction(_)) {
                            if (null === _._cacheIndex) {
                                let O = (_._localRoot || this._root).uuid,
                                    B = _._clip.uuid,
                                    N = this._actionsByClip[B];
                                this._bindAction(_, N && N.knownActions[0]), this._addInactiveAction(_, B, O)
                            }
                            let O = _._propertyBindings;
                            for (let _ = 0, B = O.length; _ !== B; ++_) {
                                let B = O[_];
                                0 == B.useCount++ && (this._lendBinding(B), B.saveOriginalState())
                            }
                            this._lendAction(_)
                        }
                    }
                    _deactivateAction(_) {
                        if (this._isActiveAction(_)) {
                            let O = _._propertyBindings;
                            for (let _ = 0, B = O.length; _ !== B; ++_) {
                                let B = O[_];
                                0 == --B.useCount && (B.restoreOriginalState(), this._takeBackBinding(B))
                            }
                            this._takeBackAction(_)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        let _ = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return _._actions.length
                                },
                                get inUse() {
                                    return _._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return _._bindings.length
                                },
                                get inUse() {
                                    return _._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return _._controlInterpolants.length
                                },
                                get inUse() {
                                    return _._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(_) {
                        let O = _._cacheIndex;
                        return null !== O && O < this._nActiveActions
                    }
                    _addInactiveAction(_, O, B) {
                        let N = this._actions,
                            k = this._actionsByClip,
                            F = k[O];
                        if (void 0 === F) F = {
                            knownActions: [_],
                            actionByRoot: {}
                        }, _._byClipCacheIndex = 0, k[O] = F;
                        else {
                            let O = F.knownActions;
                            _._byClipCacheIndex = O.length, O.push(_)
                        }
                        _._cacheIndex = N.length, N.push(_), F.actionByRoot[B] = _
                    }
                    _removeInactiveAction(_) {
                        let O = this._actions,
                            B = O[O.length - 1],
                            N = _._cacheIndex;
                        B._cacheIndex = N, O[N] = B, O.pop(), _._cacheIndex = null;
                        let k = _._clip.uuid,
                            F = this._actionsByClip,
                            U = F[k],
                            j = U.knownActions,
                            G = j[j.length - 1],
                            Y = _._byClipCacheIndex;
                        G._byClipCacheIndex = Y, j[Y] = G, j.pop(), _._byClipCacheIndex = null;
                        let Q = U.actionByRoot,
                            K = (_._localRoot || this._root).uuid;
                        delete Q[K], 0 === j.length && delete F[k], this._removeInactiveBindingsForAction(_)
                    }
                    _removeInactiveBindingsForAction(_) {
                        let O = _._propertyBindings;
                        for (let _ = 0, B = O.length; _ !== B; ++_) {
                            let B = O[_];
                            0 == --B.referenceCount && this._removeInactiveBinding(B)
                        }
                    }
                    _lendAction(_) {
                        let O = this._actions,
                            B = _._cacheIndex,
                            N = this._nActiveActions++,
                            k = O[N];
                        _._cacheIndex = N, O[N] = _, k._cacheIndex = B, O[B] = k
                    }
                    _takeBackAction(_) {
                        let O = this._actions,
                            B = _._cacheIndex,
                            N = --this._nActiveActions,
                            k = O[N];
                        _._cacheIndex = N, O[N] = _, k._cacheIndex = B, O[B] = k
                    }
                    _addInactiveBinding(_, O, B) {
                        let N = this._bindingsByRootAndName,
                            k = this._bindings,
                            F = N[O];
                        void 0 === F && (F = {}, N[O] = F), F[B] = _, _._cacheIndex = k.length, k.push(_)
                    }
                    _removeInactiveBinding(_) {
                        let O = this._bindings,
                            B = _.binding,
                            N = B.rootNode.uuid,
                            k = B.path,
                            F = this._bindingsByRootAndName,
                            U = F[N],
                            j = O[O.length - 1],
                            G = _._cacheIndex;
                        j._cacheIndex = G, O[G] = j, O.pop(), delete U[k], 0 === Object.keys(U).length && delete F[N]
                    }
                    _lendBinding(_) {
                        let O = this._bindings,
                            B = _._cacheIndex,
                            N = this._nActiveBindings++,
                            k = O[N];
                        _._cacheIndex = N, O[N] = _, k._cacheIndex = B, O[B] = k
                    }
                    _takeBackBinding(_) {
                        let O = this._bindings,
                            B = _._cacheIndex,
                            N = --this._nActiveBindings,
                            k = O[N];
                        _._cacheIndex = N, O[N] = _, k._cacheIndex = B, O[B] = k
                    }
                    _lendControlInterpolant() {
                        let _ = this._controlInterpolants,
                            O = this._nActiveControlInterpolants++,
                            B = _[O];
                        return void 0 === B && ((B = new oD(new Float32Array(2), new Float32Array(2), 1, lb)).__cacheIndex = O, _[O] = B), B
                    }
                    _takeBackControlInterpolant(_) {
                        let O = this._controlInterpolants,
                            B = _.__cacheIndex,
                            N = --this._nActiveControlInterpolants,
                            k = O[N];
                        _.__cacheIndex = N, O[N] = _, k.__cacheIndex = B, O[B] = k
                    }
                    clipAction(_, O, B) {
                        let N = O || this._root,
                            k = N.uuid,
                            F = "string" == typeof _ ? oj.findByName(N, _) : _,
                            U = null !== F ? F.uuid : _,
                            j = this._actionsByClip[U],
                            G = null;
                        if (void 0 === B && (B = null !== F ? F.blendMode : 2500), void 0 !== j) {
                            let _ = j.actionByRoot[k];
                            if (void 0 !== _ && _.blendMode === B) return _;
                            G = j.knownActions[0], null === F && (F = G._clip)
                        }
                        if (null === F) return null;
                        let Y = new lx(this, F, O, B);
                        return this._bindAction(Y, G), this._addInactiveAction(Y, U, k), Y
                    }
                    existingAction(_, O) {
                        let B = O || this._root,
                            N = B.uuid,
                            k = "string" == typeof _ ? oj.findByName(B, _) : _,
                            F = k ? k.uuid : _,
                            U = this._actionsByClip[F];
                        return void 0 !== U && U.actionByRoot[N] || null
                    }
                    stopAllAction() {
                        let _ = this._actions,
                            O = this._nActiveActions;
                        for (let B = O - 1; B >= 0; --B) _[B].stop();
                        return this
                    }
                    update(_) {
                        _ *= this.timeScale;
                        let O = this._actions,
                            B = this._nActiveActions,
                            N = this.time += _,
                            k = Math.sign(_),
                            F = this._accuIndex ^= 1;
                        for (let U = 0; U !== B; ++U) O[U]._update(N, _, k, F);
                        let U = this._bindings,
                            j = this._nActiveBindings;
                        for (let _ = 0; _ !== j; ++_) U[_].apply(F);
                        return this
                    }
                    setTime(_) {
                        this.time = 0;
                        for (let _ = 0; _ < this._actions.length; _++) this._actions[_].time = 0;
                        return this.update(_)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(_) {
                        let O = this._actions,
                            B = _.uuid,
                            N = this._actionsByClip,
                            k = N[B];
                        if (void 0 !== k) {
                            let _ = k.knownActions;
                            for (let B = 0, N = _.length; B !== N; ++B) {
                                let N = _[B];
                                this._deactivateAction(N);
                                let k = N._cacheIndex,
                                    F = O[O.length - 1];
                                N._cacheIndex = null, N._byClipCacheIndex = null, F._cacheIndex = k, O[k] = F, O.pop(), this._removeInactiveBindingsForAction(N)
                            }
                            delete N[B]
                        }
                    }
                    uncacheRoot(_) {
                        let O = _.uuid,
                            B = this._actionsByClip;
                        for (let _ in B) {
                            let N = B[_].actionByRoot[O];
                            void 0 !== N && (this._deactivateAction(N), this._removeInactiveAction(N))
                        }
                        let N = this._bindingsByRootAndName[O];
                        if (void 0 !== N)
                            for (let _ in N) {
                                let O = N[_];
                                O.restoreOriginalState(), this._removeInactiveBinding(O)
                            }
                    }
                    uncacheAction(_, O) {
                        let B = this.existingAction(_, O);
                        null !== B && (this._deactivateAction(B), this._removeInactiveAction(B))
                    }
                },
                l_ = class {
                    constructor(_) {
                        this.value = _
                    }
                    clone() {
                        return new l_(void 0 === this.value.clone ? this.value : this.value.clone())
                    }
                },
                lA = class {
                    constructor(_, O, B = 0, N = 1 / 0) {
                        this.ray = new rK(_, O), this.near = B, this.far = N, this.camera = null, this.layers = new r7, this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(_, O) {
                        this.ray.set(_, O)
                    }
                    setFromCamera(_, O) {
                        O.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(O.matrixWorld), this.ray.direction.set(_.x, _.y, .5).unproject(O).sub(this.ray.origin).normalize(), this.camera = O) : O.isOrthographicCamera ? (this.ray.origin.set(_.x, _.y, (O.near + O.far) / (O.near - O.far)).unproject(O), this.ray.direction.set(0, 0, -1).transformDirection(O.matrixWorld), this.camera = O) : console.error("THREE.Raycaster: Unsupported camera type: " + O.type)
                    }
                    intersectObject(_, O = !0, B = []) {
                        return Yb(_, this, B, O), B.sort(jE), B
                    }
                    intersectObjects(_, O = !0, B = []) {
                        for (let N = 0, k = _.length; N < k; N++) Yb(_[N], this, B, O);
                        return B.sort(jE), B
                    }
                };

            function jE(_, O) {
                return _.distance - O.distance
            }

            function Yb(_, O, B, N) {
                if (_.layers.test(O.layers) && _.raycast(O, B), !0 === N) {
                    let N = _.children;
                    for (let _ = 0, k = N.length; _ < k; _++) Yb(N[_], O, B, !0)
                }
            }
            var lM = class {
                    constructor(_ = 1, O = 0, B = 0) {
                        return this.radius = _, this.phi = O, this.theta = B, this
                    }
                    set(_, O, B) {
                        return this.radius = _, this.phi = O, this.theta = B, this
                    }
                    copy(_) {
                        return this.radius = _.radius, this.phi = _.phi, this.theta = _.theta, this
                    }
                    makeSafe() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    }
                    setFromVector3(_) {
                        return this.setFromCartesianCoords(_.x, _.y, _.z)
                    }
                    setFromCartesianCoords(_, O, B) {
                        return this.radius = Math.sqrt(_ * _ + O * O + B * B), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(_, B), this.phi = Math.acos(Yr(O / this.radius, -1, 1))), this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                },
                lE = new iJ,
                lC = class {
                    constructor(_ = new iJ(1 / 0, 1 / 0), O = new iJ(-1 / 0, -1 / 0)) {
                        this.isBox2 = !0, this.min = _, this.max = O
                    }
                    set(_, O) {
                        return this.min.copy(_), this.max.copy(O), this
                    }
                    setFromPoints(_) {
                        this.makeEmpty();
                        for (let O = 0, B = _.length; O < B; O++) this.expandByPoint(_[O]);
                        return this
                    }
                    setFromCenterAndSize(_, O) {
                        let B = lE.copy(O).multiplyScalar(.5);
                        return this.min.copy(_).sub(B), this.max.copy(_).add(B), this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        return this.min.copy(_.min), this.max.copy(_.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(_) {
                        return this.isEmpty() ? _.set(0, 0) : _.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(_) {
                        return this.isEmpty() ? _.set(0, 0) : _.subVectors(this.max, this.min)
                    }
                    expandByPoint(_) {
                        return this.min.min(_), this.max.max(_), this
                    }
                    expandByVector(_) {
                        return this.min.sub(_), this.max.add(_), this
                    }
                    expandByScalar(_) {
                        return this.min.addScalar(-_), this.max.addScalar(_), this
                    }
                    containsPoint(_) {
                        return !(_.x < this.min.x || _.x > this.max.x || _.y < this.min.y || _.y > this.max.y)
                    }
                    containsBox(_) {
                        return this.min.x <= _.min.x && _.max.x <= this.max.x && this.min.y <= _.min.y && _.max.y <= this.max.y
                    }
                    getParameter(_, O) {
                        return O.set((_.x - this.min.x) / (this.max.x - this.min.x), (_.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(_) {
                        return !(_.max.x < this.min.x || _.min.x > this.max.x || _.max.y < this.min.y || _.min.y > this.max.y)
                    }
                    clampPoint(_, O) {
                        return O.copy(_).clamp(this.min, this.max)
                    }
                    distanceToPoint(_) {
                        return lE.copy(_).clamp(this.min, this.max).sub(_).length()
                    }
                    intersect(_) {
                        return this.min.max(_.min), this.max.min(_.max), this
                    }
                    union(_) {
                        return this.min.min(_.min), this.max.max(_.max), this
                    }
                    translate(_) {
                        return this.min.add(_), this.max.add(_), this
                    }
                    equals(_) {
                        return _.min.equals(this.min) && _.max.equals(this.max)
                    }
                },
                lT = new rv,
                lD = new rv,
                lP = class {
                    constructor(_ = new rv, O = new rv) {
                        this.start = _, this.end = O
                    }
                    set(_, O) {
                        return this.start.copy(_), this.end.copy(O), this
                    }
                    copy(_) {
                        return this.start.copy(_.start), this.end.copy(_.end), this
                    }
                    getCenter(_) {
                        return _.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(_) {
                        return _.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(_, O) {
                        return this.delta(O).multiplyScalar(_).add(this.start)
                    }
                    closestPointToPointParameter(_, O) {
                        lT.subVectors(_, this.start), lD.subVectors(this.end, this.start);
                        let B = lD.dot(lD),
                            N = lD.dot(lT) / B;
                        return O && (N = Yr(N, 0, 1)), N
                    }
                    closestPointToPoint(_, O, B) {
                        let N = this.closestPointToPointParameter(_, O);
                        return this.delta(B).multiplyScalar(N).add(this.start)
                    }
                    applyMatrix4(_) {
                        return this.start.applyMatrix4(_), this.end.applyMatrix4(_), this
                    }
                    equals(_) {
                        return _.start.equals(this.start) && _.end.equals(this.end)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                },
                lI = new rv,
                lO = class extends sv {
                    constructor(_, O) {
                        super(), this.light = _, this.matrix = _.matrixWorld, this.matrixAutoUpdate = !1, this.color = O, this.type = "SpotLightHelper";
                        let B = new sK,
                            N = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let _ = 0, O = 1; _ < 32; _++, O++) {
                            let B = _ / 32 * Math.PI * 2,
                                k = O / 32 * Math.PI * 2;
                            N.push(Math.cos(B), Math.sin(B), 1, Math.cos(k), Math.sin(k), 1)
                        }
                        B.setAttribute("position", new sG(N, 3));
                        let k = new nk({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new nX(B, k), this.add(this.cone), this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(), this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
                        let _ = this.light.distance ? this.light.distance : 1e3,
                            O = _ * Math.tan(this.light.angle);
                        this.cone.scale.set(O, O, _), lI.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(lI), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                },
                lR = class extends at {
                    constructor(_, O, B) {
                        super(new oS(O, 4, 2), new sz({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        })), this.light = _, this.color = B, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                },
                lB = new rv,
                lN = new rv,
                lk = new rv,
                lF = class extends sv {
                    constructor(_, O, B) {
                        super(), this.light = _, this.matrix = _.matrixWorld, this.matrixAutoUpdate = !1, this.color = B, this.type = "DirectionalLightHelper", void 0 === O && (O = 1);
                        let N = new sK;
                        N.setAttribute("position", new sG([-O, O, 0, O, O, 0, O, -O, 0, -O, -O, 0, -O, O, 0], 3));
                        let k = new nk({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new nW(N, k), this.add(this.lightPlane), (N = new sK).setAttribute("position", new sG([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new nW(N, k), this.add(this.targetLine), this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), lB.setFromMatrixPosition(this.light.matrixWorld), lN.setFromMatrixPosition(this.light.target.matrixWorld), lk.subVectors(lN, lB), this.lightPlane.lookAt(lN), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(lN), this.targetLine.scale.z = lk.length()
                    }
                },
                lU = new rv,
                lj = new ao,
                lG = class extends nX {
                    constructor(_) {
                        let O = new sK,
                            B = new nk({
                                color: 16777215,
                                vertexColors: !0,
                                toneMapped: !1
                            }),
                            N = [],
                            k = [],
                            F = {};

                        function a(_, O) {
                            l(_), l(O)
                        }

                        function l(_) {
                            N.push(0, 0, 0), k.push(0, 0, 0), void 0 === F[_] && (F[_] = []), F[_].push(N.length / 3 - 1)
                        }
                        a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), O.setAttribute("position", new sG(N, 3)), O.setAttribute("color", new sG(k, 3)), super(O, B), this.type = "CameraHelper", this.camera = _, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = _.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = F, this.update();
                        let U = new re(16755200),
                            j = new re(16711680),
                            G = new re(43775),
                            Y = new re(16777215),
                            Q = new re(3355443);
                        this.setColors(U, j, G, Y, Q)
                    }
                    setColors(_, O, B, N, k) {
                        let F = this.geometry.getAttribute("color");
                        F.setXYZ(0, _.r, _.g, _.b), F.setXYZ(1, _.r, _.g, _.b), F.setXYZ(2, _.r, _.g, _.b), F.setXYZ(3, _.r, _.g, _.b), F.setXYZ(4, _.r, _.g, _.b), F.setXYZ(5, _.r, _.g, _.b), F.setXYZ(6, _.r, _.g, _.b), F.setXYZ(7, _.r, _.g, _.b), F.setXYZ(8, _.r, _.g, _.b), F.setXYZ(9, _.r, _.g, _.b), F.setXYZ(10, _.r, _.g, _.b), F.setXYZ(11, _.r, _.g, _.b), F.setXYZ(12, _.r, _.g, _.b), F.setXYZ(13, _.r, _.g, _.b), F.setXYZ(14, _.r, _.g, _.b), F.setXYZ(15, _.r, _.g, _.b), F.setXYZ(16, _.r, _.g, _.b), F.setXYZ(17, _.r, _.g, _.b), F.setXYZ(18, _.r, _.g, _.b), F.setXYZ(19, _.r, _.g, _.b), F.setXYZ(20, _.r, _.g, _.b), F.setXYZ(21, _.r, _.g, _.b), F.setXYZ(22, _.r, _.g, _.b), F.setXYZ(23, _.r, _.g, _.b), F.setXYZ(24, O.r, O.g, O.b), F.setXYZ(25, O.r, O.g, O.b), F.setXYZ(26, O.r, O.g, O.b), F.setXYZ(27, O.r, O.g, O.b), F.setXYZ(28, O.r, O.g, O.b), F.setXYZ(29, O.r, O.g, O.b), F.setXYZ(30, O.r, O.g, O.b), F.setXYZ(31, O.r, O.g, O.b), F.setXYZ(32, B.r, B.g, B.b), F.setXYZ(33, B.r, B.g, B.b), F.setXYZ(34, B.r, B.g, B.b), F.setXYZ(35, B.r, B.g, B.b), F.setXYZ(36, B.r, B.g, B.b), F.setXYZ(37, B.r, B.g, B.b), F.setXYZ(38, N.r, N.g, N.b), F.setXYZ(39, N.r, N.g, N.b), F.setXYZ(40, k.r, k.g, k.b), F.setXYZ(41, k.r, k.g, k.b), F.setXYZ(42, k.r, k.g, k.b), F.setXYZ(43, k.r, k.g, k.b), F.setXYZ(44, k.r, k.g, k.b), F.setXYZ(45, k.r, k.g, k.b), F.setXYZ(46, k.r, k.g, k.b), F.setXYZ(47, k.r, k.g, k.b), F.setXYZ(48, k.r, k.g, k.b), F.setXYZ(49, k.r, k.g, k.b), F.needsUpdate = !0
                    }
                    update() {
                        let _ = this.geometry,
                            O = this.pointMap;
                        lj.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Dr("c", O, _, lj, 0, 0, -1), Dr("t", O, _, lj, 0, 0, 1), Dr("n1", O, _, lj, -1, -1, -1), Dr("n2", O, _, lj, 1, -1, -1), Dr("n3", O, _, lj, -1, 1, -1), Dr("n4", O, _, lj, 1, 1, -1), Dr("f1", O, _, lj, -1, -1, 1), Dr("f2", O, _, lj, 1, -1, 1), Dr("f3", O, _, lj, -1, 1, 1), Dr("f4", O, _, lj, 1, 1, 1), Dr("u1", O, _, lj, .7, 1.1, -1), Dr("u2", O, _, lj, -.7, 1.1, -1), Dr("u3", O, _, lj, 0, 2, -1), Dr("cf1", O, _, lj, -1, 0, 1), Dr("cf2", O, _, lj, 1, 0, 1), Dr("cf3", O, _, lj, 0, -1, 1), Dr("cf4", O, _, lj, 0, 1, 1), Dr("cn1", O, _, lj, -1, 0, -1), Dr("cn2", O, _, lj, 1, 0, -1), Dr("cn3", O, _, lj, 0, -1, -1), Dr("cn4", O, _, lj, 0, 1, -1), _.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                };

            function Dr(_, O, B, N, k, F, U) {
                lU.set(k, F, U).unproject(N);
                let j = O[_];
                if (void 0 !== j) {
                    let _ = B.getAttribute("position");
                    for (let O = 0, B = j.length; O < B; O++) _.setXYZ(j[O], lU.x, lU.y, lU.z)
                }
            }
            var lH = class extends nX {
                    constructor(_, O = 16776960) {
                        let B = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            N = new sK;
                        N.setIndex(new sF(B, 1)), N.setAttribute("position", new sG([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(N, new nk({
                            color: O,
                            toneMapped: !1
                        })), this.box = _, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(_) {
                        let O = this.box;
                        O.isEmpty() || (O.getCenter(this.position), O.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(_))
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                },
                lW = class extends nX {
                    constructor(_ = 1) {
                        let O = [0, 0, 0, _, 0, 0, 0, 0, 0, 0, _, 0, 0, 0, 0, 0, 0, _],
                            B = new sK;
                        B.setAttribute("position", new sG(O, 3)), B.setAttribute("color", new sG([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(B, new nk({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "AxesHelper"
                    }
                    setColors(_, O, B) {
                        let N = new re,
                            k = this.geometry.attributes.color.array;
                        return N.set(_), N.toArray(k, 0), N.toArray(k, 3), N.set(O), N.toArray(k, 6), N.toArray(k, 9), N.set(B), N.toArray(k, 12), N.toArray(k, 15), this.geometry.attributes.color.needsUpdate = !0, this
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                },
                lq = function() {
                    let _ = new ArrayBuffer(4),
                        O = new Float32Array(_),
                        B = new Uint32Array(_),
                        N = new Uint32Array(512),
                        k = new Uint32Array(512);
                    for (let _ = 0; _ < 256; ++_) {
                        let O = _ - 127;
                        O < -27 ? (N[_] = 0, N[256 | _] = 32768, k[_] = 24, k[256 | _] = 24) : O < -14 ? (N[_] = 1024 >> -O - 14, N[256 | _] = 1024 >> -O - 14 | 32768, k[_] = -O - 1, k[256 | _] = -O - 1) : O <= 15 ? (N[_] = O + 15 << 10, N[256 | _] = O + 15 << 10 | 32768, k[_] = 13, k[256 | _] = 13) : O < 128 ? (N[_] = 31744, N[256 | _] = 64512, k[_] = 24, k[256 | _] = 24) : (N[_] = 31744, N[256 | _] = 64512, k[_] = 13, k[256 | _] = 13)
                    }
                    let F = new Uint32Array(2048),
                        U = new Uint32Array(64),
                        j = new Uint32Array(64);
                    for (let _ = 1; _ < 1024; ++_) {
                        let O = _ << 13,
                            B = 0;
                        for (;
                            (8388608 & O) == 0;) O <<= 1, B -= 8388608;
                        O &= -8388609, B += 947912704, F[_] = O | B
                    }
                    for (let _ = 1024; _ < 2048; ++_) F[_] = 939524096 + (_ - 1024 << 13);
                    for (let _ = 1; _ < 31; ++_) U[_] = _ << 23;
                    U[31] = 1199570944, U[32] = 2147483648;
                    for (let _ = 33; _ < 63; ++_) U[_] = 2147483648 + (_ - 32 << 23);
                    U[63] = 3347054592;
                    for (let _ = 1; _ < 64; ++_) 32 !== _ && (j[_] = 1024);
                    return {
                        floatView: O,
                        uint32View: B,
                        baseTable: N,
                        shiftTable: k,
                        mantissaTable: F,
                        exponentTable: U,
                        offsetTable: j
                    }
                }(),
                lY = Object.freeze({
                    __proto__: null,
                    fromHalfFloat: function(_) {
                        let O = _ >> 10;
                        return lq.uint32View[0] = lq.mantissaTable[lq.offsetTable[O] + (1023 & _)] + lq.exponentTable[O], lq.floatView[0]
                    },
                    toHalfFloat: function(_) {
                        Math.abs(_) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), _ = Yr(_, -65504, 65504), lq.floatView[0] = _;
                        let O = lq.uint32View[0],
                            B = O >> 23 & 511;
                        return lq.baseTable[B] + ((8388607 & O) >> lq.shiftTable[B])
                    }
                });
            "u" > typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "149"
                }
            })), "u" > typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "149");
            var lX = Symbol("target"),
                lQ = Symbol("unsubscribe");

            function Qf(_) {
                return _ instanceof Date || _ instanceof Set || _ instanceof Map || _ instanceof WeakSet || _ instanceof WeakMap || ArrayBuffer.isView(_)
            }
            var lZ = Array.isArray;

            function Jl(_) {
                return "symbol" == typeof _
            }
            var lK = {
                after: (_, O) => lZ(_) ? _.slice(O.length) : "" === O ? _ : _.slice(O.length + 1),
                concat: (_, O) => lZ(_) ? (_ = [..._], O && _.push(O), _) : O && void 0 !== O.toString ? ("" !== _ && (_ += "."), Jl(O) ? _ + O.toString() : _ + O) : _,
                initial: _ => {
                    if (lZ(_)) return _.slice(0, -1);
                    if ("" === _) return _;
                    let O = _.lastIndexOf(".");
                    return -1 === O ? "" : _.slice(0, O)
                },
                last: _ => {
                    if (lZ(_)) return _[_.length - 1] || "";
                    if ("" === _) return _;
                    let O = _.lastIndexOf(".");
                    return -1 === O ? _ : _.slice(O + 1)
                },
                walk: (_, O) => {
                    if (lZ(_))
                        for (let B of _) O(B);
                    else if ("" !== _) {
                        let B = 0,
                            N = _.indexOf(".");
                        if (-1 === N) O(_);
                        else
                            for (; B < _.length;) - 1 === N && (N = _.length), O(_.slice(B, N)), B = N + 1, N = _.indexOf(".", B)
                    }
                },
                get(_, O) {
                    return this.walk(O, O => {
                        _ && (_ = _[O])
                    }), _
                }
            };

            function kg(_, O, B) {
                return _.isUnsubscribed || O.ignoreSymbols && Jl(B) || O.ignoreUnderscores && "_" === B.charAt(0) || "ignoreKeys" in O && O.ignoreKeys.includes(B)
            }
            var lJ = class {
                constructor(_) {
                    this._equals = _, this._proxyCache = new WeakMap, this._pathCache = new WeakMap, this.isUnsubscribed = !1
                }
                _getDescriptorCache() {
                    return void 0 === this._descriptorCache && (this._descriptorCache = new WeakMap), this._descriptorCache
                }
                _getProperties(_) {
                    let O = this._getDescriptorCache(),
                        B = O.get(_);
                    return void 0 === B && (B = {}, O.set(_, B)), B
                }
                _getOwnPropertyDescriptor(_, O) {
                    if (this.isUnsubscribed) return Reflect.getOwnPropertyDescriptor(_, O);
                    let B = this._getProperties(_),
                        N = B[O];
                    return void 0 === N && (N = Reflect.getOwnPropertyDescriptor(_, O), B[O] = N), N
                }
                getProxy(_, O, B, N) {
                    if (this.isUnsubscribed) return _;
                    let k = _[N],
                        F = k || _;
                    this._pathCache.set(F, O);
                    let U = this._proxyCache.get(F);
                    return void 0 === U && (U = void 0 === k ? new Proxy(_, B) : _, this._proxyCache.set(F, U)), U
                }
                getPath(_) {
                    return this.isUnsubscribed ? void 0 : this._pathCache.get(_)
                }
                isDetached(_, O) {
                    return !Object.is(_, lK.get(O, this.getPath(_)))
                }
                defineProperty(_, O, B) {
                    return !!Reflect.defineProperty(_, O, B) && (this.isUnsubscribed || (this._getProperties(_)[O] = B), !0)
                }
                setProperty(_, O, B, N, k) {
                    if (!this._equals(k, B) || !(O in _)) {
                        let k = this._getOwnPropertyDescriptor(_, O);
                        return void 0 !== k && "set" in k ? Reflect.set(_, O, B, N) : Reflect.set(_, O, B)
                    }
                    return !0
                }
                deleteProperty(_, O, B) {
                    if (Reflect.deleteProperty(_, O)) {
                        if (!this.isUnsubscribed) {
                            let N = this._getDescriptorCache().get(_);
                            N && (delete N[O], this._pathCache.delete(B))
                        }
                        return !0
                    }
                    return !1
                }
                isSameDescriptor(_, O, B) {
                    let N = this._getOwnPropertyDescriptor(O, B);
                    return void 0 !== _ && void 0 !== N && Object.is(_.value, N.value) && (_.writable || !1) === (N.writable || !1) && (_.enumerable || !1) === (N.enumerable || !1) && (_.configurable || !1) === (N.configurable || !1) && _.get === N.get && _.set === N.set
                }
                isGetInvariant(_, O) {
                    let B = this._getOwnPropertyDescriptor(_, O);
                    return void 0 !== B && !0 !== B.configurable && !0 !== B.writable
                }
                unsubscribe() {
                    this._descriptorCache = null, this._pathCache = null, this._proxyCache = null, this.isUnsubscribed = !0
                }
            };

            function Ou(_) {
                return "[object Object]" === toString.call(_)
            }

            function Ru() {
                return !0
            }

            function Ba(_, O) {
                return _.length !== O.length || _.some((_, B) => O[B] !== _)
            }
            var l$ = new Set(["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]),
                l0 = new Set(["concat", "includes", "indexOf", "join", "keys", "lastIndexOf"]),
                l3 = {
                    push: Ru,
                    pop: Ru,
                    shift: Ru,
                    unshift: Ru,
                    copyWithin: Ba,
                    reverse: Ba,
                    sort: Ba,
                    splice: Ba,
                    flat: Ba,
                    fill: Ba
                },
                l4 = new Set([...l$, ...l0, ...Object.keys(l3)]);

            function Lu(_, O) {
                if (_.size !== O.size) return !0;
                for (let B of _)
                    if (!O.has(B)) return !0;
                return !1
            }
            var l5 = ["keys", "values", "entries"],
                l6 = new Set(["has", "toString"]),
                l8 = {
                    add: Lu,
                    clear: Lu,
                    delete: Lu,
                    forEach: Lu
                },
                l9 = new Set([...l6, ...Object.keys(l8), ...l5]);

            function Nu(_, O) {
                let B;
                if (_.size !== O.size) return !0;
                for (let [N, k] of _)
                    if ((B = O.get(N)) !== k || void 0 === B && !O.has(N)) return !0;
                return !1
            }
            var l7 = new Set([...l6, "get"]),
                ht = {
                    set: Nu,
                    clear: Nu,
                    delete: Nu,
                    forEach: Nu
                },
                hi = new Set([...l7, ...Object.keys(ht), ...l5]),
                hs = class {
                    constructor(_, O, B, N) {
                        this._path = O, this._isChanged = !1, this._clonedCache = new Set, this._hasOnValidate = N, this._changes = N ? [] : null, this.clone = void 0 === O ? _ : this._shallowClone(_)
                    }
                    static isHandledMethod(_) {
                        return l$.has(_)
                    }
                    _shallowClone(_) {
                        let O = _;
                        if (Ou(_)) O = { ..._
                        };
                        else if (lZ(_)) O = [..._];
                        else if (_ instanceof Date) O = new Date(_);
                        else if (_ instanceof Set) O = new Set([..._].map(_ => this._shallowClone(_)));
                        else if (_ instanceof Map)
                            for (let [B, N] of (O = new Map, _.entries())) O.set(B, this._shallowClone(N));
                        return this._clonedCache.add(O), O
                    }
                    preferredThisArg(_, O, B, N) {
                        return _ ? (lZ(N) ? this._onIsChanged = l3[O] : N instanceof Set ? this._onIsChanged = l8[O] : N instanceof Map && (this._onIsChanged = ht[O]), N) : B
                    }
                    update(_, O, B) {
                        let N = lK.after(_, this._path);
                        if ("length" !== O) {
                            let _ = this.clone;
                            lK.walk(N, O => {
                                _ && _[O] && (this._clonedCache.has(_[O]) || (_[O] = this._shallowClone(_[O])), _ = _[O])
                            }), this._hasOnValidate && this._changes.push({
                                path: N,
                                property: O,
                                previous: B
                            }), _ && _[O] && (_[O] = B)
                        }
                        this._isChanged = !0
                    }
                    undo(_) {
                        let O;
                        for (let B = this._changes.length - 1; - 1 !== B; B--) O = this._changes[B], lK.get(_, O.path)[O.property] = O.previous
                    }
                    isChanged(_) {
                        return void 0 === this._onIsChanged ? this._isChanged : this._onIsChanged(this.clone, _)
                    }
                },
                ha = class extends hs {
                    static isHandledMethod(_) {
                        return l4.has(_)
                    }
                },
                hn = class extends hs {
                    undo(_) {
                        _.setTime(this.clone.getTime())
                    }
                    isChanged(_, O) {
                        return !O(this.clone.valueOf(), _.valueOf())
                    }
                },
                ho = class extends hs {
                    static isHandledMethod(_) {
                        return l9.has(_)
                    }
                    undo(_) {
                        for (let O of this.clone) _.add(O);
                        for (let O of _) this.clone.has(O) || _.delete(O)
                    }
                },
                hl = class extends hs {
                    static isHandledMethod(_) {
                        return hi.has(_)
                    }
                    undo(_) {
                        for (let [O, B] of this.clone.entries()) _.set(O, B);
                        for (let O of _.keys()) this.clone.has(O) || _.delete(O)
                    }
                },
                hh = class extends hs {
                    constructor(_, O, B, N) {
                        super(void 0, O, B, N), this._arg1 = B[0], this._weakValue = _.has(this._arg1)
                    }
                    isChanged(_) {
                        return this._weakValue !== _.has(this._arg1)
                    }
                    undo(_) {
                        this._weakValue && !_.has(this._arg1) ? _.add(this._arg1) : _.delete(this._arg1)
                    }
                },
                hc = class extends hs {
                    constructor(_, O, B, N) {
                        super(void 0, O, B, N), this._weakKey = B[0], this._weakHas = _.has(this._weakKey), this._weakValue = _.get(this._weakKey)
                    }
                    isChanged(_) {
                        return this._weakValue !== _.get(this._weakKey)
                    }
                    undo(_) {
                        let O = _.has(this._weakKey);
                        this._weakHas && !O ? _.set(this._weakKey, this._weakValue) : !this._weakHas && O ? _.delete(this._weakKey) : this._weakValue !== _.get(this._weakKey) && _.set(this._weakKey, this._weakValue)
                    }
                },
                hd = class {
                    constructor(_) {
                        this._stack = [], this._hasOnValidate = _
                    }
                    static isHandledType(_) {
                        return Ou(_) || lZ(_) || Qf(_)
                    }
                    static isHandledMethod(_, O) {
                        return Ou(_) ? hs.isHandledMethod(O) : lZ(_) ? ha.isHandledMethod(O) : _ instanceof Set ? ho.isHandledMethod(O) : _ instanceof Map ? hl.isHandledMethod(O) : Qf(_)
                    }
                    get isCloning() {
                        return this._stack.length > 0
                    }
                    start(_, O, B) {
                        let N = hs;
                        lZ(_) ? N = ha : _ instanceof Date ? N = hn : _ instanceof Set ? N = ho : _ instanceof Map ? N = hl : _ instanceof WeakSet ? N = hh : _ instanceof WeakMap && (N = hc), this._stack.push(new N(_, O, B, this._hasOnValidate))
                    }
                    update(_, O, B) {
                        this._stack[this._stack.length - 1].update(_, O, B)
                    }
                    preferredThisArg(_, O, B) {
                        let {
                            name: N
                        } = _, k = hd.isHandledMethod(B, N);
                        return this._stack[this._stack.length - 1].preferredThisArg(k, N, O, B)
                    }
                    isChanged(_, O, B) {
                        return this._stack[this._stack.length - 1].isChanged(_, O, B)
                    }
                    undo(_) {
                        void 0 !== this._previousClone && this._previousClone.undo(_)
                    }
                    stop() {
                        return this._previousClone = this._stack.pop(), this._previousClone.clone
                    }
                },
                hu = {
                    equals: Object.is,
                    isShallow: !1,
                    pathAsArray: !1,
                    ignoreSymbols: !1,
                    ignoreUnderscores: !1,
                    ignoreDetached: !1,
                    details: !1
                },
                fw = (_, O, B = {}) => {
                    B = { ...hu,
                        ...B
                    };
                    let N = Symbol("ProxyTarget"),
                        {
                            equals: k,
                            isShallow: F,
                            ignoreDetached: U,
                            details: j
                        } = B,
                        G = new lJ(k),
                        Y = "function" == typeof B.onValidate,
                        Q = new hd(Y),
                        h = (_, O, N, k, F) => !Y || Q.isCloning || !0 === B.onValidate(lK.concat(G.getPath(_), O), N, k, F),
                        d = (O, N, k, F) => {
                            kg(G, B, N) || U && G.isDetached(O, _) || f(G.getPath(O), N, k, F)
                        },
                        f = (_, B, N, k, F) => {
                            Q.isCloning ? Q.update(_, B, k) : O(lK.concat(_, B), N, k, F)
                        },
                        p = _ => _ && (_[N] || _),
                        m = (O, k, j, Y) => ("object" == typeof O ? null === O : "function" != typeof O) || O instanceof RegExp || "constructor" === j || F && !hd.isHandledMethod(k, j) || kg(G, B, j) || G.isGetInvariant(k, j) || U && G.isDetached(k, _) ? O : (void 0 === Y && (Y = G.getPath(k)), G.getProxy(O, lK.concat(Y, j), K, N)),
                        K = {
                            get(_, O, B) {
                                if (Jl(O)) {
                                    if (O === N || O === lX) return _;
                                    if (O === lQ && !G.isUnsubscribed && 0 === G.getPath(_).length) return G.unsubscribe(), _
                                }
                                return m(Qf(_) ? Reflect.get(_, O) : Reflect.get(_, O, B), _, O)
                            },
                            set(_, O, B, F) {
                                B = p(B);
                                let U = _[N] || _,
                                    j = U[O];
                                if (k(j, B) && O in _) return !0;
                                let Y = h(_, O, B, j);
                                return Y && G.setProperty(U, O, B, F, j) ? (d(_, O, _[O], j), !0) : !Y
                            },
                            defineProperty(_, O, B) {
                                if (!G.isSameDescriptor(B, _, O)) {
                                    let N = _[O];
                                    h(_, O, B.value, N) && G.defineProperty(_, O, B, N) && d(_, O, B.value, N)
                                }
                                return !0
                            },
                            deleteProperty(_, O) {
                                if (!Reflect.has(_, O)) return !0;
                                let B = Reflect.get(_, O),
                                    N = h(_, O, void 0, B);
                                return N && G.deleteProperty(_, O, B) ? (d(_, O, void 0, B), !0) : !N
                            },
                            apply(O, B, F) {
                                let U = B[N] || B;
                                if (G.isUnsubscribed) return Reflect.apply(O, U, F);
                                if ((!1 === j || !0 !== j && !j.includes(O.name)) && hd.isHandledType(U)) {
                                    var Y;
                                    let N = lK.initial(G.getPath(O)),
                                        j = hd.isHandledMethod(U, O.name);
                                    Q.start(U, N, F);
                                    let $ = Reflect.apply(O, Q.preferredThisArg(O, B, U), j ? F.map(_ => p(_)) : F),
                                        ee = Q.isChanged(U, k),
                                        et = Q.stop();
                                    if (hd.isHandledType($) && j && (B instanceof Map && "get" === O.name && (N = lK.concat(N, F[0])), $ = G.getProxy($, N, K)), ee) {
                                        let B = {
                                                name: O.name,
                                                args: F,
                                                result: $
                                            },
                                            k = Q.isCloning ? lK.initial(N) : N,
                                            j = Q.isCloning ? lK.last(N) : "";
                                        h(lK.get(_, k), j, U, et, B) ? f(k, j, U, et, B) : Q.undo(U)
                                    }
                                    return (B instanceof Map || B instanceof Set) && "object" == typeof(Y = $) && "function" == typeof Y.next ? function(_, O, B, N, k) {
                                        let F = _.next;
                                        if ("entries" === O.name) _.next = function() {
                                            let _ = F.call(this);
                                            return !1 === _.done && (_.value[0] = k(_.value[0], O, _.value[0], N), _.value[1] = k(_.value[1], O, _.value[0], N)), _
                                        };
                                        else if ("values" === O.name) {
                                            let U = B[lX].keys();
                                            _.next = function() {
                                                let _ = F.call(this);
                                                return !1 === _.done && (_.value = k(_.value, O, U.next().value, N)), _
                                            }
                                        } else _.next = function() {
                                            let _ = F.call(this);
                                            return !1 === _.done && (_.value = k(_.value, O, _.value, N)), _
                                        };
                                        return _
                                    }($, O, B, N, m) : $
                                }
                                return Reflect.apply(O, B, F)
                            }
                        },
                        $ = G.getProxy(_, B.pathAsArray ? [] : "", K);
                    return O = O.bind($), Y && (B.onValidate = B.onValidate.bind($)), $
                };
            fw.target = _ => _ && _[lX] || _, fw.unsubscribe = _ => _[lQ] || _;
            var hp = "object" == typeof global && global && global.Object === Object && global,
                hf = "object" == typeof self && self && self.Object === Object && self,
                hm = hp || hf || Function("return this")(),
                hg = hm.Symbol,
                hx = Object.prototype,
                hb = hx.hasOwnProperty,
                hw = hx.toString,
                h_ = hg ? hg.toStringTag : void 0,
                SM = function(_) {
                    var O = hb.call(_, h_),
                        B = _[h_];
                    try {
                        _[h_] = void 0;
                        var N = !0
                    } catch {}
                    var k = hw.call(_);
                    return N && (O ? _[h_] = B : delete _[h_]), k
                },
                hS = Object.prototype.toString,
                hA = hg ? hg.toStringTag : void 0,
                Li = function(_) {
                    return null == _ ? void 0 === _ ? "[object Undefined]" : "[object Null]" : hA && hA in Object(_) ? SM(_) : hS.call(_)
                },
                Bn = function(_) {
                    return null != _ && "object" == typeof _
                },
                Fa = function(_) {
                    return "symbol" == typeof _ || Bn(_) && "[object Symbol]" == Li(_)
                },
                Ug = function(_, O) {
                    for (var B = -1, N = null == _ ? 0 : _.length, k = Array(N); ++B < N;) k[B] = O(_[B], B, _);
                    return k
                },
                hC = Array.isArray,
                hT = 1 / 0,
                hI = hg ? hg.prototype : void 0,
                hO = hI ? hI.toString : void 0,
                CM = function TM(_) {
                    if ("string" == typeof _) return _;
                    if (hC(_)) return Ug(_, TM) + "";
                    if (Fa(_)) return hO ? hO.call(_) : "";
                    var O = _ + "";
                    return "0" == O && 1 / _ == -hT ? "-0" : O
                },
                hR = /\s/,
                PM = function(_) {
                    for (var O = _.length; O-- && hR.test(_.charAt(O)););
                    return O
                },
                hB = /^\s+/,
                Kr = function(_) {
                    var O = typeof _;
                    return null != _ && ("object" == O || "function" == O)
                },
                hz = 0 / 0,
                hN = /^[-+]0x[0-9a-f]+$/i,
                hk = /^0b[01]+$/i,
                hF = /^0o[0-7]+$/i,
                hU = parseInt,
                mw = function(_) {
                    if ("number" == typeof _) return _;
                    if (Fa(_)) return hz;
                    if (Kr(_)) {
                        var O, B = "function" == typeof _.valueOf ? _.valueOf() : _;
                        _ = Kr(B) ? B + "" : B
                    }
                    if ("string" != typeof _) return 0 === _ ? _ : +_;
                    _ = (O = _) && O.slice(0, PM(O) + 1).replace(hB, "");
                    var N = hk.test(_);
                    return N || hF.test(_) ? hU(_.slice(2), N ? 2 : 8) : hN.test(_) ? hz : +_
                },
                Gg = function(_) {
                    if (!Kr(_)) return !1;
                    var O = Li(_);
                    return "[object Function]" == O || "[object GeneratorFunction]" == O || "[object AsyncFunction]" == O || "[object Proxy]" == O
                },
                hj = hm["__core-js_shared__"],
                hG = (dZ = /[^.]+$/.exec(hj && hj.keys && hj.keys.IE_PROTO || "")) ? "Symbol(src)_1." + dZ : "",
                hH = Function.prototype.toString,
                Yo = function(_) {
                    if (null != _) {
                        try {
                            return hH.call(_)
                        } catch {}
                        try {
                            return _ + ""
                        } catch {}
                    }
                    return ""
                },
                hW = /^\[object .+?Constructor\]$/,
                hq = Object.prototype,
                hY = Function.prototype.toString,
                hX = hq.hasOwnProperty,
                hQ = RegExp("^" + hY.call(hX).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                ci = function(_, O) {
                    var B, N = _ ? .[O];
                    return Kr(B = N) && (!hG || !(hG in B)) && (Gg(B) ? hQ : hW).test(Yo(B)) ? N : void 0
                },
                hZ = ci(hm, "WeakMap"),
                hK = Object.create,
                hJ = function() {
                    function i() {}
                    return function(_) {
                        if (!Kr(_)) return {};
                        if (hK) return hK(_);
                        i.prototype = _;
                        var O = new i;
                        return i.prototype = void 0, O
                    }
                }(),
                VM = function(_, O, B) {
                    switch (B.length) {
                        case 0:
                            return _.call(O);
                        case 1:
                            return _.call(O, B[0]);
                        case 2:
                            return _.call(O, B[0], B[1]);
                        case 3:
                            return _.call(O, B[0], B[1], B[2])
                    }
                    return _.apply(O, B)
                },
                zM = function(_, O) {
                    var B = -1,
                        N = _.length;
                    for (O || (O = Array(N)); ++B < N;) O[B] = _[B];
                    return O
                },
                h$ = Date.now,
                h0 = function() {
                    try {
                        var _ = ci(Object, "defineProperty");
                        return _({}, "", {}), _
                    } catch {}
                }(),
                h1 = h0 ? function(_, O) {
                    return h0(_, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: function() {
                            return O
                        },
                        writable: !0
                    })
                } : function(_) {
                    return _
                },
                h4 = (dK = 0, dJ = 0, function() {
                    var _ = h$(),
                        O = 16 - (_ - dJ);
                    if (dJ = _, O > 0) {
                        if (++dK >= 800) return arguments[0]
                    } else dK = 0;
                    return h1.apply(void 0, arguments)
                }),
                WM = function(_, O) {
                    for (var B = -1, N = null == _ ? 0 : _.length; ++B < N && !1 !== O(_[B], B, _););
                    return _
                },
                h5 = /^(?:0|[1-9]\d*)$/,
                zu = function(_, O) {
                    var B = typeof _;
                    return !!(O = O ? ? 9007199254740991) && ("number" == B || "symbol" != B && h5.test(_)) && _ > -1 && _ % 1 == 0 && _ < O
                },
                Wg = function(_, O, B) {
                    "__proto__" == O && h0 ? h0(_, O, {
                        configurable: !0,
                        enumerable: !0,
                        value: B,
                        writable: !0
                    }) : _[O] = B
                },
                Uu = function(_, O) {
                    return _ === O || _ != _ && O != O
                },
                h6 = Object.prototype.hasOwnProperty,
                Gu = function(_, O, B) {
                    var N = _[O];
                    h6.call(_, O) && Uu(N, B) && (void 0 !== B || O in _) || Wg(_, O, B)
                },
                qs = function(_, O, B, N) {
                    var k = !B;
                    B || (B = {});
                    for (var F = -1, U = O.length; ++F < U;) {
                        var j = O[F],
                            G = N ? N(B[j], _[j], j, B, _) : void 0;
                        void 0 === G && (G = _[j]), k ? Wg(B, j, G) : Gu(B, j, G)
                    }
                    return B
                },
                h8 = Math.max,
                Hu = function(_) {
                    return "number" == typeof _ && _ > -1 && _ % 1 == 0 && _ <= 9007199254740991
                },
                qg = function(_) {
                    return null != _ && Hu(_.length) && !Gg(_)
                },
                h9 = Object.prototype,
                ju = function(_) {
                    var O = _ && _.constructor;
                    return _ === ("function" == typeof O && O.prototype || h9)
                },
                XM = function(_, O) {
                    for (var B = -1, N = Array(_); ++B < _;) N[B] = O(B);
                    return N
                },
                gw = function(_) {
                    return Bn(_) && "[object Arguments]" == Li(_)
                },
                h7 = Object.prototype,
                ce = h7.hasOwnProperty,
                cr = h7.propertyIsEnumerable,
                cs = gw(function() {
                    return arguments
                }()) ? gw : function(_) {
                    return Bn(_) && ce.call(_, "callee") && !cr.call(_, "callee")
                },
                ca = "object" == typeof exports && exports && !exports.nodeType && exports,
                cn = ca && "object" == typeof module && module && !module.nodeType && module,
                co = cn && cn.exports === ca ? hm.Buffer : void 0,
                ch = (co ? co.isBuffer : void 0) || function() {
                    return !1
                },
                cc = {};
            cc["[object Float32Array]"] = cc["[object Float64Array]"] = cc["[object Int8Array]"] = cc["[object Int16Array]"] = cc["[object Int32Array]"] = cc["[object Uint8Array]"] = cc["[object Uint8ClampedArray]"] = cc["[object Uint16Array]"] = cc["[object Uint32Array]"] = !0, cc["[object Arguments]"] = cc["[object Array]"] = cc["[object ArrayBuffer]"] = cc["[object Boolean]"] = cc["[object DataView]"] = cc["[object Date]"] = cc["[object Error]"] = cc["[object Function]"] = cc["[object Map]"] = cc["[object Number]"] = cc["[object Object]"] = cc["[object RegExp]"] = cc["[object Set]"] = cc["[object String]"] = cc["[object WeakMap]"] = !1;
            var qu = function(_) {
                    return function(O) {
                        return _(O)
                    }
                },
                cd = "object" == typeof exports && exports && !exports.nodeType && exports,
                cu = cd && "object" == typeof module && module && !module.nodeType && module,
                cp = cu && cu.exports === cd && hp.process,
                cf = function() {
                    try {
                        return cu && cu.require && cu.require("util").types || cp && cp.binding && cp.binding("util")
                    } catch {}
                }(),
                cm = cf && cf.isTypedArray,
                cg = cm ? qu(cm) : function(_) {
                    return Bn(_) && Hu(_.length) && !!cc[Li(_)]
                },
                cv = Object.prototype.hasOwnProperty,
                Xg = function(_, O) {
                    var B = hC(_),
                        N = !B && cs(_),
                        k = !B && !N && ch(_),
                        F = !B && !N && !k && cg(_),
                        U = B || N || k || F,
                        j = U ? XM(_.length, String) : [],
                        G = j.length;
                    for (var Y in _)(O || cv.call(_, Y)) && !(U && ("length" == Y || k && ("offset" == Y || "parent" == Y) || F && ("buffer" == Y || "byteLength" == Y || "byteOffset" == Y) || zu(Y, G))) && j.push(Y);
                    return j
                },
                Qg = function(_, O) {
                    return function(B) {
                        return _(O(B))
                    }
                },
                cy = Qg(Object.keys, Object),
                cx = Object.prototype.hasOwnProperty,
                iT = function(_) {
                    if (!ju(_)) return cy(_);
                    var O = [];
                    for (var B in Object(_)) cx.call(_, B) && "constructor" != B && O.push(B);
                    return O
                },
                Yu = function(_) {
                    return qg(_) ? Xg(_) : iT(_)
                },
                sT = function(_) {
                    var O = [];
                    if (null != _)
                        for (var B in Object(_)) O.push(B);
                    return O
                },
                cb = Object.prototype.hasOwnProperty,
                oT = function(_) {
                    if (!Kr(_)) return sT(_);
                    var O = ju(_),
                        B = [];
                    for (var N in _) "constructor" == N && (O || !cb.call(_, N)) || B.push(N);
                    return B
                },
                qi = function(_) {
                    return qg(_) ? Xg(_, !0) : oT(_)
                },
                cw = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                c_ = /^\w*$/,
                aT = function(_, O) {
                    if (hC(_)) return !1;
                    var B = typeof _;
                    return !!("number" == B || "symbol" == B || "boolean" == B || null == _ || Fa(_)) || c_.test(_) || !cw.test(_) || null != O && _ in Object(O)
                },
                cS = ci(Object, "create"),
                cA = Object.prototype.hasOwnProperty,
                cM = Object.prototype.hasOwnProperty;

            function Xu(_) {
                var O = -1,
                    B = null == _ ? 0 : _.length;
                for (this.clear(); ++O < B;) {
                    var N = _[O];
                    this.set(N[0], N[1])
                }
            }
            Xu.prototype.clear = function() {
                this.__data__ = cS ? cS(null) : {}, this.size = 0
            }, Xu.prototype.delete = function(_) {
                var O = this.has(_) && delete this.__data__[_];
                return this.size -= O ? 1 : 0, O
            }, Xu.prototype.get = function(_) {
                var O = this.__data__;
                if (cS) {
                    var B = O[_];
                    return "__lodash_hash_undefined__" === B ? void 0 : B
                }
                return cA.call(O, _) ? O[_] : void 0
            }, Xu.prototype.has = function(_) {
                var O = this.__data__;
                return cS ? void 0 !== O[_] : cM.call(O, _)
            }, Xu.prototype.set = function(_, O) {
                var B = this.__data__;
                return this.size += this.has(_) ? 0 : 1, B[_] = cS && void 0 === O ? "__lodash_hash_undefined__" : O, this
            };
            var ka = function(_, O) {
                    for (var B = _.length; B--;)
                        if (Uu(_[B][0], O)) return B;
                    return -1
                },
                cE = Array.prototype.splice;

            function Qu(_) {
                var O = -1,
                    B = null == _ ? 0 : _.length;
                for (this.clear(); ++O < B;) {
                    var N = _[O];
                    this.set(N[0], N[1])
                }
            }
            Qu.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, Qu.prototype.delete = function(_) {
                var O = this.__data__,
                    B = ka(O, _);
                return !(B < 0) && (B == O.length - 1 ? O.pop() : cE.call(O, B, 1), --this.size, !0)
            }, Qu.prototype.get = function(_) {
                var O = this.__data__,
                    B = ka(O, _);
                return B < 0 ? void 0 : O[B][1]
            }, Qu.prototype.has = function(_) {
                return ka(this.__data__, _) > -1
            }, Qu.prototype.set = function(_, O) {
                var B = this.__data__,
                    N = ka(B, _);
                return N < 0 ? (++this.size, B.push([_, O])) : B[N][1] = O, this
            };
            var cT = ci(hm, "Map"),
                xT = function(_) {
                    var O = typeof _;
                    return "string" == O || "number" == O || "symbol" == O || "boolean" == O ? "__proto__" !== _ : null === _
                },
                Ua = function(_, O) {
                    var B = _.__data__;
                    return xT(O) ? B["string" == typeof O ? "string" : "hash"] : B.map
                };

            function Ku(_) {
                var O = -1,
                    B = null == _ ? 0 : _.length;
                for (this.clear(); ++O < B;) {
                    var N = _[O];
                    this.set(N[0], N[1])
                }
            }

            function xw(_, O) {
                if ("function" != typeof _ || null != O && "function" != typeof O) throw TypeError("Expected a function");
                var e = function() {
                    var B = arguments,
                        N = O ? O.apply(this, B) : B[0],
                        k = e.cache;
                    if (k.has(N)) return k.get(N);
                    var F = _.apply(this, B);
                    return e.cache = k.set(N, F) || k, F
                };
                return e.cache = new(xw.Cache || Ku), e
            }
            Ku.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Xu,
                    map: new(cT || Qu),
                    string: new Xu
                }
            }, Ku.prototype.delete = function(_) {
                var O = Ua(this, _).delete(_);
                return this.size -= O ? 1 : 0, O
            }, Ku.prototype.get = function(_) {
                return Ua(this, _).get(_)
            }, Ku.prototype.has = function(_) {
                return Ua(this, _).has(_)
            }, Ku.prototype.set = function(_, O) {
                var B = Ua(this, _),
                    N = B.size;
                return B.set(_, O), this.size += B.size == N ? 0 : 1, this
            }, xw.Cache = Ku;
            var cD = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                cP = /\\(\\)?/g,
                cO = (d0 = (d$ = xw(function(_) {
                    var O = [];
                    return 46 === _.charCodeAt(0) && O.push(""), _.replace(cD, function(_, B, N, k) {
                        O.push(N ? k.replace(cP, "$1") : B || _)
                    }), O
                }, function(_) {
                    return 500 === d0.size && d0.clear(), _
                })).cache, d$),
                Yi = function(_, O) {
                    return hC(_) ? _ : aT(_, O) ? [_] : cO(null == _ ? "" : CM(_))
                },
                cR = 1 / 0,
                Ga = function(_) {
                    if ("string" == typeof _ || Fa(_)) return _;
                    var O = _ + "";
                    return "0" == O && 1 / _ == -cR ? "-0" : O
                },
                Kg = function(_, O) {
                    O = Yi(O, _);
                    for (var B = 0, N = O.length; null != _ && B < N;) _ = _[Ga(O[B++])];
                    return B && B == N ? _ : void 0
                },
                Zu = function(_, O) {
                    for (var B = -1, N = O.length, k = _.length; ++B < N;) _[k + B] = O[B];
                    return _
                },
                cB = hg ? hg.isConcatSpreadable : void 0,
                PT = function(_) {
                    return hC(_) || cs(_) || !!(cB && _ && _[cB])
                },
                IT = function DT(_, O, B, N, k) {
                    var F = -1,
                        U = _.length;
                    for (B || (B = PT), k || (k = []); ++F < U;) {
                        var j = _[F];
                        O > 0 && B(j) ? O > 1 ? DT(j, O - 1, B, N, k) : Zu(k, j) : N || (k[k.length] = j)
                    }
                    return k
                },
                Zg = function(_) {
                    var O;
                    return h4((O = h8((O = void 0, _.length - 1), 0), function() {
                        for (var B, N = arguments, k = -1, F = h8(N.length - O, 0), U = Array(F); ++k < F;) U[k] = N[O + k];
                        k = -1;
                        for (var j = Array(O + 1); ++k < O;) j[k] = N[k];
                        return j[O] = (null == (B = U) ? 0 : B.length) ? IT(B, 1) : [], VM(_, this, j)
                    }), _ + "")
                },
                cN = Qg(Object.getPrototypeOf, Object),
                ck = Object.prototype,
                cF = Function.prototype.toString,
                cU = ck.hasOwnProperty,
                cj = cF.call(Object),
                LT = function(_) {
                    if (!Bn(_) || "[object Object]" != Li(_)) return !1;
                    var O = cN(_);
                    if (null === O) return !0;
                    var B = cU.call(O, "constructor") && O.constructor;
                    return "function" == typeof B && B instanceof B && cF.call(B) == cj
                },
                NT = function(_, O, B) {
                    var N = -1,
                        k = _.length;
                    O < 0 && (O = -O > k ? 0 : k + O), (B = B > k ? k : B) < 0 && (B += k), k = O > B ? 0 : B - O >>> 0, O >>>= 0;
                    for (var F = Array(k); ++N < k;) F[N] = _[N + O];
                    return F
                };

            function $u(_) {
                var O = this.__data__ = new Qu(_);
                this.size = O.size
            }
            $u.prototype.clear = function() {
                this.__data__ = new Qu, this.size = 0
            }, $u.prototype.delete = function(_) {
                var O = this.__data__,
                    B = O.delete(_);
                return this.size = O.size, B
            }, $u.prototype.get = function(_) {
                return this.__data__.get(_)
            }, $u.prototype.has = function(_) {
                return this.__data__.has(_)
            }, $u.prototype.set = function(_, O) {
                var B = this.__data__;
                if (B instanceof Qu) {
                    var N = B.__data__;
                    if (!cT || N.length < 199) return N.push([_, O]), this.size = ++B.size, this;
                    B = this.__data__ = new Ku(N)
                }
                return B.set(_, O), this.size = B.size, this
            };
            var cG = "object" == typeof exports && exports && !exports.nodeType && exports,
                cH = cG && "object" == typeof module && module && !module.nodeType && module,
                cW = cH && cH.exports === cG ? hm.Buffer : void 0,
                cq = cW ? cW.allocUnsafe : void 0,
                YT = function(_, O) {
                    if (O) return _.slice();
                    var B = _.length,
                        N = cq ? cq(B) : new _.constructor(B);
                    return _.copy(N), N
                },
                XT = function(_, O) {
                    for (var B = -1, N = null == _ ? 0 : _.length, k = 0, F = []; ++B < N;) {
                        var U = _[B];
                        O(U, B, _) && (F[k++] = U)
                    }
                    return F
                },
                Jg = function() {
                    return []
                },
                cY = Object.prototype.propertyIsEnumerable,
                cX = Object.getOwnPropertySymbols,
                cZ = cX ? function(_) {
                    return null == _ ? [] : XT(cX(_ = Object(_)), function(O) {
                        return cY.call(_, O)
                    })
                } : Jg,
                cK = Object.getOwnPropertySymbols ? function(_) {
                    for (var O = []; _;) Zu(O, cZ(_)), _ = cN(_);
                    return O
                } : Jg,
                ey = function(_, O, B) {
                    var N = O(_);
                    return hC(_) ? N : Zu(N, B(_))
                },
                rp = function(_) {
                    return ey(_, Yu, cZ)
                },
                ty = function(_) {
                    return ey(_, qi, cK)
                },
                cJ = ci(hm, "DataView"),
                c$ = ci(hm, "Promise"),
                c0 = ci(hm, "Set"),
                c4 = "[object Map]",
                c5 = "[object Promise]",
                c6 = "[object Set]",
                c8 = "[object WeakMap]",
                c9 = "[object DataView]",
                c7 = Yo(cJ),
                de = Yo(cT),
                dt = Yo(c$),
                di = Yo(c0),
                dr = Yo(hZ),
                ds = Li;
            (cJ && ds(new cJ(new ArrayBuffer(1))) != c9 || cT && ds(new cT) != c4 || c$ && ds(c$.resolve()) != c5 || c0 && ds(new c0) != c6 || hZ && ds(new hZ) != c8) && (ds = function(_) {
                var O = Li(_),
                    B = "[object Object]" == O ? _.constructor : void 0,
                    N = B ? Yo(B) : "";
                if (N) switch (N) {
                    case c7:
                        return c9;
                    case de:
                        return c4;
                    case dt:
                        return c5;
                    case di:
                        return c6;
                    case dr:
                        return c8
                }
                return O
            });
            var da = ds,
                dn = Object.prototype.hasOwnProperty,
                nC = function(_) {
                    var O = _.length,
                        B = new _.constructor(O);
                    return O && "string" == typeof _[0] && dn.call(_, "index") && (B.index = _.index, B.input = _.input), B
                },
                dl = hm.Uint8Array,
                nh = function(_) {
                    var O = new _.constructor(_.byteLength);
                    return new dl(O).set(new dl(_)), O
                },
                iC = function(_, O) {
                    var B = O ? nh(_.buffer) : _.buffer;
                    return new _.constructor(B, _.byteOffset, _.byteLength)
                },
                dh = /\w*$/,
                sC = function(_) {
                    var O = new _.constructor(_.source, dh.exec(_));
                    return O.lastIndex = _.lastIndex, O
                },
                dc = hg ? hg.prototype : void 0,
                dd = dc ? dc.valueOf : void 0,
                cC = function(_, O) {
                    var B = O ? nh(_.buffer) : _.buffer;
                    return new _.constructor(B, _.byteOffset, _.length)
                },
                uC = function(_, O, B) {
                    var N = _.constructor;
                    switch (O) {
                        case "[object ArrayBuffer]":
                            return nh(_);
                        case "[object Boolean]":
                        case "[object Date]":
                            return new N(+_);
                        case "[object DataView]":
                            return iC(_, B);
                        case "[object Float32Array]":
                        case "[object Float64Array]":
                        case "[object Int8Array]":
                        case "[object Int16Array]":
                        case "[object Int32Array]":
                        case "[object Uint8Array]":
                        case "[object Uint8ClampedArray]":
                        case "[object Uint16Array]":
                        case "[object Uint32Array]":
                            return cC(_, B);
                        case "[object Map]":
                        case "[object Set]":
                            return new N;
                        case "[object Number]":
                        case "[object String]":
                            return new N(_);
                        case "[object RegExp]":
                            return sC(_);
                        case "[object Symbol]":
                            return dd ? Object(dd.call(_)) : {}
                    }
                },
                du = cf && cf.isMap,
                dp = du ? qu(du) : function(_) {
                    return Bn(_) && "[object Map]" == da(_)
                },
                df = cf && cf.isSet,
                dm = df ? qu(df) : function(_) {
                    return Bn(_) && "[object Set]" == da(_)
                },
                dy = "[object Arguments]",
                dx = "[object Function]",
                db = "[object Object]",
                dw = {};
            dw[dy] = dw["[object Array]"] = dw["[object ArrayBuffer]"] = dw["[object DataView]"] = dw["[object Boolean]"] = dw["[object Date]"] = dw["[object Float32Array]"] = dw["[object Float64Array]"] = dw["[object Int8Array]"] = dw["[object Int16Array]"] = dw["[object Int32Array]"] = dw["[object Map]"] = dw["[object Number]"] = dw[db] = dw["[object RegExp]"] = dw["[object Set]"] = dw["[object String]"] = dw["[object Symbol]"] = dw["[object Uint8Array]"] = dw["[object Uint8ClampedArray]"] = dw["[object Uint16Array]"] = dw["[object Uint32Array]"] = !0, dw["[object Error]"] = dw[dx] = dw["[object WeakMap]"] = !1;
            var oy = function sy(_, O, B, N, k, F) {
                    var U, j = 1 & O,
                        G = 2 & O,
                        Y = 4 & O;
                    if (B && (U = k ? B(_, N, k, F) : B(_)), void 0 !== U) return U;
                    if (!Kr(_)) return _;
                    var Q = hC(_);
                    if (Q) {
                        if (U = nC(_), !j) return zM(_, U)
                    } else {
                        var K, $, ee, et, ei = da(_),
                            er = ei == dx || "[object GeneratorFunction]" == ei;
                        if (ch(_)) return YT(_, j);
                        if (ei == db || ei == dy || er && !k) {
                            if (U = G || er ? {} : "function" != typeof _.constructor || ju(_) ? {} : hJ(cN(_)), !j) return G ? ($ = (K = U) && qs(_, qi(_), K), qs(_, cK(_), $)) : (et = (ee = U) && qs(_, Yu(_), ee), qs(_, cZ(_), et))
                        } else {
                            if (!dw[ei]) return k ? _ : {};
                            U = uC(_, ei, j)
                        }
                    }
                    F || (F = new $u);
                    var ea = F.get(_);
                    if (ea) return ea;
                    F.set(_, U), dm(_) ? _.forEach(function(N) {
                        U.add(sy(N, O, B, N, _, F))
                    }) : dp(_) && _.forEach(function(N, k) {
                        U.set(k, sy(N, O, B, k, _, F))
                    });
                    var en = Y ? G ? ty : rp : G ? qi : Yu,
                        eo = Q ? void 0 : en(_);
                    return WM(eo || _, function(N, k) {
                        eo && (N = _[k = N]), Gu(U, k, sy(N, O, B, k, _, F))
                    }), U
                },
                Zo = function(_) {
                    return oy(_, 5)
                };

            function ay(_) {
                var O = -1,
                    B = null == _ ? 0 : _.length;
                for (this.__data__ = new Ku; ++O < B;) this.add(_[O])
            }
            ay.prototype.add = ay.prototype.push = function(_) {
                return this.__data__.set(_, "__lodash_hash_undefined__"), this
            }, ay.prototype.has = function(_) {
                return this.__data__.has(_)
            };
            var _C = function(_, O) {
                    for (var B = -1, N = null == _ ? 0 : _.length; ++B < N;)
                        if (O(_[B], B, _)) return !0;
                    return !1
                },
                ly = function(_, O, B, N, k, F) {
                    var U = 1 & B,
                        j = _.length,
                        G = O.length;
                    if (j != G && !(U && G > j)) return !1;
                    var Y = F.get(_),
                        Q = F.get(O);
                    if (Y && Q) return Y == O && Q == _;
                    var K = -1,
                        $ = !0,
                        ee = 2 & B ? new ay : void 0;
                    for (F.set(_, O), F.set(O, _); ++K < j;) {
                        var et = _[K],
                            ei = O[K];
                        if (N) var er = U ? N(ei, et, K, O, _, F) : N(et, ei, K, _, O, F);
                        if (void 0 !== er) {
                            if (er) continue;
                            $ = !1;
                            break
                        }
                        if (ee) {
                            if (!_C(O, function(_, O) {
                                    if (!ee.has(O) && (et === _ || k(et, _, B, N, F))) return ee.push(O)
                                })) {
                                $ = !1;
                                break
                            }
                        } else if (!(et === ei || k(et, ei, B, N, F))) {
                            $ = !1;
                            break
                        }
                    }
                    return F.delete(_), F.delete(O), $
                },
                MC = function(_) {
                    var O = -1,
                        B = Array(_.size);
                    return _.forEach(function(_, N) {
                        B[++O] = [N, _]
                    }), B
                },
                TC = function(_) {
                    var O = -1,
                        B = Array(_.size);
                    return _.forEach(function(_) {
                        B[++O] = _
                    }), B
                },
                d_ = hg ? hg.prototype : void 0,
                dA = d_ ? d_.valueOf : void 0,
                PC = function(_, O, B, N, k, F, U) {
                    switch (B) {
                        case "[object DataView]":
                            if (_.byteLength != O.byteLength || _.byteOffset != O.byteOffset) break;
                            _ = _.buffer, O = O.buffer;
                        case "[object ArrayBuffer]":
                            return !(_.byteLength != O.byteLength || !F(new dl(_), new dl(O)));
                        case "[object Boolean]":
                        case "[object Date]":
                        case "[object Number]":
                            return Uu(+_, +O);
                        case "[object Error]":
                            return _.name == O.name && _.message == O.message;
                        case "[object RegExp]":
                        case "[object String]":
                            return _ == O + "";
                        case "[object Map]":
                            var j = MC;
                        case "[object Set]":
                            var G = 1 & N;
                            if (j || (j = TC), _.size != O.size && !G) break;
                            var Y = U.get(_);
                            if (Y) return Y == O;
                            N |= 2, U.set(_, O);
                            var Q = ly(j(_), j(O), N, k, F, U);
                            return U.delete(_), Q;
                        case "[object Symbol]":
                            if (dA) return dA.call(_) == dA.call(O)
                    }
                    return !1
                },
                dC = Object.prototype.hasOwnProperty,
                DC = function(_, O, B, N, k, F) {
                    var U = 1 & B,
                        j = rp(_),
                        G = j.length;
                    if (G != rp(O).length && !U) return !1;
                    for (var Y = G; Y--;) {
                        var Q = j[Y];
                        if (!(U ? Q in O : dC.call(O, Q))) return !1
                    }
                    var K = F.get(_),
                        $ = F.get(O);
                    if (K && $) return K == O && $ == _;
                    var ee = !0;
                    F.set(_, O), F.set(O, _);
                    for (var et = U; ++Y < G;) {
                        var ei = _[Q = j[Y]],
                            er = O[Q];
                        if (N) var ea = U ? N(er, ei, Q, O, _, F) : N(ei, er, Q, _, O, F);
                        if (!(void 0 === ea ? ei === er || k(ei, er, B, N, F) : ea)) {
                            ee = !1;
                            break
                        }
                        et || (et = "constructor" == Q)
                    }
                    if (ee && !et) {
                        var en = _.constructor,
                            eo = O.constructor;
                        en != eo && "constructor" in _ && "constructor" in O && !("function" == typeof en && en instanceof en && "function" == typeof eo && eo instanceof eo) && (ee = !1)
                    }
                    return F.delete(_), F.delete(O), ee
                },
                dT = "[object Arguments]",
                dP = "[object Array]",
                dI = "[object Object]",
                dO = Object.prototype.hasOwnProperty,
                LC = function(_, O, B, N, k, F) {
                    var U = hC(_),
                        j = hC(O),
                        G = U ? dP : da(_),
                        Y = j ? dP : da(O);
                    G = G == dT ? dI : G, Y = Y == dT ? dI : Y;
                    var Q = G == dI,
                        K = Y == dI,
                        $ = G == Y;
                    if ($ && ch(_)) {
                        if (!ch(O)) return !1;
                        U = !0, Q = !1
                    }
                    if ($ && !Q) return F || (F = new $u), U || cg(_) ? ly(_, O, B, N, k, F) : PC(_, O, G, B, N, k, F);
                    if (!(1 & B)) {
                        var ee = Q && dO.call(_, "__wrapped__"),
                            et = K && dO.call(O, "__wrapped__");
                        if (ee || et) {
                            var ei = ee ? _.value() : _,
                                er = et ? O.value() : O;
                            return F || (F = new $u), k(ei, er, B, N, F)
                        }
                    }
                    return !!$ && (F || (F = new $u), DC(_, O, B, N, k, F))
                },
                FC = function(_, O) {
                    return null != _ && O in Object(_)
                },
                kC = function(_, O, B) {
                    O = Yi(O, _);
                    for (var N = -1, k = O.length, F = !1; ++N < k;) {
                        var U = Ga(O[N]);
                        if (!(F = null != _ && B(_, U))) break;
                        _ = _[U]
                    }
                    return F || ++N != k ? F : !!(k = null == _ ? 0 : _.length) && Hu(k) && zu(U, k) && (hC(_) || cs(_))
                },
                uy = function() {
                    return hm.Date.now()
                },
                dR = Math.max,
                dB = Math.min,
                rc = function(_, O, B) {
                    var N, k, F, U, j, G, Y = 0,
                        Q = !1,
                        K = !1,
                        $ = !0;
                    if ("function" != typeof _) throw TypeError("Expected a function");

                    function f(O) {
                        var B = N,
                            F = k;
                        return N = k = void 0, Y = O, U = _.apply(F, B)
                    }

                    function g(_) {
                        var B = _ - G,
                            N = _ - Y;
                        return void 0 === G || B >= O || B < 0 || K && N >= F
                    }

                    function y() {
                        var _, B, N, k = uy();
                        if (g(k)) return v(k);
                        j = setTimeout(y, (_ = k - G, B = k - Y, N = O - _, K ? dB(N, F - B) : N))
                    }

                    function v(_) {
                        return j = void 0, $ && N ? f(_) : (N = k = void 0, U)
                    }

                    function S() {
                        var _, B = uy(),
                            F = g(B);
                        if (N = arguments, k = this, G = B, F) {
                            if (void 0 === j) return Y = _ = G, j = setTimeout(y, O), Q ? f(_) : U;
                            if (K) return clearTimeout(j), j = setTimeout(y, O), f(G)
                        }
                        return void 0 === j && (j = setTimeout(y, O)), U
                    }
                    return O = mw(O) || 0, Kr(B) && (Q = !!B.leading, F = (K = "maxWait" in B) ? dR(mw(B.maxWait) || 0, O) : F, $ = "trailing" in B ? !!B.trailing : $), S.cancel = function() {
                        void 0 !== j && clearTimeout(j), Y = 0, N = G = k = j = void 0
                    }, S.flush = function() {
                        return void 0 === j ? U : v(uy())
                    }, S
                },
                zC = function(_) {
                    var O = null == _ ? 0 : _.length;
                    return O ? _[O - 1] : void 0
                },
                np = function(_, O) {
                    return function NC(_, O, B, N, k) {
                        return _ === O || (null != _ && null != O && (Bn(_) || Bn(O)) ? LC(_, O, B, N, NC, k) : _ != _ && O != O)
                    }(_, O)
                },
                GC = function(_, O) {
                    var B, N;
                    return O = Yi(O, _), B = _, null == (_ = (N = O).length < 2 ? B : Kg(B, NT(N, 0, -1))) || delete _[Ga(zC(O))]
                },
                HC = function(_) {
                    return LT(_) ? void 0 : _
                },
                dN = Zg(function(_, O) {
                    var B = {};
                    if (null == _) return B;
                    var N = !1;
                    O = Ug(O, function(O) {
                        return O = Yi(O, _), N || (N = O.length > 1), O
                    }), qs(_, ty(_), B), N && (B = oy(B, 7, HC));
                    for (var k = O.length; k--;) GC(B, O[k]);
                    return B
                }),
                jC = function(_, O, B, N) {
                    if (!Kr(_)) return _;
                    O = Yi(O, _);
                    for (var k = -1, F = O.length, U = F - 1, j = _; null != j && ++k < F;) {
                        var G = Ga(O[k]),
                            Y = B;
                        if ("__proto__" === G || "constructor" === G || "prototype" === G) break;
                        if (k != U) {
                            var Q = j[G];
                            void 0 === (Y = N ? N(Q, G, j) : void 0) && (Y = Kr(Q) ? Q : zu(O[k + 1]) ? [] : {})
                        }
                        Gu(j, G, Y), j = j[G]
                    }
                    return _
                },
                WC = function(_, O, B) {
                    for (var N = -1, k = O.length, F = {}; ++N < k;) {
                        var U = O[N],
                            j = Kg(_, U);
                        B(j, U) && jC(F, Yi(U, _), j)
                    }
                    return F
                },
                dk = Zg(function(_, O) {
                    return null == _ ? {} : WC(_, O, function(O, B) {
                        return null != _ && kC(_, B, FC)
                    })
                }),
                ww = function(_, O, B) {
                    var N = !0,
                        k = !0;
                    if ("function" != typeof _) throw TypeError("Expected a function");
                    return Kr(B) && (N = "leading" in B ? !!B.leading : N, k = "trailing" in B ? !!B.trailing : k), rc(_, O, {
                        leading: N,
                        maxWait: O,
                        trailing: k
                    })
                };

            function ui(_, O) {
                return Object.setPrototypeOf(_, O), _
            }
            var dF = (!(typeof window > "u") && window.navigator.userAgent.toLowerCase().includes(" electron/") && (() => {
                    if (typeof window > "u") return;
                    let _ = new URLSearchParams(window.location.search).get("desktop-app-version");
                    return _ ? (window.localStorage.setItem("desktop-app-version", _), _) : window.localStorage.getItem("desktop-app-version") ? ? "0.0.6"
                })(), !(typeof window > "u") && window.navigator.platform.toUpperCase().includes("MAC")),
                dU = !(typeof window > "u") && (/iPad|iPhone|iPod/.test(window.navigator.userAgent) || dF && "ontouchend" in document),
                dj = !(typeof window > "u") && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1,
                dG = !(typeof window > "u") && ("ontouchstart" in window || navigator.maxTouchPoints > 0),
                dH = (() => {
                    if (typeof window > "u") return !1;
                    let _ = navigator.userAgent,
                        O = navigator.vendor;
                    return /Safari/i.test(_) && /Apple Computer/.test(O)
                })(),
                dW = Number((() => {
                    if (typeof window > "u") return null;
                    let _ = navigator.userAgent.match(/Version\/(\d+\.\d)/);
                    return _ && _[1]
                })());

            function hy(_) {
                return Array.isArray(_) ? _ : [_]
            }

            function ip(_) {
                return dF ? _.metaKey : _.ctrlKey
            }
            var dq = [],
                dY = {},
                dX = {},
                dQ = {};

            function KC(_) {
                dq.includes(_) || dq.push(_)
            }

            function oh(_) {
                delete dY[_.pointerId];
                for (let O = 0; O < dq.length; O++)
                    if (dq[O].pointerId === _.pointerId) {
                        dq.splice(O, 1);
                        break
                    }
            }

            function py(_) {
                if ("touch" !== _.pointerType) return;
                let O = dY[_.pointerId];
                void 0 === O && (O = {
                    x: 0,
                    y: 0
                }, dY[_.pointerId] = O), O.x = _.pageX, O.y = _.pageY
            }

            function my(_) {
                return dY[(_.pointerId === dq[0].pointerId ? dq[1] : dq[0]).pointerId]
            }

            function JC(_) {
                dX[_.key] = !0, dQ[_.key] = void 0 === dQ[_.key] ? 1 : dQ[_.key] + 1
            }

            function $C(_) {
                if (dF && dX.Meta)
                    for (let _ in dX) dX[_] = !1;
                else dX[_.key] = !1;
                dQ = {}
            }
            var dZ, dK, dJ, d$, d0, d3, d4, d5, d6 = new Promise(_ => {
                    d3 = _
                }),
                d8 = new Promise(_ => {
                    d5 = _
                }),
                d7 = class {
                    modifyById(_, O) {
                        if (void 0 === this[_]) throw Error("not expected"); {
                            let B = { ...this,
                                [_]: O
                            };
                            return Object.setPrototypeOf(B, d7.prototype), B
                        }
                    }
                    add(_, O) {
                        return this.runOp({
                            type: 1,
                            id: _,
                            data: O
                        }) ? .data ? ? this
                    }
                    runOp(_) {
                        if (1 === _.type) {
                            let O = this[_.id],
                                B;
                            B = void 0 === O ? {
                                type: 2,
                                id: _.id
                            } : {
                                type: 1,
                                id: _.id,
                                data: O
                            };
                            let {
                                id: N,
                                data: k
                            } = _, F = { ...this,
                                [N]: k
                            };
                            return Object.setPrototypeOf(F, d7.prototype), {
                                data: F,
                                actual: _,
                                reverse: B
                            }
                        }
                        if (2 === _.type) {
                            let {
                                id: O
                            } = _, B = this[O];
                            if (void 0 === B) return null; {
                                let N = { ...this
                                };
                                return Object.setPrototypeOf(N, d7.prototype), delete N[O], {
                                    data: N,
                                    actual: _,
                                    reverse: {
                                        type: 1,
                                        id: O,
                                        data: B
                                    }
                                }
                            }
                        }
                        return null
                    }
                };

            function op(_) {
                if (void 0 !== _.deepFreeze) {
                    _.deepFreeze(_);
                    return
                }
                for (let O of Object.getOwnPropertyNames(_)) {
                    let B = _[O];
                    B && "object" == typeof B && op(B)
                }
                return Object.freeze(_)
            }
            var ue = class extends Error {};

            function vy(_) {
                let O = { ..._
                };
                return Object.setPrototypeOf(O, Object.getPrototypeOf(_)), O
            }

            function Ys(_, O, B) {
                if (void 0 === _ ? void 0 === O ? (_ = 0, O = 10) : _ = O - 10 : void 0 === O && (O = _ + 10), _ > O) {
                    let B = _;
                    _ = O, O = B
                }
                let N = [],
                    k = 1 / (B + 1);
                for (let F = 0; F < B; F++) {
                    let B = _ + (O - _) * (F + .75 + .5 * Math.random()) * k;
                    N.push(B)
                }
                return N
            }

            function lh(_) {
                return _ instanceof Uint8Array || _ instanceof Uint16Array || _ instanceof Uint32Array || _ instanceof Int8Array || _ instanceof Int16Array || _ instanceof Int32Array || _ instanceof Float32Array || _ instanceof Float64Array
            }
            var ut = class extends Array {
                constructor(..._) {
                    super(..._), Object.setPrototypeOf(this, ut.prototype)
                }
                deepFreeze() {
                    let _ = 0;
                    for (; _ < this.length;) op(this[_]), _++
                }
                fillCaches0(_, O) {
                    for (let B of (this.objCaches.set(_.id, _), this.parentCaches.set(_.id, O), _.children)) this.fillCaches0(B, _.id)
                }
                fillCaches() {
                    if (void 0 === this.objCaches)
                        for (let _ of (this.objCaches = new Map, this.parentCaches = new Map, this)) this.fillCaches0(_, null)
                }
                randomId() {
                    this.fillCaches();
                    let _ = Array.from(this.objCaches.keys());
                    if (0 !== _.length) return _[Math.max(0, Math.floor(Math.random() * _.length) - 1)]
                }
                nonExistOrDescendantOf(_, O) {
                    if (!this.has(_)) return !0;
                    for (; _;) {
                        let B = this.parent(_);
                        if (B === O) return !0;
                        _ = B
                    }
                    return !1
                }
                rootAcestor(_) {
                    for (; _;) {
                        let O = this.parent(_);
                        if (O) _ = O;
                        else break
                    }
                    return _
                }
                isDescendantOf(_, O) {
                    for (; _;) {
                        let B = this.parent(_);
                        if (B === O) return !0;
                        _ = B
                    }
                    return !1
                }
                data(_) {
                    return this.get(_) ? .data
                }
                has(_) {
                    return void 0 !== this.childrenOf(_)
                }
                get(_) {
                    return this.fillCaches(), this.objCaches.get(_)
                }
                childrenOf(_) {
                    return null === _ ? this : this.get(_) ? .children
                }
                traverseFrom(_, O) {
                    if (null === _) this.traverse(O);
                    else {
                        let B = this.get(_);
                        B && function hP(_, O) {
                            if (!0 !== O(_.id, _.data))
                                for (let B of _.children) hP(B, O)
                        }(B, O)
                    }
                }
                traverse(_) {
                    ! function uP(_, O) {
                        for (let B of _) !0 !== O(B.id, B.data) && uP(B.children, O)
                    }(this, _)
                }
                totalSize() {
                    return this.fillCaches(), this.objCaches.size
                }
                parent(_) {
                    return this.fillCaches(), this.parentCaches.get(_)
                }
                childrenArray(_) {
                    return null === _ ? this : this.get(_).children
                }
                modifyById(_, O) {
                    if (void 0 === this.get(_)) throw Error("not expected"); {
                        let B = this.parent(_),
                            N = this.childrenArray(B),
                            k = N.findIndex(O => O.id === _);
                        if (k < 0) throw Error("not expected");
                        let F = N[k];
                        return (N = [...N])[k] = { ...F,
                            data: O
                        }, this.modifyArrayBy(B, N)
                    }
                }
                modifyArrayBy(_, O) {
                    let B = _,
                        N = O;
                    for (; null !== B;) {
                        let _ = N,
                            O = B;
                        if (void 0 === (B = this.parent(B))) throw Error();
                        let k = (N = this.childrenArray(B)).findIndex(_ => _.id === O);
                        if (k < 0) throw Error();
                        (N = [...N])[k] = { ...N[k],
                            children: _
                        }
                    }
                    Object.setPrototypeOf(N, ut.prototype);
                    let k = N;
                    return k.fillCaches(), k
                }
                runOp(_) {
                    switch (_.type) {
                        case 7:
                            return this.addOp(_);
                        case 8:
                            return this.deleteOp(_);
                        case 9:
                            return this.moveOp(_)
                    }
                    return null
                }
                checkDuplicatedIdRec({
                    id: _,
                    children: O
                }) {
                    if (void 0 !== this.get(_)) return !0;
                    for (let _ of O)
                        if (this.checkDuplicatedIdRec(_)) return !0;
                    return !1
                }
                addOp(_) {
                    let {
                        parent: O,
                        fi: B,
                        id: N,
                        data: k,
                        children: F
                    } = _;
                    if (null !== O && void 0 === this.get(O) || this.checkDuplicatedIdRec(_)) return null; {
                        let U = this.childrenArray(O),
                            j = {
                                fi: B,
                                id: N,
                                data: k,
                                children: F
                            };
                        return (U = [...U, j]).sort((_, O) => _.fi - O.fi), _.localIndex = U.indexOf(j), {
                            data: this.modifyArrayBy(O, U),
                            actual: _,
                            reverse: {
                                type: 8,
                                id: N
                            }
                        }
                    }
                }
                deleteOp(_) {
                    let {
                        id: O
                    } = _;
                    if (null === this.get(O)) return null; {
                        let B = this.parent(O);
                        if (void 0 === B) return null;
                        let N = this.childrenArray(B),
                            k = N.findIndex(_ => _.id === O);
                        _.localIndex = k;
                        let F = (N = [...N]).splice(k, 1)[0];
                        return {
                            data: this.modifyArrayBy(B, N),
                            actual: _,
                            reverse: {
                                type: 7,
                                ...F,
                                parent: B
                            }
                        }
                    }
                }
                moveOp(_) {
                    let {
                        parent: O,
                        fi: B,
                        id: N
                    } = _;
                    if (null !== O && void 0 === this.get(O)) return this.deleteOp({
                        type: 8,
                        id: N
                    });
                    if (null !== O) {
                        let _ = O;
                        for (; null !== _;) {
                            if (void 0 === _) throw Error();
                            if (_ === N) throw new ue("cyclic tree");
                            _ = this.parent(_)
                        }
                    }
                    let k = this.parent(N);
                    if (void 0 === k) return null;
                    let F = k,
                        U = this.childrenArray(k),
                        j = U.findIndex(_ => _.id === N),
                        G = (U = [...U]).splice(j, 1)[0],
                        Y = this.modifyArrayBy(k, U);
                    k = O, U = Y.childrenArray(k);
                    let Q = G.fi;
                    return (U = [...U, G = { ...G,
                        fi: B
                    }]).sort((_, O) => _.fi - O.fi), _.localIndex = U.indexOf(G), {
                        data: Y = Y.modifyArrayBy(k, U),
                        actual: _,
                        reverse: {
                            type: 9,
                            parent: F,
                            fi: Q,
                            id: N
                        }
                    }
                }
                previous(_, O) {
                    if (null === O) {
                        let O = this.childrenArray(_);
                        return 0 === O.length ? null : O[O.length - 1].id
                    }
                    let B = null;
                    for (let N of this.childrenArray(_)) {
                        if (N.id === O) return B;
                        B = N.id
                    }
                    return null
                }
                traverseSortNext(_) {
                    let O = this.parent(_);
                    if (void 0 !== O) {
                        let B = this.childrenArray(O),
                            N = B.findIndex(O => O.id === _) + 1;
                        if (N < B.length) return B[N].id;
                        if (O) return this.traverseSortNext(O)
                    }
                }
                sortNext(_) {
                    let O = this.childrenArray(_);
                    return O.length > 0 ? O[0].id : this.traverseSortNext(_)
                }
                traverseSortPrevious(_) {
                    let O = this.childrenArray(_);
                    return O.length > 0 ? this.traverseSortPrevious(O[O.length - 1].id) : _
                }
                sortPrevious(_) {
                    let O = this.parent(_);
                    if (void 0 !== O) {
                        let B = this.childrenArray(O),
                            N = B.findIndex(O => O.id === _) - 1;
                        return N >= 0 ? this.traverseSortPrevious(B[N].id) : O
                    }
                }
                getAllSorted(_) {
                    let O = [];
                    for (let B of _) {
                        let _ = this.getWithSortKey(B.id);
                        void 0 !== _ && O.push({ ...B,
                            ..._
                        })
                    }
                    for (let _ of (O.sort((_, O) => (function(_, O) {
                            let B = 0;
                            for (; B < _.length && B < O.length;) {
                                if (_[B] < O[B]) return -1;
                                if (_[B] > O[B]) return 1;
                                B += 1
                            }
                            return B !== O.length ? -1 : B !== _.length ? 1 : 0
                        })(_.sortKey, O.sortKey)), O)) delete _.sortKey;
                    return O
                }
                getWithSortKey(_) {
                    var O = _;
                    let B = [],
                        N = this.get(O),
                        k = N;
                    if (void 0 !== N) {
                        for (; O;) B.splice(0, 0, N.fi), null !== (O = this.parent(O)) && (N = this.get(O));
                        return { ...k,
                            sortKey: B
                        }
                    }
                }
                insertBeforeHelper(_, O, B) {
                    return this.insertAfterHelper(_, this.previous(_, O), B)
                }
                insertAfterHelper(_, O, B) {
                    let N = this.childrenArray(_);
                    if (null === O) {
                        if (0 === N.length) return Ys(0, B, B); {
                            let _ = N[0].fi;
                            return Ys(_ - B, _, B)
                        }
                    } {
                        let k = this.get(O);
                        if (void 0 === k || this.parent(O) !== _) throw Error("illegal args");
                        let F = N.find(_ => _.fi > k.fi);
                        if (void 0 !== F) return Ys(k.fi, F.fi, B); {
                            let _ = N[N.length - 1].fi;
                            return Ys(_, _ + B, B)
                        }
                    }
                }
            };
            (ua || (ua = {})).runOp = function(_, O) {
                if (0 !== O.type) return null;
                if (Array.isArray(_)) {
                    let B = O.props,
                        N = {},
                        k = [..._],
                        F = !1;
                    if (B)
                        for (let _ of Object.keys(B)) {
                            let O = parseInt(_);
                            if (isNaN(O)) throw Error("wrong index");
                            N[_] = k[O], k[O] = B[_], F = !0
                        }
                    return F ? {
                        data: k,
                        actual: O,
                        reverse: {
                            type: 0,
                            props: N
                        }
                    } : null
                } {
                    let B = O.props,
                        N = {},
                        k = { ..._
                        },
                        F = !1;
                    if (B)
                        for (let _ of Object.keys(B)) {
                            N[_] = k[_];
                            let O = B[_];
                            void 0 === O ? delete k[_] : k[_] = O, F = !0
                        }
                    return F ? {
                        data: k,
                        actual: O,
                        reverse: {
                            type: 0,
                            props: N
                        }
                    } : null
                }
            };
            var ur = class extends Array {
                constructor(..._) {
                    super(..._), Object.setPrototypeOf(this, ur.prototype)
                }
                deepFreeze() {
                    let _ = 0;
                    for (; _ < this.length;) op(this[_]), _++
                }
                fillCaches0(_) {
                    this.objCaches.set(_.id, _)
                }
                fillCaches() {
                    if (void 0 === this.objCaches)
                        for (let _ of (this.objCaches = new Map, Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = !1, this)) this.fillCaches0(_)
                }
                randomId() {
                    this.fillCaches();
                    let _ = Array.from(this.objCaches.keys());
                    if (0 !== _.length) return _[Math.max(0, Math.floor(Math.random() * _.length) - 1)]
                }
                data(_) {
                    return this.get(_) ? .data
                }
                get(_) {
                    return this.fillCaches(), this.objCaches.get(_)
                }
                modifyById(_, O) {
                    if (void 0 === this.get(_)) throw Error("not expected"); {
                        let B = this,
                            N = B.findIndex(O => O.id === _);
                        if (N < 0) throw Error("not expected");
                        let k = B[N];
                        return (B = [...B])[N] = { ...k,
                            data: O
                        }, this.modifyArrayBy(B)
                    }
                }
                modifyArrayBy(_) {
                    return Object.setPrototypeOf(_, ur.prototype), "u" > typeof io || _.fillCaches(), _
                }
                runOp(_) {
                    switch (_.type) {
                        case 4:
                            return this.addOp(_);
                        case 5:
                            return this.deleteOp(_);
                        case 6:
                            return this.moveOp(_)
                    }
                    return null
                }
                addOp(_) {
                    let {
                        fi: O,
                        id: B,
                        data: N
                    } = _, k = this, F = {
                        fi: O,
                        id: B,
                        data: N
                    };
                    return (k = [...k, F]).sort((_, O) => _.fi - O.fi), _.localIndex = k.indexOf(F), {
                        data: this.modifyArrayBy(k),
                        actual: _,
                        reverse: {
                            type: 5,
                            id: B
                        }
                    }
                }
                deleteOp(_) {
                    let {
                        id: O
                    } = _, B = this, N = B.findIndex(_ => _.id === O);
                    if (-1 === N) return null;
                    _.localIndex = N;
                    let k = (B = [...B]).splice(N, 1)[0];
                    return {
                        data: this.modifyArrayBy(B),
                        actual: _,
                        reverse: {
                            type: 4,
                            ...k
                        }
                    }
                }
                moveOp(_) {
                    let {
                        fi: O,
                        id: B
                    } = _, N = this, k = (N = [...N]).findIndex(_ => _.id === B);
                    if (-1 === k) return null;
                    let F = N[k].fi,
                        U = { ...N[k],
                            fi: O
                        };
                    return N[k] = U, N.sort((_, O) => _.fi - O.fi), _.localIndex = N.indexOf(U), {
                        data: this.modifyArrayBy(N),
                        actual: _,
                        reverse: {
                            type: 6,
                            fi: F,
                            id: B
                        }
                    }
                }
                previous(_) {
                    if (null === _) return 0 === this.length ? null : this[this.length - 1].id;
                    let O = null;
                    for (let B of this) {
                        if (B.id === _) return O;
                        O = B.id
                    }
                    return null
                }
                insertBeforeHelper(_, O) {
                    return this.insertAfterHelper(this.previous(_), O)
                }
                insertAfterHelper(_, O) {
                    if (null === _) {
                        if (0 === this.length) return Ys(0, O, O); {
                            let _ = this[0].fi;
                            return Ys(_ - O, _, O)
                        }
                    } {
                        let B = this.get(_);
                        if (void 0 === B) throw Error("illegal args");
                        let N = this.find(_ => _.fi > B.fi);
                        if (void 0 !== N) return Ys(B.fi, N.fi, O); {
                            let _ = this[this.length - 1].fi;
                            return Ys(_, _ + O, O)
                        }
                    }
                }
            };

            function uh(_) {
                return _ && "object" == typeof _ && _ instanceof ul
            }
            var us, ua, uo, ul = class {
                unusedFunOverridesTable(_) {}
                runOp(_) {
                    let O = [],
                        B = this,
                        N = 0,
                        k = {};
                    for (; N < _.path.length;) {
                        if (O.push(B), void 0 !== (B = void 0 === B ? void 0 : B[_.path[N]]) && !uh(B)) return null;
                        N += 1
                    }
                    for (let [O, N] of (B = B ? vy(B) : new ul, Object.entries(_.props))) {
                        let _ = B[O];
                        k[O] = _, void 0 === N ? delete B[O] : B[O] = N
                    }
                    for (; N > 0;) {
                        if (0 === Object.keys(B).length) {
                            let k = O[N - 1];
                            k && (B = vy(k), delete B[_.path[N - 1]])
                        } else {
                            let k = O[N - 1];
                            if (k) {
                                let O = vy(k);
                                O[_.path[N - 1]] = B, B = O
                            } else {
                                let O = new ul;
                                O[_.path[N - 1]] = B, B = O
                            }
                        }
                        N -= 1
                    }
                    let F = Object.setPrototypeOf(B, ul.prototype),
                        U = { ..._,
                            props: k
                        };
                    return {
                        data: F,
                        actual: _,
                        reverse: U
                    }
                }
            };

            function _w(_, O) {
                if (void 0 === O) return;
                let B = !1,
                    N = _.map(_ => {
                        let N = _.id,
                            k = ap(_.data, O[N]);
                        if (B = B || void 0 !== k, void 0 === k && (k = _.data), !_.children) return { ..._,
                            id: N,
                            data: k
                        }; {
                            let F = _w(_.children, O);
                            return void 0 !== F ? B = !0 : F = _.children, { ..._,
                                id: N,
                                data: k,
                                children: F
                            }
                        }
                    });
                if (B) return N
            }

            function ap(_, O) {
                if (!uh(O)) return O;
                if (_ instanceof ut) {
                    let B = _w(_, O);
                    return void 0 !== B && Object.setPrototypeOf(B, Object.getPrototypeOf(_)), B
                }
                if (_ instanceof ur) return function(_, O) {
                    if (void 0 === O) return;
                    let B = !1,
                        N = _.map(_ => {
                            let N = _.id,
                                k = ap(_.data, O[N]);
                            return B = B || void 0 !== k, void 0 === k && (k = _.data), { ..._,
                                id: N,
                                data: k
                            }
                        });
                    if (B) return Object.setPrototypeOf(N, Object.getPrototypeOf(_)), N
                }(_, O);
                if (Array.isArray(_)) {
                    let B = !1,
                        N = _.map((_, N) => {
                            let k = ap(_, O[N]);
                            return B = B || void 0 !== k, void 0 === k && (k = _), k
                        });
                    return B ? (Object.setPrototypeOf(N, Object.getPrototypeOf(_)), N) : void 0
                }
                if (_ instanceof ul) return Ew(_, O);
                if (_ && "object" == typeof _) {
                    let B = {},
                        N = !1;
                    for (let [k, F] of Object.entries(_)) {
                        let _ = ap(F, O[k]);
                        N = N || void 0 !== _, void 0 === _ && (_ = F), B[k] = _
                    }
                    return N ? (Object.setPrototypeOf(B, Object.getPrototypeOf(_)), B) : void 0
                }
            }

            function Ew(_, O) {
                if (void 0 === _) return O;
                if (void 0 === O) return _;
                if (!uh(O)) return O;
                if (!uh(_)) return uo.apply(_, O);
                let B = new Set;
                for (let O of Object.keys(_)) B.add(O);
                for (let _ of Object.keys(O)) B.add(_);
                let N = new ul;
                for (let k of B) {
                    let B = Ew(void 0 === _ ? void 0 : _[k], void 0 === O ? void 0 : O[k]);
                    N[k] = B
                }
                return N
            }

            function xy(_, O) {
                return null === _ ? null : (_.cur[_.len] = O, _.len += 1, _)
            }

            function by(_) {
                _ && (_.len -= 1)
            }(uO = uo || (uo = {})).apply = function(_, O) {
                return ap(_, O) ? ? _
            }, uO.merge = function(_, O) {
                return Ew(_, O)
            }, uO.filterOp = function(_, O) {
                let B = 0,
                    N = O.path,
                    k = _;
                for (; B < N.length && void 0 !== k;) {
                    if (void 0 === (k = uz.zoomOnce(k, N[B]))) return O;
                    if (!uh(k)) return;
                    B += 1
                }
                if (void 0 === k) return O;
                if (uh(k)) {
                    if (0 === O.type) {
                        let _ = { ...O.props
                        };
                        for (let O of Object.keys(k)) delete _[O];
                        return { ...O,
                            props: _
                        }
                    } {
                        if (1 !== O.type && 4 !== O.type && 7 !== O.type) return O;
                        let _ = _w([O], k);
                        return _ ? (console.log(_), _) : O
                    }
                }
            }, (uL || (uL = {})).replaceProps = function(_, O) {
                let B = uz.zoom(O, _.path);
                if ("object" != typeof B) return { ..._,
                    props: {}
                }; {
                    let O = {};
                    for (let N of Object.keys(_.props)) O[N] = B[N];
                    return { ..._,
                        props: O
                    }
                }
            }, (_ => {
                function e(_, O) {
                    let B = O.path;
                    for (var N = [];;) {
                        let k;
                        if (_ instanceof ul && 0 === O.type && null === (k = _.runOp({ ...O,
                                path: B.slice(N.length)
                            })) && (k = void 0), void 0 === k && N.length === B.length && (k = _ instanceof ut || _ instanceof ur || _ instanceof d7 ? _.runOp(O) : ua.runOp(_, O)), void 0 !== k) {
                            if (null === k) return null; {
                                let _ = k.data;
                                for (let O = N.length - 1; O >= 0; O--) {
                                    let k = B[O],
                                        F = N[O];
                                    if (F instanceof ut) {
                                        if ("number" == typeof k) throw Error("illegal arg");
                                        _ = F.modifyById(k, _)
                                    } else if (F instanceof ur) {
                                        if ("number" == typeof k) throw Error("illegal arg");
                                        _ = F.modifyById(k, _)
                                    } else if (F instanceof d7) {
                                        if ("number" == typeof k) throw Error("illegal arg");
                                        _ = F.modifyById(k, _)
                                    } else if (F instanceof ul) _ = Object.setPrototypeOf({ ...F,
                                        [k]: _
                                    }, ul.prototype);
                                    else if ("object" != typeof F) return null;
                                    else if (Array.isArray(F)) {
                                        if ("string" == typeof k && isNaN(k = parseInt(k))) throw Error("Invalid path");
                                        let O = _;
                                        (_ = [...F])[k] = O
                                    } else _ = { ...F,
                                        [k]: _
                                    }
                                }
                                return {
                                    data: _,
                                    actual: { ...k.actual,
                                        path: B
                                    },
                                    reverse: { ...k.reverse,
                                        path: B
                                    }
                                }
                            }
                        }
                        let F = B[N.length],
                            U;
                        if (_ instanceof ut) {
                            if ("number" == typeof F) throw Error("");
                            U = _.get(F) ? .data
                        } else if (_ instanceof ur) {
                            if ("number" == typeof F) throw Error("");
                            U = _.get(F) ? .data
                        } else null !== _ && (U = _[F]);
                        if (void 0 === U) return null;
                        N.push(_), _ = U
                    }
                }

                function r(_, O) {
                    for (let B = 0; B < _.length && B < O.length; B++)
                        if (_[B] !== O[B]) return !0;
                    return !1
                }

                function n(_, O) {
                    if (_.length !== O.length) return !1;
                    for (let B = 0; B < _.length; B++)
                        if (_[B] !== O[B]) return !1;
                    return !0
                }
                _.drop = function(_, O) {
                    return { ..._,
                        path: _.path.slice(O)
                    }
                }, _.applySimple = function(_, O) {
                    return e(_, O) ? .data ? ? _
                }, _.apply = e, _.pathDisjoint = r, _.pathEq = n, _.commutative = function(_, O) {
                    return r(_.path, O.path)
                }, _.subsumed = function(_, O) {
                    return !!(0 === _.type && 0 === O.type && n(_.path, O.path)) && Object.keys(_.props).every(_ => void 0 !== O.props[_])
                }
            })(uR || (uR = {})), (_ => {
                function a(_, O) {
                    var B = _;
                    let N = [],
                        k = [];
                    for (let _ of O) try {
                        if (3 === _.type || 5 === _.type && "variables" === _.path[_.path.length - 1]) {
                            let O, F, U;
                            if (3 === _.type ? (O = uz.zoom(B, [..._.path, _.id]), U = uR.apply(B, { ..._,
                                    type: 2
                                })) : (O = uz.zoom(B, [..._.path, _.id, "value"]), U = uR.apply(B, _)), null !== U) {
                                B = U.data;
                                let [j, G] = function(_, O) {
                                    let B = {
                                        cur: [],
                                        result: [],
                                        len: 0
                                    };
                                    return [_ = function lp(_, O, B) {
                                        if (_ instanceof ut) {
                                            let N = function fP(_, O, B) {
                                                let N = !1,
                                                    k = _.map(_ => {
                                                        let k = _.id,
                                                            F = O[k];
                                                        if (void 0 !== F && "string" == typeof F && (N = !0, k = F, null !== B)) throw Error("not supported");
                                                        let U = lp(_.data, O, xy(B, k));
                                                        by(B), N = N || void 0 !== U, void 0 === U && (U = _.data);
                                                        let j = fP(_.children, O, B);
                                                        return void 0 !== j ? N = !0 : j = _.children, { ..._,
                                                            id: k,
                                                            data: U,
                                                            children: j
                                                        }
                                                    });
                                                if (N) return k
                                            }(_, O, B);
                                            return void 0 !== N && Object.setPrototypeOf(N, Object.getPrototypeOf(_)), N
                                        }
                                        if (_ instanceof ur) return function(_, O, B) {
                                            let N = !1,
                                                k = _.map(_ => {
                                                    let k = _.id,
                                                        F = O[k];
                                                    if (void 0 !== F && "string" == typeof F && (N = !0, k = F, null !== B)) throw Error("not supported");
                                                    let U = lp(_.data, O, xy(B, k));
                                                    return by(B), N = N || void 0 !== U, void 0 === U && (U = _.data), { ..._,
                                                        id: k,
                                                        data: U
                                                    }
                                                });
                                            if (N) return Object.setPrototypeOf(k, Object.getPrototypeOf(_)), k
                                        }(_, O, B);
                                        if (Array.isArray(_)) {
                                            let N = !1,
                                                k = _.map((_, k) => {
                                                    let F = lp(_, O, xy(B, k));
                                                    return by(B), N = N || void 0 !== F, void 0 === F && (F = _), F
                                                });
                                            return N ? (Object.setPrototypeOf(k, Object.getPrototypeOf(_)), k) : void 0
                                        }
                                        if (_ && "object" == typeof _ && !lh(_)) {
                                            let N = {},
                                                k = !1;
                                            for (let [F, U] of Object.entries(_))
                                                if ("name" !== F) {
                                                    let _ = O[F];
                                                    if ("string" == typeof _) {
                                                        if (null !== B) throw Error("not supported");
                                                        k = !0, F = _
                                                    }
                                                    let j = lp(U, O, xy(B, F));
                                                    by(B), k = k || void 0 !== j, void 0 === j && (j = U), N[F] = j
                                                } else N[F] = U;
                                            return k ? (Object.setPrototypeOf(N, Object.getPrototypeOf(_)), N) : void 0
                                        } {
                                            var N;
                                            if ("string" != typeof _) return;
                                            let k = O[_];
                                            return void 0 !== k && (N = B, null !== N && N.result.push(N.cur.slice(0, N.len))), k
                                        }
                                    }(_, O, B) ? ? _, B.result]
                                }(B, {
                                    [_.id]: O
                                });
                                B = j;
                                for (let U = 0; U < G.length; U++) {
                                    let j = G[U],
                                        Y = j.pop();
                                    if ("number" == typeof Y) {
                                        let N = [Y];
                                        for (let _ = U + 1; _ < G.length; _++) {
                                            let O = G[_],
                                                B = O[O.length - 1];
                                            if ("number" == typeof B && uz.equal(j, O.slice(0, O.length - 1))) N.push(B), G.splice(_, 1);
                                            else break
                                        }
                                        let k = uz.zoom(B, j);
                                        F = k.map((O, B) => N.includes(B) ? _.id : O), O = k, Y = j.pop()
                                    } else {
                                        if ("alphaOverride" === Y || "alpha" === Y) {
                                            let _ = O /= 100,
                                                N = uz.zoom(B, j.slice(0, j.length - 2)),
                                                k = N.layers.map(O => O.id === j[j.length - 1] ? { ...O,
                                                    data: { ...O.data,
                                                        [Y]: _
                                                    }
                                                } : O);
                                            Object.setPrototypeOf(k, Object.getPrototypeOf(N.layers)), N.layers = k
                                        }
                                        F = _.id
                                    }
                                    N.push({
                                        type: 0,
                                        path: j,
                                        props: {
                                            [Y]: O
                                        }
                                    }), k.push({
                                        type: 0,
                                        path: j,
                                        props: {
                                            [Y]: F
                                        }
                                    })
                                }
                                k.push(U.reverse), N.push(U.actual)
                            }
                        } else {
                            let O = uR.apply(B, _);
                            null !== O && (N.push(O.actual), B = O.data, k.push(O.reverse))
                        }
                    } catch (_) {
                        if (_ instanceof ue) return null;
                        throw _
                    }
                    return {
                        data: B,
                        actual: N,
                        reverse: k.reverse()
                    }
                }
                _.empty = function() {
                    return []
                }, _.removePrefix = function(_, O) {
                    let B = [];
                    for (let N of _) {
                        let [_, ...k] = N.path;
                        _ === O && B.push({ ...N,
                            path: k
                        })
                    }
                    return B
                }, _.addPrefix = function(_, O) {
                    return _.map(_ => ({ ..._,
                        path: [O, ..._.path]
                    }))
                }, _.concat = function(_, O) {
                    return [..._, ...O]
                }, _.compress = function(_, O) {
                    return [..._.filter(_ => !O.some(O => uR.subsumed(_, O))), ...O]
                }, _.commutative = function(_, O) {
                    return _.every(_ => O.every(O => uR.commutative(_, O)))
                }, _.applyAll = function(_, O) {
                    for (let B of O) {
                        let O = a(_, B);
                        null !== O && (_ = O.data)
                    }
                    return _
                }, _.apply = a
            })(uB || (uB = {}));
            var uc = Symbol(),
                ud = Symbol(),
                uu = Symbol(),
                up = class {
                    reportOp(_, O, B = []) {
                        let N = this;
                        if (null !== O) {
                            for (N._current = O.data; !(N instanceof uA);) {
                                let _ = N._path,
                                    O = N._current;
                                if ("" !== _ && B.splice(0, 0, _), null === (N = N._parent)) return;
                                N.update(_, O)
                            }
                            N.push(B, _, O.actual, O.reverse)
                        }
                    }
                    deleteChildren(_) {
                        if (this._children) {
                            let O = this._children[_];
                            if (O) {
                                let B = O[uu];
                                B && B(), delete this._children[_]
                            }
                        }
                    }
                },
                uf = class extends up {
                    constructor(_, O, B) {
                        super(), this._parent = _, this._path = O, this._current = B
                    }
                    update(_, O) {
                        if (Array.isArray(this._current)) {
                            if ("string" == typeof _ && isNaN(_ = parseInt(_))) throw Error("Invalid path");
                            this._current = [...this._current], this._current[_] = O
                        } else this._current = { ...this._current,
                            [_]: O
                        }
                    }
                    runOp(_) {
                        this.reportOp(_, ua.runOp(this._current, _), _.path)
                    }
                },
                um = class extends up {
                    constructor(_, O, B) {
                        super(), this._parent = _, this._path = O, this._current = B
                    }
                    update(_, O) {
                        this._current = { ...this._current,
                            [_]: O
                        }, Object.setPrototypeOf(this._current, d7.prototype)
                    }
                    runOp(_) {
                        this.reportOp(_, this._current.runOp(_))
                    }
                },
                ug = {
                    get(_, O) {
                        if (O === uu) return () => {
                            _._parent = null
                        };
                        if (O === uc) return _._current;
                        if (O === ud) return _;
                        let {
                            _current: B,
                            _children: N
                        } = _;
                        if ("push" === O && Array.isArray(B)) throw Error("not supported to expand array");
                        let k = void 0 === N ? void 0 : N[O];
                        if (void 0 !== k) return k;
                        let F = B[O],
                            U = _y(_, O, F);
                        return U !== F ? (void 0 === N && (N = {}, _._children = N), N[O] = U, U) : F
                    },
                    has: (_, O) => O in _._current,
                    ownKeys: _ => Reflect.ownKeys(_._current),
                    defineProperty() {
                        throw Error("not supported")
                    },
                    getPrototypeOf: _ => Object.getPrototypeOf(_._current),
                    setPrototypeOf() {
                        throw Error("not supported")
                    },
                    getOwnPropertyDescriptor(_, O) {
                        let B = _._current,
                            N = Reflect.getOwnPropertyDescriptor(B, O);
                        return N && {
                            writable: !0,
                            configurable: !0,
                            enumerable: N.enumerable,
                            value: B[O]
                        }
                    }
                },
                ux = { ...ug,
                    set(_, O, B) {
                        let N = {
                            type: 0,
                            props: {
                                [O]: xr(B) ? ? B
                            }
                        };
                        return _.deleteChildren(O), _.runOp(N), !0
                    },
                    deleteProperty: (_, O) => (_.deleteChildren(O), _.runOp({
                        type: 0,
                        props: {
                            [O]: void 0
                        }
                    }), !0)
                },
                ub = { ...ug,
                    set(_, O, B) {
                        return void 0 === B ? this.deleteProperty(_, O) : (_.deleteChildren(O), _.runOp({
                            type: 1,
                            id: O,
                            data: B
                        })), !0
                    },
                    deleteProperty: (_, O) => (_.runOp({
                        type: 2,
                        id: O
                    }), !0)
                },
                uw = class extends up {
                    constructor(_, O, B) {
                        super(), this._children = {}, this._parent = _, this._path = O, this._current = B, this[uu] = () => {
                            this._parent = null
                        }
                    }
                    unproxy() {
                        return this._current
                    }
                    update(_, O) {
                        this._current = this._current.modifyById(_, O)
                    }
                    runOp(_) {
                        this.reportOp(_, this._current.runOp(_))
                    }
                    randomId() {
                        return this._current.randomId()
                    }
                    isDescendantOf(_, O) {
                        return this._current.isDescendantOf(_, O)
                    }
                    childrenOf(_) {
                        return this._current.childrenOf(_)
                    }
                    traverse(_) {
                        return this._current.traverse(_)
                    }
                    get(_) {
                        return this._current.get(_)
                    }
                    parent(_) {
                        return this._current.parent(_)
                    }
                    traverse(_) {
                        this._current.traverse((O, B) => {
                            _(O, this.data(O))
                        })
                    }
                    data(_) {
                        let {
                            _current: O,
                            _children: B
                        } = this, N = void 0 === B ? void 0 : B[_];
                        if (void 0 !== N) return N;
                        let k = O.get(_) ? .data,
                            F = _y(this, _, k);
                        return F !== k ? (void 0 === B && (B = {}, this._children = B), B[_] = F, F) : k
                    }
                    add(_, O, B, N, k) {
                        this.runOp({
                            type: 7,
                            parent: _,
                            fi: O,
                            id: B,
                            data: N,
                            children: k
                        })
                    }
                    move(_, O, B) {
                        this.runOp({
                            type: 9,
                            parent: _,
                            fi: O,
                            id: B
                        })
                    }
                    insertAfter(_, O, B) {
                        let N = this._current.insertAfterHelper(_, O, B.length);
                        for (let O = 0; O < B.length; O++) {
                            let k = B[O];
                            this.add(_, N[O], k.id, k.data, k.children)
                        }
                    }
                    insertBefore(_, O, B) {
                        let N = this._current.insertBeforeHelper(_, O, B.length);
                        for (let O = 0; O < B.length; O++) {
                            let k = B[O];
                            this.add(_, N[O], k.id, k.data, k.children)
                        }
                    }
                    moveAfter(_, O, B) {
                        let N = this._current.insertAfterHelper(_, O, B.length);
                        for (let O = 0; O < B.length; O++) {
                            let k = B[O];
                            this.move(_, N[O], k)
                        }
                    }
                    moveBefore(_, O, B) {
                        let N = this._current.insertBeforeHelper(_, O, B.length);
                        for (let O = 0; O < B.length; O++) {
                            let k = B[O];
                            this.move(_, N[O], k)
                        }
                    }
                    delete(_) {
                        this.deleteChildren(_), this.runOp({
                            type: 8,
                            id: _
                        })
                    }
                    sortNext(_) {
                        return this._current.sortNext(_)
                    }
                    sortPrevious(_) {
                        return this._current.sortPrevious(_)
                    }
                    getAllSorted(_) {
                        return this._current.getAllSorted(_)
                    }
                },
                u_ = class extends up {
                    constructor(_, O, B) {
                        super(), this._children = {}, this._parent = _, this._path = O, this._current = B, this[uu] = () => {
                            this._parent = null
                        }
                    }
                    unproxy() {
                        return this._current
                    }
                    get length() {
                        return this._current.length
                    }
                    forEach(_) {
                        let O = this.length;
                        for (let B = 0; B < O; B++) {
                            let O = this._current[B].id,
                                N = this._current[B].fi;
                            _(this.data(this._current[B].id), O, N)
                        }
                    }
                    find(_) {
                        let O = this.length;
                        for (let B = 0; B < O; B++) {
                            let O = this._current[B].id;
                            if (_(this.data(O), O)) return this.get(O)
                        }
                    }
                    update(_, O) {
                        this._current = this._current.modifyById(_, O)
                    }
                    randomId() {
                        return this._current.randomId()
                    }
                    get(_) {
                        return { ...this._current.get(_),
                            data: this.data(_)
                        }
                    }
                    data(_) {
                        let {
                            _current: O,
                            _children: B
                        } = this, N = void 0 === B ? void 0 : B[_];
                        if (void 0 !== N) return N;
                        let k = O.get(_) ? .data,
                            F = _y(this, _, k);
                        return F !== k ? (void 0 === B && (B = {}, this._children = B), B[_] = F, F) : k
                    }
                    runOp(_) {
                        this.reportOp(_, this._current.runOp(_))
                    }
                    add(_, O, B) {
                        this.runOp({
                            type: 4,
                            fi: _,
                            id: O,
                            data: B
                        })
                    }
                    move(_, O) {
                        this.runOp({
                            type: 6,
                            fi: _,
                            id: O
                        })
                    }
                    insertAfter(_, O) {
                        let B = this._current.insertAfterHelper(_, O.length);
                        for (let _ = 0; _ < O.length; _++) {
                            let N = O[_];
                            this.add(B[_], N.id, N.data)
                        }
                    }
                    insertBefore(_, O) {
                        let B = this._current.insertBeforeHelper(_, O.length);
                        for (let _ = 0; _ < O.length; _++) {
                            let N = O[_];
                            this.add(B[_], N.id, N.data)
                        }
                    }
                    moveAfter(_, O) {
                        let B = this._current.insertAfterHelper(_, O.length);
                        for (let _ = 0; _ < O.length; _++) {
                            let N = O[_];
                            this.move(B[_], N)
                        }
                    }
                    moveBefore(_, O) {
                        let B = this._current.insertBeforeHelper(_, O.length);
                        for (let _ = 0; _ < O.length; _++) {
                            let N = O[_];
                            this.move(B[_], N)
                        }
                    }
                    delete(_) {
                        this.deleteChildren(_), this.runOp({
                            type: 5,
                            id: _
                        })
                    }
                };

            function Mw(_, O, B) {
                if (_.length > 0) {
                    let N = _[_.length - 1];
                    if (0 === N.type && 0 === O.type && uz.equal(N.path, B)) {
                        Object.assign(N.props, O.props);
                        return
                    }
                }
                _.push({ ...O,
                    path: B
                })
            }
            var uA = class extends up {
                constructor(_) {
                    super(), this.ts = [], this.actual = [], this.reverse = [], this._current = _
                }
                update(_, O) {
                    if ("" !== _) throw Error("");
                    this._current = O
                }
                push(_, O, B, N) {
                    Mw(this.ts, O, _), Mw(this.actual, B, _), Mw(this.reverse, N, _)
                }
                result() {
                    return {
                        data: this._current,
                        ts: this.ts,
                        actual: this.actual,
                        reverse: this.reverse.reverse()
                    }
                }
            };

            function _y(_, O, B) {
                return B instanceof ut ? new uw(_, O, B) : B instanceof ur ? new u_(_, O, B) : B instanceof d7 ? new Proxy(new um(_, O, B), ub) : null !== B && "object" == typeof B ? lh(B) ? B : new Proxy(new uf(_, O, B), ux) : B
            }

            function Pw(_) {
                let O = new uA(_);
                return [_y(O, "", _), O]
            }

            function Ha(_, O) {
                let [B, N] = Pw(_);
                return O(B), N.result()
            }

            function xr(_) {
                return _ instanceof uw || _ instanceof u_ ? _._current : null !== _ && "object" == typeof _ ? _[uc] : _
            }

            function qn(_, O) {
                let B = [];
                if (!(O.length <= _.length)) return null;
                for (var N = 0; N < O.length;) {
                    if ("*" === O[N]) B.push(_[N]);
                    else if (_[N] !== O[N]) return null;
                    N += 1
                }
                return B
            }(_ => {
                function e(_, O) {
                    return (_ instanceof ut || _ instanceof uw) && "string" == typeof O || (_ instanceof ur || _ instanceof u_) && "string" == typeof O ? _.data(O) : "number" == typeof O && Array.isArray(_) || "string" == typeof O && "object" == typeof _ && null !== _ ? _[O] : void 0
                }

                function r(_, O, B = 0) {
                    for (; B < O.length && void 0 !== _;) _ = e(_, O[B]), B += 1;
                    return _
                }
                _.equal = function(_, O) {
                    if (O.length !== _.length) return !1;
                    for (var B = 0; B < _.length;) {
                        if (_[B] !== O[B]) return !1;
                        B += 1
                    }
                    return !0
                }, _.removeOverridden = function(_, O, B) {
                    let N = r(B, _);
                    if (void 0 === N || "object" != typeof N || null === N) return O; {
                        let _ = { ...O
                        };
                        return Object.keys(N).forEach(O => {
                            delete _[O]
                        }), _
                    }
                }, _.zoomOnce = e, _.zoom = r
            })(uz || (uz = {}));
            var uM = class {},
                uT = class extends uM {
                    constructor(_) {
                        super(), this.id = _
                    }
                },
                uI = class extends uM {
                    constructor(_) {
                        super(), this.data = _
                    }
                };
            try {
                uN = new TextDecoder
            } catch {}
            var uO, uL, uR, uB, uz, uN, uk, uF, uU, uj, uG, uH, uW, uq = 0,
                uY = [],
                uX = uY,
                uQ = 0,
                uZ = {},
                uK = 0,
                uJ = 0,
                u$ = [],
                u0 = {
                    useRecords: !1,
                    mapsAsObjects: !0
                },
                u3 = class {},
                u4 = new u3;
            u4.name = "MessagePack 0xC1";
            var u5 = !1,
                u6 = class {
                    constructor(_) {
                        _ && (!1 === _.useRecords && void 0 === _.mapsAsObjects && (_.mapsAsObjects = !0), _.structures ? _.structures.sharedLength = _.structures.length : _.getStructures && ((_.structures = []).uninitialized = !0, _.structures.sharedLength = 0)), Object.assign(this, _)
                    }
                    unpack(_, O) {
                        if (uk) return PP(() => (Ty(), this ? this.unpack(_, O) : u6.prototype.unpack.call(u0, _, O)));
                        uF = O > -1 ? O : _.length, uq = 0, uQ = 0, uJ = 0, uj = null, uX = uY, uG = null, uk = _;
                        try {
                            uW = _.dataView || (_.dataView = new DataView(_.buffer, _.byteOffset, _.byteLength))
                        } catch (O) {
                            throw uk = null, _ instanceof Uint8Array ? O : Error("Source must be a Uint8Array or Buffer but was a " + (_ && "object" == typeof _ ? _.constructor.name : typeof _))
                        }
                        if (this instanceof u6) {
                            if (uZ = this, this.structures) return uU = this.structures, My();
                            (!uU || uU.length > 0) && (uU = [])
                        } else uZ = u0, (!uU || uU.length > 0) && (uU = []);
                        return My()
                    }
                    unpackMultiple(_, O) {
                        let B, N = 0;
                        try {
                            u5 = !0;
                            let k = _.length,
                                F = this ? this.unpack(_, k) : pl.unpack(_, k);
                            if (O) {
                                for (O(F); uq < k;)
                                    if (N = uq, !1 === O(My())) return
                            } else {
                                for (B = [F]; uq < k;) N = uq, B.push(My());
                                return B
                            }
                        } catch (_) {
                            throw _.lastPosition = N, _.values = B, _
                        } finally {
                            u5 = !1, Ty()
                        }
                    }
                    _mergeStructures(_, O) {
                        _ = _ || [];
                        for (let O = 0, B = _.length; O < B; O++) {
                            let B = _[O];
                            B && (B.isShared = !0, O >= 32 && (B.highByte = O - 32 >> 5))
                        }
                        for (let B in _.sharedLength = _.length, O || [])
                            if (B >= 0) {
                                let N = _[B],
                                    k = O[B];
                                k && (N && ((_.restoreStructures || (_.restoreStructures = []))[B] = N), _[B] = k)
                            }
                        return this.structures = _
                    }
                    decode(_, O) {
                        return this.unpack(_, O)
                    }
                };

            function My() {
                try {
                    if (!uZ.trusted && !u5) {
                        let _ = uU.sharedLength || 0;
                        _ < uU.length && (uU.length = _)
                    }
                    let _ = Mr();
                    if (uq == uF) uU.restoreStructures && vP(), uU = null, uk = null, uH && (uH = null);
                    else if (uq > uF) {
                        let _ = Error("Unexpected end of MessagePack data");
                        throw _.incomplete = !0, _
                    } else if (!u5) throw Error("Data read, but end of buffer not reached");
                    return _
                } catch (_) {
                    throw uU.restoreStructures && vP(), Ty(), (_ instanceof RangeError || _.message.startsWith("Unexpected end of buffer")) && (_.incomplete = !0), _
                }
            }

            function vP() {
                for (let _ in uU.restoreStructures) uU[_] = uU.restoreStructures[_];
                uU.restoreStructures = null
            }

            function Mr() {
                let _ = uk[uq++];
                if (_ < 160) {
                    if (_ < 128) {
                        if (_ < 64) return _; {
                            let O = uU[63 & _] || uZ.getStructures && EP()[63 & _];
                            return O ? (O.read || (O.read = Bw(O, 63 & _)), O.read()) : _
                        }
                    }
                    if (_ < 144) {
                        if (_ -= 128, uZ.mapsAsObjects) {
                            let O = {};
                            for (let B = 0; B < _; B++) O[TP()] = Mr();
                            return O
                        } {
                            let O = new Map;
                            for (let B = 0; B < _; B++) O.set(Mr(), Mr());
                            return O
                        }
                    } {
                        let O = Array(_ -= 144);
                        for (let B = 0; B < _; B++) O[B] = Mr();
                        return O
                    }
                }
                if (_ < 192) {
                    let O = _ - 160;
                    if (uJ >= uq) return uj.slice(uq - uK, (uq += O) - uK);
                    if (0 == uJ && uF < 140) {
                        let _ = O < 16 ? Fw(O) : MP(O);
                        if (null != _) return _
                    }
                    return u9(O)
                } {
                    let O;
                    switch (_) {
                        case 192:
                            return null;
                        case 193:
                            return uG ? (O = Mr()) > 0 ? uG[1].slice(uG.position1, uG.position1 += O) : uG[0].slice(uG.position0, uG.position0 -= O) : u4;
                        case 194:
                            return !1;
                        case 195:
                            return !0;
                        case 196:
                            return Dw(uk[uq++]);
                        case 197:
                            return O = uW.getUint16(uq), uq += 2, Dw(O);
                        case 198:
                            return O = uW.getUint32(uq), uq += 4, Dw(O);
                        case 199:
                            return sc(uk[uq++]);
                        case 200:
                            return O = uW.getUint16(uq), uq += 2, sc(O);
                        case 201:
                            return O = uW.getUint32(uq), uq += 4, sc(O);
                        case 202:
                            if (O = uW.getFloat32(uq), uZ.useFloat32 > 2) {
                                let _ = po[(127 & uk[uq]) << 1 | uk[uq + 1] >> 7];
                                return uq += 4, (_ * O + (O > 0 ? .5 : -.5) >> 0) / _
                            }
                            return uq += 4, O;
                        case 203:
                            return O = uW.getFloat64(uq), uq += 8, O;
                        case 204:
                            return uk[uq++];
                        case 205:
                            return O = uW.getUint16(uq), uq += 2, O;
                        case 206:
                            return O = uW.getUint32(uq), uq += 4, O;
                        case 207:
                            return O = uZ.int64AsNumber ? 4294967296 * uW.getUint32(uq) + uW.getUint32(uq + 4) : uW.getBigUint64(uq), uq += 8, O;
                        case 208:
                            return uW.getInt8(uq++);
                        case 209:
                            return O = uW.getInt16(uq), uq += 2, O;
                        case 210:
                            return O = uW.getInt32(uq), uq += 4, O;
                        case 211:
                            return O = uZ.int64AsNumber ? 4294967296 * uW.getInt32(uq) + uW.getUint32(uq + 4) : uW.getBigInt64(uq), uq += 8, O;
                        case 212:
                            if (114 == (O = uk[uq++])) return AP(63 & uk[uq++]); {
                                let _ = u$[O];
                                if (_) return _.read ? (uq++, _.read(Mr())) : _.noBuffer ? (uq++, _()) : _(uk.subarray(uq, ++uq));
                                throw Error("Unknown extension " + O)
                            }
                        case 213:
                            return 114 == (O = uk[uq]) ? (uq++, AP(63 & uk[uq++], uk[uq++])) : sc(2);
                        case 214:
                            return sc(4);
                        case 215:
                            return sc(8);
                        case 216:
                            return sc(16);
                        case 217:
                            return O = uk[uq++], uJ >= uq ? uj.slice(uq - uK, (uq += O) - uK) : u7(O);
                        case 218:
                            return O = uW.getUint16(uq), uq += 2, uJ >= uq ? uj.slice(uq - uK, (uq += O) - uK) : pe(O);
                        case 219:
                            return O = uW.getUint32(uq), uq += 4, uJ >= uq ? uj.slice(uq - uK, (uq += O) - uK) : pt(O);
                        case 220:
                            return O = uW.getUint16(uq), uq += 2, bP(O);
                        case 221:
                            return O = uW.getUint32(uq), uq += 4, bP(O);
                        case 222:
                            return O = uW.getUint16(uq), uq += 2, wP(O);
                        case 223:
                            return O = uW.getUint32(uq), uq += 4, wP(O);
                        default:
                            if (_ >= 224) return _ - 256;
                            if (void 0 === _) {
                                let _ = Error("Unexpected end of MessagePack data");
                                throw _.incomplete = !0, _
                            }
                            throw Error("Unknown MessagePack token " + _)
                    }
                }
            }
            var u8 = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;

            function Bw(_, O) {
                function e() {
                    if (e.count++ > 2) {
                        let B = _.read = Function("r", "return function(){return {" + _.map(_ => u8.test(_) ? _ + ":r()" : "[" + JSON.stringify(_) + "]:r()").join(",") + "}}")(Mr);
                        return 0 === _.highByte && (_.read = xP(O, _.read)), B()
                    }
                    let B = {};
                    for (let O = 0, N = _.length; O < N; O++) B[_[O]] = Mr();
                    return B
                }
                return e.count = 0, 0 === _.highByte ? xP(O, e) : e
            }
            var xP = (_, O) => function() {
                let B = uk[uq++];
                if (0 === B) return O();
                let N = _ < 32 ? -(_ + (B << 5)) : _ + (B << 5),
                    k = uU[N] || EP()[N];
                if (!k) throw Error("Record id is not defined for " + N);
                return k.read || (k.read = Bw(k, _)), k.read()
            };

            function EP() {
                let _ = PP(() => (uk = null, uZ.getStructures()));
                return uU = uZ._mergeStructures(_, uU)
            }
            var u9 = Cy,
                u7 = Cy,
                pe = Cy,
                pt = Cy;

            function Cy(_) {
                let O;
                if (_ < 16 && (O = Fw(_))) return O;
                if (_ > 64 && uN) return uN.decode(uk.subarray(uq, uq += _));
                let B = uq + _,
                    N = [];
                for (O = ""; uq < B;) {
                    let _ = uk[uq++];
                    if ((128 & _) == 0) N.push(_);
                    else if ((224 & _) == 192) {
                        let O = 63 & uk[uq++];
                        N.push((31 & _) << 6 | O)
                    } else if ((240 & _) == 224) {
                        let O = 63 & uk[uq++],
                            B = 63 & uk[uq++];
                        N.push((31 & _) << 12 | O << 6 | B)
                    } else if ((248 & _) == 240) {
                        let O = (7 & _) << 18 | (63 & uk[uq++]) << 12 | (63 & uk[uq++]) << 6 | 63 & uk[uq++];
                        O > 65535 && (O -= 65536, N.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), N.push(O)
                    } else N.push(_);
                    N.length >= 4096 && (O += pi.apply(String, N), N.length = 0)
                }
                return N.length > 0 && (O += pi.apply(String, N)), O
            }

            function bP(_) {
                let O = Array(_);
                for (let B = 0; B < _; B++) O[B] = Mr();
                return O
            }

            function wP(_) {
                if (uZ.mapsAsObjects) {
                    let O = {};
                    for (let B = 0; B < _; B++) O[TP()] = Mr();
                    return O
                } {
                    let O = new Map;
                    for (let B = 0; B < _; B++) O.set(Mr(), Mr());
                    return O
                }
            }
            var pi = String.fromCharCode;

            function MP(_) {
                let O = uq,
                    B = Array(_);
                for (let N = 0; N < _; N++) {
                    let _ = uk[uq++];
                    if ((128 & _) > 0) {
                        uq = O;
                        return
                    }
                    B[N] = _
                }
                return pi.apply(String, B)
            }

            function Fw(_) {
                if (_ < 4) {
                    if (_ < 2) {
                        if (0 === _) return ""; {
                            let _ = uk[uq++];
                            if ((128 & _) > 1) {
                                uq -= 1;
                                return
                            }
                            return pi(_)
                        }
                    } {
                        let O = uk[uq++],
                            B = uk[uq++];
                        if ((128 & O) > 0 || (128 & B) > 0) {
                            uq -= 2;
                            return
                        }
                        if (_ < 3) return pi(O, B);
                        let N = uk[uq++];
                        if ((128 & N) > 0) {
                            uq -= 3;
                            return
                        }
                        return pi(O, B, N)
                    }
                } {
                    let O = uk[uq++],
                        B = uk[uq++],
                        N = uk[uq++],
                        k = uk[uq++];
                    if ((128 & O) > 0 || (128 & B) > 0 || (128 & N) > 0 || (128 & k) > 0) {
                        uq -= 4;
                        return
                    }
                    if (_ < 6) {
                        if (4 === _) return pi(O, B, N, k); {
                            let _ = uk[uq++];
                            if ((128 & _) > 0) {
                                uq -= 5;
                                return
                            }
                            return pi(O, B, N, k, _)
                        }
                    }
                    if (_ < 8) {
                        let F = uk[uq++],
                            U = uk[uq++];
                        if ((128 & F) > 0 || (128 & U) > 0) {
                            uq -= 6;
                            return
                        }
                        if (_ < 7) return pi(O, B, N, k, F, U);
                        let j = uk[uq++];
                        if ((128 & j) > 0) {
                            uq -= 7;
                            return
                        }
                        return pi(O, B, N, k, F, U, j)
                    } {
                        let F = uk[uq++],
                            U = uk[uq++],
                            j = uk[uq++],
                            G = uk[uq++];
                        if ((128 & F) > 0 || (128 & U) > 0 || (128 & j) > 0 || (128 & G) > 0) {
                            uq -= 8;
                            return
                        }
                        if (_ < 10) {
                            if (8 === _) return pi(O, B, N, k, F, U, j, G); {
                                let _ = uk[uq++];
                                if ((128 & _) > 0) {
                                    uq -= 9;
                                    return
                                }
                                return pi(O, B, N, k, F, U, j, G, _)
                            }
                        }
                        if (_ < 12) {
                            let Y = uk[uq++],
                                Q = uk[uq++];
                            if ((128 & Y) > 0 || (128 & Q) > 0) {
                                uq -= 10;
                                return
                            }
                            if (_ < 11) return pi(O, B, N, k, F, U, j, G, Y, Q);
                            let K = uk[uq++];
                            if ((128 & K) > 0) {
                                uq -= 11;
                                return
                            }
                            return pi(O, B, N, k, F, U, j, G, Y, Q, K)
                        } {
                            let Y = uk[uq++],
                                Q = uk[uq++],
                                K = uk[uq++],
                                $ = uk[uq++];
                            if ((128 & Y) > 0 || (128 & Q) > 0 || (128 & K) > 0 || (128 & $) > 0) {
                                uq -= 12;
                                return
                            }
                            if (_ < 14) {
                                if (12 === _) return pi(O, B, N, k, F, U, j, G, Y, Q, K, $); {
                                    let _ = uk[uq++];
                                    if ((128 & _) > 0) {
                                        uq -= 13;
                                        return
                                    }
                                    return pi(O, B, N, k, F, U, j, G, Y, Q, K, $, _)
                                }
                            } {
                                let ee = uk[uq++],
                                    et = uk[uq++];
                                if ((128 & ee) > 0 || (128 & et) > 0) {
                                    uq -= 14;
                                    return
                                }
                                if (_ < 15) return pi(O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et);
                                let ei = uk[uq++];
                                if ((128 & ei) > 0) {
                                    uq -= 15;
                                    return
                                }
                                return pi(O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei)
                            }
                        }
                    }
                }
            }

            function Dw(_) {
                return uZ.copyBuffers ? Uint8Array.prototype.slice.call(uk, uq, uq += _) : uk.subarray(uq, uq += _)
            }

            function sc(_) {
                let O = uk[uq++];
                if (u$[O]) return u$[O](uk.subarray(uq, uq += _));
                throw Error("Unknown extension type " + O)
            }
            var pr = Array(4096);

            function TP() {
                let _ = uk[uq++];
                if (!(_ >= 160) || !(_ < 192)) return uq--, Mr();
                if (_ -= 160, uJ >= uq) return uj.slice(uq - uK, (uq += _) - uK);
                if (!(0 == uJ && uF < 180)) return u9(_);
                let O = (_ << 5 ^ (_ > 1 ? uW.getUint16(uq) : _ > 0 ? uk[uq] : 0)) & 4095,
                    B = pr[O],
                    N = uq,
                    k = uq + _ - 3,
                    F, U = 0;
                if (B && B.bytes == _) {
                    for (; N < k;) {
                        if ((F = uW.getUint32(N)) != B[U++]) {
                            N = 1879048192;
                            break
                        }
                        N += 4
                    }
                    for (k += 3; N < k;)
                        if ((F = uk[N++]) != B[U++]) {
                            N = 1879048192;
                            break
                        }
                    if (N === k) return uq = N, B.string;
                    k -= 3, N = uq
                }
                for (B = [], pr[O] = B, B.bytes = _; N < k;) F = uW.getUint32(N), B.push(F), N += 4;
                for (k += 3; N < k;) F = uk[N++], B.push(F);
                let j = _ < 16 ? Fw(_) : MP(_);
                return null != j ? B.string = j : B.string = u9(_)
            }
            var AP = (_, O) => {
                    var B = Mr();
                    let N = _;
                    void 0 !== O && (_ = _ < 32 ? -((O << 5) + _) : (O << 5) + _, B.highByte = O);
                    let k = uU[_];
                    return k && k.isShared && ((uU.restoreStructures || (uU.restoreStructures = []))[_] = k), uU[_] = B, B.read = Bw(B, N), B.read()
                },
                ps = "object" == typeof self ? self : global;
            u$[0] = () => {}, u$[0].noBuffer = !0, u$[101] = () => {
                let _ = Mr();
                return (ps[_[0]] || Error)(_[1])
            }, u$[105] = _ => {
                let O = uW.getUint32(uq - 4);
                uH || (uH = new Map);
                let B = uk[uq],
                    N, k = {
                        target: N = B >= 144 && B < 160 || 220 == B || 221 == B ? [] : {}
                    };
                uH.set(O, k);
                let F = Mr();
                return k.used ? Object.assign(N, F) : (k.target = F, F)
            }, u$[112] = _ => {
                let O = uW.getUint32(uq - 4),
                    B = uH.get(O);
                return B.used = !0, B.target
            }, u$[115] = () => new Set(Mr());
            var pa = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map(_ => _ + "Array");

            function PP(_) {
                let O = uF,
                    B = uq,
                    N = uQ,
                    k = uK,
                    F = uJ,
                    U = uj,
                    j = uX,
                    G = uH,
                    Y = uG,
                    Q = new Uint8Array(uk.slice(0, uF)),
                    K = uU,
                    $ = uU.slice(0, uU.length),
                    ee = uZ,
                    et = u5,
                    ei = _();
                return uF = O, uq = B, uQ = N, uK = k, uJ = F, uj = U, uX = j, uH = G, uG = Y, uk = Q, u5 = et, (uU = K).splice(0, uU.length, ...$), uZ = ee, uW = new DataView(uk.buffer, uk.byteOffset, uk.byteLength), ei
            }

            function Ty() {
                uk = null, uH = null, uU = null
            }
            u$[116] = _ => {
                let O = _[0],
                    B = pa[O];
                if (!B) throw Error("Could not find typed array for code " + O);
                return new ps[B](Uint8Array.prototype.slice.call(_, 1).buffer)
            }, u$[120] = () => {
                let _ = Mr();
                return new RegExp(_[0], _[1])
            }, u$[98] = _ => {
                let O = (_[0] << 24) + (_[1] << 16) + (_[2] << 8) + _[3],
                    B = uq;
                uq += O - 4, (uG = [Mr(), Mr()]).position0 = 0, uG.position1 = 0;
                let N = uq;
                uq = B;
                try {
                    return Mr()
                } finally {
                    uq = N
                }
            }, u$[255] = _ => new Date(4 == _.length ? (16777216 * _[0] + (_[1] << 16) + (_[2] << 8) + _[3]) * 1e3 : 8 == _.length ? ((_[0] << 22) + (_[1] << 14) + (_[2] << 6) + (_[3] >> 2)) / 1e6 + ((3 & _[3]) * 4294967296 + 16777216 * _[4] + (_[5] << 16) + (_[6] << 8) + _[7]) * 1e3 : 12 == _.length ? ((_[0] << 24) + (_[1] << 16) + (_[2] << 8) + _[3]) / 1e6 + ((128 & _[4] ? -281474976710656 : 0) + 1099511627776 * _[6] + 4294967296 * _[7] + 16777216 * _[8] + (_[9] << 16) + (_[10] << 8) + _[11]) * 1e3 : "invalid");
            var po = Array(147);
            for (let _ = 0; _ < 256; _++) po[_] = +("1e" + Math.floor(45.15 - .30103 * _));
            var pl = new u6({
                    useRecords: !1
                }),
                ph = (pl.unpack, pl.unpackMultiple, pl.unpack, new Float32Array(1));
            new Uint8Array(ph.buffer, 0, 4);
            try {
                pc = new TextEncoder
            } catch {}
            var pc, pd, pu, pp, pf, pg, px = "u" > typeof il,
                pb = px ? il.allocUnsafeSlow : Uint8Array,
                pw = px ? il : Uint8Array,
                p_ = px ? 4294967296 : 2144337920,
                pA = 0,
                pE = null,
                pC = /[\u0080-\uFFFF]/,
                pT = Symbol("record-id"),
                pP = class extends u6 {
                    constructor(_) {
                        super(_), this.offset = 0;
                        let O, B, N, k, F, U = 0,
                            j = pw.prototype.utf8Write ? function(_, O, B) {
                                return pp.utf8Write(_, O, B)
                            } : !!pc && !!pc.encodeInto && function(_, O) {
                                return pc.encodeInto(_, pp.subarray(O)).written
                            },
                            G = this;
                        _ || (_ = {});
                        let Y = _ && _.sequential,
                            Q = _.structures || _.saveStructures,
                            K = _.maxSharedStructures;
                        if (null == K && (K = Q ? 32 : 0), K > 8160) throw Error("Maximum maxSharedStructure is 8160");
                        let $ = _.maxOwnStructures;
                        null == $ && ($ = Q ? 32 : 64), Y && !_.saveStructures && (this.structures = []);
                        let ee = K > 32 || $ + K > 64,
                            et = K + 64,
                            ei = K + $ + 64;
                        if (ei > 8256) throw Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
                        let er = [],
                            ea = 0,
                            en = 0;
                        this.pack = this.encode = function(_, j) {
                            if (pp || (pp = new pb(8192), pf = new DataView(pp.buffer, 0, 8192), pA = 0), (pg = pp.length - 10) - pA < 2048 ? (pp = new pb(pp.length), pf = new DataView(pp.buffer, 0, pp.length), pg = pp.length - 10, pA = 0) : pA = pA + 7 & 2147483640, O = pA, F = G.structuredClone ? new Map : null, G.bundleStrings ? (pE = ["", ""], pp[pA++] = 214, pp[pA++] = 98, pE.position = pA - O, pA += 4) : pE = null, B = G.structures) {
                                B.uninitialized && (B = G._mergeStructures(G.getStructures()));
                                let _ = B.sharedLength || 0;
                                if (_ > K) throw Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + B.sharedLength);
                                if (!B.transitions) {
                                    B.transitions = Object.create(null);
                                    for (let O = 0; O < _; O++) {
                                        let _ = B[O];
                                        if (!_) continue;
                                        let N, k = B.transitions;
                                        for (let O = 0, B = _.length; O < B; O++) {
                                            let B = _[O];
                                            (N = k[B]) || (N = k[B] = Object.create(null)), k = N
                                        }
                                        k[pT] = O + 64
                                    }
                                    U = _
                                }
                                Y || (B.nextId = _ + 64)
                            }
                            N && (N = !1), k = B || [];
                            try {
                                if (S(_), pE) {
                                    pf.setUint32(pE.position + O, pA - pE.position - O);
                                    let _ = pE;
                                    pE = null, S(_[0]), S(_[1])
                                }
                                if (G.offset = pA, F && F.idsToInsert) {
                                    (pA += 6 * F.idsToInsert.length) > pg && E(pA), G.offset = pA;
                                    let _ = function(_, O) {
                                        let B, N = 6 * O.length,
                                            k = _.length - N;
                                        for (O.sort((_, O) => _.offset > O.offset ? 1 : -1); B = O.pop();) {
                                            let O = B.offset,
                                                F = B.id;
                                            _.copyWithin(O + N, O, k);
                                            let U = O + (N -= 6);
                                            _[U++] = 214, _[U++] = 105, _[U++] = F >> 24, _[U++] = F >> 16 & 255, _[U++] = F >> 8 & 255, _[U++] = 255 & F, k = O
                                        }
                                        return _
                                    }(pp.subarray(O, pA), F.idsToInsert);
                                    return F = null, _
                                }
                                return j & pN ? (pp.start = O, pp.end = pA, pp) : pp.subarray(O, pA)
                            } finally {
                                if (B) {
                                    if (en < 10 && en++, ea > 1e4) B.transitions = null, en = 0, ea = 0, er.length > 0 && (er = []);
                                    else if (er.length > 0 && !Y) {
                                        for (let _ = 0, O = er.length; _ < O; _++) er[_][pT] = 0;
                                        er = []
                                    }
                                    if (N && G.saveStructures) {
                                        let N = B.sharedLength || K;
                                        B.length > N && (B = B.slice(0, N));
                                        let k = pp.subarray(O, pA);
                                        return !1 === G.saveStructures(B, U) ? (G._mergeStructures(G.getStructures()), G.pack(_)) : (U = N, k)
                                    }
                                }
                                j & pk && (pA = O)
                            }
                        };
                        let S = _ => {
                                pA > pg && (pp = E(pA));
                                var B, N = typeof _;
                                if ("string" === N) {
                                    let O, N = _.length;
                                    if (pE && N >= 8 && N < 4096) {
                                        let O = pC.test(_);
                                        pE[O ? 0 : 1] += _, pp[pA++] = 193, S(O ? -N : N);
                                        return
                                    }
                                    O = N < 32 ? 1 : N < 256 ? 2 : N < 65536 ? 3 : 5;
                                    let k = 3 * N;
                                    if (pA + k > pg && (pp = E(pA + k)), N < 64 || !j) {
                                        let k, F, U, j = pA + O;
                                        for (k = 0; k < N; k++)(F = _.charCodeAt(k)) < 128 ? pp[j++] = F : (F < 2048 ? pp[j++] = F >> 6 | 192 : ((64512 & F) == 55296 && (64512 & (U = _.charCodeAt(k + 1))) == 56320 ? (F = 65536 + ((1023 & F) << 10) + (1023 & U), k++, pp[j++] = F >> 18 | 240, pp[j++] = F >> 12 & 63 | 128) : pp[j++] = F >> 12 | 224, pp[j++] = F >> 6 & 63 | 128), pp[j++] = 63 & F | 128);
                                        B = j - pA - O
                                    } else B = j(_, pA + O, k);
                                    B < 32 ? pp[pA++] = 160 | B : B < 256 ? (O < 2 && pp.copyWithin(pA + 2, pA + 1, pA + 1 + B), pp[pA++] = 217, pp[pA++] = B) : B < 65536 ? (O < 3 && pp.copyWithin(pA + 3, pA + 2, pA + 2 + B), pp[pA++] = 218, pp[pA++] = B >> 8, pp[pA++] = 255 & B) : (O < 5 && pp.copyWithin(pA + 5, pA + 3, pA + 3 + B), pp[pA++] = 219, pf.setUint32(pA, B), pA += 4), pA += B
                                } else if ("number" === N) {
                                    if (_ >>> 0 === _) _ < 64 ? pp[pA++] = _ : _ < 256 ? (pp[pA++] = 204, pp[pA++] = _) : _ < 65536 ? (pp[pA++] = 205, pp[pA++] = _ >> 8, pp[pA++] = 255 & _) : (pp[pA++] = 206, pf.setUint32(pA, _), pA += 4);
                                    else if (_ >> 0 === _) _ >= -32 ? pp[pA++] = 256 + _ : _ >= -128 ? (pp[pA++] = 208, pp[pA++] = _ + 256) : _ >= -32768 ? (pp[pA++] = 209, pf.setInt16(pA, _), pA += 2) : (pp[pA++] = 210, pf.setInt32(pA, _), pA += 4);
                                    else {
                                        let O;
                                        if ((O = this.useFloat32) > 0 && _ < 4294967296 && _ >= -2147483648) {
                                            let B;
                                            if (pp[pA++] = 202, pf.setFloat32(pA, _), O < 4 || (B = _ * po[(127 & pp[pA]) << 1 | pp[pA + 1] >> 7]) >> 0 === B) {
                                                pA += 4;
                                                return
                                            }
                                            pA--
                                        }
                                        pp[pA++] = 203, pf.setFloat64(pA, _), pA += 8
                                    }
                                } else if ("object" === N) {
                                    if (_) {
                                        if (F) {
                                            let B = F.get(_);
                                            if (B) {
                                                if (!B.id) {
                                                    let _ = F.idsToInsert || (F.idsToInsert = []);
                                                    B.id = _.push(B)
                                                }
                                                pp[pA++] = 214, pp[pA++] = 112, pf.setUint32(pA, B.id), pA += 4;
                                                return
                                            }
                                            F.set(_, {
                                                offset: pA - O
                                            })
                                        }
                                        let N = _.constructor;
                                        if (N === Object) eo(_, !0);
                                        else if (N === Array) {
                                            (B = _.length) < 16 ? pp[pA++] = 144 | B : B < 65536 ? (pp[pA++] = 220, pp[pA++] = B >> 8, pp[pA++] = 255 & B) : (pp[pA++] = 221, pf.setUint32(pA, B), pA += 4);
                                            for (let O = 0; O < B; O++) S(_[O])
                                        } else if (N === Map)
                                            for (let [O, N] of ((B = _.size) < 16 ? pp[pA++] = 128 | B : B < 65536 ? (pp[pA++] = 222, pp[pA++] = B >> 8, pp[pA++] = 255 & B) : (pp[pA++] = 223, pf.setUint32(pA, B), pA += 4), _)) S(O), S(N);
                                        else {
                                            for (let O = 0, B = pd.length; O < B; O++)
                                                if (_ instanceof pu[O]) {
                                                    let B, N = pd[O];
                                                    if (N.write) {
                                                        N.type && (pp[pA++] = 212, pp[pA++] = N.type, pp[pA++] = 0), S(N.write.call(this, _));
                                                        return
                                                    }
                                                    let k = pp,
                                                        F = pf,
                                                        U = pA;
                                                    pp = null;
                                                    try {
                                                        B = N.pack.call(this, _, _ => (pp = k, k = null, (pA += _) > pg && E(pA), {
                                                            target: pp,
                                                            targetView: pf,
                                                            position: pA - _
                                                        }), S)
                                                    } finally {
                                                        k && (pp = k, pf = F, pA = U, pg = pp.length - 10)
                                                    }
                                                    B && (B.length + pA > pg && E(B.length + pA), pA = function(_, O, B, N) {
                                                        let k = _.length;
                                                        switch (k) {
                                                            case 1:
                                                                O[B++] = 212;
                                                                break;
                                                            case 2:
                                                                O[B++] = 213;
                                                                break;
                                                            case 4:
                                                                O[B++] = 214;
                                                                break;
                                                            case 8:
                                                                O[B++] = 215;
                                                                break;
                                                            case 16:
                                                                O[B++] = 216;
                                                                break;
                                                            default:
                                                                k < 256 ? (O[B++] = 199, O[B++] = k) : (k < 65536 ? (O[B++] = 200, O[B++] = k >> 8) : (O[B++] = 201, O[B++] = k >> 24, O[B++] = k >> 16 & 255, O[B++] = k >> 8 & 255), O[B++] = 255 & k)
                                                        }
                                                        return O[B++] = N, O.set(_, B), B += k
                                                    }(B, pp, pA, N.type));
                                                    return
                                                }
                                            eo(_, !_.hasOwnProperty)
                                        }
                                    } else pp[pA++] = 192
                                } else if ("boolean" === N) pp[pA++] = _ ? 195 : 194;
                                else if ("bigint" === N) {
                                    if (_ < BigInt(1) << BigInt(63) && _ >= -(BigInt(1) << BigInt(63))) pp[pA++] = 211, pf.setBigInt64(pA, _);
                                    else if (_ < BigInt(1) << BigInt(64) && _ > 0) pp[pA++] = 207, pf.setBigUint64(pA, _);
                                    else if (this.largeBigIntToFloat) pp[pA++] = 203, pf.setFloat64(pA, Number(_));
                                    else throw RangeError(_ + " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");
                                    pA += 8
                                } else if ("undefined" === N) this.encodeUndefinedAsNil ? pp[pA++] = 192 : (pp[pA++] = 212, pp[pA++] = 0, pp[pA++] = 0);
                                else if ("function" === N) S(this.writeFunction && this.writeFunction());
                                else throw Error("Unknown type: " + N)
                            },
                            eo = !1 === this.useRecords ? this.variableMapSize ? _ => {
                                let O, B = Object.keys(_),
                                    N = B.length;
                                N < 16 ? pp[pA++] = 128 | N : N < 65536 ? (pp[pA++] = 222, pp[pA++] = N >> 8, pp[pA++] = 255 & N) : (pp[pA++] = 223, pf.setUint32(pA, N), pA += 4);
                                for (let k = 0; k < N; k++) S(O = B[k]), S(_[O])
                            } : (_, B) => {
                                pp[pA++] = 222;
                                let N = pA - O;
                                pA += 2;
                                let k = 0;
                                for (let O in _)(B || _.hasOwnProperty(O)) && (S(O), S(_[O]), k++);
                                pp[N++ + O] = k >> 8, pp[N + O] = 255 & k
                            } : _ => {
                                let O = Object.keys(_),
                                    B, F = k.transitions || (k.transitions = Object.create(null)),
                                    U = 0;
                                for (let _ = 0, N = O.length; _ < N; _++) {
                                    let N = O[_];
                                    (B = F[N]) || (B = F[N] = Object.create(null), U++), F = B
                                }
                                let j = F[pT];
                                if (j) j >= 96 && ee ? (pp[pA++] = (31 & (j -= 96)) + 96, pp[pA++] = j >> 5) : pp[pA++] = j;
                                else {
                                    (j = k.nextId) || (j = 64), j < et && this.shouldShareStructure && !this.shouldShareStructure(O) ? ((j = k.nextOwnId) < ei || (j = et), k.nextOwnId = j + 1) : (j >= ei && (j = et), k.nextId = j + 1);
                                    let _ = O.highByte = j >= 96 && ee ? j - 96 >> 5 : -1;
                                    F[pT] = j, k[j - 64] = O, j < et ? (O.isShared = !0, k.sharedLength = j - 63, N = !0, _ >= 0 ? (pp[pA++] = (31 & j) + 96, pp[pA++] = _) : pp[pA++] = j) : (_ >= 0 ? (pp[pA++] = 213, pp[pA++] = 114, pp[pA++] = (31 & j) + 96, pp[pA++] = _) : (pp[pA++] = 212, pp[pA++] = 114, pp[pA++] = j), U && (ea += en * U), er.length >= $ && (er.shift()[pT] = 0), er.push(F), S(O))
                                }
                                for (let B = 0, N = O.length; B < N; B++) S(_[O[B]])
                            },
                            E = _ => {
                                let B;
                                if (_ > 16777216) {
                                    if (_ - O > p_) throw Error("Packed buffer would be larger than maximum buffer size");
                                    B = Math.min(p_, 4096 * Math.round(Math.max((_ - O) * (_ > 67108864 ? 1.25 : 2), 4194304) / 4096))
                                } else B = (Math.max(_ - O << 2, pp.length - 1) >> 12) + 1 << 12;
                                let N = new pb(B);
                                return pf = new DataView(N.buffer, 0, B), pp.copy ? pp.copy(N, 0, O, _) : N.set(pp.slice(O, _)), pA -= O, O = 0, pg = N.length - 10, pp = N
                            }
                    }
                    useBuffer(_) {
                        pp = _, pf = new DataView(pp.buffer, pp.byteOffset, pp.byteLength), pA = 0
                    }
                };

            function OP(_, O, B, N) {
                let k = _.byteLength;
                if (k + 1 < 256) {
                    var {
                        target: F,
                        position: U
                    } = B(4 + k);
                    F[U++] = 199, F[U++] = k + 1
                } else if (k + 1 < 65536) {
                    var {
                        target: F,
                        position: U
                    } = B(5 + k);
                    F[U++] = 200, F[U++] = k + 1 >> 8, F[U++] = k + 1 & 255
                } else {
                    var {
                        target: F,
                        position: U,
                        targetView: j
                    } = B(7 + k);
                    F[U++] = 201, j.setUint32(U, k + 1), U += 4
                }
                F[U++] = 116, F[U++] = O, F.set(new Uint8Array(_.buffer, _.byteOffset, _.byteLength), U)
            }

            function RP(_, O) {
                let B = _.byteLength;
                if (B < 256) {
                    var N, k, {
                        target: N,
                        position: k
                    } = O(B + 2);
                    N[k++] = 196, N[k++] = B
                } else if (B < 65536) {
                    var {
                        target: N,
                        position: k
                    } = O(B + 3);
                    N[k++] = 197, N[k++] = B >> 8, N[k++] = 255 & B
                } else {
                    var {
                        target: N,
                        position: k,
                        targetView: F
                    } = O(B + 5);
                    N[k++] = 198, F.setUint32(k, B), k += 4
                }
                N.set(_, k)
            }

            function qa(_) {
                if (_.Class) {
                    if (!_.pack && !_.write) throw Error("Extension has no pack or write function");
                    if (_.pack && !_.type) throw Error("Extension has no type (numeric code to identify the extension)");
                    pu.unshift(_.Class), pd.unshift(_)
                }
                _.unpack ? u$[_.type] = _.unpack : u$[_.type] = _
            }
            pu = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, u3], pd = [{
                pack(_, O, B) {
                    let N = _.getTime() / 1e3;
                    if ((this.useTimestamp32 || 0 === _.getMilliseconds()) && N >= 0 && N < 4294967296) {
                        let {
                            target: _,
                            targetView: B,
                            position: k
                        } = O(6);
                        _[k++] = 214, _[k++] = 255, B.setUint32(k, N)
                    } else if (N > 0 && N < 17179869184) {
                        let {
                            target: B,
                            targetView: k,
                            position: F
                        } = O(10);
                        B[F++] = 215, B[F++] = 255, k.setUint32(F, 4e6 * _.getMilliseconds() + (N / 1e3 / 4294967296 >> 0)), k.setUint32(F + 4, N)
                    } else if (isNaN(N)) {
                        if (this.onInvalidDate) return O(0), B(this.onInvalidDate());
                        let {
                            target: _,
                            targetView: N,
                            position: k
                        } = O(3);
                        _[k++] = 212, _[k++] = 255, _[k++] = 255
                    } else {
                        let {
                            target: B,
                            targetView: k,
                            position: F
                        } = O(15);
                        B[F++] = 199, B[F++] = 12, B[F++] = 255, k.setUint32(F, 1e6 * _.getMilliseconds()), k.setBigInt64(F + 4, BigInt(Math.floor(N)))
                    }
                }
            }, {
                pack(_, O, B) {
                    let N = Array.from(_),
                        {
                            target: k,
                            position: F
                        } = O(this.structuredClone ? 3 : 0);
                    this.structuredClone && (k[F++] = 212, k[F++] = 115, k[F++] = 0), B(N)
                }
            }, {
                pack(_, O, B) {
                    let {
                        target: N,
                        position: k
                    } = O(this.structuredClone ? 3 : 0);
                    this.structuredClone && (N[k++] = 212, N[k++] = 101, N[k++] = 0), B([_.name, _.message])
                }
            }, {
                pack(_, O, B) {
                    let {
                        target: N,
                        position: k
                    } = O(this.structuredClone ? 3 : 0);
                    this.structuredClone && (N[k++] = 212, N[k++] = 120, N[k++] = 0), B([_.source, _.flags])
                }
            }, {
                pack(_, O) {
                    this.structuredClone ? OP(_, 16, O) : RP(px ? il.from(_) : new Uint8Array(_), O)
                }
            }, {
                pack(_, O) {
                    let B = _.constructor;
                    B !== pw && this.structuredClone ? OP(_, pa.indexOf(B.name), O) : RP(_, O)
                }
            }, {
                pack(_, O) {
                    let {
                        target: B,
                        position: N
                    } = O(1);
                    B[N] = 193
                }
            }];
            var pI = new pP({
                useRecords: !1
            });
            pI.pack, pI.pack;
            var {
                NEVER: pO,
                ALWAYS: pL,
                DECIMAL_ROUND: pR,
                DECIMAL_FIT: pB
            } = {
                NEVER: 0,
                ALWAYS: 1,
                DECIMAL_ROUND: 3,
                DECIMAL_FIT: 4
            }, pN = 512, pk = 1024, pF = new pP({
                structuredClone: !0
            });
            qa({
                Class: d7.prototype.constructor,
                type: 1,
                write: _ => ({ ..._
                }),
                read: _ => (Object.setPrototypeOf(_, d7.prototype), _)
            }), qa({
                Class: ur.prototype.constructor,
                type: 2,
                write: _ => [..._],
                read: _ => (Object.setPrototypeOf(_, ur.prototype), _)
            }), qa({
                Class: ut.prototype.constructor,
                type: 3,
                write: _ => [..._],
                read: _ => (Object.setPrototypeOf(_, ut.prototype), _)
            }), qa({
                Class: uT.prototype.constructor,
                type: 4,
                write: _ => _.id,
                read: _ => new uT(_)
            }), qa({
                Class: uI.prototype.constructor,
                type: 5,
                write: _ => _.data,
                read: _ => new uI(_)
            }), qa({
                Class: ul.prototype.constructor,
                type: 6,
                write: _ => ({ ..._
                }),
                read: _ => (Object.setPrototypeOf(_, ul.prototype), _)
            }), (_ => {
                function i(_) {
                    return pF.pack(_)
                }
                _.serialize = i, _.deserialize = function(_) {
                    return pF.unpack(_)
                }, _.checksum = function(_) {
                    return (function(_) {
                        var O = 0;
                        if (0 === _.length) return O;
                        for (let B = 0; B < _.length; B++) O = (O << 5) - O + _[B], O &= O;
                        return O
                    })(i(function Uw(_) {
                        if (lh(_)) return _;
                        if (Array.isArray(_)) return _.map(Uw);
                        if ("object" != typeof _ || null === _) return _; {
                            let O = {};
                            for (let B of Object.keys(_).sort()) O[B] = Uw(_[B]);
                            return Object.setPrototypeOf(O, Object.getPrototypeOf(_)), O
                        }
                    }(_))).toString()
                }
            })(pj || (pj = {})), (pU = pG || (pG = {})).toEventUIType = function(_) {
                return "Conditional" === _.type ? "Distance" === _.condition.type ? "Distance" : "StateChange" : _.type
            }, pU.fromEventUIType = function(_) {
                return "Distance" === _ || "StateChange" === _ ? "Conditional" : _
            };
            var pU, pj, pG, pH, pW = {
                LookAt: [],
                Follow: ["Create"],
                DragDrop: ["Transition", "Animation", "Audio", "Create", "SetVariable", "DynamicVariablePlay", "Conditional"],
                MouseHover: ["Transition", "Animation", "Create", "Destroy", "SwitchCamera", "SceneTransition", "SetVariable", "DynamicVariablePlay", "Conditional"],
                Scroll: ["Transition", "Animation", "Create", "SetVariable", "DynamicVariablePlay", "Conditional"],
                Start: ["Transition", "Animation", "Audio", "Video", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                Conditional: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                MouseDown: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                MouseUp: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                MousePress: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                KeyDown: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                KeyUp: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                KeyPress: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "SwitchCamera", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                GameControl: ["Transition", "Animation", "Audio", "Create", "Conditional"],
                Collision: ["Transition", "Animation", "Audio", "Video", "Create", "Destroy", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                Trigger: ["Transition", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                Resize: ["Transition", "Animation", "Audio", "Video", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"],
                VariableChange: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset", "SetVariable", "DynamicVariablePlay", "Conditional"]
            };
            (p0 = pH || (pH = {})).is = function(_) {
                return "MouseDown" === _.type || "MouseUp" === _.type || "MousePress" === _.type || "KeyDown" === _.type || "KeyUp" === _.type || "KeyPress" === _.type
            }, p0.defaultData = function(_) {
                return "MouseDown" === _ || "MouseUp" === _ || "MousePress" === _ ? {
                    type: _,
                    mode: "Object",
                    disabled: !1,
                    runMode: "Once",
                    actions: new ur
                } : {
                    type: _,
                    disabled: !1,
                    key: void 0,
                    runMode: "Once",
                    actions: new ur
                }
            }, (p1 = fb || (fb = {})).propertyDefaultData = function(_) {
                return {
                    type: "Property",
                    value: [_ ? ? null, "position", "x"]
                }
            }, p1.valueDefaultData = {
                type: "Literal",
                value: 0
            }, (p3 = f_ || (f_ = {})).comparisonDefaultData = function(_) {
                return {
                    type: "Comparison",
                    operator: "==",
                    lOperand: fb.propertyDefaultData(_),
                    rOperand: { ...fb.valueDefaultData
                    }
                }
            }, p3.distanceDefaultData = function(_) {
                return {
                    type: "Distance",
                    toObject: _ ? ? null,
                    fromObject: _ ? ? null,
                    distance: 200
                }
            }, p3.stateDefaultData = function(_, O) {
                return {
                    type: "State",
                    object: _ ? ? null,
                    state: O ? ? null
                }
            }, (p4 = fS || (fS = {})).is = function(_) {
                return "Conditional" === _.type
            }, p4.defaultData = function(_) {
                return {
                    type: "Conditional",
                    disabled: !1,
                    inActions: new ur,
                    outActions: new ur,
                    condition: f_.distanceDefaultData(_)
                }
            }, (fA || (fA = {})).defaultData = {
                type: "DragDrop",
                cursor: "hand",
                disabled: !1,
                dampingFactor: 1,
                objects: [],
                snapTo: "center",
                snapSurfaceMode: "bbox",
                snapSurfaceOffset: 0,
                dropOn: "all",
                autoOrient: !0,
                dropDestinations: [],
                plane: "adaptive",
                planeMode: "locked",
                referenceFrame: "global",
                limits: [-1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0],
                drop: !1,
                resetOnSnapFail: !1,
                snapSpeed: 20,
                resetSpeed: 20,
                dragDropActions: {
                    drag: new ur,
                    drop: new ur
                }
            }, (fE || (fE = {})).defaultData = {
                type: "Follow",
                disabled: !1,
                maxDelta: 0,
                dampingFactor: 1,
                target: "cursor",
                plane: "custom",
                resetOnPointerLeave: !0,
                resetAfterDistanceLimit: !0,
                enabledTranslation: [!0, !0, !0],
                limitDistanceEnabled: !1,
                limitDistance: 1e3,
                snapDelay: 0,
                resetSpeed: 5,
                actions: new ur
            }, (fC || (fC = {})).defaultData = {
                type: "LookAt",
                disabled: !1,
                distance: 1e3,
                dampingFactor: 1,
                target: "cursor",
                tilt: "up",
                axis: "z",
                plane: "custom",
                resetOnPointerLeave: !0,
                resetAfterDistanceLimit: !0,
                enabledRotation: [!0, !0, !0],
                limitDistanceEnabled: !1,
                limitDistance: 1e3,
                snapDelay: 0,
                resetSpeed: 5
            }, (p5 = fT || (fT = {})).is = function(_) {
                return "MouseHover" === _.type
            }, p5.defaultData = function() {
                return {
                    type: "MouseHover",
                    disabled: !1,
                    actions: new ur
                }
            }, (p6 = fD || (fD = {})).is = function(_) {
                return "Scroll" === _.type
            }, p6.defaultData = function() {
                return {
                    type: "Scroll",
                    disabled: !1,
                    steps: 100,
                    trigger: "load",
                    startFrom: "enter",
                    enterAnchor: "top",
                    startOffset: 0,
                    endAfter: 400,
                    actions: new ur
                }
            }, (p8 = fI || (fI = {})).is = function(_) {
                return "Start" === _.type
            }, p8.defaultData = function() {
                return {
                    type: "Start",
                    disabled: !1,
                    actions: new ur
                }
            }, (p9 = fO || (fO = {})).is = function(_) {
                return "Collision" === _.type
            }, p9.defaultData = function() {
                return {
                    type: "Collision",
                    disabled: !1,
                    runMode: "Once",
                    target: "character",
                    actions: new ur
                }
            }, (p7 = fL || (fL = {})).is = function(_) {
                return "Trigger" === _.type
            }, p7.defaultData = function(_, O) {
                return {
                    type: "Trigger",
                    disabled: !1,
                    runMode: "Once",
                    target: "all",
                    triggeringObjects: [],
                    actions: new ur,
                    triggerZone: "box",
                    position: O.toArray(),
                    rotation: [0, 0, 0],
                    size: _.toArray(),
                    radius: _.length() / 2,
                    helperVisible: !0
                }
            }, (fe = fR || (fR = {})).defaultSizes = {
                mobile: [480, 480],
                tablet: [768, 768],
                desktop: [1200, 1200],
                custom: [769, 1200]
            }, fe.is = function(_) {
                return "Resize" === _.type
            }, fe.sizeToDevice = function(_) {
                return "string" == typeof _ ? _ : "custom"
            }, fe.deviceToSize = function(_) {
                return "string" == typeof _ ? [...fe.defaultSizes[_]] : [..._]
            }, fe.defaultData = function() {
                let _ = {
                        size: "mobile",
                        operator: "<",
                        actions: new ur
                    },
                    O = {
                        size: "tablet",
                        operator: "<",
                        actions: new ur
                    },
                    B = {
                        size: [...fe.defaultSizes.custom],
                        operator: "<>",
                        actions: new ur
                    },
                    N = new ur;
                return N.push({
                    id: iK.generateUUID(),
                    fi: 0,
                    data: _
                }, {
                    id: iK.generateUUID(),
                    fi: 1,
                    data: O
                }, {
                    id: iK.generateUUID(),
                    fi: 2,
                    data: B
                }), {
                    type: "Resize",
                    disabled: !1,
                    orientation: "horizontal",
                    breakpoints: N
                }
            }, fe.defaultBreakpointData = function() {
                return {
                    size: [...fe.defaultSizes.custom],
                    operator: "<>",
                    actions: new ur
                }
            }, (ft = fB || (fB = {})).propertyPaths = {
                Position: ["position"],
                "Position X": ["position", "x"],
                "Position Y": ["position", "y"],
                "Position Z": ["position", "z"],
                Rotation: ["rotation"],
                "Rotation X": ["rotation", "x"],
                "Rotation Y": ["rotation", "y"],
                "Rotation Z": ["rotation", "z"],
                Scale: ["scale"],
                "Scale X": ["scale", "x"],
                "Scale Y": ["scale", "y"],
                "Scale Z": ["scale", "z"],
                Width: ["width"],
                Height: ["height"],
                Depth: ["depth"],
                "Mouse Position X": ["mouse", "x"],
                "Mouse Position Y": ["mouse", "y"],
                "Mouse Pressed": ["mouse", "pressed"],
                "Screen Width": ["mouse", "width"],
                "Screen Height": ["mouse", "height"],
                "Hit Position X": ["raycast", "x"],
                "Hit Position Y": ["raycast", "y"],
                "Hit Position Z": ["raycast", "z"],
                "Hit Object Position X": ["raycast", "objX"],
                "Hit Object Position Y": ["raycast", "objY"],
                "Hit Object Position Z": ["raycast", "objZ"]
            }, ft.is = function(_) {
                return "VariableChange" === _.type
            }, ft.defaultData = function() {
                return {
                    disabled: !1,
                    type: "VariableChange",
                    actions: new ur,
                    variableId: "",
                    objectId: null,
                    property: "Position X"
                }
            };
            var pq = "personal camera",
                pY = "a218fcc3-276b-49b9-b485-49037fd14f5f";
            (fi = fN || (fN = {})).isEqual = function(_, O) {
                return _[0] === O[0] && _[1] === O[1]
            }, fi.lerp = function(_, O, B) {
                return [_[0] + (O[0] - _[0]) * B, _[1] + (O[1] - _[1]) * B]
            }, (fr = fk || (fk = {})).isEqual = function(_, O) {
                return _[0] === O[0] && _[1] === O[1] && _[2] === O[2]
            }, fr.add = function(_, O) {
                return [_[0] + O[0], _[1] + O[1], _[2] + O[2]]
            }, fr.sub = function(_, O) {
                return [_[0] - O[0], _[1] - O[1], _[2] - O[2]]
            }, fr.div = function(_, O) {
                return [_[0] / O[0], _[1] / O[1], _[2] / O[2]]
            }, fr.mul = function(_, O) {
                return [_[0] * O[0], _[1] * O[1], _[2] * O[2]]
            }, fr.dist = function(_, O) {
                return Math.hypot(_[0] - O[0], _[1] - O[1], _[2] - O[2])
            }, fr.lerp = function(_, O, B) {
                return [_[0] + (O[0] - _[0]) * B, _[1] + (O[1] - _[1]) * B, _[2] + (O[2] - _[2]) * B]
            }, (fs = fF || (fF = {})).isEqual = function(_, O) {
                return _[0] === O[0] && _[1] === O[1] && _[2] === O[2] && _[3] === O[3]
            }, fs.lerp = function(_, O, B) {
                return [_[0] + (O[0] - _[0]) * B, _[1] + (O[1] - _[1]) * B, _[2] + (O[2] - _[2]) * B, _[3] + (O[3] - _[3]) * B]
            }, (fn = fU || (fU = {})).identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], fn.isEqual = function(_, O) {
                for (let B = 0; B < 16; B++)
                    if (_[B] !== O[B]) return !1;
                return !0
            }, fn.simplify = function(_) {
                return _ ? ? fn.identity
            }, fn.applyMatrix4 = function(_, O) {
                let B = O.slice(0);
                for (var N = 0, k = O.length; N < k; N += 3) {
                    let k = _[3] * O[N] + _[7] * O[N + 1] + _[11] * O[N + 2] + _[15];
                    B[N] = (_[0] * O[N] + _[4] * O[N + 1] + _[8] * O[N + 2] + _[12]) / k, B[N + 1] = (_[1] * O[N] + _[5] * O[N + 1] + _[9] * O[N + 2] + _[13]) / k, B[N + 2] = (_[2] * O[N] + _[6] * O[N + 1] + _[10] * O[N + 2] + _[14]) / k
                }
                return B
            }, (fo = fV || (fV = {})).isRGB = function(_) {
                return "object" == typeof _ && "number" == typeof _.r && "number" == typeof _.g && "number" == typeof _.b
            }, fo.white = {
                r: 1,
                g: 1,
                b: 1
            }, fo.red = {
                r: 1,
                g: 0,
                b: 0
            }, fo.black = {
                r: 0,
                g: 0,
                b: 0
            }, fo.toRgb255a1 = function(_) {
                return {
                    r: Math.round(255 * _.r),
                    g: Math.round(255 * _.g),
                    b: Math.round(255 * _.b),
                    a: 1
                }
            }, fo.clone = function(_) {
                return {
                    r: _.r,
                    g: _.g,
                    b: _.b
                }
            }, fo.fromHex = function(_) {
                return {
                    r: ((_ = Math.floor(_)) >> 16 & 255) / 255,
                    g: (_ >> 8 & 255) / 255,
                    b: (255 & _) / 255
                }
            }, fo.toHex = function(_) {
                return 65536 * Math.round(255 * _.r) + 256 * Math.round(255 * _.g) + Math.round(255 * _.b)
            }, fo.equals = function(_, O) {
                return _.r === O.r && _.g === O.g && _.b === O.b
            }, fo.lerp = function(_, O, B) {
                return {
                    r: _.r + (O.r - _.r) * B,
                    g: _.g + (O.g - _.g) * B,
                    b: _.b + (O.b - _.b) * B
                }
            }, (fl = fj || (fj = {})).white = { ...fV.white,
                a: 1
            }, fl.transparent = { ...fV.white,
                a: 0
            }, fl.from0to1 = function(_) {
                return {
                    r: _[0],
                    g: _[1],
                    b: _[2],
                    a: _[3]
                }
            }, fl.fromHexAndA = function(_, O) {
                return { ...fV.fromHex(_),
                    a: O
                }
            }, fl.toRgb255a1 = function(_) {
                return {
                    r: Math.round(255 * _.r),
                    g: Math.round(255 * _.g),
                    b: Math.round(255 * _.b),
                    a: _.a
                }
            }, fl.equals = function(_, O) {
                return fV.equals(_, O) && _.a === O.a
            }, fl.lerp = function(_, O, B) {
                return {
                    r: _.r + (O.r - _.r) * B,
                    g: _.g + (O.g - _.g) * B,
                    b: _.b + (O.b - _.b) * B,
                    a: _.a + (O.a - _.a) * B
                }
            }, (fG || (fG = {})).identity = {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: [1, 1, 1]
            }, (fH || (fH = {})).defaultData = {
                mass: 1,
                stiffness: 80,
                damping: 10,
                velocity: 0
            }, (fW || (fW = {})).defaultData = {
                control1: [.5, 0],
                control2: [.5, 1]
            }, (fh = fq || (fq = {})).linear = [0, 0, 1, 1], fh.ease = [.25, .1, .25, 1], fh.easeIn = [.42, 0, 1, 1], fh.easeOut = [0, 0, .58, 1], fh.easeInOut = [.42, 0, .58, 1], (fc = fY || (fY = {})).all = ["PerspectiveCamera", "OrthographicCamera"], fc.is = function(_) {
                return fc.all.includes(_)
            }, (fd = fX || (fX = {})).DefaultUp = [0, 1, 0], fd.DefaultTargetOffset = 1e3, fd.defaultData = {
                far: 1e5,
                type: "OrthographicCamera",
                perspective: {
                    near: 70,
                    fov: 45,
                    zoom: 1
                },
                orthographic: {
                    near: -1e5,
                    zoom: 1
                },
                up: fd.DefaultUp,
                isUpVectorFlipped: !1,
                targetOffset: fd.DefaultTargetOffset
            }, fd.getZoom = function(_) {
                return "PerspectiveCamera" === _.type ? _.perspective.zoom : _.orthographic.zoom
            }, (fu = fQ || (fQ = {})).defaultData = function(_, O = .1) {
                return {
                    disabled: !1,
                    type: "linear",
                    hideBase: !1,
                    count: 3,
                    radial: {
                        radius: 2 * Math.max(_[0], _[1]),
                        start: 0,
                        end: 360,
                        alignment: !1,
                        axis: "y",
                        scale: [1, 1, 1],
                        rotation: [0, 0, 0],
                        position: [0, 0, 0]
                    },
                    toObject: {
                        object: "",
                        spreadType: "random",
                        scale: [0, 0, 0],
                        rotation: [0, 0, 0],
                        position: [0, 0, 0],
                        axis: "x",
                        seed: 0,
                        count: 99,
                        align: "normal"
                    },
                    linear: {
                        scale: [1, 1, 1],
                        rotation: [0, 0, 0],
                        position: [_[0] + _[0] * O, 0, 0]
                    },
                    grid: {
                        count: [2, 2, 2],
                        size: _.map(_ => _ * (1 + O)),
                        useCenter: !0
                    },
                    randomness: !1,
                    randomnessObject: {
                        strength: 100,
                        scale: [0, 0, 0],
                        rotation: [0, 0, 0],
                        position: [0, 0, 0],
                        movement: 1,
                        seed: 0,
                        freqScale: 10,
                        noiseType: "perlin"
                    }
                }
            }, fu.merge = function(_, O) {
                let B = { ..._
                };
                if (pX.forEach(N => {
                        Object.assign(B, {
                            [N]: O[N] ? ? _[N]
                        })
                    }), B.radial = { ..._.radial
                    }, O.radial) {
                    let N = _.radial,
                        k = O.radial;
                    pQ.forEach(_ => {
                        Object.assign(B.radial, {
                            [_]: k[_] ? ? N[_]
                        })
                    })
                }
                if (B.linear = { ..._.linear
                    }, O.linear) {
                    let N = _.linear,
                        k = O.linear;
                    pZ.forEach(_ => {
                        Object.assign(B.linear, {
                            [_]: k[_] ? ? N[_]
                        })
                    })
                }
                if (B.grid = { ..._.grid
                    }, O.grid) {
                    let N = _.grid,
                        k = O.grid;
                    pK.forEach(_ => {
                        Object.assign(B.grid, {
                            [_]: k[_] ? ? N[_]
                        })
                    })
                }
                if (B.toObject = { ..._.toObject
                    }, O.toObject) {
                    let N = _.toObject,
                        k = O.toObject;
                    pJ.forEach(_ => {
                        Object.assign(B.toObject, {
                            [_]: k[_] ? ? N[_]
                        })
                    })
                }
                if (B.randomnessObject = { ..._.randomnessObject
                    }, O.randomnessObject) {
                    let N = _.randomnessObject,
                        k = O.randomnessObject;
                    p$.forEach(_ => {
                        Object.assign(B.randomnessObject, {
                            [_]: k[_] ? ? N[_]
                        })
                    })
                }
                return B
            }, (fp = fZ || (fZ = {})).defaultData = {
                radial: {},
                linear: {},
                grid: {},
                toObject: {},
                randomnessObject: {}
            }, N = ["radial", "linear", "grid", "toObject", "randomnessObject"], fp.toOps = function(_, O) {
                let B = [];
                for (let k of (void 0 !== _.count && B.push({
                        type: 0,
                        path: O,
                        props: {
                            count: _.count
                        }
                    }), N)) {
                    let N = _[k];
                    N && Object.keys(N).length > 0 && B.push({
                        type: 0,
                        path: [...O, k],
                        props: N
                    })
                }
                return B
            };
            var pX = ["count"],
                pQ = ["radius", "start", "end", "position", "scale", "rotation"],
                pZ = ["position", "scale", "rotation"],
                pK = ["count", "size"],
                pJ = ["count", "position", "scale", "rotation"],
                p$ = ["strength", "scale", "rotation", "position", "movement", "seed", "freqScale"];
            (ff = fK || (fK = {})).all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"], ff.is = function(_) {
                return ff.all.includes(_)
            }, (fJ || (fJ = {})).defaultData = function(_) {
                return function(_) {
                    if ("PointLight" === _) return {
                        type: _,
                        color: fj.white,
                        intensity: 1,
                        distance: 2e3,
                        decay: 1,
                        shadows: !0,
                        shadowResolution: 1024,
                        shadowRadius: 1,
                        penumbraSize: .5,
                        depth: 1e5
                    };
                    if ("SpotLight" === _) return {
                        type: _,
                        color: fj.white,
                        intensity: 1,
                        distance: 2e3,
                        decay: 1,
                        shadows: !0,
                        penumbra: 0,
                        angle: 30 / 180 * Math.PI,
                        depth: 1e5,
                        penumbraSize: .5,
                        shadowResolution: 1024,
                        shadowRadius: 1
                    };
                    if ("DirectionalLight" === _) return {
                        type: _,
                        color: fj.white,
                        intensity: 1,
                        shadows: !0,
                        size: 2e3,
                        depth: 1e5,
                        penumbraSize: .5,
                        shadowResolution: 1024,
                        shadowRadius: 1
                    };
                    throw Error("not implemented")
                }(_)
            }, (f$ || (f$ = {})).defaultData = {
                enabled: "visibility",
                fusedBody: !0,
                rigidBody: "positioned",
                density: 1,
                pointMass: 0,
                gravityScale: 1,
                friction: .5,
                damping: 0,
                restitution: .2,
                colliderType: "convex",
                enabledRotation: [!0, !0, !0],
                enabledTranslation: [!0, !0, !0]
            }, (fv = f0 || (f0 = {})).defaultData = {
                castShadow: !0,
                receiveShadow: !0
            }, fv.equals = function(_, O) {
                return _.castShadow === O.castShadow && _.receiveShadow === O.receiveShadow
            }, (fy = f1 || (f1 = {})).defaultData = {
                flatShading: !1,
                wireframe: !1,
                side: 0
            }, fy.equals = function(_, O) {
                return _.flatShading === O.flatShading && _.side === O.side && _.wireframe === O.wireframe
            }, (f3 || (f3 = {})).defaultData = { ...f1.defaultData,
                ...f0.defaultData
            }, (f4 || (f4 = {})).getMaterialData = function(_, O) {
                let B = [];
                if ("material" in _) {
                    let N = "string" == typeof _.material ? O.materials[_.material] ? ? O.lib.materials[_.material] ? .asset : _.material;
                    N && B.push(N)
                } else if ("materials" in _)
                    for (let N of _.materials) {
                        let _ = "string" == typeof N ? O.materials[N] ? ? O.lib.materials[N] ? .asset : N;
                        _ && B.push(_)
                    }
                return B
            }, (fx = f5 || (f5 = {})).defaultVideo = {
                data: "",
                thumb: "/_assets/_videos/catThumb.png",
                type: "video",
                name: "Cat video"
            }, fx.maxSize = 3e7, (f6 || (f6 = {})).is = function(_) {
                return "texture" === _ || "video" === _ || "color" === _ || "depth" === _ || "normal" === _ || "gradient" === _ || "noise" === _ || "fresnel" === _ || "rainbow" === _ || "toon" === _ || "outline" === _ || "transmission" === _ || "matcap" === _ || "displace" === _ || "pattern" === _ || "light" === _
            }, (f8 || (f8 = {})).is = function(_) {
                return "phong" === _ || "toon" === _ || "lambert" === _ || "physical" === _
            };
            var p0, p1, p3, p4, p5, p6, p8, p9, p7, fe, ft, fi, fr, fs, fn, fo, fl, fh, fc, fd, fu, fp, ff, fv, fy, fx, fb, f_, fS, fA, fE, fC, fT, fD, fI, fO, fL, fR, fB, fN, fk, fF, fU, fV, fj, fG, fH, fW, fq, fY, fX, fQ, fZ, fK, fJ, f$, f0, f1, f3, f4, f5, f6, f8, f9, f7 = ["mode", "gradientType", "noiseType", "displacementType", "projection", "cnormal", "crop", "axis", "side"],
                me = ["wrapping", "image", "video", "name"];
            (mU = f9 || (f9 = {})).patch = function(_, O) {
                let {
                    texture: B,
                    ...N
                } = O;
                if (Object.assign(_, N), B) {
                    let O = _.texture;
                    O && Object.assign(O, B)
                }
            }, mU.defaultData = function(_, O) {
                return "light" === _ && O ? function(_) {
                    let O = {
                        mode: 0,
                        isMask: !1,
                        visible: !0,
                        bumpMap: void 0,
                        bumpMapIntensity: 5,
                        roughnessMap: void 0,
                        alphaOverride: 1
                    };
                    switch (_) {
                        case "phong":
                            return { ...O,
                                category: "phong",
                                specular: {
                                    r: .2,
                                    g: .2,
                                    b: .2
                                },
                                shininess: 5,
                                type: "light",
                                visible: !0,
                                mode: 0,
                                occlusion: !0,
                                alpha: .6
                            };
                        case "toon":
                            return { ...O,
                                category: "toon",
                                specular: {
                                    r: .2,
                                    g: .2,
                                    b: .2
                                },
                                shininess: 10,
                                type: "light",
                                alpha: 1
                            };
                        case "lambert":
                            return { ...O,
                                category: "lambert",
                                emissive: {
                                    r: 0,
                                    g: 0,
                                    b: 0
                                },
                                type: "light",
                                alpha: 1,
                                visible: !0,
                                mode: 0,
                                occlusion: !0
                            };
                        case "physical":
                            return { ...O,
                                category: "physical",
                                roughness: .2,
                                metalness: .2,
                                reflectivity: .2,
                                type: "light",
                                alpha: 1,
                                visible: !0,
                                mode: 0,
                                occlusion: !0
                            }
                    }
                }(O) : function(_) {
                    let O = {
                        alpha: 1,
                        mode: 0,
                        isMask: !1,
                        visible: !0
                    };
                    switch (_) {
                        case "texture":
                            return { ...O,
                                type: "texture",
                                size: [128, 128],
                                blending: 0,
                                axis: "x",
                                side: 2,
                                projection: 0,
                                texture: {
                                    image: "image_0",
                                    wrapping: 1e3,
                                    repeat: [1, 1],
                                    offset: [0, 0]
                                },
                                crop: !1
                            };
                        case "video":
                            return { ...O,
                                type: "video",
                                size: [128, 128],
                                blending: 0,
                                axis: "x",
                                side: 2,
                                projection: 0,
                                texture: {
                                    video: f5.defaultVideo,
                                    wrapping: 1001,
                                    repeat: [1, 1],
                                    offset: [0, 0]
                                },
                                crop: !1
                            };
                        case "color":
                            return { ...O,
                                type: "color",
                                color: fV.fromHex(5526619)
                            };
                        case "depth":
                            return { ...O,
                                type: "depth",
                                gradientType: 1,
                                smooth: !1,
                                isVector: !0,
                                isWorldSpace: !1,
                                origin: [0, 0, 0],
                                direction: [1, 0, 0],
                                colors: [
                                    [1, 1, 1, 1],
                                    [0, 0, 0, 1]
                                ],
                                steps: [0, 1],
                                near: 50,
                                far: 200
                            };
                        case "normal":
                            return { ...O,
                                type: "normal",
                                cnormal: [1, 1, 1]
                            };
                        case "gradient":
                            return { ...O,
                                type: "gradient",
                                gradientType: 0,
                                smooth: !1,
                                colors: [
                                    [0, 0, 0, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1]
                                ],
                                steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                                num: 2,
                                angle: 0,
                                offset: [0, 0],
                                morph: [0, 0]
                            };
                        case "noise":
                            return { ...O,
                                type: "noise",
                                size: [100, 100, 100],
                                noiseType: 0,
                                scale: 1,
                                move: 1,
                                colorA: { ...fV.fromHex(6710886),
                                    a: 1
                                },
                                colorB: { ...fV.fromHex(6710886),
                                    a: 1
                                },
                                colorC: { ...fV.fromHex(16777215),
                                    a: 1
                                },
                                colorD: { ...fV.fromHex(16777215),
                                    a: 1
                                },
                                distortion: [1, 1],
                                fA: [1.7, 9.2],
                                fB: [8.3, 2.8],
                                voronoiStyle: 0,
                                highCut: 1,
                                lowCut: 0,
                                smoothness: .3,
                                seed: 0,
                                quality: 1
                            };
                        case "fresnel":
                            return { ...O,
                                type: "fresnel",
                                color: fj.fromHexAndA(16777215, 1),
                                bias: .1,
                                scale: 1,
                                intensity: 2,
                                factor: 1
                            };
                        case "rainbow":
                            return { ...O,
                                type: "rainbow",
                                filmThickness: 30,
                                movement: 0,
                                wavelengths: [0, 0, 0],
                                noiseStrength: 0,
                                noiseScale: 1,
                                offset: [0, 0, 0]
                            };
                        case "toon":
                            return { ...O,
                                type: "toon",
                                positioning: 2,
                                colors: [
                                    [0, 0, 0, 1],
                                    [.5, .5, .5, 1],
                                    [.5, .5, .5, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1],
                                    [1, 1, 1, 1]
                                ],
                                steps: [0, .475, .525, 1, 1, 1, 1, 1, 1, 1],
                                num: 4,
                                source: [0, 1e3, 0],
                                isWorldSpace: !0,
                                noiseStrength: 0,
                                noiseScale: 1,
                                shadowColor: fj.fromHexAndA(0, 0),
                                offset: [0, 0, 0]
                            };
                        case "outline":
                            return { ...O,
                                type: "outline",
                                outlineColor: fj.fromHexAndA(0, 1),
                                contourColor: fj.fromHexAndA(0, 1),
                                outlineWidth: 2,
                                contourWidth: 5,
                                outlineThreshold: .4,
                                contourThreshold: 0,
                                outlineSmoothing: 0,
                                contourFrequency: 10,
                                contourDirection: [0, 1, 0],
                                positionalLines: !1,
                                compensation: !0
                            };
                        case "matcap":
                            return { ...O,
                                type: "matcap",
                                texture: {
                                    image: "matcap_0",
                                    wrapping: 1001,
                                    repeat: [1, 1],
                                    offset: [0, 0]
                                }
                            };
                        case "transmission":
                            return { ...O,
                                type: "transmission",
                                thickness: 10,
                                ior: 1.5,
                                roughness: 1
                            };
                        case "displace":
                            return {
                                visible: !0,
                                type: "displace",
                                displacementType: "noise",
                                noiseType: 0,
                                scale: 10,
                                movement: 1,
                                offset: [0, 0, 0],
                                intensity: 8,
                                voronoiStyle: 0,
                                smoothness: .3,
                                seed: 0,
                                highCut: 1,
                                lowCut: 0,
                                quality: 1
                            };
                        case "pattern":
                            return { ...O,
                                type: "pattern",
                                style: 0,
                                projection: 0,
                                axis: "y",
                                blending: 0,
                                offset: [0, 0],
                                colorA: { ...fV.fromHex(0),
                                    a: 1
                                },
                                colorB: { ...fV.fromHex(16777215),
                                    a: 1
                                },
                                frequency: [10, 10],
                                size: .5,
                                variation: 0,
                                smoothness: .5,
                                zigzag: 0,
                                rotation: 0,
                                vertical: [0, 1],
                                horizontal: [0, 1],
                                sides: 6
                            }
                    }
                }(_)
            }, (_ => {
                function s(_, O = "layer1", B = "layer2") {
                    let N = new ur;
                    return N.push({
                        fi: 0,
                        data: f9.defaultData("light", _),
                        id: O
                    }), N.push({
                        fi: 1,
                        data: f9.defaultData("color"),
                        id: B
                    }), {
                        layers: N
                    }
                }
                _.isMergable = function(_) {
                    return !_.layers.some(_ => "texture" === _.data.type && 0 !== _.data.projection || "depth" === _.data.type && !_.data.isWorldSpace || "noise" === _.data.type || "displace" === _.data.type)
                }, _.getHash = function(_) {
                    let O = "";
                    return _.layers.forEach(_ => {
                        Object.entries(_.data).forEach(([_, B]) => {
                            O += `${_}${B}`, Array.isArray(B) ? B.forEach(_ => O += `${_}`) : "object" == typeof B ? Object.values(B).forEach(_ => {
                                "number" == typeof _ ? O += `${_.toFixed(4)}` : O += `${_}`
                            }) : O += `${B}`
                        })
                    }), O
                }, _.defaultEmptyData = function() {
                    return {
                        layers: new ur
                    }
                }, _.defaultData = function(_ = "layer1", O = "layer2") {
                    return s("phong", _, O)
                }, _.withName = function(_, O) {
                    return { ..._,
                        name: O
                    }
                }, _.defaultTwoLayerData = s, _.defaultTwoLayerTextureData = function(_, O = "phong", B = "layer1", N = "layer2") {
                    let k = f9.defaultData("texture");
                    Object.assign(k.texture, {
                        image: _
                    });
                    let F = new ur;
                    return F.push({
                        fi: 0,
                        data: k,
                        id: B
                    }), F.push({
                        fi: 1,
                        data: f9.defaultData("light", O),
                        id: N
                    }), {
                        layers: F
                    }
                }, _.defaultTwoLayerVideoTextureData = function(_, O = "phong", B = "layer1", N = "layer2") {
                    let k = f9.defaultData("video");
                    Object.assign(k.texture, {
                        video: _
                    });
                    let F = new ur;
                    return F.push({
                        fi: 0,
                        data: k,
                        id: B
                    }), F.push({
                        fi: 1,
                        data: f9.defaultData("light", O),
                        id: N
                    }), {
                        layers: F
                    }
                }
            })(m0 || (m0 = {})), (m2 || (m2 = {})).defaultData = function() {
                return {
                    points: new ur,
                    roundness: 0,
                    shapeHoles: [],
                    isClosed: !1
                }
            }, (m3 || (m3 = {})).defaultData = function() {
                return {
                    points: new ur,
                    lastInsertionPlane: null,
                    subdivisions: 12,
                    isClosed: !1
                }
            };
            var mt = {
                type: "Ellipse",
                width: 50,
                height: 50,
                spikes: 16,
                angle: 360,
                innerRadius: 0
            };
            (m4 || (m4 = {})).merge = function(_, O) {
                let B = { ..._
                };
                return mr.forEach(N => {
                    Object.assign(B, {
                        [N]: O[N] ? ? _[N]
                    })
                }), B
            };
            var mi = {
                    shape: mt,
                    depth: 1,
                    offset: 0,
                    bevel: 50,
                    bevelSides: 6,
                    angle: 0,
                    twist: 0,
                    startScale: 1,
                    endScale: 1,
                    capType: "flat"
                },
                mr = ["depth", "offset", "angle", "twist", "startScale", "endScale"];
            (mj = m5 || (m5 = {})).is2DParametricMesh = function(_) {
                return "PolygonGeometry" === _ || "RectangleGeometry" === _ || "StarGeometry" === _ || "TriangleGeometry" === _ || "EllipseGeometry" === _
            }, mj.isParametricMesh = function(_) {
                return "PolygonGeometry" === _ || "PolygonGeometry" === _ || "RectangleGeometry" === _ || "StarGeometry" === _ || "TriangleGeometry" === _ || "EllipseGeometry" === _ || "PathGeometry" === _ || "VectorGeometry" === _ || "ConeGeometry" === _ || "CubeGeometry" === _ || "CylinderGeometry" === _ || "DodecahedronGeometry" === _ || "HelixGeometry" === _ || "IcosahedronGeometry" === _ || "LatheGeometry" === _ || "PyramidGeometry" === _ || "SphereGeometry" === _ || "PlaneGeometry" === _ || "BackdropGeometry" === _ || "TorusGeometry" === _ || "TorusKnotGeometry" === _ || "BooleanGeometry" === _ || "TextGeometry" === _
            }, (m6 || (m6 = {})).merge = function(_, O) {
                let B = { ..._
                };
                return Object.assign(B, O), "PathGeometry" === B.type && "extrusion" in O && O.extrusion && (B.extrusion = { ..._.extrusion
                }, Object.assign(B.extrusion, m4.merge(B.extrusion, O.extrusion))), B
            }, (m8 || (m8 = {})).defaultData = function(_) {
                if ("RectangleGeometry" === _) return {
                    width: 320,
                    height: 320,
                    type: _,
                    cornerRadius: [0, 0, 0, 0],
                    cornerType: 0,
                    depth: 0,
                    extrudeBevelSize: 0,
                    extrudeBevelSegments: 1
                };
                if ("PathGeometry" === _) return {
                    type: _,
                    width: 1,
                    height: 1,
                    depth: 1,
                    path: m3.defaultData(),
                    extrusion: mi
                };
                if ("VectorGeometry" === _) return {
                    width: 1,
                    height: 1,
                    type: _,
                    subdivisions: 12,
                    shape: m2.defaultData(),
                    depth: 0,
                    extrudeBevelSize: 0,
                    extrudeBevelSegments: 1
                };
                if ("BooleanGeometry" === _) return {
                    type: _,
                    operation: 2,
                    width: 0,
                    height: 0,
                    depth: 0,
                    phongAngle: 35
                };
                if ("TextGeometry" === _) return {
                    type: _,
                    width: 100,
                    height: 100,
                    depth: 0,
                    horizontalAlign: 1,
                    verticalAlign: 1,
                    fontSize: 16,
                    lineHeight: 1.2,
                    letterSpacing: 0,
                    text: {
                        textValue: ""
                    },
                    textTransform: 1,
                    font: "Roboto_regular",
                    extrudeBevelSize: 0,
                    extrudeBevelSegments: 1
                };
                if ("SphereGeometry" === _) return {
                    type: "SphereGeometry",
                    width: 100,
                    height: 100,
                    depth: 100,
                    widthSegments: 64,
                    heightSegments: 64,
                    phiStart: 0,
                    phiLength: 2 * Math.PI,
                    thetaStart: 0,
                    thetaLength: 180
                };
                throw Error("not implemented")
            };
            var ms = ["width", "height", "depth"];

            function o2(_) {
                _.layers.forEach(_ => {
                    if ("depth" === _.type && void 0 !== _.colorA) {
                        let O = _.colorA,
                            B = _.colorB,
                            N = [
                                [O.r, O.g, O.b, O.a],
                                [B.r, B.g, B.b, B.a]
                            ],
                            k = [0, 1];
                        for (let _ = 2; _ < 10; _++) N.push(N[1]), k.push(1);
                        let F = { ...dk(xr(_), "type", "visible", "isVector", "isWorldSpace", "origin", "alpha", "mode"),
                            near: Math.max(0, _.near),
                            far: Math.max(0, _.far),
                            colors: N,
                            steps: k,
                            num: 2,
                            direction: [1, 0, 0],
                            smooth: !1,
                            gradientType: 1
                        };
                        Object.assign(_, F)
                    } else if ("depth" === _.type && 1 === _.gradientType && (_.near < 0 || _.far < 0)) {
                        let O = { ...xr(_),
                            near: Math.max(_.near, 0),
                            far: Math.max(_.far, 0)
                        };
                        Object.assign(_, O)
                    }
                })
            }

            function ra(_, O) {
                Object.values(_.shared.materials).forEach(_ => O(_))
            }

            function na(_, O) {
                _.scene.objects.traverse((_, B) => {
                    "materials" in B ? B.materials.forEach((_, N) => {
                        void 0 === _ && (B.materials[N] = m0.defaultData(), _ = B.materials[N]), "string" != typeof _ && O(_)
                    }) : "material" in B ? "string" != typeof B.material && (void 0 === B.material && (B.material = m0.defaultData()), O(B.material)) : "Mesh" === B.type && (void 0 === B.material && (B.material = m0.defaultData()), O(B.material)), "overrides" in B && Object.values(B.overrides).forEach(_ => {
                        _.material && "string" != typeof _.material && O(_.material)
                    })
                })
            }

            function a2(_) {
                void 0 === _.layers && Object.assign(_, m0.defaultTwoLayerData("lambert"))
            }

            function aS(_) {
                _.layers && _.layers.forEach(_ => {
                    if ("depth" === _.type && 10 === _.colors.length) {
                        let O = [..._.colors];
                        O.push(_.colors[9]);
                        let B = [..._.steps];
                        B.push(_.steps[9]);
                        let N = { ...xr(_),
                            colors: O,
                            steps: B
                        };
                        Object.assign(_, N)
                    }
                })
            }

            function l2(_) {
                _.scene.objects.traverse((_, O) => {
                    "materials" in O ? O.materials.forEach(_ => {
                        "string" != typeof _ && aS(_)
                    }) : "material" in O && "string" != typeof O.material && aS(O.material)
                }), Object.values(_.shared.materials).forEach(_ => aS(_))
            }

            function c2(_) {
                _.layers && _.layers.forEach(_ => {
                    "depth" === _.type && void 0 !== _.num && (_.colors = _.colors.slice(0, _.num), _.steps = _.steps.slice(0, _.num), delete _.num)
                })
            }

            function u2(_) {
                _.layers && _.layers.forEach(_ => {
                    "displace" !== _.type && void 0 === _.isMask && (_.isMask = !1), ("texture" === _.type || "video" === _.type) && void 0 === _.blending && (_.blending = 0), ("noise" === _.type || "displace" === _.type && "noise" === _.displacementType) && (void 0 === _.voronoiStyle && (_.voronoiStyle = 0), void 0 === _.highCut && (_.highCut = 1), void 0 === _.lowCut && (_.lowCut = 0), void 0 === _.smoothness && (_.smoothness = .3), void 0 === _.seed && (_.seed = 0), void 0 === _.quality && (_.quality = 1))
                })
            }

            function h2(_) {
                let O = _.layers.find(_ => "light" === _.type) ? .data;
                O ? .category === "basic" && (Object.assign(O, f9.defaultData("light", "phong")), O.visible = !1)
            }

            function d2(_) {
                ra(_, h2), na(_, h2)
            }

            function f2(_) {
                _.layers.forEach(_ => {
                    "light" === _.type && "toon" !== _.category && void 0 === _.occlusion && (_.occlusion = !0)
                })
            }

            function p2(_) {
                _.layers && _.layers.forEach(_ => {
                    "light" === _.type && void 0 === _.bumpMapIntensity && (_.bumpMapIntensity = 5)
                })
            }

            function g2(_) {
                _.layers && _.layers.forEach(_ => {
                    "light" === _.type && void 0 === _.alphaOverride && (_.alphaOverride = 1)
                })
            }(m9 || (m9 = {})).defaultData = {
                enabled: !1,
                useBackgroundColor: !1,
                color: fV.white,
                near: .1,
                far: 2e3
            }, k = {
                opacity: 1,
                blendFunction: 13,
                enabled: !1
            }, (m7 || (m7 = {})).defaultData = {
                enabled: !1,
                pixelation: { ...k,
                    blendFunction: 16,
                    granularity: 15
                },
                bloom: { ...k,
                    blendFunction: 16,
                    intensity: 1,
                    blurScale: 1,
                    luminanceThreshold: .25,
                    luminanceSmoothing: .025,
                    kernelSize: 3
                },
                chromaticAberration: { ...k,
                    offset: [2, 2]
                },
                vignette: { ...k,
                    darkness: 1,
                    offset: 0
                },
                hueSaturation: { ...k,
                    hue: 3,
                    saturation: 0
                },
                brightnessContrast: { ...k,
                    brightness: .25,
                    contrast: 0
                },
                depthOfField: { ...k,
                    focalLength: 2,
                    focusDistance: 2,
                    bokehScale: 2
                },
                noise: { ...k,
                    blendFunction: 16
                }
            }, (ge || (ge = {})).defaultData = {
                softShadowQuality: "low"
            }, (gt || (gt = {})).defaultData = {
                enabled: !0,
                color: {
                    r: .8274509803921568,
                    g: .8274509803921568,
                    b: .8274509803921568
                },
                intensity: .75
            }, (gi || (gi = {})).defaultData = {
                occlusion: !1,
                aoFullRes: !1,
                radius: 256,
                bias: .5,
                aoColor: {
                    r: .19607843137254902,
                    g: .19607843137254902,
                    b: .19607843137254902
                }
            }, (gr || (gr = {})).defaultData = {
                usePhysics: !1,
                gravity: -10
            }, (gs || (gs = {})).defaultData = {
                playCamera: pq,
                gameControlObject: null
            }, (ga || (ga = {})).defaultData = {
                backgroundColor: fj.fromHexAndA(2960946, 1),
                postprocessing: m7.defaultData,
                fog: m9.defaultData,
                globalPhysics: gr.defaultData,
                ambient: gt.defaultData,
                ao: gi.defaultData,
                shadow: ge.defaultData,
                publish: gs.defaultData
            }, (mG = gn || (gn = {})).isComponentRelated = function(_) {
                return "Component" === _ || "Instance" === _
            }, mG.isEmptyOrComponent = function(_) {
                return "Empty" === _ || "Instance" === _
            }, (mH = gl || (gl = {})).identity = { ...fG.identity,
                hiddenMatrix: fU.identity
            }, mH.fromObject = function(_) {
                return {
                    position: _.position,
                    rotation: _.rotation,
                    scale: _.scale,
                    hiddenMatrix: _.hiddenMatrix
                }
            }, mH.merge = function(_, O) {
                return {
                    position: O ? .position || _.position,
                    rotation: O ? .rotation || _.rotation,
                    scale: O ? .scale || _.scale,
                    hiddenMatrix: O ? .hiddenMatrix || _.hiddenMatrix
                }
            }, mH.diff = function(_, O) {
                return function(_) {
                    for (let O of Object.keys(_)) void 0 === _[O] && delete _[O];
                    return _
                }({
                    position: fk.isEqual(_.position, O.position) ? void 0 : O.position,
                    rotation: fk.isEqual(_.rotation, O.rotation) ? void 0 : O.rotation,
                    scale: fk.isEqual(_.scale, O.scale) ? null : O.scale,
                    hiddenMatrix: fU.isEqual(_.hiddenMatrix, O.hiddenMatrix) ? void 0 : O.hiddenMatrix
                })
            }, (gh || (gh = {})).defaultData = {
                states: new ur,
                events: new ur,
                visible: !0,
                raycastLock: !1,
                physics: f$.defaultData,
                pathSnapping: {
                    pathId: null,
                    slide: 0,
                    offset: 0,
                    orientation: "tangential"
                },
                ...gl.identity,
                cloner: null
            }, (gd || (gd = {})).defaultData = {
                type: "Empty",
                ...gh.defaultData
            }, (gu || (gu = {})).defaultData = {
                type: "Component",
                ...gh.defaultData
            }, (gf || (gf = {})).defaultData = {
                type: "Mesh",
                ...gh.defaultData,
                ...f3.defaultData
            }, (gm || (gm = {})).defaultData = { ...gh.defaultData,
                ...gl.identity,
                position: [0, 0, fX.DefaultTargetOffset],
                ...fX.defaultData
            }, (mW = gg || (gg = {})).defaultData = function(_) {
                return { ...gh.defaultData,
                    ...fJ.defaultData(_)
                }
            }, mW.defaultDirectionalLightData = { ...mW.defaultData("DirectionalLight"),
                position: [200, 300, 300],
                name: "Directional Light",
                intensity: .7
            }, (_ => {
                function i(_, O, B = 0) {
                    for (; B < O.length;) {
                        let N = _ ? _[O[B]] : void 0;
                        if (O.length === B + 1) return N;
                        if (!N) return;
                        _ = N.descendants, B += 1
                    }
                }
                _.resolveWithDes = i, _.resolve = function(_, O, B = 0) {
                    let N = i(_, O, B);
                    if (N) {
                        let _ = Object.keys(N);
                        if (1 === _.length && "descendants" === _[0]) return
                    }
                    return N
                }
            })(gv || (gv = {})), (_ => {
                function r(_, O) {
                    return { ...gh.defaultData,
                        ...O,
                        component: _,
                        overrides: new ul,
                        physics: void 0,
                        events: void 0,
                        type: "Instance"
                    }
                }
                _.rootOverrideProps = ["physics", "events"], _.compositeNonOptionalOverrideProps = ["geometry"], _.compositeEntireOverrideOverrideProps = ["material"], _.ofComponent = r, _.fromComponentData = function(_) {
                    let O = gl.fromObject(_.data);
                    return r(_.id, O)
                }
            })(gy || (gy = {})), (gx || (gx = {})).defaultData = {
                type: "Page",
                ...gh.defaultData,
                physics: { ...f$.defaultData,
                    fusedBody: !1
                },
                ...ga.defaultData,
                camera: gm.defaultData
            }, (mY = gb || (gb = {})).defaultCamera = {
                position: [0, 0, 1e3],
                scale: [1, 1, 1],
                rotation: [0, 0, 0],
                hiddenMatrix: fU.identity,
                name: "Play Camera",
                visible: !0,
                raycastLock: !1,
                physics: f$.defaultData,
                states: new ur,
                events: new ur,
                cloner: null,
                pathSnapping: {
                    pathId: null,
                    orientation: "tangential",
                    slide: 0,
                    offset: 0
                },
                ...fX.defaultData
            }, mY.KeysByResetCategory = {
                States: ["states"],
                Events: ["events"],
                Material: ["material", "materials"],
                Geometry: ["geometry"],
                Position: ["position"],
                Rotation: ["rotation"],
                Scale: ["scale"],
                Transform: ["position", "scale", "rotation", "hiddenMatrix"],
                Name: ["name"],
                Visibility: ["visible", "raycastLock", "flatShading", "wireframe", "side"],
                Shadows: ["castShadow", "receiveShadow"],
                Cloner: ["cloner"],
                Physics: ["physics"]
            }, mY.defaultMeshObject = {
                name: "Rectangle",
                ...gh.defaultData,
                ...gf.defaultData,
                geometry: m8.defaultData("RectangleGeometry"),
                material: m0.defaultTwoLayerData("phong", "layer1", "layer2")
            }, mY.defaultBooleanObject = {
                name: "Boolean",
                ...gh.defaultData,
                ...gf.defaultData,
                geometry: m8.defaultData("BooleanGeometry"),
                material: m0.defaultTwoLayerData("phong", "layer1", "layer2")
            }, mY.defaultTextObject = {
                name: "Text",
                ...gh.defaultData,
                ...gf.defaultData,
                geometry: m8.defaultData("TextGeometry"),
                material: m0.defaultTwoLayerData("phong", "layer1", "layer2")
            }, (mX = gS || (gS = {})).newEmpty = function(_, O) {
                let B = {
                    name: O
                };
                return "Mesh" === _.type ? (B.geometry = {}, "material" in _ && (B.material = {
                    layers: new ul
                }), "materials" in _ && (B.materials = _.materials.map(_ => ({
                    layers: new ul
                })))) : fY.is(_.type) && (B.perspective = {}, B.orthographic = {}), B
            }, mX.toOps = function(_, O) {
                let B, N = [],
                    k = {
                        orthographic: 0,
                        perspective: 0,
                        geometry: 0
                    };

                function c(_, O) {
                    for (let [B, k] of Object.entries(O.layers)) {
                        let {
                            texture: O,
                            ...F
                        } = k;
                        if (void 0 !== O && Object.keys(O).length > 0) {
                            let k = {
                                path: [..._, "layers", B, "texture"],
                                props: O,
                                type: 0
                            };
                            N.push(k)
                        }
                        if (Object.keys(F).length > 0) {
                            let O = {
                                path: [..._, "layers", B],
                                props: F,
                                type: 0
                            };
                            N.push(O)
                        }
                    }
                }
                for (let [_, F] of Object.entries(O))
                    if ("name" !== _) {
                        if ("cloner" === _) N.push(...fZ.toOps(F, ["cloner"]));
                        else if ("pathSnapping" === _) N.push({
                            path: [_],
                            props: {
                                slide: F.slide,
                                offset: F.offset
                            },
                            type: 0
                        });
                        else if ("material" === _) c(["material"], F);
                        else if ("materials" === _)
                            for (let [_, O] of Object.entries(F)) c(["materials", _], O);
                        else if (0 === k[_]) {
                            if ("geometry" === _ && void 0 !== F.extrusion) {
                                let O = {
                                    path: [_, "extrusion"],
                                    props: F.extrusion,
                                    type: 0
                                };
                                N.push(O), F = { ...F
                                }, delete F.extrusion
                            }
                            if (Object.keys(F).length > 0) {
                                let O = {
                                    path: [_],
                                    props: F,
                                    type: 0
                                };
                                N.push(O)
                            }
                        } else void 0 === B && (B = {
                            path: [],
                            props: {},
                            type: 0
                        }, N.push(B)), B.props[_] = F
                    }
                return N
            }, mX.patch = function(_, O) {
                if (void 0 === O) return _;
                let B = { ..._
                };
                return (Object.assign(B, gl.merge(B, O)), Object.assign(B, {
                    pathSnapping: Object.assign({}, B.pathSnapping, {
                        slide: O.pathSnapping ? .slide ? ? B.pathSnapping ? .slide ? ? 0,
                        offset: O.pathSnapping ? .offset ? ? B.pathSnapping ? .offset ? ? 0
                    })
                }), fY.is(_.type)) ? (B.orthographic = { ...B.orthographic
                }, B.perspective = { ...B.perspective
                }, O.orthographic ? .zoom !== void 0 && (B.orthographic.zoom = O.orthographic.zoom), O.perspective ? .zoom !== void 0 && (B.perspective.zoom = O.perspective.zoom), void 0 !== O.isUpVectorFlipped && (B.isUpVectorFlipped = O.isUpVectorFlipped), void 0 !== O.targetOffset && (B.targetOffset = O.targetOffset)) : "Mesh" === _.type ? ("geometry" in O && Object.assign(B, {
                    geometry: m6.merge(B.geometry, O.geometry)
                }), (O.material || O.materials) && (B = function(_, O) {
                    if (void 0 === O) return _;
                    let B = { ..._
                    };
                    return "material" in B && "material" in O && O.material && (B.material = Ha(B.material, _ => {
                        if ("string" != typeof _)
                            for (let [B, N] of Object.entries(O.material.layers)) {
                                let O = _.layers.data(B);
                                O && f9.patch(O, N)
                            }
                    }).data), B.materials && O.materials && (B.materials = Ha(B.materials, _ => {
                        for (let N = 0; N < B.materials.length; N++) {
                            let B = O.materials[N];
                            if ("string" != typeof B)
                                for (let [O, k] of Object.entries(B.layers)) {
                                    let B = _[N] ? .layers ? .data(O);
                                    B && f9.patch(B, k)
                                }
                        }
                    }).data), B
                }(B, O)), B.cloner && "cloner" in O && Object.assign(B, {
                    cloner: fQ.merge(B.cloner, O.cloner)
                })) : "Empty" === _.type ? B.cloner && "cloner" in O && Object.assign(B, {
                    cloner: fQ.merge(B.cloner, O.cloner)
                }) : fK.is(_.type) && (void 0 !== O.intensity && (B.intensity = O.intensity), void 0 !== O.color && ("string" == typeof O.color ? B.color = O.color : B.color = fV.clone(O.color))), B
            }, (gA || (gA = {})).defaultData = {
                enablePan: !0,
                enableZoom: !0,
                enableRotate: !0,
                enableDamping: !0,
                rotationLimitsMode: 0,
                rotationVerticalOffset: {
                    min: Math.PI / 4,
                    max: Math.PI / 4
                },
                rotationHorizontalOffset: {
                    min: Math.PI / 4,
                    max: Math.PI / 4
                },
                rotationSoftLimit: 2,
                panLimitsMode: 0,
                panVerticalOffset: {
                    min: 250,
                    max: 250
                },
                panHorizontalOffset: {
                    min: 250,
                    max: 250
                },
                panSoftLimit: 2,
                zoomLimitsEnabled: !1,
                zoomLimits: {
                    min: .1,
                    max: 2
                },
                autoRotate: !1,
                autoRotateSpeed: 2,
                autoRotateClockwise: !0,
                hoverRotatePanMode: 0,
                hoverRotatePanStrength: 20,
                hoverRotateDamping: .125,
                isTouchZoom: !0,
                orbitTouches: 2,
                panTouches: 3,
                resetHoverEffectOnPointerLeave: !0
            }, (gM || (gM = {})).defaultData = {
                orbitControls: gA.defaultData,
                playPage: pY,
                withBackground: !0,
                preventScroll: !1,
                preventTouchScroll: !1,
                hideCursor: !1,
                mouseEventTarget: "canvas",
                joystickSizeAndXYOffset: Array(12).fill(0).map((_, O) => {
                    let B = 0,
                        N = 0;
                    return O < 5 ? N = -30 : O < 10 && (N = 30), 0 === O || 10 === O || 5 === O ? B = 30 : (4 === O || 11 === O || 9 === O) && (B = -30), [120, [B, N], "show"]
                }),
                settings: {
                    image: {
                        format: "jpg",
                        ratio: 1
                    },
                    video: {
                        format: "mp4",
                        imageFormat: "jpg",
                        fps: 30,
                        mbps: 80,
                        ratio: Math.max(1, "u" > typeof window ? Math.floor(window.devicePixelRatio) : 1),
                        stopMode: "manual",
                        duration: 5e3
                    },
                    web: {
                        logo: !0,
                        compress: !0,
                        preset: 1,
                        preload: !0,
                        hint: !1
                    }
                },
                stopRaycast: !0,
                hdTransmission: !1
            }, (gE || (gE = {})).defaultData = {
                id: "basic",
                label: "Basic",
                style: "None",
                prompt: ""
            }, (gC || (gC = {})).defaultData = {
                weather: 0,
                shadows: 0,
                lightOrigin: 0,
                temperature: 0,
                sun: 0,
                camera: 0,
                environment: 0,
                particles: 0,
                nature: 0,
                floor: 0
            }, (mQ = gT || (gT = {})).defaultData = () => ({
                mode: "line-art-both",
                prompt: "",
                negativePrompt: "",
                style: { ...gE.defaultData
                },
                isRandomSeed: !0,
                seed: mQ.generateSeed(),
                guessMode: !1,
                advanced: !1,
                steps: 20,
                guidanceScale: 7.5,
                controlNetScale: 1,
                modifiers: gC.defaultData
            }), mQ.generateSeed = () => Math.round(1e5 * Math.random()), (mZ = gD || (gD = {})).physicsEnabled = function(_) {
                return void 0 !== _.find(_ => "Page" === _.data.type && _.data.globalPhysics.usePhysics)
            }, mZ.traverseModuleInstances = function(_, O, B) {
                _.scene.objects.traverseFrom(O, (O, N) => {
                    if ("Instance" === N.type) {
                        let k = gj.getComponentData(_, N.component) ? .data;
                        k && B(O, N, k.events)
                    } else B(O, N, N.events)
                })
            }, (_ => {
                function t(_ = {
                    withLight: !0,
                    withSquare: !0
                }) {
                    let O = [],
                        B = gb.defaultMeshObject;
                    !0 === _.withLight && O.push({
                        fi: -1,
                        data: gg.defaultDirectionalLightData,
                        id: "830a2708-8ed9-49cf-a68e-085299899103",
                        children: []
                    }), !0 === _.withSquare && O.push({
                        fi: 1,
                        id: "7ba78968-2a55-48f2-b14c-5191da3e075e",
                        data: B,
                        children: []
                    });
                    let N = new ut;
                    return N.push({
                        fi: 1,
                        id: pY,
                        data: { ...gx.defaultData,
                            name: "Scene 1"
                        },
                        children: O
                    }), N
                }

                function s(O) {
                    return { ..._.defaultData,
                        objects: ui(O, ut.prototype)
                    }
                }
                _.TRASH_CAN_ID = "830a2708-8ed9-49cf-a68e-085299892222", _.defaultData = {
                    objects: t(),
                    publish: gM.defaultData,
                    styles: gT.defaultData()
                }, _.emptyDataWithoutPage = function() {
                    return {
                        objects: new ut,
                        publish: gM.defaultData,
                        styles: gT.defaultData()
                    }
                }, _.emptyDataWithPage = function(_) {
                    return {
                        objects: t(_),
                        publish: gM.defaultData,
                        styles: gT.defaultData()
                    }
                }, _.withObjs = s, _.withObj = function(_, O) {
                    return s([{
                        id: _,
                        data: O,
                        children: [],
                        fi: 0
                    }])
                }
            })(gP || (gP = {})), (gI || (gI = {})).defaultData = {
                preset: "fullscreen",
                allowResponsive: !1,
                size: [512, 512],
                coords: [0, 0],
                sceneScale: 1,
                color: {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: .5
                }
            }, (gO || (gO = {})).emptyImage = {
                data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",
                name: "empty"
            }, (_ => {
                function i(_) {
                    return void 0 !== _.textValue
                }

                function e(_) {
                    return "boolean" == typeof _
                }
                _.isTextValue = i, _.isNumber = function(_) {
                    return "number" == typeof _
                }, _.isBoolean = e, _.typeOfVariable = function(_) {
                    return i(_) ? "string" : e(_) ? "boolean" : "number"
                }, _.getDisplayedValue = function(O) {
                    return _.isTextValue(O) ? Array.isArray(O.textValue) ? O.textValue.map(_ => _.toString().padStart(O.padding ? ? 2, "0")).join(O.deliminator ? ? ":") + (void 0 !== O.suffix ? " " + O.suffix : "") : O.textValue.toString() : _.isBoolean(O) ? O ? "True" : "False" : _.isNumber(O) ? parseFloat(O.toFixed(3)).toString() : O.toString()
                }
            })(gL || (gL = {})), (gR || (gR = {})).all = ["images", "videos", "colors", "audios", "fonts", "materials", "variables"], (gB || (gB = {})).all = [...gR.all, "components"], (gz || (gz = {})).defaultData = function() {
                return {
                    images: new d7,
                    videos: new d7,
                    colors: new d7,
                    audios: new d7,
                    fonts: new d7,
                    materials: new d7,
                    components: new d7,
                    variables: new d7
                }
            }, (gN || (gN = {})).defaultData = function() {
                return {
                    images: new d7,
                    videos: new d7,
                    colors: new d7,
                    audios: new d7,
                    fonts: new d7,
                    materials: new d7,
                    components: new d7,
                    variables: new d7
                }
            }, (mK = gk || (gk = {})).defaultColors = function() {
                let _ = {};
                return _["89b10010-844c-11ec-a8a3-0242ac120002"] = {
                    r: .5,
                    g: .5,
                    b: .5,
                    a: 1,
                    name: "Default Color"
                }, ui(_, d7.prototype)
            }, mK.defaultImages = function(_) {
                let O = {};
                return _ ? .withAITexture && (O["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = { ...gO.emptyImage,
                    name: "AI generated image"
                }), ui(O, d7.prototype)
            }, mK.emptyData = function() {
                return {
                    catelogs: new d7,
                    materials: new d7,
                    images: new d7,
                    videos: new d7,
                    colors: new d7,
                    audios: new d7,
                    fonts: new d7,
                    variables: new ur,
                    lib: gN.defaultData()
                }
            }, mK.defaultVariables = function(_) {
                switch (_) {
                    case "number":
                        return {
                            value: 0,
                            name: "Number"
                        };
                    case "boolean":
                        return {
                            value: !1,
                            name: "Boolean"
                        };
                    case "string":
                        return {
                            value: {
                                textValue: "String value"
                            },
                            name: "String"
                        };
                    case "time":
                        let O = [0, 0, 0];
                        return {
                            name: "Time",
                            value: {
                                textValue: O,
                                deliminator: ":",
                                padding: 2,
                                suffix: "AM"
                            },
                            dynamicVariableType: "time",
                            format: "HH:mm:ss",
                            format12h24h: "12ampm",
                            timeZone: null,
                            hasEnd: !1,
                            endValue: {
                                textValue: O,
                                deliminator: ":",
                                padding: 2,
                                suffix: "AM"
                            },
                            autoStart: !0,
                            repeat: !1
                        };
                    case "counter":
                        return {
                            name: "Counter",
                            value: 0,
                            dynamicVariableType: "counter",
                            updateInterval: 1e3,
                            increment: 1,
                            autoStart: !0,
                            hasEnd: !0,
                            endValue: 60,
                            repeat: !0,
                            randomStart: !1,
                            range: [0, 100],
                            decimals: 0
                        };
                    case "random":
                        return {
                            name: "Random",
                            value: 0,
                            dynamicVariableType: "random",
                            updateInterval: 1e3,
                            increment: 1,
                            autoStart: !0,
                            isStatic: !1,
                            hasEnd: !0,
                            endValue: 60,
                            repeat: !0,
                            min: 0,
                            max: 100,
                            decimals: 0
                        };
                    default:
                        console.error("Unknown variable type", _)
                }
            }, mK.getFormattedTimerTime = function(_, O) {
                if ("HH:mm:ss" === O.format) {
                    let O = Math.floor(_ / 3600),
                        B = Math.floor((_ - 3600 * O) / 60),
                        N = Math.round(_ - 3600 * O - 60 * B);
                    return {
                        textValue: [O, B, N]
                    }
                }
                if ("mm:ss" !== O.format) return _ = "number" === O.format ? Math.round(_) : Math.round(1e3 * _) / 1e3; {
                    let O = Math.floor(_ / 60),
                        B = Math.round(_ - 60 * O);
                    return {
                        textValue: [O, B]
                    }
                }
            }, (gF || (gF = {})).list = ["idle", "move", "jump", "run"], (mJ = gU || (gU = {})).defaultColliderData = {
                type: "capsule",
                height: 200,
                radius: 50,
                position: [0, 0, 0],
                rotation: [0, 0, 0]
            }, mJ.defaultDataThirdPerson = {
                moveMode: "walk",
                forwardDirection: "+z",
                speedTranslate: 1e3,
                speedRotate: 100,
                runMultiplier: 2,
                rotationMode: "normal",
                rotBy: "keys",
                rotByTouch: "drag",
                delayPos: [.3, .3],
                delayRot: [.3, .3],
                keyAssignments: [
                    ["moveNegZ", "W"],
                    ["moveNegX", "A"],
                    ["movePosZ", "S"],
                    ["movePosX", "D"],
                    ["rotPosX", "▲"],
                    ["rotPosY", "◀"],
                    ["rotNegX", "▼"],
                    ["rotNegY", "▶"],
                    ["jump", "Space"],
                    ["run", "⇧"],
                    ["none", "Ctrl"]
                ],
                touchControl: !0,
                joystickPosLoc: 5,
                joystickRotLoc: 11,
                jumpTouchButtonLoc: 9,
                collider: mJ.defaultColliderData,
                colliderHelperVisible: !0,
                collisionEnabled: !0,
                jumpPower: 100,
                resetYPosition: 3e3,
                alignToGround: !1,
                autoOrientMove: !0,
                orientWith: "camera",
                orientMode: "radial",
                delayPosCamera: .3,
                delayRotCamera: .3,
                camera: "",
                cameraXAxis: "Limit",
                cameraYAxis: "Free",
                cameraRotXLimits: [0, Math.PI / 2],
                cameraRotYLimits: [-Math.PI / 2, Math.PI / 2],
                gameActions: {
                    idle: new ur,
                    move: new ur,
                    jump: new ur,
                    run: new ur
                },
                navmesh: {
                    enabled: !1,
                    ch: 6,
                    cs: 6,
                    walkableClimb: 5,
                    walkableHeight: 1,
                    walkableRadius: 0,
                    zones: "all",
                    objects: [],
                    helperVisible: !0,
                    destinationHelperRadius: 0,
                    destinationHelperColor: fj.fromHexAndA(3728051, 1)
                }
            };
            var ma = 180 / Math.PI;

            function y2(_) {
                _.rotation = _.rotation.slice(0, 3).map(_ => _ * ma)
            }

            function v2(_) {
                y2(_), "Page" === _.type && y2(_.camera), _.states ? .forEach(_ => {
                    void 0 === _.rotation || null === _.rotation || (_.rotation = _.rotation.slice(0, 3).map(_ => _ * ma))
                });
                let O = _.geometry;
                O && "SphereGeometry" === O.type && (O.thetaLength = (O.thetaLength ? ? 180) * ma), O && "TorusGeometry" === O.type && (O.arc = O.arc * ma), O && "PathGeometry" === O.type && (O.extrusion.angle *= ma, O.extrusion.twist *= ma), "Mesh" === _.type && "TextGeometry" === _.geometry.type && (_.geometry.text = {
                    textValue: _.geometry.text
                }), Array.isArray(xr(_.events)) && _.events ? .forEach(_ => {
                    ("MouseDown" === _.type || "MouseUp" === _.type || "MousePress" === _.type || "KeyDown" === _.type || "KeyUp" === _.type || "KeyPress" === _.type || "Collision" === _.type || "Trigger" === _.type) && (_.runMode = _.toggle ? "Toggle" : "Once")
                })
            }

            function tv(_) {
                let O = _.schema ? ? 0;
                if (107 !== O) {
                    let B;
                    for (let B of (console.warn("updating from ", O, "to ", 107), function(_, O) {
                            let B, N;
                            if (O < 1 && (na(_, o2), ra(_, o2), _.schema = 1), O < 2 && (Object.assign(_.scene.publish, {
                                    orbitControls: { ...gA.defaultData,
                                        ...xr(_.scene.publish.orbitControls)
                                    }
                                }), _.schema = 2), O < 3 && (function(_) {
                                    function t(_) {
                                        if (_.layers) {
                                            for (let O of Object.values(_.layers))
                                                if (O) {
                                                    for (let [_, B] of Object.entries(O))
                                                        if ((f7.includes(_) || "boolean" == typeof B) && delete O[_], "texture" === _)
                                                            for (let [_, O] of Object.entries(B))(me.includes(_) || "boolean" == typeof O) && delete B[_]
                                                }
                                        }
                                    }
                                    _.scene.objects.traverse((_, O) => {
                                        O.states.forEach(_ => {
                                            _.material ? t(_.material) : _.materials && _.materials.forEach(_ => {
                                                t(_)
                                            })
                                        })
                                    })
                                }(_), _.schema = 3), O < 4 && (_.scene.publish.withBackground = !0, _.schema = 4), O < 5 && (_.scene.publish.settings.web = {
                                    compress: !0,
                                    preload: !0,
                                    preset: 1,
                                    logo: !0,
                                    hint: !1
                                }, _.schema = 5), O < 6 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        let B = O.cloner;
                                        B && (B.radial.scale = B.radial.scale.map(_ => _ + 1), B.linear.scale = B.linear.scale.map(_ => _ + 1))
                                    })
                                }(_), _.schema = 6), O < 7 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        let B = O.geometry;
                                        B && ("DodecahedronGeometry" === B.type || "IcosahedronGeometry" === B.type) && (B.detail = Math.round(B.detail))
                                    })
                                }(_), _.schema = 7), O < 8 && (_.schema = 8), O < 9 && (l2(_), _.schema = 9), O < 10 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        "Mesh" === O.type && ("BooleanGeometry" === O.geometry.type || "SubdivGeometry" === O.geometry.type) && (O.geometry.phongAngle = 35)
                                    })
                                }(_), _.schema = 10), O < 11 && (_.scene.environment.ambientLight.softShadows = !1, _.scene.environment.ambientLight.softShadowQuality = "low", _.scene.objects.traverse((_, O) => {
                                    ("DirectionalLight" === O.type || "SpotLight" === O.type) && (O.shadowResolution = 1024, O.shadowRadius = 1, O.depth = 1e5)
                                }), _.shared.penumbraSize = [, , , , , ].fill(.5), _.schema = 11), O < 12 && (l2(_), _.schema = 12), O < 13 && (_.shared.audios = ui({}, d7.prototype), _.schema = 13), O < 14 && (Object.entries(B = _.shared.materials).forEach(([_, O]) => {
                                    O.layers || Object.assign(B, {
                                        [_]: {
                                            name: "Untitled Material",
                                            layers: [{
                                                fi: 0,
                                                data: {
                                                    type: "light",
                                                    category: "phong",
                                                    alpha: .6,
                                                    visible: !0,
                                                    mode: 0,
                                                    specular: {
                                                        r: .2,
                                                        g: .2,
                                                        b: .2
                                                    },
                                                    shininess: 5
                                                },
                                                id: "layer1"
                                            }, {
                                                fi: 1,
                                                data: {
                                                    type: "color",
                                                    alpha: 1,
                                                    visible: !0,
                                                    mode: 0,
                                                    color: {
                                                        r: .2823529411764706,
                                                        g: .2823529411764706,
                                                        b: .30196078431372547
                                                    }
                                                },
                                                id: "layer2"
                                            }]
                                        }
                                    })
                                }), _.schema = 14), O < 15 && (Object.entries(xr(_.shared.images)).filter(_ => !1 === _[1].asset).map(_ => _[0]).forEach(O => {
                                    delete _.shared.images[O]
                                }), Object.entries(xr(_.shared.audios)).filter(_ => !1 === _[1].asset).map(_ => _[0]).forEach(O => {
                                    delete _.shared.audios[O]
                                }), _.schema = 15), O < 16 && (_.scene.publish.settings.web.preload = !1, _.schema = 16), O < 17 && (na(_, c2), ra(_, c2), _.schema = 17), O < 18 && (na(_, a2), ra(_, a2), _.schema = 18), O < 19 && (Object.assign(_.scene.publish.settings, {
                                    video: { ...gM.defaultData.settings.video,
                                        ...xr(_.scene.publish.settings.video)
                                    }
                                }), _.schema = 19), O < 20 && (_.shared.fonts = ui({}, d7.prototype), N = [], _.scene.objects.traverse((O, B) => {
                                    if ("TextFrame" === B.type) {
                                        let k = m0.defaultTwoLayerData("phong"),
                                            F = "string" == typeof B.color ? _.shared.colors[B.color] : B.color;
                                        k.layers[1].data.color = {
                                            r: F.r,
                                            g: F.g,
                                            b: F.b
                                        }, k.layers[1].data.alpha = B.alpha;
                                        let U = B.font.replace(".typeface", "").replace(/optimer/gi, "open sans").replace("space_mono", "space mono").replace(/alma_mono/gi, "varela round").replace(/droid_sans_mono/gi, "noto sans mono").replace(/droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi, "roboto").replace(/droid_serif/gi, "roboto slab").replace("_sans", " sans").replace("crimson_text", "crimson text").replace("medium_medium", "medium").replace("fatface_fatface", "fatface").replace("100hairline", "thin").replace("200thin", "extralight").replace("300light", "light").replace("500medium", "medium").replace("600semi", "semibold").replace("800heavy", "extrabold").replace("900black", "black").replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi, "bodoni_$1_$2").replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda").replace(/(thin|hairline)(_regular)?/gi, "100").replace(/(extra|ultra)light(_regular)?/gi, "200").replace(/light(_regular)?/gi, "300").replace(/_book|_normal|_roman/gi, "_regular").replace(/medium(_regular)?/gi, "500").replace(/(semi|demi)bold(_regular)?/gi, "600").replace(/(extra|ultra)bold(_regular)?/gi, "800").replace(/bold(_regular)?/gi, "700").replace(/(black|heavy|fatface)(_regular)?/gi, "900").replace(/([1-9]00)_italic/gi, "$1italic").replace(/regularitalic/gi, "italic").replace(/regularitalic/gi, "italic").split(" ").map(_ => _.charAt(0).toUpperCase() + _.slice(1)).join(" ");
                                        void 0 === _.shared.fonts[U] && (_.shared.fonts[U] = {
                                            name: U
                                        });
                                        let j = {
                                                name: B.name,
                                                ...gh.defaultData,
                                                ...gf.defaultData,
                                                flatShading: !1,
                                                wireframe: !1,
                                                geometry: { ...m8.defaultData("TextGeometry"),
                                                    width: B.width,
                                                    height: B.height,
                                                    font: U,
                                                    depth: 0,
                                                    horizontalAlign: B.horizontalAlign,
                                                    verticalAlign: B.verticalAlign,
                                                    fontSize: 1.40625 * B.fontSize,
                                                    lineHeight: B.lineHeight / 1.40625,
                                                    letterSpacing: B.letterSpacing - 1,
                                                    text: B.text,
                                                    textTransform: B.textTransform,
                                                    extrudeBevelSize: 0,
                                                    extrudeBevelSegments: 1
                                                },
                                                material: k,
                                                states: xr(B.states),
                                                events: xr(B.events),
                                                visible: B.visible,
                                                raycastLock: B.raycastLock,
                                                position: B.position,
                                                rotation: B.rotation,
                                                scale: B.scale,
                                                hiddenMatrix: B.hiddenMatrix
                                            },
                                            G = xr(_.scene.objects).parent(O);
                                        _.scene.objects.insertAfter(G ? ? null, O, [{
                                            id: O + "new",
                                            data: j,
                                            children: []
                                        }]), N.push(O)
                                    }
                                }), N.forEach(O => {
                                    _.scene.objects.delete(O)
                                }), _.schema = 20), O < 21 && (function(_) {
                                    let O = {
                                        0: "MouseDown",
                                        1: "MouseUp",
                                        2: "MouseHover",
                                        5: "KeyDown",
                                        6: "KeyUp",
                                        7: "Start",
                                        9: "LookAt",
                                        10: "Follow",
                                        11: "Scroll",
                                        12: "Audio",
                                        13: "GameControl"
                                    };
                                    _.scene.objects.traverse((_, B) => {
                                        B.events.forEach(_ => {
                                            if (O[Number(_.type)]) {
                                                if (Object.assign(_, {
                                                        type: O[Number(_.type)]
                                                    }), "Audio" === _.type && "audioEvent" in _ && (Object.assign(_, {
                                                        playAudio: _.audioEvent
                                                    }), delete _.audioEvent), "GameControl" === _.type) Object.assign(_, {
                                                    gameActions: {
                                                        idle: new ur,
                                                        move: new ur,
                                                        jump: new ur
                                                    }
                                                });
                                                else {
                                                    let O = new ur;
                                                    Object.assign(_, {
                                                        actions: O
                                                    }), ("MouseDown" === _.type || "MouseUp" === _.type || "KeyDown" === _.type || "KeyUp" === _.type) && "url" in _ && O.push({
                                                        fi: 0,
                                                        id: iK.generateUUID(),
                                                        data: {
                                                            type: "Link",
                                                            url: _.url,
                                                            delay: 0
                                                        }
                                                    }), "targets" in _ && (_.targets.forEach((_, B, N) => {
                                                        let k = {
                                                            easing: _.easing,
                                                            duration: _.duration
                                                        };
                                                        6 === _.easing ? Object.assign(k, dk(_, "mass", "stiffness", "damping", "velocity")) : 5 === _.easing && Object.assign(k, {
                                                            control1: { ..._.control1
                                                            },
                                                            control2: { ..._.control2
                                                            }
                                                        });
                                                        let F = {
                                                                repeat: _.repeat ? -1 : 0,
                                                                delay: _.delay,
                                                                delayDirection: _.delayDirection,
                                                                direction: _.cycle && _.rewind ? "pingpong-rewind" : _.cycle ? "pingpong" : "normal"
                                                            },
                                                            U = {
                                                                state: _.state,
                                                                ...F,
                                                                ...k
                                                            },
                                                            j = {
                                                                allowSlerp: !0,
                                                                type: "Transition",
                                                                object: _.object,
                                                                repeat: 0,
                                                                delay: 0,
                                                                delayDirection: void 0,
                                                                direction: "normal",
                                                                tweens: new ur({
                                                                    fi: 0,
                                                                    id: iK.generateUUID(),
                                                                    data: {
                                                                        state: void 0,
                                                                        repeat: 0,
                                                                        delay: 0,
                                                                        delayDirection: void 0,
                                                                        direction: "normal",
                                                                        duration: 0,
                                                                        easing: 4
                                                                    }
                                                                }, {
                                                                    fi: 1,
                                                                    id: iK.generateUUID(),
                                                                    data: U
                                                                })
                                                            };
                                                        O.push({
                                                            fi: N,
                                                            id: B,
                                                            data: j
                                                        })
                                                    }), delete _.targets)
                                                }
                                            }
                                        })
                                    })
                                }(_), function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        function r(_, B) {
                                            let N = new ur,
                                                k = [];
                                            if (O.events.forEach((_, O, F) => {
                                                    if ("Audio" === _.type && _.trigger === B) {
                                                        let B;
                                                        k.push(O), "play" === _.interaction ? B = { ...dk(_, "interaction", "audio", "delay", "volume", "loop"),
                                                            triggerAfter: "after" in _ ? _.after : void 0,
                                                            toggle: "after" in _ ? _.toggle : void 0,
                                                            type: "Audio"
                                                        } : ("pause" === _.interaction || "stop" === _.interaction) && (B = { ...dk(_, "interaction", "delay", "object", "playAudio"),
                                                            type: "Audio"
                                                        }), B && N.push({
                                                            fi: F,
                                                            id: O,
                                                            data: B
                                                        })
                                                    }
                                                }), k.forEach(_ => O.events.delete(_)), N.length) {
                                                let B = O.events.find(O => O.type === _) ? .data;
                                                B ? "actions" in B && B.actions.insertBefore(null, N) : O.events.insertBefore(null, [{
                                                    id: iK.generateUUID(),
                                                    data: {
                                                        type: _,
                                                        actions: N
                                                    }
                                                }])
                                            }
                                        }
                                        r("Start", "start"), r("MouseDown", "mouseDown"), r("MouseUp", "mouseUp"), r("KeyDown", "keyDown"), r("KeyUp", "keyUp")
                                    })
                                }(_), _.schema = 21), O < 22 && (d2(_), _.schema = 22), O < 23 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        "Mesh" === O.type && "SubdivGeometry" === O.geometry.type && (O.geometry.scaleBaked || (O.geometry.scaleBaked = [1, 1, 1]))
                                    })
                                }(_), _.schema = 23), O < 24 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        "Empty" !== O.type && "Mesh" !== O.type || !O.cloner || O.cloner.randomnessObject || O.cloner.toObject || O.cloner.randomness || (O.cloner = { ...O.cloner,
                                            toObject: {
                                                object: "",
                                                spreadType: "random",
                                                scale: [0, 0, 0],
                                                rotation: [0, 0, 0],
                                                position: [0, 0, 0],
                                                axis: "x",
                                                seed: 0,
                                                count: 99,
                                                align: "normal"
                                            },
                                            randomness: !1,
                                            randomnessObject: {
                                                strength: 100,
                                                scale: [0, 0, 0],
                                                rotation: [0, 0, 0],
                                                position: [0, 0, 0],
                                                movement: 1,
                                                seed: 0,
                                                freqScale: 10,
                                                noiseType: "perlin"
                                            }
                                        })
                                    })
                                }(_), _.schema = 24), (O < 25 || void 0 === _.shared.videos) && (_.shared.videos = ui({}, d7.prototype), O < 25 && (_.schema = 25)), O < 26 && (function(_) {
                                    _.scene.objects.traverse((O, B) => {
                                        let N = _.scene.objects.unproxy().parent(O);
                                        if (N) {
                                            let O = xr(_.scene.objects.data(N));
                                            O && "Mesh" === O.type && "BooleanGeometry" === O.geometry.type && "Mesh" === B.type && (B.visible = !0 !== xr(B).booleanExclude)
                                        }
                                    })
                                }(_), _.schema = 26), O < 27 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        "Mesh" === O.type && ("NonParametricGeometry" === O.geometry.type ? void 0 !== O.material && delete O.material : void 0 !== O.materials && delete O.materials)
                                    })
                                }(_), _.schema = 27), O < 28 && (d2(_), _.schema = 28), O < 29 && (function(_) {
                                    function e(_) {
                                        for (let B in Object.setPrototypeOf(_, ul.prototype), _) {
                                            var O;
                                            Object.setPrototypeOf(O = _[B], ul.prototype), O.texture && Object.setPrototypeOf(O.texture, ul.prototype)
                                        }
                                    }
                                    _.scene.objects.traverse((_, O) => {
                                        O.states.forEach(_ => {
                                            if (_.material) {
                                                let O = xr(_.material).layers;
                                                e(O), _.material.layers = O
                                            }
                                            if (_.materials)
                                                for (let O = 0; O < _.materials.length; O++) {
                                                    let B = _.materials[O],
                                                        N = xr(B).layers;
                                                    e(N), B.layers = N
                                                }
                                        })
                                    })
                                }(_), _.schema = 29), O < 30 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        "Mesh" !== O.type || "NonParametricGeometry" !== O.geometry.type || "material" in O || "materials" in O || (O.material = m0.defaultTwoLayerData("phong"))
                                    })
                                }(_), _.schema = 30), O < 31 && (void 0 === _.scene.publish.orbitControls.autoZoom && (_.scene.publish.orbitControls.autoZoom = !1), _.scene.objects.traverse((_, O) => {
                                    ("OrthographicCamera" === O.type || "PerspectiveCamera" === O.type) && (void 0 === O.orthographic.autoZoom && (O.orthographic.autoZoom = !1), void 0 === O.orthographic.autoZoomFrustumSize && (O.orthographic.autoZoomFrustumSize = 790))
                                }), _.schema = 31), O < 33 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        void 0 === O.pathSnapping && (O.pathSnapping = {
                                            pathId: null,
                                            slide: 0,
                                            offset: 0,
                                            orientation: "tangential"
                                        }), void 0 === O.pathSnapping.offset && (O.pathSnapping.offset = 0)
                                    })
                                }(_), _.schema = 33), O < 34 && (void 0 === _.scene.publish.mouseEventTarget && (_.scene.publish.mouseEventTarget = "canvas"), void 0 === _.scene.publish.settings.web.hint && (_.scene.publish.settings.web.hint = !1), _.schema = 34), O < 35 && (function(_) {
                                    let {
                                        video: O
                                    } = _.scene.publish.settings;
                                    "gif" === O.format && O.fps > 48 && (O.fps = 15)
                                }(_), _.schema = 35), O < 36 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        O.events.forEach(_ => {
                                            "GameControl" === _.type && (_.resetYPosition = Math.abs(_.resetYPosition - O.position[1]))
                                        })
                                    })
                                }(_), _.schema = 36), O < 37 && (function(_) {
                                    let O = _.scene.environment.usePhysics;
                                    _.scene.objects.traverse((_, B) => {
                                        O && null === B.physics ? B.collision = !1 : B.collision = "visibility"
                                    })
                                }(_), _.schema = 37), O < 38 && (na(_, u2), ra(_, u2), _.schema = 38), O < 39 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        O.events.forEach(_ => {
                                            "GameControl" === _.type && (_.navmesh = gU.defaultDataThirdPerson.navmesh)
                                        })
                                    })
                                }(_), _.schema = 39), O < 40 && (_.scene.styles || (_.scene.styles = gT.defaultData()), _.schema = 40), O < 41 && (void 0 === _.scene.environment.ambientLight.occlusion && (_.scene.environment.ambientLight.occlusion = !1), void 0 === _.scene.environment.ambientLight.aoFullRes && (_.scene.environment.ambientLight.aoFullRes = !1), void 0 === _.scene.environment.ambientLight.radius && (_.scene.environment.ambientLight.radius = 256), void 0 === _.scene.environment.ambientLight.bias && (_.scene.environment.ambientLight.bias = .5), void 0 === _.scene.environment.ambientLight.aoColor && (_.scene.environment.ambientLight.aoColor = {
                                    r: .19607843137254902,
                                    g: .19607843137254902,
                                    b: .19607843137254902
                                }), na(_, f2), ra(_, f2), _.schema = 41), O < 42 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        O.events.forEach(_ => {
                                            "GameControl" === _.type && Object.assign(_.gameActions, {
                                                run: new ur
                                            })
                                        })
                                    })
                                }(_), _.schema = 42), O < 43 && (function(_) {
                                    _.scene.objects.traverse((_, O) => {
                                        O.events.forEach(_ => {
                                            "GameControl" === _.type && (_.keyAssignments = [..._.keyAssignments, ["run", "⇧"],
                                                ["none", "Ctrl"]
                                            ])
                                        })
                                    })
                                }(_), _.schema = 43), O < 99) {
                                na(_, p2), ra(_, p2), null === _.scene.publish.playCamera && (_.scene.publish.playCamera = pq);
                                let O = xr(_.scene.objects),
                                    B = _.scene.objects;
                                for (let N of (_.scene.publish.playPage = pY, B.insertBefore(null, null, [{
                                        id: pY,
                                        data: { ...gx.defaultData,
                                            backgroundColor: _.scene.backgroundColor,
                                            fog: _.scene.fog,
                                            postprocessing: _.scene.postprocessing,
                                            ao: dk(_.scene.environment.ambientLight, "occlusion", "aoFullRes", "radius", "bias", "aoColor"),
                                            publish: {
                                                playCamera: _.scene.publish.playCamera,
                                                gameControlObject: _.scene.publish.gameControlObject
                                            },
                                            shadow: dk(_.scene.environment.ambientLight, "softShadowQuality"),
                                            globalPhysics: { ...gr.defaultData,
                                                ...dk(_.scene.environment, "usePhysics", "gravity")
                                            },
                                            camera: xr(_.scene.ownerCamera) ? ? gx.defaultData.camera,
                                            name: "Scene"
                                        },
                                        children: []
                                    }]), O)) N.id !== gP.TRASH_CAN_ID && B.move(pY, N.fi, N.id);
                                let N = 0,
                                    k = 0;
                                _.shared.penumbraSize && _.scene.objects.traverse((O, B) => {
                                    "DirectionalLight" === B.type ? (B.penumbraSize = _.shared.penumbraSize[Math.min(N, 2)], N += 1) : "SpotLight" === B.type && (B.penumbraSize = _.shared.penumbraSize[3 + Math.min(k, 1)], k += 1), (void 0 === B.physics || null === B.physics) && "Instance" !== B.type && (B.physics = {}, Object.assign(B.physics, f$.defaultData)), void 0 !== B.physics && null !== B.physics && (B.physics.enabled = B.collision ? ? "visibility", delete B.collision)
                                }), _.schema = 99
                            }
                        }(_, O), O < 100 && (void 0 === _.scene.publish.joystickSizeAndXYOffset && (_.scene.publish.joystickSizeAndXYOffset = gM.defaultData.joystickSizeAndXYOffset), _.schema = 100), O < 101 && (na(_, g2), ra(_, g2), _.schema = 101), O < 102 && (function(_) {
                            _.scene.objects.traverse((_, O) => {
                                let B = O.geometry;
                                B && "PathGeometry" === B.type && (B.extrusion.capType = "flat", B.extrusion.bevel = 50, B.extrusion.bevelSides = 6, "Custom" === B.extrusion.shape.type && (B.extrusion.shape.shapeQuality = "low"))
                            })
                        }(_), _.schema = 102), O < 104 && (_.shared.catelogs = new d7, _.shared.lib = gN.defaultData(), _.schema = 104), O < 105 && (_.shared.variables = ui({}, d7.prototype), _.scene.objects.traverse((_, O) => {
                            v2(O)
                        }), _.schema = 105), Object.values(_.shared.lib.components))) ! function(_) {
                        let O = _.schema ? ? 104;
                        107 !== O && O < 105 && (function x2(_, O) {
                            for (let B of (O(_.data), _.children)) x2(B, O)
                        }(_.asset, v2), _.schema = 105)
                    }(B);
                    O < 106 && (B = xr(_.shared.variables), _.shared.variables = ui(Object.entries(B ? ? {}).map(([_, O], B) => ({
                        fi: B,
                        id: _,
                        data: O
                    })), ur.prototype), _.schema = 106), O < 107 && (_.shared.lib.variables = gN.defaultData().variables, _.schema = 107)
                }
            }

            function ws(_, O = !1) {
                let B = null !== _[0].index,
                    N = new Set(Object.keys(_[0].attributes)),
                    k = new Set(Object.keys(_[0].morphAttributes)),
                    F = {},
                    U = {},
                    j = _[0].morphTargetsRelative,
                    G = new sK,
                    Y = 0;
                for (let Q = 0; Q < _.length; ++Q) {
                    let K = _[Q],
                        $ = 0;
                    if (B !== (null !== K.index)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + Q + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
                    for (let _ in K.attributes) {
                        if (!N.has(_)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + Q + '. All geometries must have compatible attributes; make sure "' + _ + '" attribute exists among all geometries, or in none of them.'), null;
                        void 0 === F[_] && (F[_] = []), F[_].push(K.attributes[_]), $++
                    }
                    if ($ !== N.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + Q + ". Make sure all geometries have the same number of attributes."), null;
                    if (j !== K.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + Q + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
                    for (let _ in K.morphAttributes) {
                        if (!k.has(_)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + Q + ".  .morphAttributes must be consistent throughout all geometries."), null;
                        void 0 === U[_] && (U[_] = []), U[_].push(K.morphAttributes[_])
                    }
                    if (O) {
                        let _;
                        if (B) _ = K.index.count;
                        else {
                            if (void 0 === K.attributes.position) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + Q + ". The geometry must have either an index or a position attribute"), null;
                            _ = K.attributes.position.count
                        }
                        G.addGroup(Y, _, Q), Y += _
                    }
                }
                if (B) {
                    let O = 0,
                        B = [];
                    for (let N = 0; N < _.length; ++N) {
                        let k = _[N].index;
                        for (let _ = 0; _ < k.count; ++_) B.push(k.getX(_) + O);
                        O += _[N].attributes.position.count
                    }
                    G.setIndex(B)
                }
                for (let _ in F) {
                    let O = b2(F[_]);
                    if (!O) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + _ + " attribute."), null;
                    G.setAttribute(_, O)
                }
                for (let _ in U) {
                    let O = U[_][0].length;
                    if (0 === O) break;
                    G.morphAttributes = G.morphAttributes || {}, G.morphAttributes[_] = [];
                    for (let B = 0; B < O; ++B) {
                        let O = [];
                        for (let N = 0; N < U[_].length; ++N) O.push(U[_][N][B]);
                        let N = b2(O);
                        if (!N) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + _ + " morphAttribute."), null;
                        G.morphAttributes[_].push(N)
                    }
                }
                return G
            }

            function b2(_) {
                let O, B, N, k = 0;
                for (let F = 0; F < _.length; ++F) {
                    let U = _[F];
                    if (U.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null;
                    if (void 0 === O && (O = U.array.constructor), O !== U.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
                    if (void 0 === B && (B = U.itemSize), B !== U.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
                    if (void 0 === N && (N = U.normalized), N !== U.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
                    k += U.array.length
                }
                let F = new O(k),
                    U = 0;
                for (let O = 0; O < _.length; ++O) F.set(_[O].array, U), U += _[O].array.length;
                return new sF(F, B, N)
            }(m$ = gj || (gj = {})).defaultData = {
                schema: 107,
                scene: gP.defaultData,
                frames: new d7().add("72fc2993-2da3-4b6b-96ac-2879db3a28bd", gI.defaultData),
                shared: { ...gk.emptyData(),
                    colors: gk.defaultColors()
                }
            }, m$.emptyDataForImports = function(_) {
                return {
                    schema: 107,
                    scene: gP.emptyDataWithPage(_),
                    frames: new d7().add("72fc2993-2da3-4b6b-96ac-2879db3a28bd", gI.defaultData),
                    shared: { ...gk.emptyData(),
                        colors: gk.defaultColors(),
                        images: gk.defaultImages(_)
                    }
                }
            }, m$.emptyData = function() {
                return {
                    schema: 107,
                    scene: gP.emptyDataWithPage(),
                    frames: new d7().add("72fc2993-2da3-4b6b-96ac-2879db3a28bd", gI.defaultData),
                    shared: gk.emptyData()
                }
            }, m$.collabHelper = { ...uB,
                updateSchema: _ => (_.schema ? ? 0) < 107 ? Ha(_, tv) : (_.schema ? ? 0) - 107
            }, m$.updateSchemaDirectly = function(_) {
                let O = m$.collabHelper.updateSchema(_);
                return "number" == typeof O ? 0 === O ? _ : null : O.data
            }, m$.withoutLib = function(_) {
                return { ..._,
                    shared: { ..._.shared,
                        lib: gN.defaultData()
                    }
                }
            }, m$.getComponentData = function(_, O) {
                let B = _.scene.objects.get(O);
                if (B && "Component" === B.data.type) return B; {
                    let B = _.shared.lib.components[O];
                    if (B) return B.asset
                }
            };
            var mh = class {
                constructor() {}
            };

            function Ki(_, O, B) {
                return B.min.x = O[_], B.min.y = O[_ + 1], B.min.z = O[_ + 2], B.max.x = O[_ + 3], B.max.y = O[_ + 4], B.max.z = O[_ + 5], B
            }

            function lS(_) {
                let O = -1,
                    B = -1 / 0;
                for (let N = 0; N < 3; N++) {
                    let k = _[N + 3] - _[N];
                    k > B && (B = k, O = N)
                }
                return O
            }

            function uS(_, O, B) {
                let N, k;
                for (let F = 0; F < 3; F++) {
                    let U = F + 3;
                    N = _[F], k = O[F], B[F] = N < k ? N : k, N = _[U], k = O[U], B[U] = N > k ? N : k
                }
            }

            function gp(_, O, B) {
                for (let N = 0; N < 3; N++) {
                    let k = O[_ + 2 * N],
                        F = O[_ + 2 * N + 1],
                        U = k - F,
                        j = k + F;
                    U < B[N] && (B[N] = U), j > B[N + 3] && (B[N + 3] = j)
                }
            }

            function Ch(_) {
                let O = _[3] - _[0],
                    B = _[4] - _[1],
                    N = _[5] - _[2];
                return 2 * (O * B + B * N + N * O)
            }

            function dS(_, O, B, N, k = null) {
                let F = 1 / 0,
                    U = 1 / 0,
                    j = 1 / 0,
                    G = -1 / 0,
                    Y = -1 / 0,
                    Q = -1 / 0,
                    K = 1 / 0,
                    $ = 1 / 0,
                    ee = 1 / 0,
                    et = -1 / 0,
                    ei = -1 / 0,
                    er = -1 / 0,
                    ea = null !== k;
                for (let N = 6 * O, k = (O + B) * 6; N < k; N += 6) {
                    let O = _[N + 0],
                        B = _[N + 1],
                        k = O - B,
                        en = O + B;
                    k < F && (F = k), en > G && (G = en), ea && O < K && (K = O), ea && O > et && (et = O);
                    let eo = _[N + 2],
                        el = _[N + 3],
                        eh = eo - el,
                        ec = eo + el;
                    eh < U && (U = eh), ec > Y && (Y = ec), ea && eo < $ && ($ = eo), ea && eo > ei && (ei = eo);
                    let eu = _[N + 4],
                        ep = _[N + 5],
                        ef = eu - ep,
                        em = eu + ep;
                    ef < j && (j = ef), em > Q && (Q = em), ea && eu < ee && (ee = eu), ea && eu > er && (er = eu)
                }
                N[0] = F, N[1] = U, N[2] = j, N[3] = G, N[4] = Y, N[5] = Q, ea && (k[0] = K, k[1] = $, k[2] = ee, k[3] = et, k[4] = ei, k[5] = er)
            }
            var Z6 = (_, O) => _.candidate - O.candidate,
                md = Array(32).fill().map(() => ({
                    count: 0,
                    bounds: new Float32Array(6),
                    rightCacheBounds: new Float32Array(6),
                    leftCacheBounds: new Float32Array(6),
                    candidate: 0
                })),
                mu = new Float32Array(6),
                mp = class {
                    constructor() {
                        this.min = 1 / 0, this.max = -1 / 0
                    }
                    setFromPointsField(_, O) {
                        let B = 1 / 0,
                            N = -1 / 0;
                        for (let k = 0, F = _.length; k < F; k++) {
                            let F = _[k][O];
                            B = F < B ? F : B, N = F > N ? F : N
                        }
                        this.min = B, this.max = N
                    }
                    setFromPoints(_, O) {
                        let B = 1 / 0,
                            N = -1 / 0;
                        for (let k = 0, F = O.length; k < F; k++) {
                            let F = O[k],
                                U = _.dot(F);
                            B = U < B ? U : B, N = U > N ? U : N
                        }
                        this.min = B, this.max = N
                    }
                    isSeparated(_) {
                        return this.min > _.max || _.min > this.max
                    }
                };
            mp.prototype.setFromBox = (F = new rv, function(_, O) {
                let B = O.min,
                    N = O.max,
                    k = 1 / 0,
                    U = -1 / 0;
                for (let O = 0; O <= 1; O++)
                    for (let j = 0; j <= 1; j++)
                        for (let G = 0; G <= 1; G++) {
                            F.x = B.x * O + N.x * (1 - O), F.y = B.y * j + N.y * (1 - j), F.z = B.z * G + N.z * (1 - G);
                            let Y = _.dot(F);
                            k = Math.min(Y, k), U = Math.max(Y, U)
                        }
                this.min = k, this.max = U
            }), new mp;
            var mf = (U = new rv, j = new rv, G = new rv, function(_, O, B) {
                    let N = _.start,
                        k = O.start;
                    G.subVectors(N, k), U.subVectors(_.end, _.start), j.subVectors(O.end, O.start);
                    let F = G.dot(j),
                        Y = j.dot(U),
                        Q = j.dot(j),
                        K = G.dot(U),
                        $ = U.dot(U) * Q - Y * Y,
                        ee, et;
                    ee = 0 !== $ ? (F * Y - K * Q) / $ : 0, et = (F + ee * Y) / Q, B.x = ee, B.y = et
                }),
                mm = (Y = new iJ, Q = new rv, K = new rv, function(_, O, B, N) {
                    mf(_, O, Y);
                    let k = Y.x,
                        F = Y.y;
                    if (k >= 0 && k <= 1 && F >= 0 && F <= 1) {
                        _.at(k, B), O.at(F, N);
                        return
                    }
                    if (k >= 0 && k <= 1) {
                        F < 0 ? O.at(0, N) : O.at(1, N), _.closestPointToPoint(N, !0, B);
                        return
                    }
                    if (F >= 0 && F <= 1) {
                        k < 0 ? _.at(0, B) : _.at(1, B), O.closestPointToPoint(B, !0, N);
                        return
                    } {
                        let U, j;
                        if (U = k < 0 ? _.start : _.end, j = F < 0 ? O.start : O.end, _.closestPointToPoint(j, !0, Q), O.closestPointToPoint(U, !0, K), Q.distanceToSquared(j) <= K.distanceToSquared(U)) {
                            B.copy(Q), N.copy(j);
                            return
                        }
                        B.copy(U), N.copy(K);
                        return
                    }
                }),
                mg = ($ = new rv, ee = new rv, et = new av, ei = new lP, function(_, O) {
                    let {
                        radius: B,
                        center: N
                    } = _, {
                        a: k,
                        b: F,
                        c: U
                    } = O;
                    if (ei.start = k, ei.end = F, ei.closestPointToPoint(N, !0, $).distanceTo(N) <= B || (ei.start = k, ei.end = U, ei.closestPointToPoint(N, !0, $).distanceTo(N) <= B) || (ei.start = F, ei.end = U, ei.closestPointToPoint(N, !0, $).distanceTo(N) <= B)) return !0;
                    let j = O.getPlane(et);
                    if (Math.abs(j.distanceToPoint(N)) <= B) {
                        let _ = j.projectPoint(N, ee);
                        if (O.containsPoint(_)) return !0
                    }
                    return !1
                });

            function Ph(_) {
                return 1e-15 > Math.abs(_)
            }
            var mv = class extends sO {
                constructor(..._) {
                    super(..._), this.isExtendedTriangle = !0, this.satAxes = [, , , , ].fill().map(() => new rv), this.satBounds = [, , , , ].fill().map(() => new mp), this.points = [this.a, this.b, this.c], this.sphere = new rG, this.plane = new av, this.needsUpdate = !0
                }
                intersectsSphere(_) {
                    return mg(_, this)
                }
                update() {
                    let _ = this.a,
                        O = this.b,
                        B = this.c,
                        N = this.points,
                        k = this.satAxes,
                        F = this.satBounds,
                        U = k[0],
                        j = F[0];
                    this.getNormal(U), j.setFromPoints(U, N);
                    let G = k[1],
                        Y = F[1];
                    G.subVectors(_, O), Y.setFromPoints(G, N);
                    let Q = k[2],
                        K = F[2];
                    Q.subVectors(O, B), K.setFromPoints(Q, N);
                    let $ = k[3],
                        ee = F[3];
                    $.subVectors(B, _), ee.setFromPoints($, N), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(U, _), this.needsUpdate = !1
                }
            };
            mv.prototype.closestPointToSegment = (er = new rv, ea = new rv, en = new lP, function(_, O = null, B = null) {
                let {
                    start: N,
                    end: k
                } = _, F = this.points, U, j = 1 / 0;
                for (let N = 0; N < 3; N++) {
                    let k = (N + 1) % 3;
                    en.start.copy(F[N]), en.end.copy(F[k]), mm(en, _, er, ea), (U = er.distanceToSquared(ea)) < j && (j = U, O && O.copy(er), B && B.copy(ea))
                }
                return this.closestPointToPoint(N, er), (U = N.distanceToSquared(er)) < j && (j = U, O && O.copy(er), B && B.copy(N)), this.closestPointToPoint(k, er), (U = k.distanceToSquared(er)) < j && (j = U, O && O.copy(er), B && B.copy(k)), Math.sqrt(j)
            }), mv.prototype.intersectsTriangle = (eo = new mv, el = [, , , ], eh = [, , , ], ec = new mp, eu = new mp, ep = new rv, ef = new rv, em = new rv, eg = new rv, ev = new lP, ex = new lP, eb = new lP, function(_, O = null, B = !1) {
                this.needsUpdate && this.update(), _.isExtendedTriangle ? _.needsUpdate && _.update() : (eo.copy(_), eo.update(), _ = eo);
                let N = this.plane,
                    k = _.plane;
                if (Math.abs(N.normal.dot(k.normal)) > 1 - 1e-10) {
                    let N = this.satBounds,
                        k = this.satAxes;
                    eh[0] = _.a, eh[1] = _.b, eh[2] = _.c;
                    for (let _ = 0; _ < 4; _++) {
                        let O = N[_],
                            B = k[_];
                        if (ec.setFromPoints(B, eh), O.isSeparated(ec)) return !1
                    }
                    let F = _.satBounds,
                        U = _.satAxes;
                    el[0] = this.a, el[1] = this.b, el[2] = this.c;
                    for (let _ = 0; _ < 4; _++) {
                        let O = F[_],
                            B = U[_];
                        if (ec.setFromPoints(B, el), O.isSeparated(ec)) return !1
                    }
                    for (let _ = 0; _ < 4; _++) {
                        let O = k[_];
                        for (let _ = 0; _ < 4; _++) {
                            let B = U[_];
                            if (ep.crossVectors(O, B), ec.setFromPoints(ep, el), eu.setFromPoints(ep, eh), ec.isSeparated(eu)) return !1
                        }
                    }
                    return O && (B || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), O.start.set(0, 0, 0), O.end.set(0, 0, 0)), !0
                } {
                    let B = this.points,
                        F = !1,
                        U = 0;
                    for (let _ = 0; _ < 3; _++) {
                        let O = B[_],
                            N = B[(_ + 1) % 3];
                        ev.start.copy(O), ev.end.copy(N), ev.delta(ef);
                        let j = F ? ex.start : ex.end,
                            G = Ph(k.distanceToPoint(O));
                        if (Ph(k.normal.dot(ef)) && G) {
                            ex.copy(ev), U = 2;
                            break
                        }
                        if ((k.intersectLine(ev, j) || G) && !Ph(j.distanceTo(N))) {
                            if (U++, F) break;
                            F = !0
                        }
                    }
                    if (1 === U && _.containsPoint(ex.end)) return O && (O.start.copy(ex.end), O.end.copy(ex.end)), !0;
                    if (2 !== U) return !1;
                    let j = _.points,
                        G = !1,
                        Y = 0;
                    for (let _ = 0; _ < 3; _++) {
                        let O = j[_],
                            B = j[(_ + 1) % 3];
                        ev.start.copy(O), ev.end.copy(B), ev.delta(em);
                        let k = G ? eb.start : eb.end,
                            F = Ph(N.distanceToPoint(O));
                        if (Ph(N.normal.dot(em)) && F) {
                            eb.copy(ev), Y = 2;
                            break
                        }
                        if ((N.intersectLine(ev, k) || F) && !Ph(k.distanceTo(B))) {
                            if (Y++, G) break;
                            G = !0
                        }
                    }
                    if (1 === Y && this.containsPoint(eb.end)) return O && (O.start.copy(eb.end), O.end.copy(eb.end)), !0;
                    if (2 !== Y) return !1;
                    if (ex.delta(ef), eb.delta(em), 0 > ef.dot(em)) {
                        let _ = eb.start;
                        eb.start = eb.end, eb.end = _
                    }
                    let Q = ex.start.dot(ef),
                        K = ex.end.dot(ef),
                        $ = eb.start.dot(ef),
                        ee = eb.end.dot(ef);
                    return (Q === ee || $ === K || K < $ != Q < ee) && (O && (eg.subVectors(ex.start, eb.start), eg.dot(ef) > 0 ? O.start.copy(ex.start) : O.start.copy(eb.start), eg.subVectors(ex.end, eb.end), 0 > eg.dot(ef) ? O.end.copy(ex.end) : O.end.copy(eb.end)), !0)
                }
            }), mv.prototype.distanceToPoint = (e_ = new rv, function(_) {
                return this.closestPointToPoint(_, e_), _.distanceTo(e_)
            }), mv.prototype.distanceToTriangle = (eS = new rv, eA = new rv, eM = ["a", "b", "c"], eE = new lP, eC = new lP, function(_, O = null, B = null) {
                let N = O || B ? eE : null;
                if (this.intersectsTriangle(_, N)) return (O || B) && (O && N.getCenter(O), B && N.getCenter(B)), 0;
                let k = 1 / 0;
                for (let N = 0; N < 3; N++) {
                    let F, U = eM[N],
                        j = _[U];
                    this.closestPointToPoint(j, eS), (F = j.distanceToSquared(eS)) < k && (k = F, O && O.copy(eS), B && B.copy(j));
                    let G = this[U];
                    _.closestPointToPoint(G, eS), (F = G.distanceToSquared(eS)) < k && (k = F, O && O.copy(G), B && B.copy(eS))
                }
                for (let N = 0; N < 3; N++) {
                    let F = eM[N],
                        U = eM[(N + 1) % 3];
                    eE.set(this[F], this[U]);
                    for (let N = 0; N < 3; N++) {
                        let F = eM[N],
                            U = eM[(N + 1) % 3];
                        eC.set(_[F], _[U]), mm(eE, eC, eS, eA);
                        let j = eS.distanceToSquared(eA);
                        j < k && (k = j, O && O.copy(eS), B && B.copy(eA))
                    }
                }
                return Math.sqrt(k)
            });
            var mx = class {
                constructor(_, O, B) {
                    this.isOrientedBox = !0, this.min = new rv, this.max = new rv, this.matrix = new rJ, this.invMatrix = new rJ, this.points = Array(8).fill().map(() => new rv), this.satAxes = [, , , ].fill().map(() => new rv), this.satBounds = [, , , ].fill().map(() => new mp), this.alignedSatBounds = [, , , ].fill().map(() => new mp), this.needsUpdate = !1, _ && this.min.copy(_), O && this.max.copy(O), B && this.matrix.copy(B)
                }
                set(_, O, B) {
                    this.min.copy(_), this.max.copy(O), this.matrix.copy(B), this.needsUpdate = !0
                }
                copy(_) {
                    this.min.copy(_.min), this.max.copy(_.max), this.matrix.copy(_.matrix), this.needsUpdate = !0
                }
            };
            mx.prototype.update = function() {
                let _ = this.matrix,
                    O = this.min,
                    B = this.max,
                    N = this.points;
                for (let k = 0; k <= 1; k++)
                    for (let F = 0; F <= 1; F++)
                        for (let U = 0; U <= 1; U++) {
                            let j = N[1 * k | 2 * F | 4 * U];
                            j.x = k ? B.x : O.x, j.y = F ? B.y : O.y, j.z = U ? B.z : O.z, j.applyMatrix4(_)
                        }
                let k = this.satBounds,
                    F = this.satAxes,
                    U = N[0];
                for (let _ = 0; _ < 3; _++) {
                    let O = F[_],
                        B = k[_],
                        j = N[1 << _];
                    O.subVectors(U, j), B.setFromPoints(O, N)
                }
                let j = this.alignedSatBounds;
                j[0].setFromPointsField(N, "x"), j[1].setFromPointsField(N, "y"), j[2].setFromPointsField(N, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1
            }, mx.prototype.intersectsBox = (eT = new mp, function(_) {
                this.needsUpdate && this.update();
                let O = _.min,
                    B = _.max,
                    N = this.satBounds,
                    k = this.satAxes,
                    F = this.alignedSatBounds;
                if (eT.min = O.x, eT.max = B.x, F[0].isSeparated(eT) || (eT.min = O.y, eT.max = B.y, F[1].isSeparated(eT)) || (eT.min = O.z, eT.max = B.z, F[2].isSeparated(eT))) return !1;
                for (let O = 0; O < 3; O++) {
                    let B = k[O],
                        F = N[O];
                    if (eT.setFromBox(B, _), F.isSeparated(eT)) return !1
                }
                return !0
            }), mx.prototype.intersectsTriangle = (eD = new mv, eP = [, , , ], eI = new mp, eO = new mp, eL = new rv, function(_) {
                this.needsUpdate && this.update(), _.isExtendedTriangle ? _.needsUpdate && _.update() : (eD.copy(_), eD.update(), _ = eD);
                let O = this.satBounds,
                    B = this.satAxes;
                eP[0] = _.a, eP[1] = _.b, eP[2] = _.c;
                for (let _ = 0; _ < 3; _++) {
                    let N = O[_],
                        k = B[_];
                    if (eI.setFromPoints(k, eP), N.isSeparated(eI)) return !1
                }
                let N = _.satBounds,
                    k = _.satAxes,
                    F = this.points;
                for (let _ = 0; _ < 3; _++) {
                    let O = N[_],
                        B = k[_];
                    if (eI.setFromPoints(B, F), O.isSeparated(eI)) return !1
                }
                for (let _ = 0; _ < 3; _++) {
                    let O = B[_];
                    for (let _ = 0; _ < 4; _++) {
                        let B = k[_];
                        if (eL.crossVectors(O, B), eI.setFromPoints(eL, eP), eO.setFromPoints(eL, F), eI.isSeparated(eO)) return !1
                    }
                }
                return !0
            }), mx.prototype.closestPointToPoint = function(_, O) {
                return this.needsUpdate && this.update(), O.copy(_).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), O
            }, mx.prototype.distanceToPoint = (eR = new rv, function(_) {
                return this.closestPointToPoint(_, eR), _.distanceTo(eR)
            }), mx.prototype.distanceToBox = (eB = ["x", "y", "z"], eN = Array(12).fill().map(() => new lP), ek = Array(12).fill().map(() => new lP), eF = new rv, eU = new rv, function(_, O = 0, B = null, N = null) {
                if (this.needsUpdate && this.update(), this.intersectsBox(_)) return (B || N) && (_.getCenter(eU), this.closestPointToPoint(eU, eF), _.closestPointToPoint(eF, eU), B && B.copy(eF), N && N.copy(eU)), 0;
                let k = O * O,
                    F = _.min,
                    U = _.max,
                    j = this.points,
                    G = 1 / 0;
                for (let _ = 0; _ < 8; _++) {
                    let O = j[_];
                    eU.copy(O).clamp(F, U);
                    let Y = O.distanceToSquared(eU);
                    if (Y < G && (G = Y, B && B.copy(O), N && N.copy(eU), Y < k)) return Math.sqrt(Y)
                }
                let Y = 0;
                for (let _ = 0; _ < 3; _++)
                    for (let O = 0; O <= 1; O++)
                        for (let B = 0; B <= 1; B++) {
                            let N = (_ + 1) % 3,
                                k = (_ + 2) % 3,
                                G = O << N | B << k,
                                Q = 1 << _ | O << N | B << k,
                                K = j[G],
                                $ = j[Q];
                            eN[Y].set(K, $);
                            let ee = eB[_],
                                et = eB[N],
                                ei = eB[k],
                                er = ek[Y],
                                ea = er.start,
                                en = er.end;
                            ea[ee] = F[ee], ea[et] = O ? F[et] : U[et], ea[ei] = B ? F[ei] : U[et], en[ee] = U[ee], en[et] = O ? F[et] : U[et], en[ei] = B ? F[ei] : U[et], Y++
                        }
                for (let _ = 0; _ <= 1; _++)
                    for (let O = 0; O <= 1; O++)
                        for (let j = 0; j <= 1; j++) {
                            eU.x = _ ? U.x : F.x, eU.y = O ? U.y : F.y, eU.z = j ? U.z : F.z, this.closestPointToPoint(eU, eF);
                            let Y = eU.distanceToSquared(eF);
                            if (Y < G && (G = Y, B && B.copy(eF), N && N.copy(eU), Y < k)) return Math.sqrt(Y)
                        }
                for (let _ = 0; _ < 12; _++) {
                    let O = eN[_];
                    for (let _ = 0; _ < 12; _++) {
                        mm(O, ek[_], eF, eU);
                        let F = eF.distanceToSquared(eU);
                        if (F < G && (G = F, B && B.copy(eF), N && N.copy(eU), F < k)) return Math.sqrt(F)
                    }
                }
                return Math.sqrt(G)
            });
            var mb = new rv,
                m_ = new rv,
                mA = new rv,
                mE = new iJ,
                mC = new iJ,
                mT = new iJ,
                mD = new rv,
                mP = new rv,
                mI = new rv,
                mO = new rv;

            function pS(_, O, B, N, k) {
                let F = 3 * N,
                    U = _.index.getX(F),
                    j = _.index.getX(F + 1),
                    G = _.index.getX(F + 2),
                    {
                        position: Y,
                        normal: Q,
                        uv: K,
                        uv1: $
                    } = _.attributes,
                    ee = function(_, O, B, N, k, F, U, j, G) {
                        mb.fromBufferAttribute(O, F), m_.fromBufferAttribute(O, U), mA.fromBufferAttribute(O, j);
                        let Y = null === (1 === G ? _.intersectTriangle(mA, m_, mb, !0, mO) : _.intersectTriangle(mb, m_, mA, 2 !== G, mO)) ? null : {
                            distance: _.origin.distanceTo(mO),
                            point: mO.clone()
                        };
                        if (Y) {
                            N && (mE.fromBufferAttribute(N, F), mC.fromBufferAttribute(N, U), mT.fromBufferAttribute(N, j), Y.uv = sO.getInterpolation(mO, mb, m_, mA, mE, mC, mT, new iJ)), k && (mE.fromBufferAttribute(k, F), mC.fromBufferAttribute(k, U), mT.fromBufferAttribute(k, j), Y.uv1 = sO.getInterpolation(mO, mb, m_, mA, mE, mC, mT, new iJ)), B && (mD.fromBufferAttribute(B, F), mP.fromBufferAttribute(B, U), mI.fromBufferAttribute(B, j), Y.normal = sO.getInterpolation(mO, mb, m_, mA, mD, mP, mI, new rv), Y.normal.dot(_.direction) > 0 && Y.normal.multiplyScalar(-1));
                            let O = {
                                a: F,
                                b: U,
                                c: j,
                                normal: new rv,
                                materialIndex: 0
                            };
                            sO.getNormal(mb, m_, mA, O.normal), Y.face = O, Y.faceIndex = F
                        }
                        return Y
                    }(B, Y, Q, K, $, U, j, G, O);
                return ee ? (ee.faceIndex = N, k && k.push(ee), ee) : null
            }

            function Zi(_, O, B, N) {
                let k = _.a,
                    F = _.b,
                    U = _.c,
                    j = O,
                    G = O + 1,
                    Y = O + 2;
                B && (j = B.getX(O), G = B.getX(O + 1), Y = B.getX(O + 2)), k.x = N.getX(j), k.y = N.getY(j), k.z = N.getZ(j), F.x = N.getX(G), F.y = N.getY(G), F.z = N.getZ(G), U.x = N.getX(Y), U.y = N.getY(Y), U.z = N.getZ(Y)
            }

            function mS(_, O, B, N, k, F, U) {
                let j = B.index,
                    G = B.attributes.position;
                for (let B = _, Y = O + _; B < Y; B++)
                    if (Zi(U, 3 * B, j, G), U.needsUpdate = !0, N(U, B, k, F)) return !0;
                return !1
            }
            var mL = class {
                constructor(_) {
                    this._getNewPrimitive = _, this._primitives = []
                }
                getPrimitive() {
                    let _ = this._primitives;
                    return 0 === _.length ? this._getNewPrimitive() : _.pop()
                }
                releasePrimitive(_) {
                    this._primitives.push(_)
                }
            };

            function oa(_, O) {
                return 65535 === O[_ + 15]
            }
            var mR = new rb,
                mB = new rv,
                mN = ["x", "y", "z"],
                mk = (eH = [], eW = new mL(() => new rb), function(..._) {
                    ej = eW.getPrimitive(), eG = eW.getPrimitive(), eH.push(ej, eG);
                    let O = function n(_, O, B, N, k = null, F = 0, U = 0) {
                        function d(_) {
                            let O = 2 * _,
                                B = gW,
                                N = gY;
                            for (; !oa(O, B);) _ += 8, O = 2 * _;
                            return N[_ + 6]
                        }

                        function f(_) {
                            let O = 2 * _,
                                B = gW,
                                N = gY;
                            for (; !oa(O, B);) O = 2 * (_ = N[_ + 6]);
                            return N[_ + 6] + B[O + 14]
                        }
                        let j = 2 * _,
                            G = gH,
                            Y = gW,
                            Q = gY;
                        if (oa(j, Y)) {
                            let O = Q[_ + 6],
                                B = Y[j + 14];
                            return Ki(_, G, ej), N(O, B, !1, U, F + _, ej)
                        } {
                            let j = _ + 8,
                                K = Q[_ + 6],
                                $ = j,
                                ee = K,
                                et, ei, er, ea;
                            if (k && (er = ej, ea = eG, Ki($, G, er), Ki(ee, G, ea), et = k(er), (ei = k(ea)) < et)) {
                                $ = K, ee = j;
                                let _ = et;
                                et = ei, ei = _, er = ea
                            }
                            er || Ki($, G, er = ej);
                            let en = B(er, oa(2 * $, Y), et, U + 1, F + $),
                                eo;
                            if (2 === en) {
                                let _ = d($),
                                    O = f($) - _;
                                eo = N(_, O, !0, U + 1, F + $, er)
                            } else eo = en && n($, O, B, N, k, F, U + 1);
                            if (eo) return !0;
                            Ki(ee, G, ea = eG);
                            let el = B(ea, oa(2 * ee, Y), ei, U + 1, F + ee),
                                eh;
                            if (2 === el) {
                                let _ = d(ee),
                                    O = f(ee) - _;
                                eh = N(_, O, !0, U + 1, F + ee, ea)
                            } else eh = el && n(ee, O, B, N, k, F, U + 1);
                            return !!eh
                        }
                    }(..._);
                    eW.releasePrimitive(ej), eW.releasePrimitive(eG), eH.pop(), eH.pop();
                    let B = eH.length;
                    return B > 0 && (eG = eH[B - 1], ej = eH[B - 2]), O
                }),
                mF = (eq = new mv, eY = new mv, eX = new rJ, eQ = new mx, eZ = new mx, function s(_, O, B, N, k = null) {
                    let F = 2 * _,
                        U = gH,
                        j = gW,
                        G = gY;
                    if (null === k && (B.boundingBox || B.computeBoundingBox(), eQ.set(B.boundingBox.min, B.boundingBox.max, N), k = eQ), oa(F, j)) {
                        let k = O.index,
                            Y = O.attributes.position,
                            Q = B.index,
                            K = B.attributes.position,
                            $ = G[_ + 6],
                            ee = j[F + 14];
                        if (eX.copy(N).invert(), B.boundsTree) return Ki(_, U, eZ), eZ.matrix.copy(eX), eZ.needsUpdate = !0, B.boundsTree.shapecast({
                            intersectsBounds: _ => eZ.intersectsBox(_),
                            intersectsTriangle: _ => {
                                _.a.applyMatrix4(N), _.b.applyMatrix4(N), _.c.applyMatrix4(N), _.needsUpdate = !0;
                                for (let O = 3 * $, B = (ee + $) * 3; O < B; O += 3)
                                    if (Zi(eY, O, k, Y), eY.needsUpdate = !0, _.intersectsTriangle(eY)) return !0;
                                return !1
                            }
                        });
                        for (let _ = 3 * $, O = ee + 3 * $; _ < O; _ += 3) {
                            Zi(eq, _, k, Y), eq.a.applyMatrix4(eX), eq.b.applyMatrix4(eX), eq.c.applyMatrix4(eX), eq.needsUpdate = !0;
                            for (let _ = 0, O = Q.count; _ < O; _ += 3)
                                if (Zi(eY, _, Q, K), eY.needsUpdate = !0, eq.intersectsTriangle(eY)) return !0
                        }
                    } else {
                        let F = _ + 8,
                            j = G[_ + 6];
                        return Ki(F, U, mR), !!(k.intersectsBox(mR) && s(F, O, B, N, k) || (Ki(j, U, mR), k.intersectsBox(mR) && s(j, O, B, N, k)))
                    }
                });

            function dv(_, O, B, N) {
                return Ki(_, O, mR), B.intersectBox(mR, N)
            }
            var mU, mj, mG, mH, mW, mY, mX, mQ, mZ, mK, mJ, m$, m0, m2, m3, m4, m5, m6, m8, m9, m7, ge, gt, gi, gr, gs, ga, gn, gl, gh, gd, gu, gf, gm, gg, gv, gy, gx, gb, gS, gA, gM, gE, gC, gT, gD, gP, gI, gO, gL, gR, gB, gz, gN, gk, gF, gU, gj, gG, gH, gW, gY, gX = [];

            function Vh(_) {
                gG && gX.push(gG), gG = _, gH = new Float32Array(_), gW = new Uint16Array(_), gY = new Uint32Array(_)
            }

            function vp() {
                gG = null, gH = null, gW = null, gY = null, gX.length && Vh(gX.pop())
            }
            var gQ = Symbol("skip tree generation"),
                gZ = new rb,
                gK = new rb,
                gJ = new rJ,
                g$ = new mx,
                g0 = new mx,
                g3 = new rv,
                g4 = new rv,
                g5 = new rv,
                g6 = new rv,
                g9 = new rv,
                g7 = new rb,
                ve = new mL(() => new mv),
                vt = class {
                    static serialize(_, O = {}) {
                        if (O.isBufferGeometry) return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."), vt.serialize(arguments[0], {
                            cloneBuffers: void 0 === arguments[2] || arguments[2]
                        });
                        O = {
                            cloneBuffers: !0,
                            ...O
                        };
                        let B = _.geometry,
                            N = _._roots,
                            k = B.getIndex();
                        return O.cloneBuffers ? {
                            roots: N.map(_ => _.slice()),
                            index: k.array.slice()
                        } : {
                            roots: N,
                            index: k.array
                        }
                    }
                    static deserialize(_, O, B = {}) {
                        if ("boolean" == typeof B) return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."), vt.deserialize(arguments[0], arguments[1], {
                            setIndex: void 0 === arguments[2] || arguments[2]
                        });
                        B = {
                            setIndex: !0,
                            ...B
                        };
                        let {
                            index: N,
                            roots: k
                        } = _, F = new vt(O, { ...B,
                            [gQ]: !0
                        });
                        if (F._roots = k, B.setIndex) {
                            let B = O.getIndex();
                            if (null === B) {
                                let B = new sF(_.index, 1, !1);
                                O.setIndex(B)
                            } else B.array !== N && (B.array.set(N), B.needsUpdate = !0)
                        }
                        return F
                    }
                    constructor(_, O = {}) {
                        if (_.isBufferGeometry) {
                            if (_.index && _.index.isInterleavedBufferAttribute) throw Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")
                        } else throw Error("MeshBVH: Only BufferGeometries are supported.");
                        if ((O = Object.assign({
                                strategy: 0,
                                maxDepth: 40,
                                maxLeafTris: 10,
                                verbose: !0,
                                useSharedArrayBuffer: !1,
                                setBoundingBox: !0,
                                onProgress: null,
                                [gQ]: !1
                            }, O)).useSharedArrayBuffer && typeof SharedArrayBuffer > "u") throw Error("MeshBVH: SharedArrayBuffer is not available.");
                        this._roots = null, O[gQ] || (this._roots = function(_, O) {
                            let B = function(_, O) {
                                    function e(_) {
                                        Q && Q(_ / K)
                                    }

                                    function r(O, B, Q, K = null, ee = 0) {
                                        if (!$ && ee >= U && ($ = !0, j && (console.warn(`MeshBVH: Max depth of ${U} reached when generating BVH. Consider increasing maxDepth.`), console.warn(_))), Q <= G || ee >= U) return e(B + Q), O.offset = B, O.count = Q, O;
                                        let et = function(_, O, B, N, k, F) {
                                            let U = -1,
                                                j = 0;
                                            if (0 === F) - 1 !== (U = lS(O)) && (j = (O[U] + O[U + 3]) / 2);
                                            else if (1 === F) - 1 !== (U = lS(_)) && (j = function(_, O, B, N) {
                                                let k = 0;
                                                for (let F = O, U = O + B; F < U; F++) k += _[6 * F + 2 * N];
                                                return k / B
                                            }(B, N, k, U));
                                            else if (2 === F) {
                                                let F = Ch(_),
                                                    G = 1.25 * k,
                                                    Y = 6 * N,
                                                    Q = (N + k) * 6;
                                                for (let _ = 0; _ < 3; _++) {
                                                    let N = O[_],
                                                        K = (O[_ + 3] - N) / 32;
                                                    if (k < 8) {
                                                        let O = [...md];
                                                        O.length = k;
                                                        let N = 0;
                                                        for (let k = Y; k < Q; k += 6, N++) {
                                                            let F = O[N];
                                                            F.candidate = B[k + 2 * _], F.count = 0;
                                                            let {
                                                                bounds: U,
                                                                leftCacheBounds: j,
                                                                rightCacheBounds: G
                                                            } = F;
                                                            for (let _ = 0; _ < 3; _++) G[_] = 1 / 0, G[_ + 3] = -1 / 0, j[_] = 1 / 0, j[_ + 3] = -1 / 0, U[_] = 1 / 0, U[_ + 3] = -1 / 0;
                                                            gp(k, B, U)
                                                        }
                                                        O.sort(Z6);
                                                        let K = k;
                                                        for (let _ = 0; _ < K; _++) {
                                                            let B = O[_];
                                                            for (; _ + 1 < K && O[_ + 1].candidate === B.candidate;) O.splice(_ + 1, 1), K--
                                                        }
                                                        for (let N = Y; N < Q; N += 6) {
                                                            let k = B[N + 2 * _];
                                                            for (let _ = 0; _ < K; _++) {
                                                                let F = O[_];
                                                                k >= F.candidate ? gp(N, B, F.rightCacheBounds) : (gp(N, B, F.leftCacheBounds), F.count++)
                                                            }
                                                        }
                                                        for (let B = 0; B < K; B++) {
                                                            let N = O[B],
                                                                Y = N.count,
                                                                Q = k - N.count,
                                                                K = N.leftCacheBounds,
                                                                $ = N.rightCacheBounds,
                                                                ee = 0;
                                                            0 !== Y && (ee = Ch(K) / F);
                                                            let et = 0;
                                                            0 !== Q && (et = Ch($) / F);
                                                            let ei = 1 + 1.25 * (ee * Y + et * Q);
                                                            ei < G && (U = _, G = ei, j = N.candidate)
                                                        }
                                                    } else {
                                                        for (let _ = 0; _ < 32; _++) {
                                                            let O = md[_];
                                                            O.count = 0, O.candidate = N + K + _ * K;
                                                            let B = O.bounds;
                                                            for (let _ = 0; _ < 3; _++) B[_] = 1 / 0, B[_ + 3] = -1 / 0
                                                        }
                                                        for (let O = Y; O < Q; O += 6) {
                                                            let k = ~~((B[O + 2 * _] - N) / K);
                                                            k >= 32 && (k = 31);
                                                            let F = md[k];
                                                            F.count++, gp(O, B, F.bounds)
                                                        }
                                                        let O = md[31];
                                                        ! function(_, O) {
                                                            O.set(_)
                                                        }(O.bounds, O.rightCacheBounds);
                                                        for (let _ = 30; _ >= 0; _--) {
                                                            let O = md[_],
                                                                B = md[_ + 1];
                                                            uS(O.bounds, B.rightCacheBounds, O.rightCacheBounds)
                                                        }
                                                        let $ = 0;
                                                        for (let O = 0; O < 31; O++) {
                                                            let B = md[O],
                                                                N = B.count,
                                                                Y = B.bounds,
                                                                Q = md[O + 1].rightCacheBounds;
                                                            0 !== N && (0 === $ ? function(_, O) {
                                                                O.set(_)
                                                            }(Y, mu) : uS(Y, mu, mu));
                                                            let K = 0,
                                                                ee = 0;
                                                            0 !== ($ += N) && (K = Ch(mu) / F);
                                                            let et = k - $;
                                                            0 !== et && (ee = Ch(Q) / F);
                                                            let ei = 1 + 1.25 * (K * $ + ee * et);
                                                            ei < G && (U = _, G = ei, j = B.candidate)
                                                        }
                                                    }
                                                }
                                            } else console.warn(`MeshBVH: Invalid build strategy value ${F} used.`);
                                            return {
                                                axis: U,
                                                pos: j
                                            }
                                        }(O.boundingData, K, k, B, Q, Y);
                                        if (-1 === et.axis) return e(B + Q), O.offset = B, O.count = Q, O;
                                        let ei = function(_, O, B, N, k) {
                                            let F = B,
                                                U = B + N - 1,
                                                j = k.pos,
                                                G = 2 * k.axis;
                                            for (;;) {
                                                for (; F <= U && O[6 * F + G] < j;) F++;
                                                for (; F <= U && O[6 * U + G] >= j;) U--;
                                                if (!(F < U)) return F;
                                                for (let B = 0; B < 3; B++) {
                                                    let N = _[3 * F + B];
                                                    _[3 * F + B] = _[3 * U + B], _[3 * U + B] = N;
                                                    let k = O[6 * F + 2 * B + 0];
                                                    O[6 * F + 2 * B + 0] = O[6 * U + 2 * B + 0], O[6 * U + 2 * B + 0] = k;
                                                    let j = O[6 * F + 2 * B + 1];
                                                    O[6 * F + 2 * B + 1] = O[6 * U + 2 * B + 1], O[6 * U + 2 * B + 1] = j
                                                }
                                                F++, U--
                                            }
                                        }(F, k, B, Q, et);
                                        if (ei === B || ei === B + Q) e(B + Q), O.offset = B, O.count = Q;
                                        else {
                                            O.splitAxis = et.axis;
                                            let _ = new mh,
                                                F = ei - B;
                                            O.left = _, _.boundingData = new Float32Array(6), dS(k, B, F, _.boundingData, N), r(_, B, F, N, ee + 1);
                                            let U = new mh,
                                                j = Q - F;
                                            O.right = U, U.boundingData = new Float32Array(6), dS(k, ei, j, U.boundingData, N), r(U, ei, j, N, ee + 1)
                                        }
                                        return O
                                    }! function(_, O) {
                                        if (!_.index) {
                                            let B = _.attributes.position.count,
                                                N = O.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
                                                k;
                                            k = B > 65535 ? new Uint32Array(new N(4 * B)) : new Uint16Array(new N(2 * B)), _.setIndex(new sF(k, 1));
                                            for (let _ = 0; _ < B; _++) k[_] = _
                                        }
                                    }(_, O);
                                    let B = new Float32Array(6),
                                        N = new Float32Array(6),
                                        k = function(_, O) {
                                            let B = _.attributes.position,
                                                N = _.index.array,
                                                k = N.length / 3,
                                                F = new Float32Array(6 * k),
                                                U = B.normalized,
                                                j = B.array,
                                                G = B.offset || 0,
                                                Y = 3;
                                            B.isInterleavedBufferAttribute && (Y = B.data.stride);
                                            let Q = ["getX", "getY", "getZ"];
                                            for (let _ = 0; _ < k; _++) {
                                                let k = 3 * _,
                                                    K = 6 * _,
                                                    $, ee, et;
                                                U ? ($ = N[k + 0], ee = N[k + 1], et = N[k + 2]) : ($ = N[k + 0] * Y + G, ee = N[k + 1] * Y + G, et = N[k + 2] * Y + G);
                                                for (let _ = 0; _ < 3; _++) {
                                                    let N, k, G;
                                                    U ? (N = B[Q[_]]($), k = B[Q[_]](ee), G = B[Q[_]](et)) : (N = j[$ + _], k = j[ee + _], G = j[et + _]);
                                                    let Y = N;
                                                    k < Y && (Y = k), G < Y && (Y = G);
                                                    let ei = N;
                                                    k > ei && (ei = k), G > ei && (ei = G);
                                                    let er = (ei - Y) / 2,
                                                        ea = 2 * _;
                                                    F[K + ea + 0] = Y + er, F[K + ea + 1] = er + (Math.abs(Y) + er) * 5960464477539063e-23, Y < O[_] && (O[_] = Y), ei > O[_ + 3] && (O[_ + 3] = ei)
                                                }
                                            }
                                            return F
                                        }(_, B),
                                        F = _.index.array,
                                        U = O.maxDepth,
                                        j = O.verbose,
                                        G = O.maxLeafTris,
                                        Y = O.strategy,
                                        Q = O.onProgress,
                                        K = _.index.count / 3,
                                        $ = !1,
                                        ee = [],
                                        et = function(_) {
                                            if (!_.groups || !_.groups.length) return [{
                                                offset: 0,
                                                count: _.index.count / 3
                                            }];
                                            let O = [],
                                                B = new Set;
                                            for (let O of _.groups) B.add(O.start), B.add(O.start + O.count);
                                            let N = Array.from(B.values()).sort((_, O) => _ - O);
                                            for (let _ = 0; _ < N.length - 1; _++) {
                                                let B = N[_],
                                                    k = N[_ + 1];
                                                O.push({
                                                    offset: B / 3,
                                                    count: (k - B) / 3
                                                })
                                            }
                                            return O
                                        }(_);
                                    if (1 === et.length) {
                                        let _ = et[0],
                                            O = new mh;
                                        O.boundingData = B,
                                            function(_, O, B, N) {
                                                let k = 1 / 0,
                                                    F = 1 / 0,
                                                    U = 1 / 0,
                                                    j = -1 / 0,
                                                    G = -1 / 0,
                                                    Y = -1 / 0;
                                                for (let N = 6 * O, Q = (O + B) * 6; N < Q; N += 6) {
                                                    let O = _[N + 0];
                                                    O < k && (k = O), O > j && (j = O);
                                                    let B = _[N + 2];
                                                    B < F && (F = B), B > G && (G = B);
                                                    let Q = _[N + 4];
                                                    Q < U && (U = Q), Q > Y && (Y = Q)
                                                }
                                                N[0] = k, N[1] = F, N[2] = U, N[3] = j, N[4] = G, N[5] = Y
                                            }(k, _.offset, _.count, N), r(O, _.offset, _.count, N), ee.push(O)
                                    } else
                                        for (let _ of et) {
                                            let O = new mh;
                                            O.boundingData = new Float32Array(6), dS(k, _.offset, _.count, O.boundingData, N), r(O, _.offset, _.count, N), ee.push(O)
                                        }
                                    return ee
                                }(_, O),
                                N, k, F, U = [],
                                j = O.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
                            for (let _ = 0; _ < B.length; _++) {
                                let O = B[_],
                                    G = function l(_) {
                                        return _.count ? 1 : 1 + l(_.left) + l(_.right)
                                    }(O),
                                    Y = new j(32 * G);
                                N = new Float32Array(Y), k = new Uint32Array(Y), F = new Uint16Array(Y),
                                    function u(_, O) {
                                        let B = _ / 4,
                                            U = _ / 2,
                                            j = !!O.count,
                                            G = O.boundingData;
                                        for (let _ = 0; _ < 6; _++) N[B + _] = G[_];
                                        if (j) {
                                            let N = O.offset,
                                                j = O.count;
                                            return k[B + 6] = N, F[U + 14] = j, F[U + 15] = 65535, _ + 32
                                        } {
                                            let N = O.left,
                                                F = O.right,
                                                U = O.splitAxis,
                                                j;
                                            if ((j = u(_ + 32, N)) / 4 > 4294967296) throw Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
                                            return k[B + 6] = j / 4, j = u(j, F), k[B + 7] = U, j
                                        }
                                    }(0, O), U.push(Y)
                            }
                            return U
                        }(_, O), !_.boundingBox && O.setBoundingBox && (_.boundingBox = this.getBoundingBox(new rb))), this.geometry = _
                    }
                    refit(_ = null) {
                        _ && Array.isArray(_) && (_ = new Set(_));
                        let O = this.geometry,
                            B = O.index.array,
                            N = O.attributes.position,
                            k, F, U, j, G = 0,
                            Y = this._roots;
                        for (let O = 0, Q = Y.length; O < Q; O++) k = Y[O], F = new Uint32Array(k), U = new Uint16Array(k), j = new Float32Array(k),
                            function h(O, k, G = !1) {
                                let Y = 2 * O;
                                if (65535 === U[Y + 15]) {
                                    let _ = F[O + 6],
                                        k = U[Y + 14],
                                        G = 1 / 0,
                                        Q = 1 / 0,
                                        K = 1 / 0,
                                        $ = -1 / 0,
                                        ee = -1 / 0,
                                        et = -1 / 0;
                                    for (let O = 3 * _, F = 3 * (_ + k); O < F; O++) {
                                        let _ = B[O],
                                            k = N.getX(_),
                                            F = N.getY(_),
                                            U = N.getZ(_);
                                        k < G && (G = k), k > $ && ($ = k), F < Q && (Q = F), F > ee && (ee = F), U < K && (K = U), U > et && (et = U)
                                    }
                                    return (j[O + 0] !== G || j[O + 1] !== Q || j[O + 2] !== K || j[O + 3] !== $ || j[O + 4] !== ee || j[O + 5] !== et) && (j[O + 0] = G, j[O + 1] = Q, j[O + 2] = K, j[O + 3] = $, j[O + 4] = ee, j[O + 5] = et, !0)
                                } {
                                    let B = O + 8,
                                        N = F[O + 6],
                                        U = B + k,
                                        Y = N + k,
                                        Q = G,
                                        K = !1,
                                        $ = !1;
                                    _ ? Q || (K = _.has(U), $ = _.has(Y), Q = !K && !$) : (K = !0, $ = !0);
                                    let ee = Q || K,
                                        et = Q || $,
                                        ei = !1;
                                    ee && (ei = h(B, k, Q));
                                    let er = !1;
                                    et && (er = h(N, k, Q));
                                    let ea = ei || er;
                                    if (ea)
                                        for (let _ = 0; _ < 3; _++) {
                                            let k = B + _,
                                                F = N + _,
                                                U = j[k],
                                                G = j[k + 3],
                                                Y = j[F],
                                                Q = j[F + 3];
                                            j[O + _] = U < Y ? U : Y, j[O + _ + 3] = G > Q ? G : Q
                                        }
                                    return ea
                                }
                            }(0, G), G += k.byteLength
                    }
                    traverse(_, O = 0) {
                        let B = this._roots[O],
                            N = new Uint32Array(B),
                            k = new Uint16Array(B);
                        ! function o(O, F = 0) {
                            let U = 2 * O,
                                j = 65535 === k[U + 15];
                            if (j) {
                                let G = N[O + 6],
                                    Y = k[U + 14];
                                _(F, j, new Float32Array(B, 4 * O, 6), G, Y)
                            } else {
                                let k = O + 8,
                                    U = N[O + 6],
                                    G = N[O + 7];
                                _(F, j, new Float32Array(B, 4 * O, 6), G) || (o(k, F + 1), o(U, F + 1))
                            }
                        }(0)
                    }
                    raycast(_, O = 0) {
                        let B = this._roots,
                            N = this.geometry,
                            k = [],
                            F = O.isMaterial,
                            U = Array.isArray(O),
                            j = N.groups,
                            G = F ? O.side : O;
                        for (let F = 0, Y = B.length; F < Y; F++) {
                            let Y = U ? O[j[F].materialIndex].side : G,
                                Q = k.length;
                            if (Vh(B[F]), function uv(_, O, B, N, k) {
                                    let F = 2 * _,
                                        U = gH,
                                        j = gW,
                                        G = gY;
                                    if (oa(F, j)) ! function(_, O, B, N, k, F) {
                                        for (let U = N, j = N + k; U < j; U++) pS(_, O, B, U, F)
                                    }(O, B, N, G[_ + 6], j[F + 14], k);
                                    else {
                                        let F = _ + 8;
                                        dv(F, U, N, mB) && uv(F, O, B, N, k);
                                        let j = G[_ + 6];
                                        dv(j, U, N, mB) && uv(j, O, B, N, k)
                                    }
                                }(0, N, Y, _, k), vp(), U) {
                                let _ = j[F].materialIndex;
                                for (let O = Q, B = k.length; O < B; O++) k[O].face.materialIndex = _
                            }
                        }
                        return k
                    }
                    raycastFirst(_, O = 0) {
                        let B = this._roots,
                            N = this.geometry,
                            k = O.isMaterial,
                            F = Array.isArray(O),
                            U = null,
                            j = N.groups,
                            G = k ? O.side : O;
                        for (let k = 0, Y = B.length; k < Y; k++) {
                            let Y = F ? O[j[k].materialIndex].side : G;
                            Vh(B[k]);
                            let Q = function hv(_, O, B, N) {
                                let k = 2 * _,
                                    F = gH,
                                    U = gW,
                                    j = gY;
                                if (oa(k, U)) return function(_, O, B, N, k) {
                                    let F = 1 / 0,
                                        U = null;
                                    for (let j = N, G = N + k; j < G; j++) {
                                        let N = pS(_, O, B, j);
                                        N && N.distance < F && (U = N, F = N.distance)
                                    }
                                    return U
                                }(O, B, N, j[_ + 6], U[k + 14]); {
                                    let k = j[_ + 7],
                                        U = mN[k],
                                        G = N.direction[U] >= 0,
                                        Y, Q;
                                    G ? (Y = _ + 8, Q = j[_ + 6]) : (Y = j[_ + 6], Q = _ + 8);
                                    let K = dv(Y, F, N, mB) ? hv(Y, O, B, N) : null;
                                    if (K) {
                                        let _ = K.point[U];
                                        if (G ? _ <= F[Q + k] : _ >= F[Q + k + 3]) return K
                                    }
                                    let $ = dv(Q, F, N, mB) ? hv(Q, O, B, N) : null;
                                    return K && $ ? K.distance <= $.distance ? K : $ : K || $ || null
                                }
                            }(0, N, Y, _);
                            vp(), null != Q && (null == U || Q.distance < U.distance) && (U = Q, F && (Q.face.materialIndex = j[k].materialIndex))
                        }
                        return U
                    }
                    intersectsGeometry(_, O) {
                        let B = this.geometry,
                            N = !1;
                        for (let k of this._roots)
                            if (Vh(k), N = mF(0, B, _, O), vp(), N) break;
                        return N
                    }
                    shapecast(_, O, B) {
                        let N = this.geometry;
                        if (_ instanceof Function) {
                            if (O) {
                                let _ = O;
                                O = (O, B, N, k) => {
                                    let F = 3 * B;
                                    return _(O, F, F + 1, F + 2, N, k)
                                }
                            }
                            _ = {
                                boundsTraverseOrder: B,
                                intersectsBounds: _,
                                intersectsTriangle: O,
                                intersectsRange: null
                            }, console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")
                        }
                        let k = ve.getPrimitive(),
                            {
                                boundsTraverseOrder: F,
                                intersectsBounds: U,
                                intersectsRange: j,
                                intersectsTriangle: G
                            } = _;
                        if (j && G) {
                            let _ = j;
                            j = (O, B, F, U, j) => !!_(O, B, F, U, j) || mS(O, B, N, G, F, U, k)
                        } else j || (j = G ? (_, O, B, F) => mS(_, O, N, G, B, F, k) : (_, O, B) => B);
                        let Y = !1,
                            Q = 0;
                        for (let _ of this._roots) {
                            if (Vh(_), Y = mk(0, N, U, j, F, Q), vp(), Y) break;
                            Q += _.byteLength
                        }
                        return ve.releasePrimitive(k), Y
                    }
                    bvhcast(_, O, B) {
                        let {
                            intersectsRanges: N,
                            intersectsTriangles: k
                        } = B, F = this.geometry.index, U = this.geometry.attributes.position, j = _.geometry.index, G = _.geometry.attributes.position;
                        gJ.copy(O).invert();
                        let Y = ve.getPrimitive(),
                            Q = ve.getPrimitive();
                        if (k) {
                            let f = function(_, B, N, K, $, ee, et, ei) {
                                for (let er = N, ea = N + K; er < ea; er++) {
                                    Zi(Q, 3 * er, j, G), Q.a.applyMatrix4(O), Q.b.applyMatrix4(O), Q.c.applyMatrix4(O), Q.needsUpdate = !0;
                                    for (let O = _, N = _ + B; O < N; O++)
                                        if (Zi(Y, 3 * O, F, U), Y.needsUpdate = !0, k(Y, Q, O, er, $, ee, et, ei)) return !0
                                }
                                return !1
                            };
                            if (N) {
                                let _ = N;
                                N = function(O, B, N, k, F, U, j, G) {
                                    return !!_(O, B, N, k, F, U, j, G) || f(O, B, N, k, F, U, j, G)
                                }
                            } else N = f
                        }
                        _.getBoundingBox(gK), gK.applyMatrix4(O);
                        let K = this.shapecast({
                            intersectsBounds: _ => gK.intersectsBox(_),
                            intersectsRange: (O, B, k, F, U, j) => (gZ.copy(j), gZ.applyMatrix4(gJ), _.shapecast({
                                intersectsBounds: _ => gZ.intersectsBox(_),
                                intersectsRange: (_, k, j, G, Y) => N(O, B, _, k, F, U, G, Y)
                            }))
                        });
                        return ve.releasePrimitive(Y), ve.releasePrimitive(Q), K
                    }
                    intersectsBox(_, O) {
                        return g$.set(_.min, _.max, O), g$.needsUpdate = !0, this.shapecast({
                            intersectsBounds: _ => g$.intersectsBox(_),
                            intersectsTriangle: _ => g$.intersectsTriangle(_)
                        })
                    }
                    intersectsSphere(_) {
                        return this.shapecast({
                            intersectsBounds: O => _.intersectsBox(O),
                            intersectsTriangle: O => O.intersectsSphere(_)
                        })
                    }
                    closestPointToGeometry(_, O, B = {}, N = {}, k = 0, F = 1 / 0) {
                        _.boundingBox || _.computeBoundingBox(), g$.set(_.boundingBox.min, _.boundingBox.max, O), g$.needsUpdate = !0;
                        let U = this.geometry,
                            j = U.attributes.position,
                            G = U.index,
                            Y = _.attributes.position,
                            Q = _.index,
                            K = ve.getPrimitive(),
                            $ = ve.getPrimitive(),
                            ee = null,
                            et = null;
                        N && (ee = g6, et = g9);
                        let ei = 1 / 0,
                            er = null,
                            ea = null;
                        return gJ.copy(O).invert(), g0.matrix.copy(gJ), this.shapecast({
                            boundsTraverseOrder: _ => g$.distanceToBox(_),
                            intersectsBounds: (_, O, B) => B < ei && B < F && (O && (g0.min.copy(_.min), g0.max.copy(_.max), g0.needsUpdate = !0), !0),
                            intersectsRange: (B, N) => {
                                if (_.boundsTree) return _.boundsTree.shapecast({
                                    boundsTraverseOrder: _ => g0.distanceToBox(_),
                                    intersectsBounds: (_, O, B) => B < ei && B < F,
                                    intersectsRange: (_, F) => {
                                        for (let U = 3 * _, en = (_ + F) * 3; U < en; U += 3) {
                                            Zi($, U, Q, Y), $.a.applyMatrix4(O), $.b.applyMatrix4(O), $.c.applyMatrix4(O), $.needsUpdate = !0;
                                            for (let _ = 3 * B, O = (B + N) * 3; _ < O; _ += 3) {
                                                Zi(K, _, G, j), K.needsUpdate = !0;
                                                let O = K.distanceToTriangle($, g4, ee);
                                                if (O < ei && (g5.copy(g4), et && et.copy(ee), ei = O, er = _ / 3, ea = U / 3), O < k) return !0
                                            }
                                        }
                                    }
                                }); {
                                    let _ = Q ? Q.count : Y.count;
                                    for (let F = 0; F < _; F += 3) {
                                        Zi($, F, Q, Y), $.a.applyMatrix4(O), $.b.applyMatrix4(O), $.c.applyMatrix4(O), $.needsUpdate = !0;
                                        for (let _ = 3 * B, O = (B + N) * 3; _ < O; _ += 3) {
                                            Zi(K, _, G, j), K.needsUpdate = !0;
                                            let O = K.distanceToTriangle($, g4, ee);
                                            if (O < ei && (g5.copy(g4), et && et.copy(ee), ei = O, er = _ / 3, ea = F / 3), O < k) return !0
                                        }
                                    }
                                }
                            }
                        }), ve.releasePrimitive(K), ve.releasePrimitive($), ei === 1 / 0 ? null : (B.point ? B.point.copy(g5) : B.point = g5.clone(), B.distance = ei, B.faceIndex = er, N && (N.point ? N.point.copy(et) : N.point = et.clone(), N.point.applyMatrix4(gJ), g5.applyMatrix4(gJ), N.distance = g5.sub(N.point).length(), N.faceIndex = ea), B)
                    }
                    closestPointToPoint(_, O = {}, B = 0, N = 1 / 0) {
                        let k = B * B,
                            F = N * N,
                            U = 1 / 0,
                            j = null;
                        if (this.shapecast({
                                boundsTraverseOrder: O => (g3.copy(_).clamp(O.min, O.max), g3.distanceToSquared(_)),
                                intersectsBounds: (_, O, B) => B < U && B < F,
                                intersectsTriangle: (O, B) => {
                                    O.closestPointToPoint(_, g3);
                                    let N = _.distanceToSquared(g3);
                                    return N < U && (g4.copy(g3), U = N, j = B), N < k
                                }
                            }), U === 1 / 0) return null;
                        let G = Math.sqrt(U);
                        return O.point ? O.point.copy(g4) : O.point = g4.clone(), O.distance = G, O.faceIndex = j, O
                    }
                    getBoundingBox(_) {
                        return _.makeEmpty(), this._roots.forEach(O => {
                            Ki(0, new Float32Array(O), g7), _.union(g7)
                        }), _
                    }
                },
                vi = pn(ix()),
                vs = .5 * (Math.sqrt(3) - 1),
                va = (3 - Math.sqrt(3)) / 6,
                vn = 1 / 3,
                vo = 1 / 6,
                Sp = _ => 0 | Math.floor(_),
                vl = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]),
                vh = new Float64Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);

            function pv(_ = Math.random) {
                let O = V2(_),
                    B = new Float64Array(O).map(_ => vl[_ % 12 * 2]),
                    N = new Float64Array(O).map(_ => vl[_ % 12 * 2 + 1]);
                return function(_, k) {
                    let F = 0,
                        U = 0,
                        j = 0,
                        G = (_ + k) * vs,
                        Y = Sp(_ + G),
                        Q = Sp(k + G),
                        K = (Y + Q) * va,
                        $ = _ - (Y - K),
                        ee = k - (Q - K),
                        et, ei;
                    $ > ee ? (et = 1, ei = 0) : (et = 0, ei = 1);
                    let er = $ - et + va,
                        ea = ee - ei + va,
                        en = $ - 1 + 2 * va,
                        eo = ee - 1 + 2 * va,
                        el = 255 & Y,
                        eh = 255 & Q,
                        ec = .5 - $ * $ - ee * ee;
                    if (ec >= 0) {
                        let _ = el + O[eh],
                            k = B[_],
                            U = N[_];
                        ec *= ec, F = ec * ec * (k * $ + U * ee)
                    }
                    let eu = .5 - er * er - ea * ea;
                    if (eu >= 0) {
                        let _ = el + et + O[eh + ei],
                            k = B[_],
                            F = N[_];
                        eu *= eu, U = eu * eu * (k * er + F * ea)
                    }
                    let ep = .5 - en * en - eo * eo;
                    if (ep >= 0) {
                        let _ = el + 1 + O[eh + 1],
                            k = B[_],
                            F = N[_];
                        ep *= ep, j = ep * ep * (k * en + F * eo)
                    }
                    return 70 * (F + U + j)
                }
            }

            function V2(_) {
                let O = new Uint8Array(512);
                for (let _ = 0; _ < 256; _++) O[_] = _;
                for (let B = 0; B < 255; B++) {
                    let N = B + ~~(_() * (256 - B)),
                        k = O[B];
                    O[B] = O[N], O[N] = k
                }
                for (let _ = 256; _ < 512; _++) O[_] = O[_ - 256];
                return O
            }
            var vc, vd = new sO,
                vu = class {
                    constructor(_) {
                        this.weightAttribute = null;
                        let O = _.geometry;
                        if (!O.isBufferGeometry || 3 !== O.attributes.position.itemSize) throw Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");
                        O.index && (O = O.toNonIndexed()), this.geometry = O, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.distribution = null
                    }
                    build() {
                        let _ = this.positionAttribute,
                            O = new Float32Array(_.count / 3);
                        for (let B = 0; B < _.count; B += 3) {
                            let N = 1;
                            vd.a.fromBufferAttribute(_, B), vd.b.fromBufferAttribute(_, B + 1), vd.c.fromBufferAttribute(_, B + 2), N *= vd.getArea(), O[B / 3] = N
                        }
                        this.distribution = new Float32Array(_.count / 3);
                        let B = 0;
                        for (let _ = 0; _ < O.length; _++) B += O[_], this.distribution[_] = B;
                        return this
                    }
                    setRandomGenerator(_) {
                        return this.randomFunction = _, this
                    }
                    sample(_, O) {
                        if (this.distribution) {
                            let B = this.distribution[this.distribution.length - 1],
                                N = this.binarySearch(this.randomFunction() * B);
                            return this.sampleFace(N, _, O)
                        }
                    }
                    binarySearch(_) {
                        if (!this.distribution) return 0;
                        let O = this.distribution,
                            B = 0,
                            N = O.length - 1,
                            k = -1;
                        for (; B <= N;) {
                            let F = Math.ceil((B + N) / 2);
                            if (0 === F || O[F - 1] <= _ && O[F] > _) {
                                k = F;
                                break
                            }
                            _ < O[F] ? N = F - 1 : B = F + 1
                        }
                        return k
                    }
                    sampleFace(_, O, B) {
                        let N = this.randomFunction(),
                            k = this.randomFunction();
                        return N + k > 1 && (N = 1 - N, k = 1 - k), vd.a.fromBufferAttribute(this.positionAttribute, 3 * _), vd.b.fromBufferAttribute(this.positionAttribute, 3 * _ + 1), vd.c.fromBufferAttribute(this.positionAttribute, 3 * _ + 2), O.set(0, 0, 0).addScaledVector(vd.a, N).addScaledVector(vd.b, k).addScaledVector(vd.c, 1 - (N + k)), vd.getNormal(B), this
                    }
                },
                vf = pn(ib()),
                vm = new rJ,
                vg = new rJ,
                vv = new rJ;
            (vc || (vc = {})).is = function(_) {
                return _ && _.__isSPEObject
            };
            var Gh = _ => class extends _ {
                    constructor() {
                        super(...arguments), this.previousModelViewMatrix = new rJ, this.copyPreviousMatrix = !0, this.hiddenMatrix = new rJ, this.matrixWorldRigid = new rJ, this.shearScale = new rJ, this.shearScaleInv = new rJ
                    }
                    get __isSPEObject() {
                        return !0
                    }
                    isDescendantOf(_) {
                        _ instanceof sv && (_ = _.uuid);
                        let O = this;
                        for (; O.parent;) {
                            if (O.parent.uuid === _) return !0;
                            O = O.parent
                        }
                        return !1
                    }
                    updateMatrixWorld(_) {
                        for (let O of (this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || _) && (null === this.parent ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, _ = !0), this.children)) O.updateMatrixWorld(_)
                    }
                    updateWorldMatrix(_, O) {
                        let B = this.parent;
                        if (_ && null !== B && B.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), O)
                            for (let _ of this.children) _.updateWorldMatrix(!1, !0)
                    }
                    traverseChildren(_, O = 0) {
                        for (let B of this.children) vc.is(B) && B.traverseObject(_, O + 1)
                    }
                    traverseObject(_, O = 0) {
                        if (!0 !== _(this, O))
                            for (let B of this.children) vc.is(B) && B.traverseObject(_, O + 1)
                    }
                    updateMatrixWorldSVD() {
                        let _ = this.matrixWorld.elements,
                            O = [
                                [_[0], _[4], _[8]],
                                [_[1], _[5], _[9]],
                                [_[2], _[6], _[10]]
                            ],
                            {
                                u: B,
                                v: N,
                                q: k
                            } = (0, vf.SVD)(O),
                            F = vm.set(B[0][0], B[0][1], B[0][2], 0, B[1][0], B[1][1], B[1][2], 0, B[2][0], B[2][1], B[2][2], 0, 0, 0, 0, 1),
                            U = vg.set(N[0][0], N[0][1], N[0][2], 0, N[1][0], N[1][1], N[1][2], 0, N[2][0], N[2][1], N[2][2], 0, 0, 0, 0, 1),
                            j = vv.copy(U).transpose();
                        this.shearScale.makeScale(k[0], k[1], k[2]).multiply(j).premultiply(U), this.shearScaleInv.copy(this.shearScale).invert(), this.matrixWorldRigid.multiplyMatrices(F, j).copyPosition(this.matrixWorld), k.every(_ => .01 > Math.abs(k[0] - _)) ? this.hasNonUniformScale = !1 : this.hasNonUniformScale = !0
                    }
                    attach(_, O) {
                        this.updateWorldMatrix(!0, !1);
                        let B = new rJ().copy(this.matrixWorld).invert();
                        return null !== _.parent && (_.parent.updateWorldMatrix(!0, !1), B.multiply(_.parent.matrixWorld)), "hiddenMatrix" in _ && _.hiddenMatrix instanceof rJ ? _.hiddenMatrix.premultiply(B) : _.applyMatrix4(B), _.updateWorldMatrix(!1, !1), this.add(_), void 0 !== O && (this.children.pop(), this.children.splice(O, 0, _)), this
                    }
                    copy(_, O = !1) {
                        return super.copy(_, O), this.hasNonUniformScale = _.hasNonUniformScale, this
                    }
                    onAfterRender(_, O, B, N, k, F) {
                        this.copyPreviousMatrix && this.previousModelViewMatrix.copy(this.modelViewMatrix)
                    }
                },
                vx = class extends Gh(sv) {},
                g8 = _ => "Mesh" === _.type,
                vb = class extends vx {
                    constructor(_) {
                        super(), this.object = _, this.matrixAutoUpdate = !1, this.hasNonUniformScale = _.hasNonUniformScale
                    }
                    raycast(_, O) {}
                    expand() {
                        let _ = 0,
                            O = this.object.entityChildren(_);
                        for (; O;) {
                            let B = this.children[_];
                            B ? .object !== O && (B && this.remove(B), B = new vb(O), this.add(B), this.children.splice(_, 0, this.children.pop()), B.matrixWorldNeedsUpdate = !0, B.matrixAutoUpdate = !1, B.matrix = O.matrix, B.hiddenMatrix = O.hiddenMatrix), B.expand(), _ += 1, O = this.object.entityChildren(_)
                        }
                        for (; this.children.length > _;) this.remove(this.children[_])
                    }
                    get visible() {
                        return void 0 !== this.playModeVisible ? this.playModeVisible : this.object.visible || this.object.dataPatched.visible && this.object.dataPatched.cloner ? .hideBase === !0
                    }
                    set visible(_) {}
                    get castShadow() {
                        return this.object.castShadow
                    }
                    set castShadow(_) {}
                    get receiveShadow() {
                        return this.object.receiveShadow
                    }
                    set receiveShadow(_) {}
                    get isMesh() {
                        return g8(this.object)
                    }
                    get isLight() {
                        return this.object.isLight
                    }
                    get layers() {
                        return this.object.layers
                    }
                    set layers(_) {}
                    get isCamera() {
                        return !1
                    }
                    get geometry() {
                        if (this.object.geometry) return this.object.geometry
                    }
                    get material() {
                        if (this.object.material) return this.object.material
                    }
                },
                vw = new rv,
                v_ = new rv,
                vS = new rJ,
                vA = [new rv(-1, 1, 1), new rv(-1, -1, 1), new rv(1, -1, 1), new rv(1, 1, 1), new rv(-1, 1, -1), new rv(-1, -1, -1), new rv(1, -1, -1), new rv(1, 1, -1)],
                vM = [
                    [0, 3],
                    [1, 2],
                    [5, 6],
                    [4, 7],
                    [0, 1],
                    [3, 2],
                    [7, 6],
                    [4, 5],
                    [0, 4],
                    [1, 5],
                    [2, 6],
                    [3, 7]
                ],
                vC = [
                    [0, 2],
                    [7, 5],
                    [4, 1],
                    [3, 6],
                    [4, 3],
                    [1, 6]
                ],
                G2 = (_, O, B) => {
                    _.updateEntityBoxSize(vw, v_), vS.copy(O).multiply(_.matrixWorld), 0 === v_.x && 0 === v_.y && 0 === v_.z ? B.push(new rv(vw.x, vw.y, vw.z).applyMatrix4(vS)) : vA.forEach(_ => {
                        B.push(_.clone().multiply(v_).add(vw).applyMatrix4(vS))
                    })
                },
                vT = class extends rb {
                    constructor() {
                        super(...arguments), this.matrix = new rJ, this.vertices = [], this.faces = [], this.edges = [], this.centerEdges = []
                    }
                    copy(_) {
                        return super.copy(_), this.matrix.copy(_.matrix), this.vertices = _.vertices.map(_ => _.clone()), this.faces = _.faces.map(_ => _.clone()), this.edges = _.edges.map(_ => _.clone()), this.centerEdges = _.centerEdges.map(_ => _.clone()), this
                    }
                    setFromObjectSize(_, O = !1) {
                        _.updateWorldMatrix(!1, O), this.makeEmpty(), this.matrix.copy(_.matrixWorld);
                        let B = new rJ().copy(_.matrixWorld).invert();
                        return this.expandByObjectSize(_, B, O)
                    }
                    expandByObjectSize(_, O, B = !1) {
                        let N = [];
                        return !0 === B ? _.traverseEntity(_ => {
                            if (_.visible || _.cloner && _.data.visible) {
                                if (!("geometry" in _)) {
                                    N.push(new rv);
                                    return
                                }
                                G2(_, O, N)
                            }
                        }) : G2(_, O, N), this.setFromPoints(N)
                    }
                    getCenter(_) {
                        return (_ = super.getCenter(_)).applyMatrix4(this.matrix), _
                    }
                    getPositionToCenter(_) {
                        return (_ = super.getCenter(_)).applyMatrix4(vS.copy(this.matrix).setPosition(0, 0, 0)), _
                    }
                    computeVertices() {
                        this.getSize(v_).multiplyScalar(.5), this.getCenter(vw), vS.copy(this.matrix).setPosition(vw), this.vertices = vA.map(_ => _.clone().multiply(v_).applyMatrix4(vS))
                    }
                    computeEdges() {
                        this.vertices.length > 0 && this.computeVertices(), this.edges = vM.map(([_, O]) => new lP(this.vertices[_], this.vertices[O])), this.centerEdges = this.edges.map(_ => _.getCenter(new rv))
                    }
                    computeFaces() {
                        this.vertices.length > 0 && this.computeVertices(), this.faces = vC.map(([_, O]) => this.vertices[_].clone().add(this.vertices[O]).multiplyScalar(.5))
                    }
                },
                vD = {
                    Cloner: () => {},
                    changeEntityProptotype: () => {},
                    createEntity: () => {}
                },
                vO = class extends or {
                    constructor() {
                        super()
                    }
                    getPoints(_ = 12) {
                        let O = [],
                            B, N = this.getCurveLengths(),
                            k = N[N.length - 1] / N.length;
                        for (let F = 0, U = this.curves; F < U.length; F++) {
                            let j = U[F],
                                G = Math.ceil(_ * (0 === F ? N[F] : N[F] - N[F - 1]) / k),
                                Y = j.getPoints(G);
                            for (let _ = 0; _ < Y.length; _++) {
                                let N = Y[_];
                                B && B.equals(N) || (O.push(N), B = N)
                            }
                        }
                        return this.autoClose && O.length > 1 && !O[O.length - 1].equals(O[0]) && O.push(O[0]), O
                    }
                };

            function TS(_, O, B) {
                return .001 >= O.clone().sub(_).cross(O.clone().sub(B)).length()
            }

            function _S(_, O) {
                let B = new rv(..._.position),
                    N = new rv(..._.controlNext.position),
                    k = new rv(...O.controlPrevious.position),
                    F = new rv(...O.position);
                return TS(B, N, F) && TS(B, k, F)
            }

            function yv(_) {
                let O = _.points.map(_ => new rv(..._.data.position)),
                    B = [_.points[0]],
                    N = new rv(...B[0].data.position);
                for (let k = 0; k < _.points.length - 1; k++) TS(N, O[k], O[k + 1]) || (B.push(_.points[k]), N = O[k]);
                B.push(_.points[_.points.length - 1]);
                let k = _.isClosed,
                    F = B.length - (k ? 0 : 1),
                    U = B.length,
                    j = [];
                for (let O = 0; O < U; O++) {
                    let N = B[O].data,
                        F = new rv(...N.position),
                        G = new rv(...N.controlPrevious.position),
                        Y = new rv(...N.controlNext.position),
                        Q = {
                            position: F,
                            baseRoundness: N.roundness,
                            controlPrevious: G,
                            controlNext: Y
                        };
                    if (0 === N.roundness || !_.isClosed && (0 === O || O === U - 1)) {
                        j[O] = { ...Q,
                            removedLength: 0
                        };
                        continue
                    }
                    let K = k && 0 == O ? U - 1 : O - 1,
                        $ = k && O == U - 1 ? 0 : O + 1,
                        ee = B[K].data,
                        et = B[$].data,
                        ei = new rv(...ee.position),
                        er = new rv(...et.position),
                        ea = ei.clone().sub(F).normalize(),
                        en = er.clone().sub(F).normalize();
                    Object.assign(Q, {
                        prevDir: ea,
                        nextDir: en
                    });
                    let eo = _S(ee, N),
                        el = _S(N, et);
                    if (eo && el) {
                        let _ = ea.clone().add(en).normalize(),
                            B = _.clone().cross(ea).length() / ea.dot(_);
                        j[O] = { ...Q,
                            tan: B,
                            removedLength: N.roundness / B
                        }
                    } else j[O] = { ...Q,
                        removedLength: 0
                    }
                }
                for (let _ = 0; _ < F; _++) {
                    let O = _,
                        B = k && _ === U - 1 ? 0 : _ + 1,
                        N = j[O],
                        F = j[B];
                    if (0 !== N.removedLength || 0 !== F.removedLength) {
                        let _ = N.position.distanceTo(F.position);
                        N.removedLength = Math.min(N.removedLength, _ / 2), F.removedLength = Math.min(F.removedLength, _ / 2)
                    }
                }
                let G = [];
                for (let _ = 0; _ < F; _++) {
                    let O = _,
                        N = k && _ === U - 1 ? 0 : _ + 1,
                        F = j[O],
                        Y = j[N],
                        Q = null;
                    if (_S(B[O].data, B[N].data)) {
                        let _ = F.position.clone(),
                            O = Y.position.clone();
                        (0 !== F.removedLength || 0 !== Y.removedLength) && (F.nextDir && _.add(F.nextDir.clone().setLength(F.removedLength)), Y.prevDir && O.add(Y.prevDir.clone().setLength(Y.removedLength))), _.distanceTo(O) > .001 && (Q = new n5(_, _.clone().lerp(O, .3), O.clone().lerp(_, .3), O))
                    } else F.position.distanceTo(Y.position) > .001 && (Q = new n5(F.position, F.controlNext, Y.controlPrevious, Y.position));
                    G[2 * _ + 1] = Q
                }
                for (let _ = 0; _ < U; _++) {
                    let O = j[_];
                    if (0 === O.removedLength) {
                        G[2 * _] = null;
                        continue
                    }
                    let B = O.position,
                        N = O.prevDir.clone().multiplyScalar(O.removedLength).add(B),
                        k = O.nextDir.clone().multiplyScalar(O.removedLength).add(B),
                        F = O.tan * O.removedLength,
                        U = O.prevDir.clone().add(O.nextDir).normalize(),
                        Y = N.clone().lerp(k, .5),
                        Q = N.distanceTo(k) / 2,
                        K = U.clone().multiplyScalar(Math.sqrt(Math.pow(F, 2) - Math.pow(Q, 2))).add(Y),
                        $ = U.clone().multiplyScalar(-F).add(K),
                        ee = B.distanceTo($) / B.distanceTo(Y),
                        et = O.prevDir.clone().multiplyScalar(ee * B.distanceTo(N)).add(B),
                        ei = et.clone().lerp($, 2),
                        er = N.clone().lerp(et, 4 / 3),
                        ea = k.clone().lerp(ei, 4 / 3);
                    G[2 * _] = new n5(N, er, ea, k)
                }
                let Y = new vO;
                return G.forEach(_ => {
                    _ && Y.add(_)
                }), Y
            }(xu || (xu = {})).is = function(_) {
                return _ && _.__isEntity
            };
            var oo = _ => xu.is(_),
                vL = {
                    type: "completeState",
                    isfromEntity: !0
                },
                vR = ["x", "y", "z"],
                vB = new rv,
                vN = new rv().set(0, 1, 0),
                jh = _ => class extends Gh(_) {
                    constructor() {
                        super(...arguments), this.raycastLock = !1, this.scaleLock = !1, this.disposed = !1, this.stateSelection = null, this.destroyedInAction = !1, this.instances = [], this.prevState = null, this.currentState = null, this.reversibleToState = null, this.currentTransitionEvent = null, this.previousAction = null, this._singleBBox = new vT, this._recursiveBBox = new vT, this.singleBBoxNeedsUpdate = !0, this.recursiveBBoxNeedsUpdate = !0, this._needApplyPathSnapping = !0, this.attachedPaths = new Set
                    }
                    get __isEntity() {
                        return !0
                    }
                    entityChildren(_) {
                        let O = this.children[_];
                        if (xu.is(O)) return O
                    }
                    entityChildrenCount() {
                        let _ = this.children.length;
                        for (; _--;)
                            if (xu.is(this.children[_])) return _ + 1;
                        return 0
                    }
                    get isConcreteEntity() {
                        return "string" == typeof this.identity
                    }
                    get isVirtualEntity() {
                        return "string" != typeof this.identity
                    }
                    get isInstanceRoot() {
                        return this.isConcreteEntity && "Instance" === this.data.type
                    }
                    nearestInstanceSelfOrParent() {
                        let _ = this;
                        for (;
                            "Instance" !== _.data.type;) {
                            let O = _.parent;
                            if (!xu.is(O)) return;
                            _ = O
                        }
                        return _
                    }
                    forInstancesRec(_) {
                        this.instances.forEach(O => {
                            O.disposed || _(O), O.forInstancesRec(_)
                        })
                    }
                    super_Entity(_, O) {
                        "string" == typeof _ && (this.uuid = _), this.identity = _, this.data = O, this.matrixAutoUpdate = !1, this.dataPatched = this.data
                    }
                    changeSelectedState(_, O, B = !1) {
                        if (!(0 === this.data.states.length && !B)) {
                            for (let _ of this.data.states) gS.toOps(this.data, _.data).forEach(_ => {
                                let B = uL.replaceProps(_, this.data);
                                this.dataPatched = this.data, this.updateByPatchedOp(B, this.data, O)
                            });
                            if (null !== _) {
                                let B = this.data.states.data(_);
                                B && (this.dataPatched = gS.patch(this.data, B), gS.toOps(this.data, B).forEach(_ => {
                                    this.updateByPatchedOp(_, this.dataPatched, O)
                                }))
                            }
                            B && this.updateTransformState(this.dataPatched, O), this.stateSelection = _, this.updatePathSnapping(this.dataPatched.pathSnapping)
                        }
                    }
                    get singleBBox() {
                        return this.singleBBoxNeedsUpdate && (this.singleBBoxNeedsUpdate = !1, this._singleBBox.setFromObjectSize(this, !1), this._singleBBox.computeVertices(), this._singleBBox.computeEdges(), this._singleBBox.computeFaces()), this._singleBBox
                    }
                    get recursiveBBox() {
                        return this.recursiveBBoxNeedsUpdate && (this.recursiveBBoxNeedsUpdate = !1, this._recursiveBBox.setFromObjectSize(this, !0), this._recursiveBBox.computeVertices(), this._recursiveBBox.computeEdges(), this._recursiveBBox.computeFaces()), this._recursiveBBox
                    }
                    updateEntityBoxSize(_, O) {
                        _.setScalar(0), O.setScalar(0)
                    }
                    resetBBoxNeedsUpdateSelf() {
                        this.singleBBoxNeedsUpdate = !0, this.recursiveBBoxNeedsUpdate = !0
                    }
                    resetBBoxNeedsUpdate() {
                        this.resetBBoxNeedsUpdateSelf(), this.traverseAncestors(_ => {
                            oo(_) && _.resetBBoxNeedsUpdateSelf()
                        }), this.traverseEntity(_ => {
                            _.resetBBoxNeedsUpdateSelf()
                        })
                    }
                    find(_) {
                        let O;
                        return this.traverseEntity(B => {
                            B.uuid === _ && (O = B)
                        }), O
                    }
                    traverseSortNextHelper() {
                        let _ = this.parent;
                        if (_) {
                            let O = _.children,
                                B = O.indexOf(this) + 1;
                            if (xu.is(O[B])) return O[B];
                            if (xu.is(_)) return _.traverseSortNextHelper()
                        }
                    }
                    sortNext() {
                        let _ = this.children;
                        return this.children.length > 0 && xu.is(this.children[0]) ? _[0] : this.traverseSortNextHelper()
                    }
                    goUp(_) {
                        let O = this;
                        for (; _ > 0 && null !== O;) O = O.parent, _ -= 1;
                        return O
                    }
                    hasAnccestorOrSelf(_) {
                        return this === _ || this.hasAnccestor(_)
                    }
                    hasAnccestor(_) {
                        let O = this.parent;
                        for (; O;) {
                            if (_ === O) return !0;
                            O = O.parent
                        }
                        return !1
                    }
                    countToAccestor(_) {
                        let O = 0,
                            B = this;
                        for (; B !== _;) {
                            if (null === B) return -1;
                            B = B.parent, O += 1
                        }
                        return O
                    }
                    forEachEntity(_) {
                        for (let O of this.children) oo(O) && _(O)
                    }
                    traverseEntityAncestors(_) {
                        this.traverseAncestors(O => {
                            xu.is(O) && _(O)
                        })
                    }
                    traverseConcreteEntity(_, O = 0) {
                        if (!0 !== _(this, O))
                            for (let B of this.children) oo(B) && B.isConcreteEntity && B.traverseEntity(_, O + 1)
                    }
                    traverseEntity(_, O = 0) {
                        if (!0 !== _(this, O))
                            for (let B of this.children) oo(B) && B.traverseEntity(_, O + 1)
                    }
                    traverseVisibleEntity(_) {
                        for (let O of (_(this), this.children)) oo(O) && O.visible && O.traverseVisibleEntity(_)
                    }
                    updateMatrix() {
                        super.updateMatrix(), this.cloner && this.cloner.onObjUpdateMatrix(), this.dispatchEvent({
                            type: "updateMatrix"
                        })
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), this.dispatchEvent({
                            type: "updateMatrixWorld"
                        })
                    }
                    copy(_, O = !1) {
                        return super.copy(_, O), this.dataPatched = _.dataPatched, this.raycastLock = _.raycastLock, this.scaleLock = _.scaleLock, this.hiddenMatrix.copy(_.hiddenMatrix), this
                    }
                    hasEntityChild() {
                        return this.children.some(_ => oo(_))
                    }
                    isAncestorOf(_) {
                        if (this.uuid === _) return !1;
                        let O = !1;
                        return this.traverseEntity(B => {
                            B.uuid === _ && (O = !0)
                        }), O
                    }
                    toObjectTransformState(_ = []) {
                        return this.updateWorldMatrix(!0, !1), dN({
                            position: this.position.toArray(),
                            rotation: [this.rotation.x * iK.RAD2DEG, this.rotation.y * iK.RAD2DEG, this.rotation.z * iK.RAD2DEG],
                            scale: this.scale.toArray(),
                            hiddenMatrix: this.hiddenMatrix.toArray()
                        }, _)
                    }
                    getTransformValues(_, O, B) {
                        return O[_].map((O, N) => B ? .shared.getVariable(O, [this.uuid, _, vR[N]]) ? ? O)
                    }
                    updateTransformState(_, O) {
                        let B = !1;
                        return _.position && (this.position.fromArray(this.getTransformValues("position", _, O)), B = !0), _.rotation && (vB.fromArray(this.getTransformValues("rotation", _, O)).multiplyScalar(iK.DEG2RAD), this.rotation.setFromVector3(vB), B = !0), _.scale && (this.scale.fromArray(this.getTransformValues("scale", _, O)), B = !0), void 0 !== _.hiddenMatrix && (B = !0, this.hiddenMatrix.fromArray(_.hiddenMatrix ? ? fU.identity)), B && (this.updateMatrix(), this.resetBBoxNeedsUpdate(), this.invalidateClonerTransform(this), this.traverseEntityAncestors(_ => {
                            _.invalidateClonerTransform(this)
                        })), _.position && _.rotation && _.scale && void 0 !== _.hiddenMatrix && this.updateWorldMatrix(!1, !0), B
                    }
                    onVariableUpdate(_ = !1) {
                        if (_) {
                            this.resetBBoxNeedsUpdate();
                            return
                        }
                        this.updateMatrix(), this.resetBBoxNeedsUpdate(), this.invalidateClonerTransform(this), this.traverseEntityAncestors(_ => {
                            _.invalidateClonerTransform(this)
                        })
                    }
                    dispose() {
                        this.disposed = !0, this.cloner && (this.cloner.removeFromParent(), this.cloner = void 0)
                    }
                    disposeChildrenRecursively() {
                        for (let _ of this.children) xu.is(_) && _.disposeRecursively()
                    }
                    disposeRecursively() {
                        this.dispose(), this.children.forEach(_ => {
                            xu.is(_) && _.disposeRecursively()
                        })
                    }
                    toState(_ = []) {
                        return dN({
                            name: this.name,
                            visible: this.visible,
                            raycastLock: this.raycastLock,
                            ...this.toObjectTransformState(_)
                        }, _)
                    }
                    updateByObjUpdateOp(_, O) {
                        void 0 !== _ && this.updateByOp({
                            type: 0,
                            props: _,
                            path: []
                        }, { ...this.data,
                            ..._
                        }, O, !1)
                    }
                    updateByOp(_, O, B, N) {
                        let k = this.data;
                        this.data = O;
                        let F = _,
                            U = qn(_.path, ["states", "*"]);
                        if (null !== U) {
                            if (0 === _.type) {
                                let [O] = U;
                                if (this ? .stateSelection === O) {
                                    let O = { ..._.props
                                    };
                                    if (delete O.name, Object.values(_.props).some(_ => void 0 === _)) {
                                        let B = this.data;
                                        if (void 0 !== B) {
                                            let N = uz.zoom(B, _.path.slice(2));
                                            if (N)
                                                for (let B in _.props) void 0 === _.props[B] && B in N && (O[B] = N[B])
                                        }
                                    }
                                    F = { ..._,
                                        props: O,
                                        path: _.path.slice(2)
                                    }
                                }
                            }
                        } else if (0 === _.type) {
                            let O = this.stateSelection ? this.data.states.data(this.stateSelection) : void 0;
                            if (void 0 !== O) {
                                if (void 0 !== _.props.name && O.name) {
                                    let {
                                        name: _,
                                        ...B
                                    } = O;
                                    O = B
                                }
                                if (void 0 !== _.props.material && "material" in O) {
                                    let {
                                        material: _,
                                        ...B
                                    } = O;
                                    O = B
                                }
                                let B = uz.removeOverridden(_.path, _.props, O);
                                F = { ..._,
                                    props: B
                                }
                            }
                        }
                        if (this.updateByPatchedOpBase(F, gS.patch(this.data, this.stateSelection ? this.data.states.data(this.stateSelection) : void 0), B), qn(_.path, ["overrides"])) {
                            let N = [],
                                k = [..._.path];
                            for (N.push(k[1]), k.splice(0, 2); k.length > 0 && "descendants" === k[0];) N.push(k[1]), k.splice(0, 2);
                            if (void 0 === N[N.length - 1]) {
                                if (0 === _.type)
                                    for (let O of Object.keys(_.props)) {
                                        N[N.length - 1] = O;
                                        let k = B.scene.findInstance([this.uuid, ...N]);
                                        k && (k.overrideData = _.props[O], k.updateState(uo.apply(k.component.data, k.overrideData), B))
                                    }
                            } else {
                                let F = B.scene.findInstance([this.uuid, ...N]);
                                if (F) {
                                    let U = uz.zoom(F.component.data, k);
                                    if (0 === (_ = { ..._,
                                            path: k
                                        }).type) {
                                        let O = _.props;
                                        if (U)
                                            for (let [B, N] of Object.entries(_.props)) void 0 === N && (O === _.props && (O = { ..._.props
                                            }), O[B] = U[B]);
                                        _ = { ..._,
                                            props: O
                                        }
                                    }
                                    F.overrideData = gv.resolve(O.overrides, N), F.updateByOp(_, uR.applySimple(F.data, _), B, !1)
                                }
                            }
                        } else if (this.instances.length > 0) {
                            let N;
                            if (0 === _.path.length && 0 === _.type) {
                                let O;
                                for (let B of gy.rootOverrideProps) B in _.props && (void 0 === O && (O = {}), O[B] = _.props[B]);
                                O && (N = { ..._,
                                    props: O
                                })
                            } else
                                for (let O of gy.rootOverrideProps)
                                    if (qn(_.path, [O])) {
                                        N = _;
                                        break
                                    }
                            void 0 !== N && this.instances.forEach(_ => {
                                if (_.isInstanceRoot) {
                                    let O = uo.filterOp(_.overrideData, N);
                                    O && _.updateByOp(O, uR.applySimple(_.data, O), B, !0)
                                }
                            }), this.instances.forEach(N => {
                                if (!N.isInstanceRoot) {
                                    let F = uo.filterOp(N.overrideData, _);
                                    if (F) {
                                        let U;
                                        U = k === N.data && _ === F ? O : uR.applySimple(N.data, F), N.updateByOp(F, U, B, !0)
                                    }
                                }
                            })
                        }
                    }
                    updateByPatchedOpBase(_, O, B) {
                        if (this.dataPatched = O, 0 === _.path.length && 0 === _.type) void 0 === _.props.type || fY.is(_.props.type) || vD.changeEntityProptotype(this, O, B);
                        else if (1 === _.path.length && "geometry" === _.path[0] && 0 === _.type && "type" in _.props)
                            for (let _ of (vD.changeEntityProptotype(this, O, B), this.children)) xu.is(_) && _.updateVisible(B.scene);
                        this.updateByPatchedOp(_, O, B)
                    }
                    updateByPatchedOp(_, O, B) {
                        if (0 === _.path.length && 0 === _.type && this.updateState(_.props, B), null !== qn(_.path, ["pathSnapping"]) && this.updatePathSnapping(O.pathSnapping), null !== qn(_.path, ["cloner"])) {
                            let N = uR.drop(_, 1);
                            0 === N.path.length && 0 === N.type && !0 === N.props.disabled ? this.setFromClonerState(null, B) : this.cloner ? this.cloner.updateState(O.cloner, B.scene) : (this.setFromClonerState(O.cloner, B), this.expandCloner(B.scene)), this.updateVisible(B.scene)
                        }
                    }
                    updatePathSnapping(_ = this.dataPatched.pathSnapping) {
                        this._updatedPathSnapping = _, this._needApplyPathSnapping = !0
                    }
                    get updatedPathSnapping() {
                        return this._updatedPathSnapping
                    }
                    applyPathSnapping(_) {
                        let O = this._updatedPathSnapping ? .pathId ? ? this.dataPatched.pathSnapping.pathId,
                            B = this._updatedPathSnapping ? .slide ? ? this.dataPatched.pathSnapping.slide ? ? 0,
                            N = this._updatedPathSnapping ? .offset ? ? this.dataPatched.pathSnapping.offset ? ? 0,
                            k = this._updatedPathSnapping ? .orientation ? ? this.dataPatched.pathSnapping.orientation;
                        if (null === O) return;
                        let F = _.find(O);
                        if (!F || !1 === this._needApplyPathSnapping) return;
                        this._needApplyPathSnapping = !1;
                        let U = F.data;
                        if (U.geometry.path.points.length <= 1) return;
                        let j = yv(U.geometry.path),
                            G = (B + N) % 1;
                        B + N === 1 && 0 === G && (G = 1);
                        let Y = j.getPointAt(G);
                        if (null === Y) return;
                        let Q = this.parent ? this.parent ? .matrixWorld : new rJ;
                        F.updateMatrixWorld();
                        let K = new rJ().multiplyMatrices(Q.clone().invert(), F.matrixWorld);
                        Y.applyMatrix4(K);
                        let $ = {
                            position: Y.toArray(),
                            rotation: U.rotation
                        };
                        if ("tangential" === k) {
                            let _ = new rJ().extractRotation(F.matrixWorld),
                                O = j.getTangentAt(G).applyMatrix4(_).add(Y),
                                B = new rJ().lookAt(Y, O, vN),
                                N = vB.setFromEuler(new r9().setFromRotationMatrix(B)).multiplyScalar(iK.RAD2DEG);
                            $ = { ...$,
                                rotation: N.toArray()
                            }
                        }
                        this.updateTransformState($), this.traverseEntity(_ => {
                            _._cameraType && _.dispatchEvent(vL)
                        })
                    }
                    updateVisible(_) {
                        if (this.visible = this.dataPatched.visible && (!this.dataPatched.cloner || (this.dataPatched.cloner.disabled ? ? !1) || this.dataPatched.cloner ? .hideBase !== !0), !_) return;
                        let O = !1;
                        this.traverseEntity(_ => {
                            if ("Splat" === _.data.type) return O = !0, !0
                        }), O && _.reloadSplats()
                    }
                    updateState_Entity(_, O) {
                        void 0 !== _.name && (this.name = _.name), void 0 !== _.raycastLock && (this.raycastLock = _.raycastLock), void 0 !== _.visible && (this.updateVisible(O ? .scene), this.resetBBoxNeedsUpdate()), O && "cloner" in _ && void 0 !== _.cloner && (this.setFromClonerState(_.cloner, O), this.updateVisible(O.scene)), this.updateTransformState(_, O)
                    }
                    get attachedSurfaceCloners() {
                        return this.children.filter(_ => _ instanceof vD.Cloner && "toObject" === _.parameters.type)
                    }
                    setFromClonerState(_, O) {
                        this.disposed || (null === _ || _.disabled ? (this.cloner && this.cloner.removeFromParent(), this.cloner = void 0) : void 0 === this.cloner ? (this.cloner = new vD.Cloner(this, _), O.scene.addPendingExpandCloner(this)) : this.cloner.updateState(_, O.scene))
                    }
                    expandCloner(_) {
                        !this.disposed && this.cloner && this.cloner.expandClones(_)
                    }
                    invalidateClonerTransform(_) {
                        this.cloner && this.cloner.invalidateTransform(_)
                    }
                },
                vk = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            radialSegments: 64,
                            heightSegments: 1,
                            openEnded: !1,
                            thetaStart: 0,
                            thetaLength: 360,
                            cornerRadius: 8,
                            cornerSegments: 8,
                            hollow: 0
                        }, _.parameters);
                        B.thetaLength = iK.clamp(B.thetaLength, 0, 360);
                        let N = B.width / 2,
                            k = B.radiusTop ? ? N,
                            F = B.radiusBottom ? ? N;
                        return k === F ? (k = N, F = N) : k > F ? (k = N, F = F * N / k) : (k = k * N / F, F = N), {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width),
                                radiusTop: k,
                                radiusBottom: F
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            depth: B,
                            height: N,
                            radialSegments: k,
                            heightSegments: F,
                            openEnded: U,
                            thetaStart: j,
                            thetaLength: G,
                            radiusTop: Y,
                            radiusBottom: Q,
                            cornerRadius: K,
                            cornerSegments: $,
                            hollow: ee
                        } = _.parameters, et;
                        return 0 === G ? (et = new sK).setAttribute("position", new sG([], 3)) : et = K || ee ? new vF(Y, Q, N, k, F, U, j, G * Math.PI / 180, K, K, $, ee) : new oc(Y, Q, N, k, F, U, j, G * Math.PI / 180), et.scale(1, 1, B / O), Object.assign(et, {
                            userData: { ..._,
                                type: "CylinderGeometry"
                            }
                        })
                    }
                };

            function ol(_, O, B) {
                B.x = _.x * O.x, B.y = _.y, B.z = _.x * O.y
            }

            function j2(_) {
                return new iJ(_.y, -_.x)
            }
            var vF = class extends sK {
                    constructor(_, O, B, N, k, F, U, j, G, Y, Q, K, $ = !1) {
                        super(), this.type = "RoundedCylinderBufferGeometry", _ = void 0 !== _ ? _ : 1, O = void 0 !== O ? O : 1, B = B || 1, N = Math.floor(N) || 8, k = Math.floor(k) || 1, F = void 0 !== F && F, U = void 0 !== U ? U : 0, j = void 0 !== j ? j : 2 * Math.PI, F && (G = 0, Y = 0);
                        let ee = [],
                            et = [],
                            ei = [],
                            er = [],
                            ea = 0,
                            en = B / 2,
                            eo = new rv,
                            el = new rv;
                        $ && 0 == _ && (_ = G), $ && 0 == O && (O = Y);
                        let eh = new iJ(_, en),
                            ec = new iJ(O, -en),
                            eu = null,
                            ep = null,
                            ef = null,
                            em = null,
                            eg = eh.clone().sub(ec),
                            ev = 0,
                            ex = 0,
                            eb = 0;
                        K > 0 && (ev = Math.min(_, O) * (1 - K), ex = _ - ev, eb = O - ev);
                        let e_ = eh.clone();
                        e_.x -= ev;
                        let eS = Math.PI - eg.angle(),
                            eA = eg.angle(),
                            eM = Math.tan(eA / 2),
                            eE = Math.tan(eS / 2),
                            eC = eM + eE;
                        if (G = Math.min(G, (_ - ex) / (K ? eC : eE), eg.length() / eC), Y = Math.min(Y, (O - eb) / (K ? eC : eM), eg.length() / eC), G > 0) {
                            let _ = G / eM;
                            eu = eh.clone().sub(new iJ(_, G)), K && (ef = eu.clone(), ef.x -= ev - eC * G), eh.sub(eg.clone().setLength(_))
                        }
                        if (Y > 0) {
                            let _ = Y / eE;
                            ep = ec.clone().sub(new iJ(_, -Y)), ec.add(eg.clone().setLength(_)), K && (em = ep.clone(), em.x -= ev - eC * Y, e_.sub(eg.clone().setLength(_)))
                        }
                        let eT = .5 > (eg = eh.clone().sub(ec)).length(),
                            eD = [];
                        for (let Q = 0; Q <= N; Q++) {
                            let $ = [],
                                ee = Q / N,
                                en = ee * j + U,
                                eh = new iJ(Math.sin(en), Math.cos(en));
                            if (em && ep ? (z($, ee, eh, eS, Y, em, -1, !0), z($, ee, eh, eA, Y, ep, -1, !1)) : ep ? (J($, eh, ep.x, 0, -1), z($, ee, eh, eA, Y, ep, -1, !1)) : F || J($, eh, O, eb, -1), ol(j2(eg).normalize(), eh, eo), !eT)
                                for (let _ = 0; _ <= k; _++) {
                                    let O = _ / k;
                                    ol(eg.clone().multiplyScalar(O).add(ec), eh, el), et.push(el.x, el.y, el.z), ei.push(eo.x, eo.y, eo.z), er.push(ee, .5 + el.y / B), $.push(ea++)
                                }
                            if (ef && eu ? (z($, ee, eh, eS, G, eu, 1, !1), z($, ee, eh, eA, G, ef, 1, !0)) : eu ? (z($, ee, eh, eS, G, eu, 1, !1), J($, eh, eu.x, 0, 1)) : F || J($, eh, _, ex, 1), K && !eT) {
                                ol(j2(eg).multiplyScalar(-1).normalize(), eh, eo);
                                for (let _ = 0; _ <= k; _++) {
                                    let O = _ / k;
                                    ol(eg.clone().multiplyScalar(-O).add(e_), eh, el), et.push(el.x, el.y, el.z), ei.push(eo.x, eo.y, eo.z), er.push(ee, .5 + el.y / B), $.push(ea++)
                                }
                            }
                            K && !F && $.push($[0]), eD.push($)
                        }
                        for (let _ = 0; _ < eD.length - 1; _++)
                            for (let O = 0; O < eD[0].length - 1; O++) {
                                if (F && K && O == k) continue;
                                let B = eD[_][O],
                                    N = eD[_ + 1][O],
                                    U = eD[_ + 1][O + 1],
                                    j = eD[_][O + 1],
                                    G = et[3 * U + 0],
                                    Y = et[3 * U + 2];
                                ee.push(B, N, j), (0 != G || 0 != Y) && ee.push(N, U, j)
                            }

                        function z(_, O, N, k, F, U, j, G) {
                            for (let Y = 0; Y < Q + 1; Y++) {
                                let K = Y / Q,
                                    $ = j < 0 ? K : 1 - K;
                                G && ($ -= 1), $ *= k;
                                let ee = new iJ(Math.sin($), Math.cos($) * j);
                                ol(ee.clone().multiplyScalar(F).add(U), N, el), et.push(el.x, el.y, el.z), ol(ee, N, eo), ei.push(eo.x, eo.y, eo.z), er.push(O, .5 + el.y / B), _.push(ea++)
                            }
                        }

                        function J(_, O, B, N, k) {
                            let F = new rv,
                                U = new iJ,
                                j = [B, N];
                            for (let B of (k < 0 && j.reverse(), j)) U.set(B, en * k), ol(U, O, F), et.push(F.x, F.y, F.z), ei.push(0, k, 0), er.push(.5, .5), _.push(ea++)
                        }

                        function Z(B, N, k) {
                            let F = new iJ(Math.sin(k), Math.cos(k)),
                                U = new iJ(-Math.cos(k), Math.sin(k)),
                                j = new rv,
                                G = B < 0 ? (_, O, B) => ee.push(_, O, B) : (_, O, B) => ee.push(_, B, O);
                            ol(new iJ((_ + O + ex + eb) / 4, 0), F, j), et.push(j.x, j.y, j.z), ei.push(U.x, 0, U.y), er.push(.5, .5);
                            let Y = ea++;
                            for (let _ of N) {
                                let O = et.slice(3 * _, 3 * _ + 3);
                                et.push(...O), ei.push(U.x, 0, U.y);
                                let B = er.slice(2 * _, 2 * _ + 2);
                                er.push(...B), ea++
                            }
                            for (let _ = Y + 1; _ < ea - 1; _++) G(Y, _, _ + 1);
                            G(Y, ea - 1, Y + 1)
                        }
                        j < 2 * Math.PI && (Z(-1, eD[0], U), Z(1, eD[eD.length - 1], U + j)), this.setIndex(ee), this.setAttribute("position", new sG(et, 3)), this.setAttribute("normal", new sG(ei, 3)), this.setAttribute("uv", new sG(er, 2))
                    }
                },
                vU = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            radialSegments: 32,
                            heightSegments: 8,
                            openEnded: !1,
                            thetaStart: 0,
                            thetaLength: 360,
                            cornerRadiusTop: 8,
                            cornerRadiusBottom: 8,
                            cornerSegments: 8
                        }, _.parameters);
                        return B.thetaLength = iK.clamp(B.thetaLength, 0, 360), {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            depth: B,
                            height: N,
                            radialSegments: k,
                            heightSegments: F,
                            openEnded: U,
                            thetaStart: j,
                            thetaLength: G,
                            cornerRadiusTop: Y,
                            cornerRadiusBottom: Q,
                            cornerSegments: K
                        } = _.parameters, $;
                        return 0 === G ? ($ = new sK).setAttribute("position", new sG([], 3)) : $ = Y > 0 || Q > 0 || G < 360 ? new vF(0, O / 2, N, k, F, U, j, G * Math.PI / 180, Y, Q, K, 0, !0) : new od(O / 2, N, k, F, U), $.scale(1, 1, B / O), Object.assign($, {
                            userData: { ..._,
                                type: "ConeGeometry"
                            }
                        })
                    }
                },
                vj = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            widthSegments: 1,
                            heightSegments: 1,
                            depthSegments: 1,
                            cornerRadius: 8,
                            cornerSegments: 8
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            widthSegments: k,
                            heightSegments: F,
                            depthSegments: U,
                            cornerRadius: j,
                            cornerSegments: G
                        } = _.parameters;
                        return Object.assign(0 == j ? new ai(O, B, N, k, F, U) : new vH(O, B, N, k, F, U, j, G), {
                            userData: { ..._,
                                type: "CubeGeometry"
                            }
                        })
                    }
                },
                vG = Math.PI / 2,
                vH = class extends sK {
                    constructor(_ = 1, O = 1, B = 1, N = 1, k = 1, F = 1, U = 0, j = 4) {
                        super(), this.type = "BoxGeometry";
                        let G = this;
                        N = Math.floor(N), k = Math.floor(k), F = Math.floor(F), j = Math.floor(j), U = Math.min(U, _ / 2, O / 2, B / 2);
                        let Y = [],
                            Q = [],
                            K = [],
                            $ = [],
                            ee = 0,
                            et = 0;

                        function g(_, O, B, N, k, F, j, ei, er, ea, en) {
                            let eo = (F - 2 * U) / er,
                                el = (j - 2 * U) / ea,
                                eh = F / 2 - U,
                                ec = j / 2 - U,
                                eu = ei / 2,
                                ep = er + 1,
                                ef = ea + 1,
                                em = 0,
                                eg = 0,
                                ev = new rv;
                            for (let F = 0; F < ef; F++) {
                                let U = F * el - ec;
                                for (let j = 0; j < ep; j++) {
                                    let G = j * eo - eh;
                                    ev[_] = G * N, ev[O] = U * k, ev[B] = eu, Q.push(ev.x, ev.y, ev.z), ev[_] = 0, ev[O] = 0, ev[B] = ei > 0 ? 1 : -1, K.push(ev.x, ev.y, ev.z), $.push(j / er), $.push(1 - F / ea), em += 1
                                }
                            }
                            for (let _ = 0; _ < ea; _++)
                                for (let O = 0; O < er; O++) {
                                    let B = ee + O + ep * _,
                                        N = ee + O + ep * (_ + 1),
                                        k = ee + (O + 1) + ep * (_ + 1),
                                        F = ee + (O + 1) + ep * _;
                                    Y.push(B, N, F), Y.push(N, k, F), eg += 6
                                }
                            G.addGroup(et, eg, en), et += eg, ee += em
                        }

                        function y(_, O, B, N, k, F, ei, er, ea, en, eo) {
                            let el = (ei - 2 * U) / en,
                                eh = ei / 2 - U,
                                ec = er / 2 - U,
                                eu = ea / 2,
                                ep = en + 1,
                                ef = 0,
                                em = 0,
                                eg = new rv,
                                ev = new rv;
                            for (let G = 0; G < j + 1; G++) {
                                let Y = G / j * vG,
                                    ee = Math.sin(Y) * U,
                                    et = (1 - Math.cos(Y)) * U,
                                    ei = Math.sin(Y),
                                    er = Math.cos(Y);
                                eg[O] = (ec + ee) * k, eg[B] = (eu - et) * F, ev[_] = 0, ev[O] = ei * Math.sign(eg[O]), ev[B] = er * Math.sign(eg[B]);
                                for (let O = 0; O < ep; O++) {
                                    let B = O * el - eh;
                                    eg[_] = B * N, Q.push(eg.x, eg.y, eg.z), K.push(ev.x, ev.y, ev.z), $.push(O / en), $.push(0), ef += 1
                                }
                            }
                            for (let _ = 0; _ < j; _++)
                                for (let O = 0; O < en; O++) {
                                    let B = ee + O + ep * _,
                                        N = ee + O + ep * (_ + 1),
                                        k = ee + (O + 1) + ep * (_ + 1),
                                        F = ee + (O + 1) + ep * _;
                                    Y.push(B, N, F), Y.push(N, k, F), em += 6
                                }
                            G.addGroup(et, em, eo), et += em, ee += ef
                        }

                        function v(N, k, F) {
                            let G = new rv,
                                et = new rv(_ / 2, O / 2, B / 2);
                            et.subScalar(U);
                            let ei = [],
                                er = N * k * F > 0 ? (_, O, B) => Y.push(_, O, B) : (_, O, B) => Y.push(_, B, O);
                            for (let _ = 0; _ <= j; _++) {
                                let O = [],
                                    B = vG * (1 - _ / j),
                                    Y = Math.cos(B),
                                    er = Math.sin(B),
                                    ea = 0;
                                for (let B = 0; B <= _; B++) {
                                    let B = Math.cos(ea),
                                        j = Math.sin(ea);
                                    G.x = Y * B, G.y = er, G.z = Y * j;
                                    let ei = et.clone().addScaledVector(G, U);
                                    Q.push(N * ei.x, k * ei.y, F * ei.z), K.push(N * G.x, k * G.y, F * G.z), $.push(0, 0), O.push(ee++), ea += vG / _
                                }
                                ei.push(O)
                            }
                            let ea = ei.length - 1;
                            for (let _ = 0; _ < ea; _++) {
                                let O = ei[_],
                                    B = ei[_ + 1],
                                    N = O.length - 1;
                                er(O[0], B[1], B[0]);
                                for (let _ = 1; _ <= N; _++) er(O[_ - 1], O[_], B[_]), er(O[_], B[_ + 1], B[_])
                            }
                        }
                        g("z", "y", "x", -1, -1, B, O, _, F, k, 0), g("z", "y", "x", 1, -1, B, O, -_, F, k, 1), g("x", "z", "y", 1, 1, _, B, O, N, F, 2), g("x", "z", "y", 1, -1, _, B, -O, N, F, 3), g("x", "y", "z", 1, -1, _, O, B, N, k, 4), g("x", "y", "z", -1, -1, _, O, -B, N, k, 5), U > 0 && (y("z", "y", "x", -1, -1, 1, B, O, _, F, 0), y("z", "y", "x", 1, -1, -1, B, O, _, F, 1), y("z", "y", "x", -1, 1, -1, B, O, _, F, 1), y("z", "y", "x", 1, 1, 1, B, O, _, F, 0), y("x", "y", "z", -1, -1, -1, _, O, B, N, 0), y("x", "y", "z", 1, -1, 1, _, O, B, N, 1), y("x", "y", "z", -1, 1, 1, _, O, B, N, 0), y("x", "y", "z", 1, 1, -1, _, O, B, N, 1), y("y", "x", "z", -1, -1, 1, O, _, B, k, 0), y("y", "x", "z", 1, -1, -1, O, _, B, k, 1), y("y", "x", "z", 1, 1, 1, O, _, B, k, 1), y("y", "x", "z", -1, 1, -1, O, _, B, k, 0), v(1, 1, 1), v(-1, 1, 1), v(1, -1, 1), v(-1, -1, 1), v(1, 1, -1), v(-1, 1, -1), v(1, -1, -1), v(-1, -1, -1)), this.setIndex(Y), this.setAttribute("position", new sG(Q, 3)), this.setAttribute("normal", new sG(K, 3)), this.setAttribute("uv", new sG($, 2))
                    }
                },
                vW = class extends sK {
                    constructor(_ = [], O = [], B = "", N = 1, k = .2, F = 4) {
                        super(), this.type = "PolyhedronGeometryRound";
                        let U = [],
                            j = [],
                            G = [];
                        (function() {
                            0 == (k = Math.min(1 - 1e-5, k)) && (F = 0);
                            let j = {
                                    IcosahedronGeometry: 5,
                                    DodecahedronGeometry: 3,
                                    HexahedronGeometry: 3,
                                    OctahedronGeometry: 4,
                                    TetrahedronGeometry: 3
                                }[B],
                                Y = new rv,
                                Q = Y.clone(),
                                K = new sO,
                                $ = k * N,
                                ee = N - $,
                                et = F + 1,
                                ei = new rv,
                                S = (_, O) => ei.subVectors(_, O).normalize(),
                                A = (_, O) => Array(_).fill(void 0).map(O),
                                er = A(_.length / 3, (O, B) => new rv().fromArray(_, 3 * B).setLength(N)),
                                ea = [];
                            for (let _ = 0; _ < er.length; _++) {
                                let B = er[_],
                                    N = [],
                                    k, F, U, j = 1e10,
                                    G = -1;
                                for (; - 1 != (G = O.indexOf(_, G + 1));) {
                                    let _ = G - G % 3;
                                    k = O[_ + (G + 1) % 3], F = O[_ + (G + 2) % 3], j = Math.min(j, U = B.distanceToSquared(er[k])), N.push([k, F, U])
                                }
                                j += 1e-6;
                                let Y = [],
                                    Q = 0,
                                    K = N.length;
                                for (let O = 0; O < K; O++) {
                                    [k, F, U] = N[Q];
                                    let O = ea[k] ? .includes(_) == !0;
                                    U <= j && Y.push(k + 1e6 * +O), Q = N.findIndex(_ => _[0] == F)
                                }
                                ea.push(Y)
                            }
                            let en = []; {
                                let _ = 0,
                                    O = 0,
                                    B, N, k = 3 == j;
                                for (let U = 0; U <= F; U++) {
                                    B = U * (U + 1) / 2, N = (U + 1) * (U + 2) / 2;
                                    for (let j = 0; j < F - U; j++)[_, O] = [B + j + U + 2, N + j + U + 3], en.push(B, N, ...k ? [O, B] : [_, N], O, _), [B, N] = [_, O];
                                    en.push(B, N, B + F + 2)
                                }
                            }
                            let eo = Y.clone(),
                                el = Y.clone(),
                                eh = Y.clone(),
                                ec = Y.clone(),
                                eu = Y.clone(),
                                ep = [],
                                ef = A(er.length, () => A(j, () => Y.clone()));
                            for (let _ = 0; _ < er.length; _++) {
                                Y.copy(er[_]).normalize(), eo.copy(Y).multiplyScalar(ee);
                                let O = ea[_];
                                for (let B = 0; B < O.length; B++) {
                                    let N = O[B],
                                        k = O[(B + 1) % j];
                                    K.setFromPointsAndIndices(er, _, N % 1e6, k % 1e6), K.b.sub(K.a).setLength(1e10).add(K.a), K.c.sub(K.a).setLength(1e10).add(K.a), K.closestPointToPoint(eo, ef[_][B])
                                }
                                let B = [],
                                    N = [],
                                    k = [],
                                    em = new rv;
                                0 == F && [...ef[_]].reduce((_, O) => _.add(O), em).multiplyScalar(1 / j);
                                for (let O = 0; O < j; O++) {
                                    let U = [],
                                        G = (O - 1 + j) % j,
                                        K = ef[_][G],
                                        er = ef[_][O];
                                    Y.copy(K).sub(eo), Q.copy(er).sub(eo);
                                    let ea = eo.angleTo(Y),
                                        en = Y.angleTo(Q),
                                        ep = Math.cos(ea) * $;
                                    0 == F ? el.copy(em) : el.copy(eo).setLength(ee + ep), N.push(ep);
                                    let eg = [el, K, er];
                                    for (let _ = 0; _ < 2; _++) {
                                        let O = eg[_],
                                            N = eg[_ + 1];
                                        ec.subVectors(O, eo), eu.subVectors(N, eo), eh.crossVectors(ec, eu).normalize();
                                        for (let N = 0; N < et; N++) {
                                            let k = [ea, en][_] * N / et;
                                            Y.copy(ec).applyAxisAngle(eh, k).add(eo), B.push(Y.clone()), _ && (S(Y, eo), U.push([0 == N ? O : Y.clone(), ei.clone()]))
                                        }
                                        _ && (S(N, eo), U.push([N, ei.clone()]))
                                    }
                                    k.push(U)
                                }
                                ep.push(k);
                                let eg = 2 * et;
                                for (let _ = 0; _ < j; _++) {
                                    let O = eg * _,
                                        k = eg * ((_ + 1) % j),
                                        F = [B[O]];
                                    for (let U = 1; U < et; U++) {
                                        ec = B[O + U], eu = B[k + U], F.push(ec);
                                        for (let O = 1, B = U - 2 + 1; O <= B; O++) Y.lerpVectors(ec, eu, O / (B + 1)), Y.sub(eo).setLength(N[_]).add(eo), F.push(Y.clone());
                                        F.push(eu)
                                    }
                                    for (let _ = 0; _ < et; _++) F.push(B[_ + et + O]);
                                    F.push(B[k + et]);
                                    let Q = en.map(_ => F[_]);
                                    U.push(...Q.map(_ => [_.x, _.y, _.z]).flat()), G.push(...Q.map(_ => (S(_, eo), [ei.x, ei.y, ei.z])).flat())
                                }
                            }
                            let em = [];
                            for (let _ = 0; _ < ea.length; _++)
                                for (let O = 0; O < j; O++) {
                                    let B = ea[_][O];
                                    if (B < 1e6) {
                                        let N = ea[B].findIndex(O => O % 1e6 == _),
                                            k = ep[_][O],
                                            F = ep[B][N];
                                        for (let _ = 0; _ < et; _++) {
                                            let O = k[_],
                                                B = F[et - _],
                                                N = k[_ + 1];
                                            [O, B, N, N, B, F[et - (_ + 1)]].forEach(_ => {
                                                U.push(_[0].x, _[0].y, _[0].z), G.push(_[1].x, _[1].y, _[1].z)
                                            })
                                        }
                                        em.push(k[0][0], F[et][0], k[et][0], F[0][0])
                                    }
                                }
                            for (; em.length;) {
                                let _, O, B, N;
                                [_, O] = em.splice(0, 2);
                                let k = [_];
                                for (; _ != O;) k.push(O), N = (B = em.indexOf(O)) % 2, O = em.splice(B - N, 2)[1 - N];
                                ei.subVectors(k[0], k[1]).cross(Y.subVectors(k[0], k[2])).normalize();
                                let F = 0 > ei.dot(k[0]);
                                F && ei.negate();
                                for (let _ = 1; _ <= k.length - 2; _++)[k[_ + +F], k[_ + 1 - +F], k[0]].forEach(_ => {
                                    U.push(_.x, _.y, _.z), G.push(ei.x, ei.y, ei.z)
                                })
                            }
                        })(),
                        function() {
                            let _ = new rv;
                            for (let O = 0; O < U.length; O += 3) {
                                _.x = U[O + 0], _.y = U[O + 1], _.z = U[O + 2];
                                let B = S(_) / 2 / Math.PI + .5,
                                    N = Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) / Math.PI + .5;
                                j.push(B, 1 - N)
                            }
                            let O = new rv,
                                B = new rv,
                                N = new rv,
                                k = new rv,
                                F = new iJ,
                                G = new iJ,
                                Y = new iJ,
                                w = (_, O, B, N) => {
                                    N < 0 && 1 === _.x && (j[O] = _.x - 1), 0 === B.x && 0 === B.z && (j[O] = N / 2 / Math.PI + .5)
                                };
                            for (let _ = 0, Q = 0; _ < U.length; _ += 9, Q += 6) {
                                O.set(U[_ + 0], U[_ + 1], U[_ + 2]), B.set(U[_ + 3], U[_ + 4], U[_ + 5]), N.set(U[_ + 6], U[_ + 7], U[_ + 8]), F.set(j[Q + 0], j[Q + 1]), G.set(j[Q + 2], j[Q + 3]), Y.set(j[Q + 4], j[Q + 5]), k.copy(O).add(B).add(N).divideScalar(3);
                                let K = S(k);
                                w(F, Q + 0, O, K), w(G, Q + 2, B, K), w(Y, Q + 4, N, K)
                            }
                            for (let _ = 0; _ < j.length; _ += 6) {
                                let O = j[_ + 0],
                                    B = j[_ + 2],
                                    N = j[_ + 4],
                                    k = Math.max(O, B, N),
                                    F = Math.min(O, B, N);
                                k > .9 && F < .1 && (O < .2 && (j[_ + 0] += 1), B < .2 && (j[_ + 2] += 1), N < .2 && (j[_ + 4] += 1))
                            }

                            function S(_) {
                                return Math.atan2(_.z, -_.x)
                            }
                        }(), this.setAttribute("position", new sG(U, 3)), this.setAttribute("normal", new sG(G, 3)), this.setAttribute("uv", new sG(j, 2))
                    }
                    static fromJSON(_) {
                        return new vW(_.vertices, _.indices, _.radius, _.corner, _.cornerSides)
                    }
                },
                vY = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            detail: 0,
                            corner: 0,
                            cornerSides: 4
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            detail: k,
                            corner: F,
                            cornerSides: U
                        } = _.parameters, j = 0 === k && 0 !== F ? new vX(.5 * O, F, U) : new ov(.5 * O, k);
                        return j.scale(1, B / O, N / O), Object.assign(j, {
                            userData: { ..._,
                                type: "DodecahedronGeometry"
                            }
                        })
                    }
                },
                vX = class extends vW {
                    constructor(_ = 1, O = .2, B = 4) {
                        let N = (1 + Math.sqrt(5)) / 2,
                            k = 1 / N,
                            F = "DodecahedronGeometry";
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -k, -N, 0, -k, N, 0, k, -N, 0, k, N, -k, -N, 0, -k, N, 0, k, -N, 0, k, N, 0, -N, 0, -k, N, 0, -k, -N, 0, k, N, 0, k], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], F, _, O, B), this.type = F
                    }
                    static fromJSON(_) {
                        return new vX(_.radius, _.corner, _.cornerSides)
                    }
                },
                vQ = class {
                    constructor(_) {
                        this.position = new iJ, this.startPosition = new iJ, this.uuid = iK.generateUUID(), this.position = _.clone()
                    }
                    start() {
                        this.reset()
                    }
                    reset() {
                        this.startPosition.copy(this.position)
                    }
                    applyOffset(_) {
                        this.position.copy(this.startPosition).add(_)
                    }
                    copy(_) {
                        return this.position.copy(_.position), this.startPosition.copy(_.startPosition), this
                    }
                    clone() {
                        return new vQ(this.position).copy(this)
                    }
                    toJSON() {
                        return [this.position.x, this.position.y]
                    }
                },
                vZ = class extends vQ {
                    constructor(_) {
                        super(_.position), this.parent = _
                    }
                    copy(_) {
                        return super.copy(_), this
                    }
                    clone() {
                        return new vZ(this.parent).copy(this)
                    }
                },
                vK = class extends vQ {
                    constructor(_, O) {
                        super(O), this.controls = [], this.roundness = 0, this.areControlsDirectionsMirrored = !0, this.uuid = _, this.controls.push(new vZ(this), new vZ(this))
                    }
                    static create(_, O) {
                        let B = new vK(_, new iJ(...O.position));
                        return B.controls[0].position.set(...O.controlPrevious.position), B.controls[1].position.set(...O.controlNext.position), B.roundness = O.roundness, B.areControlsDirectionsMirrored = O.areControlsDirectionsMirrored, B
                    }
                    getOppositeControl(_) {
                        let O = this.controls.indexOf(_);
                        return 0 === O ? this.controls[1] : 1 === O ? this.controls[0] : null
                    }
                    applyOffsetToControls(_, O = 1) {
                        for (let B = 0, N = this.controls.length; B < N; B++) {
                            let N = this.controls[B];
                            this.position.distanceTo(N.position) <= O ? N.position.copy(this.position) : N.applyOffset(_)
                        }
                    }
                    controlsMoved() {
                        return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position))
                    }
                    copy(_) {
                        return super.copy(_), this.controls[0].copy(_.controls[0]), this.controls[1].copy(_.controls[1]), this.roundness = _.roundness, this.uuid = _.uuid, this
                    }
                    clone() {
                        return new vK(this.uuid, this.position).copy(this)
                    }
                    toJSON() {
                        return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [this.roundness])
                    }
                    computeTangents() {
                        return [this.curveBefore ? .getTangentAt(1), this.curveAfter ? .getTangentAt(0)]
                    }
                    computeNormals(_ = new iJ, O = new iJ) {
                        let [B, N] = this.computeTangents();
                        return B && N && (X2(B, _), X2(N, O)), [_, O]
                    }
                    computeTangent(_ = new iJ) {
                        let [O, B] = this.computeTangents();
                        return O && B && _.copy(O).add(B).normalize(), _
                    }
                    computeNormal(_ = new iJ) {
                        let [O, B] = this.computeNormals();
                        return _.copy(O).add(B).normalize(), _
                    }
                };

            function X2(_, O = new iJ) {
                let B = _.length();
                return O.set(-_.y / B, _.x / B)
            }
            var OS = _ => _,
                vJ = new iJ,
                v$ = new iJ,
                v0 = new iJ,
                v1 = new iJ,
                v3 = new iJ,
                v4 = new iJ,
                v5 = new rv,
                v6 = new rv;

            function Tp(_, O, B = Number.EPSILON) {
                return Math.abs(_ - O) < B
            }

            function RS(_, O, B) {
                let N = Math.sqrt(Math.pow(O.x - _.x, 2) + Math.pow(O.y - _.y, 2)),
                    k = Math.sqrt(Math.pow(O.x - B.x, 2) + Math.pow(O.y - B.y, 2)),
                    F = Math.sqrt(Math.pow(B.x - _.x, 2) + Math.pow(B.y - _.y, 2));
                return Math.acos((k * k + N * N - F * F) / (2 * k * N))
            }

            function IS(_, O, B) {
                return 0 === vJ.copy(O).sub(_).cross(v$.copy(B).sub(_))
            }

            function LS(_, O) {
                return _.position.equals(_.controls[1].position) && O.position.equals(O.controls[0].position)
            }

            function Q2(_, O) {
                return IS(_.position, _.controls[1].position, O.position) && IS(_.position, O.controls[0].position, O.position)
            }

            function NS(_, O = 12, B = !1) {
                let N = [];
                for (let k = 0, F = _.length; k < F; k++) {
                    let F = _[k],
                        U = 0;
                    if (B && void 0 !== F.roundedCurveCorner) {
                        let _ = .5 * ll(F.roundedCurveCorner, O);
                        k > 0 && (N[k - 1] += _), U += _
                    }
                    void 0 !== F.curveAfter && (U += ll(F.curveAfter, O)), N.push(U)
                }
                return _.length > 0 && B && void 0 !== _[0].roundedCurveCorner && (N[_.length - 1] += .5 * ll(_[0].roundedCurveCorner, O)), N
            }

            function ll(_, O = 12) {
                return _ && _ instanceof nK ? 2 * O : _ && (_ instanceof n6 || _ instanceof n8) ? 1 : _ && _ instanceof ot ? O * _.points.length : O
            }
            var v8 = new iJ,
                v9 = new iJ,
                v7 = new iJ,
                yt = new iJ,
                yi = new iJ,
                yr = new iJ,
                ys = class extends ox {
                    constructor(_ = 100, O = 100) {
                        super(), this.points = [], this.shapeHoles = [], this.plane = new av(new rv(0, 0, -1)), this.subdivision = 0, this.controlSnapDistance = 4, this.pointIDs = 0, this.isMesh2D = !1, this.isText = !1, this._roundness = 0, this.isClosed = !1, this.useCubicForRoundedCorners = !0, this.uuid = iK.generateUUID(), this.needsUpdate = !1, this.roundedCurves = [], this._width = _, this._height = O
                    }
                    static createFromState(_, O, B) {
                        let N = new ys;
                        return N.isClosed = _.isClosed, N.points = _.points.map(_ => vK.create(_.id, _.data)), "number" == typeof _.roundness && (N.roundness = _.roundness), N.shapeHoles = _.shapeHoles.map(_ => ys.createFromState(_)), void 0 !== O && void 0 !== B && N.applySize(O, B), N.update(), N
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    get roundness() {
                        return this._roundness
                    }
                    set roundness(_) {
                        if (this._roundness !== _) {
                            this._roundness = _;
                            for (let O = 0, B = this.points.length; O < B; O++) this.points[O].roundness = _;
                            this.needsUpdate = !0
                        }
                    }
                    getPointsIndexesByIds(_) {
                        return _.map(_ => this.getPointIndexById(_)).filter(_ => _ >= 0)
                    }
                    getPointIndexById(_) {
                        let O = this.points.length,
                            B = this.points.findIndex(O => O.uuid === _);
                        if (B < 0) {
                            let B = O;
                            for (let O = 0, N = this.shapeHoles.length; O < N; O++) {
                                let N = this.shapeHoles[O],
                                    k = N.points.length,
                                    F = N.getPointIndexById(_);
                                if (!(F < 0)) return F + B;
                                B += k
                            }
                        }
                        return B
                    }
                    getLineIndexById(_) {
                        return this.getPointIndexById(_)
                    }
                    getBezierPoint(_) {
                        if (_ <= this.points.length - 1) return this.points[_];
                        if (this.shapeHoles.length > 0) {
                            let O = this.points.length;
                            for (let B = 0, N = this.shapeHoles.length; B < N; B++) {
                                let N = this.shapeHoles[B],
                                    k = _ - O;
                                if (k <= N.points.length - 1) return N.points[k];
                                O += N.points.length
                            }
                        }
                        throw Error("This shape does not have a point for this index: " + _)
                    }
                    getBezierPointIndex(_) {
                        let O = this.points.indexOf(_);
                        if (O >= 0) return O;
                        if (O = this.points.length, this.shapeHoles.length > 0)
                            for (let B = 0, N = this.shapeHoles.length; B < N; B++) {
                                let N = this.shapeHoles[B],
                                    k = N.points.indexOf(_);
                                if (k >= 0) return O + k;
                                O += N.points.length
                            }
                        return -1
                    }
                    getAllPoints() {
                        let _ = [].concat(...this.shapeHoles.map(_ => _.points));
                        return [...this.points, ..._]
                    }
                    applySize(_, O) {
                        0 === _ && (_ = .001), 0 === O && (O = .001), this._width = _, this._height = O
                    }
                    applyScale(_, O) {
                        let B = v8.set(_, O);
                        for (let _ = 0, O = this.points.length; _ < O; _++) {
                            let O = this.points[_];
                            O.position.multiply(B), O.controls[0].position.multiply(B), O.controls[1].position.multiply(B)
                        }
                        for (let B = 0, N = this.shapeHoles.length; B < N; B++) this.shapeHoles[B].applyScale(_, O);
                        this._update()
                    }
                    createPoint(_, O = 0, B = iK.generateUUID()) {
                        let N;
                        N = _ instanceof iJ ? _ : new iJ(_, O);
                        let k = new vK(B, N);
                        return k.roundness = this.roundness, k
                    }
                    addPoint(_) {
                        this.points.push(_), this.needsUpdate = !0
                    }
                    addPointAt(_, O) {
                        this.points.splice(O, 0, _), this.needsUpdate = !0
                    }
                    getPointByUuid(_) {
                        for (let O = 0, B = this.points.length; O < B; O++) {
                            let B = this.points[O];
                            if (B.uuid === _) return B
                        }
                        for (let O = 0, B = this.shapeHoles.length; O < B; O++) {
                            let B = this.shapeHoles[O].getPointByUuid(_);
                            if (B) return B
                        }
                    }
                    getFirstPoint() {
                        return this.points[0]
                    }
                    getLastPoint() {
                        return this.points[this.points.length - 1]
                    }
                    removePoint(_) {
                        let O = this.points.indexOf(_);
                        O >= 0 && this.points.splice(O, 1), this.needsUpdate = !0
                    }
                    removePointById(_) {
                        let O = this.points.find(O => O.uuid === _);
                        O && this.removePoint(O)
                    }
                    update() {
                        for (let _ = 0, O = this.shapeHoles.length; _ < O; _++) this.shapeHoles[_].update();
                        this._update()
                    }
                    extractShapePointsToBuffer(_, O = 12, B = !1) {
                        this.subdivision = O, void 0 === this.curveDivisions && this.computeCurveDivisions(O);
                        let N = B ? this.roundedCurveDivisions : this.curveDivisions;
                        return function(_, O, B = 12, N = !0) {
                            let k = v6.set(0, 0, 0),
                                F, U = 0,
                                j = [];
                            for (let N = 0; N < O.length; N++) {
                                let G = OS(O[N]),
                                    Y = ll(G, B);
                                j.push(Y);
                                for (let O = 0; O <= Y; O++)
                                    if (G instanceof n4 || G instanceof n9 || G instanceof n6) {
                                        if (G.getPoint(O / Y, vJ), k.set(vJ.x, vJ.y, 0), void 0 !== F && function(_, O, B = Number.EPSILON) {
                                                return _.distanceTo(O) < B
                                            }(F, k)) continue;
                                        void 0 === F && (F = v5), F.copy(k), _.setXYZ(U, k.x, k.y, k.z), U++
                                    }
                            }
                            N && U > 1 && !(_.getX(U - 1) === _.getX(0) && _.getY(U - 1) === _.getY(0) && _.getZ(U - 1) === _.getZ(0)) && (_.setXYZ(U, _.getX(0), _.getY(0), _.getZ(0)), U++)
                        }(_, B ? this.roundedCurves : this.curves, O, this.autoClose), N.reduce((_, O) => _ + O, 0) + 1
                    }
                    computeCurveDivisions(_ = 12) {
                        return this.curveDivisions = NS(this.points, _, !1), this.roundedCurveDivisions = NS(this.points, _, !0), this.curveDivisions
                    }
                    extractFilteredShapePointsToBuffer(_, O, B = 12) {
                        return 2 * (function(_, O, B, N = 12, k = !0) {
                            let F = v6.set(0, 0, 0),
                                U = 0,
                                j = [];
                            for (let k = 0; k < O.length; k++) {
                                if (!1 === B[k]) continue;
                                let G, Y = OS(O[k]),
                                    Q = ll(Y, N);
                                j.push(Q);
                                for (let O = 0; O <= Q; O++)
                                    if (Y instanceof n4 || Y instanceof n9 || Y instanceof n6) {
                                        if (Y.getPoint(O / Q, vJ), F.set(vJ.x, vJ.y, 0), G ? .equals(F)) continue;
                                        void 0 === G ? G = v5 : (_.setXYZ(U, G.x, G.y, G.z), U++, _.setXYZ(U, F.x, F.y, F.z), U++), G.copy(F)
                                    }
                            }
                            return k && U > 1 && !(_.getX(U - 1) === _.getX(0) && _.getY(U - 1) === _.getY(0) && _.getZ(U - 1) === _.getZ(0)) && (_.setXYZ(U, _.getX(0), _.getY(0), _.getZ(0)), U++), j
                        })(_, this.curves, O, B, this.autoClose).reduce((_, O) => _ + O, 0)
                    }
                    extractShapePointsToFlatArray(_, O = 12) {
                        return this.subdivision = O, void 0 === this.curveDivisions && this.computeCurveDivisions(O),
                            function(_, O, B = 12, N = !0) {
                                let k, F = 0;
                                for (let N = 0; N < O.length; N++) {
                                    let U = OS(O[N]),
                                        j = ll(U, B);
                                    for (let O = 0; O <= j; O++)
                                        if (U instanceof n4 || U instanceof n9 || U instanceof n6) {
                                            if (U.getPoint(O / j, vJ), void 0 !== k && function(_, O, B = Number.EPSILON) {
                                                    return _.distanceTo(O) < B
                                                }(k, vJ, 1e-12)) continue;
                                            void 0 === k && (k = v$), k.copy(vJ), _.push(vJ.x, vJ.y), F++
                                        }
                                }
                                return Tp(_[0], _[_.length - 2], 1e-12) && Tp(_[1], _[_.length - 1], 1e-12) && (_.pop(), _.pop()), N && F > 1 && !(Tp(_[F - 1], _[1], 1e-12) && Tp(_[F - 2], _[0], 1e-12)) && (_.push(_[0], _[1]), F++), _
                            }(_, this.roundedCurves, O, this.autoClose)
                    }
                    getCurveIndexFromVertexId(_, O = !1) {
                        let B = 0;
                        void 0 === this.curveDivisions && this.computeCurveDivisions(this.subdivision);
                        let N = O ? this.roundedCurveDivisions : this.curveDivisions,
                            k = 0;
                        O && void 0 !== this.points[0].roundedCurveCorner && (k = .5 * ll(this.points[0].roundedCurveCorner, this.subdivision));
                        let F = _ - k;
                        F < 0 && (F += N.reduce((_, O) => _ + O, 0));
                        for (let _ = 0, O = N.length; _ < O; _++) {
                            let O = N[_];
                            if (F < B + O) return [_, (F - B + 1) / O];
                            B += O
                        }
                        return [0, 1]
                    }
                    getCurveT(_, O, B) {
                        let N = this.points[_],
                            k = this.points[_ >= this.points.length - 1 ? 0 : _ + 1],
                            F = this.curveDivisions,
                            U = F[_];
                        if (LS(N, k)) {
                            let _ = N.position.distanceTo(k.position);
                            return N.position.distanceTo(v8.set(B.x, B.y)) / _
                        }
                        let j = 0;
                        for (let O = 0; O < _; O++) j += F[O];
                        return (O - j) / U
                    }
                    dispose() {}
                    _applyCurveForPoint(_, O) {
                        LS(O, _) ? this.lineTo(_.position.x, _.position.y) : this.bezierCurveTo(O.controls[1].position.x, O.controls[1].position.y, _.controls[0].position.x, _.controls[0].position.y, _.position.x, _.position.y);
                        let B = this.curves[this.curves.length - 1];
                        _.curveBefore = B, O.curveAfter = B;
                        let N = B.clone();
                        _.roundedCurveBefore = N, O.roundedCurveAfter = N, _.roundedCurveCorner = void 0, this.roundedCurves.push(N)
                    }
                    _update() {
                        if (this.curves = [], this.roundedCurves = [], !this.points.length) return;
                        for (let _ = 0, O = this.points.length; _ < O; _++) {
                            let O = this.points[_];
                            if (0 === _) this.moveTo(O.position.x, O.position.y);
                            else {
                                let B = this.points[_ - 1];
                                this._applyCurveForPoint(O, B)
                            }
                        }
                        let _ = this.getLastPoint();
                        if (_ ? .curveAfter && (_.curveAfter = void 0), this.isClosed) {
                            let _ = this.points[0],
                                O = this.points[this.points.length - 1];
                            this._applyCurveForPoint(_, O)
                        }
                        if (this.points.length > 2) {
                            let _ = 0;
                            for (let B = 0, N = this.points.length; B < N; B++) {
                                var O;
                                let N = this.points[B],
                                    k = this.points[B - 1] ? ? this.points[this.points.length - 1],
                                    F = this.points[B + 1] ? ? this.points[0],
                                    U = N.roundness,
                                    j = k && F && Q2(k, N) && Q2(N, F) && IS(k.position, N.position, F.position);
                                if (!N.controlsMoved() && U > 0 && !j) {
                                    let k, F = N.curveBefore,
                                        j = N.curveAfter;
                                    if (void 0 === F || void 0 === j) continue;
                                    let G = N.roundedCurveBefore,
                                        Y = N.roundedCurveAfter,
                                        Q = F.getLength(),
                                        K = j.getLength(),
                                        $ = Math.min(Math.min(U, .499 * Q), Math.min(U, .499 * K)),
                                        ee = 1 - $ / Q,
                                        et = $ / K,
                                        ei = F.getPointAt(ee, v8),
                                        er = j.getPointAt(et, v9);
                                    if (this._subSplitCurve(F, G, ee, ei, void 0), this._subSplitCurve(j, Y, et, void 0, er), this.useCubicForRoundedCorners) {
                                        let _ = Math.tan(RS(ei, N.position, er) / 2) * ei.distanceTo(N.position),
                                            [B, F] = function(_, O, B, N, k) {
                                                let F = Math.sqrt(Math.pow(O.x - _.x, 2) + Math.pow(O.y - _.y, 2)),
                                                    U = (_.y + O.y) / 2,
                                                    j = (_.x + O.x) / 2,
                                                    G = Math.sqrt(Math.pow(B, 2) - Math.pow(F / 2, 2)) * (_.y - O.y) / F,
                                                    Y = Math.sqrt(Math.pow(B, 2) - Math.pow(F / 2, 2)) * (O.x - _.x) / F;
                                                return N.set(j + G, U + Y), k.set(j - G, U - Y), [N, k]
                                            }(ei, er, _, v7, yt),
                                            [U, j] = function(_, O, B, N, k, F) {
                                                let U = O.x - _.x,
                                                    j = O.y - _.y,
                                                    G = B.x - _.x,
                                                    Y = B.y - _.y,
                                                    Q = Math.sqrt((U + G) * (U + G) + (j + Y) * (j + Y)),
                                                    K;
                                                return RS(O, _, B) > Math.PI && (Q *= -1), K = Tp(Y, j) ? (j + Y) * (N / Q - .5) * 8 / 3 / (U - G) : (U + G) * (N / Q - .5) * 8 / 3 / (Y - j), k.set(O.x - K * j, O.y + K * U), F.set(B.x + K * Y, B.y - K * G), [k, F]
                                            }((O = N.position, B.distanceTo(O) < F.distanceTo(O) ? F : B), ei, er, _, yi, yr);
                                        k = new n4(ei.clone(), U.clone(), j.clone(), er.clone())
                                    } else k = new n9(ei.clone(), N.position.clone(), er.clone());
                                    N.roundedCurveCorner = k, this.roundedCurves.splice(B + _, 0, k), _++
                                }
                            }
                        }
                    }
                    _subSplitCurve(_, O, B, N, k) {
                        if (_ instanceof n6) void 0 !== N && O.v2.copy(N), void 0 !== k && O.v1.copy(k);
                        else {
                            let F = _.getUtoTmapping(B, 0),
                                U = function(_, O, B, N, k = .5) {
                                    let F = vJ.subVectors(O, _).multiplyScalar(k).add(_),
                                        U = v$.subVectors(B, O).multiplyScalar(k).add(O),
                                        j = v0.subVectors(N, B).multiplyScalar(k).add(B),
                                        G = v1.subVectors(U, F).multiplyScalar(k).add(F),
                                        Y = v3.subVectors(j, U).multiplyScalar(k).add(U),
                                        Q = v4.subVectors(Y, G).multiplyScalar(k).add(G);
                                    return [_.x, _.y, F.x, F.y, G.x, G.y, Q.x, Q.y, Y.x, Y.y, j.x, j.y, N.x, N.y]
                                }(_.v0, _.v1, _.v2, _.v3, F);
                            return void 0 !== N && (O.v0.set(U[0], U[1]), O.v1.set(U[2], U[3]), O.v2.set(U[4], U[5]), O.v3.set(U[6], U[7])), void 0 !== k && (O.v0.set(U[6], U[7]), O.v1.set(U[8], U[9]), O.v2.set(U[10], U[11]), O.v3.set(U[12], U[13])), O
                        }
                        return O
                    }
                    clone() {
                        let _ = new ys(this._width, this._height);
                        return _.points = this.points.map(_ => _.clone()), _.isClosed = this.isClosed, _.roundness = this.roundness, _.isMesh2D = this.isMesh2D, _.shapeHoles = this.shapeHoles.map(_ => _.clone()), _
                    }
                    toJSON() {
                        return {
                            points: this.points.reduce((_, O) => _.concat(O.toJSON()), []),
                            shapeHoles: this.shapeHoles.map(_ => _.toJSON()),
                            isClosed: this.isClosed,
                            roundness: this.roundness
                        }
                    }
                    fromJSON(_) {
                        this.points = [], this.pointIDs = 0;
                        let O = _.points.length / 7;
                        for (let B = 0; B < O; B++) {
                            let O = 7 * B,
                                N = _.points[O + 0],
                                k = _.points[O + 1],
                                F = _.points[O + 2],
                                U = _.points[O + 3],
                                j = _.points[O + 4],
                                G = _.points[O + 5],
                                Y = _.points[O + 6],
                                Q = new vK(iK.generateUUID(), new iJ(N, k));
                            Q.controls[0].position.set(F, U), Q.controls[1].position.set(j, G), Q.roundness = Y, this.points.push(Q)
                        }
                        return this.shapeHoles = _.shapeHoles ? .length ? _.shapeHoles.map(_ => {
                            let O = new ys;
                            return O.fromJSON(_), O
                        }) : [], this.isClosed = _.isClosed, this._roundness = _.roundness, this._update(), this
                    }
                    fromShape(_, O = !1) {
                        this.isText = O;
                        let n = (_, O) => {
                            O instanceof n4 && O.v3.equals(_.position) && _.controls[0].position.copy(O.v2)
                        };
                        return this.points = (_ => {
                            let O = [],
                                B, N;
                            for (B = 0, N = _.length; B < N; B++) _[B] instanceof n9 && (_[B] = function(_) {
                                let O = new iJ;
                                O.addVectors(_.v0, vJ.subVectors(_.v1, _.v0).multiplyScalar(2 / 3));
                                let B = new iJ;
                                return B.addVectors(_.v2, v$.subVectors(_.v1, _.v2).multiplyScalar(2 / 3)), new n4(_.v0, O, B, _.v2)
                            }(_[B]));
                            for (B = 0, N = _.length; B < N; B++) {
                                let N = _[B],
                                    k = B > 0 ? _[B - 1] : null,
                                    F;
                                N instanceof n4 ? (F = this.createPoint(N.v0)).controls[1].position.copy(N.v1) : N instanceof n6 && (F = this.createPoint(N.v1)), void 0 !== F && (null !== k && n(F, k), O.push(F))
                            }
                            let k = _[_.length - 1],
                                F = !1;
                            return k instanceof n4 ? k.v3.equals(O[0].position) && (O[0].controls[0].position.copy(k.v2), F = !0) : k instanceof n6 && k.v2.equals(O[0].position) && (F = !0), this.isClosed = F, O
                        })(_.curves), _ instanceof ox && (this.shapeHoles = _.holes.map(_ => {
                            let O = new ys;
                            return O.fromShape(_), O
                        })), this.update(), this
                    }
                    updatePoint(_, O) {
                        let B = this.getPointByUuid(_);
                        B && (void 0 !== O.position && B.position.fromArray(O.position), void 0 !== O.roundness && (B.roundness = O.roundness), void 0 !== O.areControlsDirectionsMirrored && (B.areControlsDirectionsMirrored = O.areControlsDirectionsMirrored), this.needsUpdate = !0)
                    }
                    updatePreviousControl(_, O) {
                        let B = this.getPointByUuid(_) ? .controls[0];
                        B && (O.position && B.position.fromArray(O.position), this.needsUpdate = !0)
                    }
                    updateNextControl(_, O) {
                        let B = this.getPointByUuid(_) ? .controls[1];
                        B && (O.position && B.position.fromArray(O.position), this.needsUpdate = !0)
                    }
                },
                ya = 2 * Math.PI;

            function FS({
                x: _,
                y: O
            }, B, N, k, F) {
                return {
                    x: _ * B + k,
                    y: O * N + F
                }
            }

            function aD(_, O, B, N) {
                let k = Math.min(1, Math.max(-1, _ * B + O * N));
                return (_ * N - O * B < 0 ? -1 : 1) * Math.acos(k)
            }

            function nt(_, O) {
                if (!_) throw O || "Assertion Failed!"
            }(xc = xp || (xp = {}))[xc.ODD = 0] = "ODD", xc[xc.NONZERO = 1] = "NONZERO", xc[xc.POSITIVE = 2] = "POSITIVE", xc[xc.NEGATIVE = 3] = "NEGATIVE", xc[xc.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO", (xd = xf || (xf = {}))[xd.POLYGONS = 0] = "POLYGONS", xd[xd.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", xd[xd.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS";
            var yn = function() {
                    function i() {}
                    return i.vertEq = function(_, O) {
                        return _.s === O.s && _.t === O.t
                    }, i.vertLeq = function(_, O) {
                        return _.s < O.s || _.s === O.s && _.t <= O.t
                    }, i.transLeq = function(_, O) {
                        return _.t < O.t || _.t === O.t && _.s <= O.s
                    }, i.edgeGoesLeft = function(_) {
                        return i.vertLeq(_.Dst, _.Org)
                    }, i.edgeGoesRight = function(_) {
                        return i.vertLeq(_.Org, _.Dst)
                    }, i.vertL1dist = function(_, O) {
                        return Math.abs(_.s - O.s) + Math.abs(_.t - O.t)
                    }, i.edgeEval = function(_, O, B) {
                        nt(i.vertLeq(_, O) && i.vertLeq(O, B));
                        var N = O.s - _.s,
                            k = B.s - O.s;
                        return N + k > 0 ? N < k ? O.t - _.t + (_.t - B.t) * (N / (N + k)) : O.t - B.t + (B.t - _.t) * (k / (N + k)) : 0
                    }, i.edgeSign = function(_, O, B) {
                        nt(i.vertLeq(_, O) && i.vertLeq(O, B));
                        var N = O.s - _.s,
                            k = B.s - O.s;
                        return N + k > 0 ? (O.t - B.t) * N + (O.t - _.t) * k : 0
                    }, i.transEval = function(_, O, B) {
                        nt(i.transLeq(_, O) && i.transLeq(O, B));
                        var N = O.t - _.t,
                            k = B.t - O.t;
                        return N + k > 0 ? N < k ? O.s - _.s + (_.s - B.s) * (N / (N + k)) : O.s - B.s + (B.s - _.s) * (k / (N + k)) : 0
                    }, i.transSign = function(_, O, B) {
                        nt(i.transLeq(_, O) && i.transLeq(O, B));
                        var N = O.t - _.t,
                            k = B.t - O.t;
                        return N + k > 0 ? (O.s - B.s) * N + (O.s - _.s) * k : 0
                    }, i.vertCCW = function(_, O, B) {
                        return _.s * (O.t - B.t) + O.s * (B.t - _.t) + B.s * (_.t - O.t) >= 0
                    }, i.interpolate = function(_, O, B, N) {
                        return (_ = _ < 0 ? 0 : _) <= (B = B < 0 ? 0 : B) ? 0 === B ? (O + N) / 2 : O + (N - O) * (_ / (_ + B)) : N + (O - N) * (B / (_ + B))
                    }, i.intersect = function(_, O, B, N, k) {
                        var F, U, j;
                        i.vertLeq(_, O) || (j = _, _ = O, O = j), i.vertLeq(B, N) || (j = B, B = N, N = j), i.vertLeq(_, B) || (j = _, _ = B, B = j, j = O, O = N, N = j), i.vertLeq(B, O) ? i.vertLeq(O, N) ? ((F = i.edgeEval(_, B, O)) + (U = i.edgeEval(B, O, N)) < 0 && (F = -F, U = -U), k.s = i.interpolate(F, B.s, U, O.s)) : ((F = i.edgeSign(_, B, O)) + (U = -i.edgeSign(_, N, O)) < 0 && (F = -F, U = -U), k.s = i.interpolate(F, B.s, U, N.s)) : k.s = (B.s + O.s) / 2, i.transLeq(_, O) || (j = _, _ = O, O = j), i.transLeq(B, N) || (j = B, B = N, N = j), i.transLeq(_, B) || (j = _, _ = B, B = j, j = O, O = N, N = j), i.transLeq(B, O) ? i.transLeq(O, N) ? ((F = i.transEval(_, B, O)) + (U = i.transEval(B, O, N)) < 0 && (F = -F, U = -U), k.t = i.interpolate(F, B.t, U, O.t)) : ((F = i.transSign(_, B, O)) + (U = -i.transSign(_, N, O)) < 0 && (F = -F, U = -U), k.t = i.interpolate(F, B.t, U, N.t)) : k.t = (B.t + O.t) / 2
                    }, i
                }(),
                Cp = function() {
                    this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1
                },
                yl = function() {
                    function i(_) {
                        this.side = _, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0
                    }
                    return Object.defineProperty(i.prototype, "Rface", {
                        get: function() {
                            return this.Sym.Lface
                        },
                        set: function(_) {
                            this.Sym.Lface = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Dst", {
                        get: function() {
                            return this.Sym.Org
                        },
                        set: function(_) {
                            this.Sym.Org = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Oprev", {
                        get: function() {
                            return this.Sym.Lnext
                        },
                        set: function(_) {
                            this.Sym.Lnext = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Lprev", {
                        get: function() {
                            return this.Onext.Sym
                        },
                        set: function(_) {
                            this.Onext.Sym = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Dprev", {
                        get: function() {
                            return this.Lnext.Sym
                        },
                        set: function(_) {
                            this.Lnext.Sym = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Rprev", {
                        get: function() {
                            return this.Sym.Onext
                        },
                        set: function(_) {
                            this.Sym.Onext = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Dnext", {
                        get: function() {
                            return this.Sym.Onext.Sym
                        },
                        set: function(_) {
                            this.Sym.Onext.Sym = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(i.prototype, "Rnext", {
                        get: function() {
                            return this.Sym.Lnext.Sym
                        },
                        set: function(_) {
                            this.Sym.Lnext.Sym = _
                        },
                        enumerable: !0,
                        configurable: !0
                    }), i
                }(),
                Xh = function() {
                    this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0
                },
                yh = function() {
                    function i() {
                        var _ = new Xh,
                            O = new Cp,
                            B = new yl(0),
                            N = new yl(1);
                        _.next = _.prev = _, _.anEdge = null, O.next = O.prev = O, B.next = B, B.Sym = N, N.next = N, N.Sym = B, this.vHead = _, this.fHead = O, this.eHead = B, this.eHeadSym = N
                    }
                    return i.prototype.makeEdge_ = function(_) {
                        var O = new yl(0),
                            B = new yl(1);
                        _.Sym.side < _.side && (_ = _.Sym);
                        var N = _.Sym.next;
                        return B.next = N, N.Sym.next = O, O.next = _, _.Sym.next = B, O.Sym = B, O.Onext = O, O.Lnext = B, O.Org = null, O.Lface = null, O.winding = 0, O.activeRegion = null, B.Sym = O, B.Onext = B, B.Lnext = O, B.Org = null, B.Lface = null, B.winding = 0, B.activeRegion = null, O
                    }, i.prototype.splice_ = function(_, O) {
                        var B = _.Onext,
                            N = O.Onext;
                        B.Sym.Lnext = O, N.Sym.Lnext = _, _.Onext = N, O.Onext = B
                    }, i.prototype.makeVertex_ = function(_, O, B) {
                        nt(_, "Vertex can't be null!");
                        var N = B.prev;
                        _.prev = N, N.next = _, _.next = B, B.prev = _, _.anEdge = O;
                        var k = O;
                        do k.Org = _, k = k.Onext; while (k !== O)
                    }, i.prototype.makeFace_ = function(_, O, B) {
                        nt(_, "Face can't be null");
                        var N = B.prev;
                        _.prev = N, N.next = _, _.next = B, B.prev = _, _.anEdge = O, _.trail = null, _.marked = !1, _.inside = B.inside;
                        var k = O;
                        do k.Lface = _, k = k.Lnext; while (k !== O)
                    }, i.prototype.killEdge_ = function(_) {
                        _.Sym.side < _.side && (_ = _.Sym);
                        var O = _.next,
                            B = _.Sym.next;
                        O.Sym.next = B, B.Sym.next = O
                    }, i.prototype.killVertex_ = function(_, O) {
                        var B = _.anEdge,
                            N = B;
                        do N.Org = O, N = N.Onext; while (N !== B);
                        var k = _.prev,
                            F = _.next;
                        F.prev = k, k.next = F
                    }, i.prototype.killFace_ = function(_, O) {
                        var B = _.anEdge,
                            N = B;
                        do N.Lface = O, N = N.Lnext; while (N !== B);
                        var k = _.prev,
                            F = _.next;
                        F.prev = k, k.next = F
                    }, i.prototype.makeEdge = function() {
                        var _ = new Xh,
                            O = new Xh,
                            B = new Cp,
                            N = this.makeEdge_(this.eHead);
                        return this.makeVertex_(_, N, this.vHead), this.makeVertex_(O, N.Sym, this.vHead), this.makeFace_(B, N, this.fHead), N
                    }, i.prototype.splice = function(_, O) {
                        var B = !1,
                            N = !1;
                        if (_ !== O) {
                            if (O.Org !== _.Org && (N = !0, this.killVertex_(O.Org, _.Org)), O.Lface !== _.Lface && (B = !0, this.killFace_(O.Lface, _.Lface)), this.splice_(O, _), !N) {
                                var k = new Xh;
                                this.makeVertex_(k, O, _.Org), _.Org.anEdge = _
                            }
                            if (!B) {
                                var F = new Cp;
                                this.makeFace_(F, O, _.Lface), _.Lface.anEdge = _
                            }
                        }
                    }, i.prototype.delete = function(_) {
                        var O = _.Sym,
                            B = !1;
                        if (_.Lface !== _.Rface && (B = !0, this.killFace_(_.Lface, _.Rface)), _.Onext === _) this.killVertex_(_.Org, null);
                        else if (_.Rface.anEdge = _.Oprev, _.Org.anEdge = _.Onext, this.splice_(_, _.Oprev), !B) {
                            var N = new Cp;
                            this.makeFace_(N, _, _.Lface)
                        }
                        O.Onext === O ? (this.killVertex_(O.Org, null), this.killFace_(O.Lface, null)) : (_.Lface.anEdge = O.Oprev, O.Org.anEdge = O.Onext, this.splice_(O, O.Oprev)), this.killEdge_(_)
                    }, i.prototype.addEdgeVertex = function(_) {
                        var O = this.makeEdge_(_),
                            B = O.Sym;
                        this.splice_(O, _.Lnext), O.Org = _.Dst;
                        var N = new Xh;
                        return this.makeVertex_(N, B, O.Org), O.Lface = B.Lface = _.Lface, O
                    }, i.prototype.splitEdge = function(_) {
                        var O = this.addEdgeVertex(_).Sym;
                        return this.splice_(_.Sym, _.Sym.Oprev), this.splice_(_.Sym, O), _.Dst = O.Org, O.Dst.anEdge = O.Sym, O.Rface = _.Rface, O.winding = _.winding, O.Sym.winding = _.Sym.winding, O.idx = _.idx, O.Sym.idx = _.Sym.idx, O
                    }, i.prototype.connect = function(_, O) {
                        var B = !1,
                            N = this.makeEdge_(_),
                            k = N.Sym;
                        if (O.Lface !== _.Lface && (B = !0, this.killFace_(O.Lface, _.Lface)), this.splice_(N, _.Lnext), this.splice_(k, O), N.Org = _.Dst, k.Org = O.Org, N.Lface = k.Lface = _.Lface, _.Lface.anEdge = k, !B) {
                            var F = new Cp;
                            this.makeFace_(F, N, _.Lface)
                        }
                        return N
                    }, i.prototype.zapFace = function(_) {
                        var O, B, N, k, F, U = _.anEdge;
                        B = U.Lnext;
                        do B = (O = B).Lnext, O.Lface = null, null === O.Rface && (O.Onext === O ? this.killVertex_(O.Org, null) : (O.Org.anEdge = O.Onext, this.splice_(O, O.Oprev)), (N = O.Sym).Onext === N ? this.killVertex_(N.Org, null) : (N.Org.anEdge = N.Onext, this.splice_(N, N.Oprev)), this.killEdge_(O)); while (O != U);
                        k = _.prev, (F = _.next).prev = k, k.next = F
                    }, i.prototype.countFaceVerts_ = function(_) {
                        var O = _.anEdge,
                            B = 0;
                        do B++, O = O.Lnext; while (O !== _.anEdge);
                        return B
                    }, i.prototype.mergeConvexFaces = function(_) {
                        var O, B, N, k, F;
                        for (O = this.fHead.next; O !== this.fHead; O = O.next)
                            if (O.inside)
                                for (F = (B = O.anEdge).Org; N = B.Lnext, (k = B.Sym) && k.Lface && k.Lface.inside && this.countFaceVerts_(O) + this.countFaceVerts_(k.Lface) - 2 <= _ && yn.vertCCW(B.Lprev.Org, B.Org, k.Lnext.Lnext.Org) && yn.vertCCW(k.Lprev.Org, k.Org, B.Lnext.Lnext.Org) && (N = k.Lnext, this.delete(k), B = null, k = null), !(B && B.Lnext.Org === F);) B = N;
                        return !0
                    }, i.prototype.check = function() {
                        var _, O, B, N, k, F, U = this.fHead,
                            j = this.vHead,
                            G = this.eHead;
                        for (O = U, O = U;
                            (_ = O.next) !== U; O = _) {
                            nt(_.prev === O), k = _.anEdge;
                            do nt(k.Sym !== k), nt(k.Sym.Sym === k), nt(k.Lnext.Onext.Sym === k), nt(k.Onext.Sym.Lnext === k), nt(k.Lface === _), k = k.Lnext; while (k !== _.anEdge)
                        }
                        for (nt(_.prev === O && null === _.anEdge), N = j, N = j;
                            (B = N.next) !== j; N = B) {
                            nt(B.prev === N), k = B.anEdge;
                            do nt(k.Sym !== k), nt(k.Sym.Sym === k), nt(k.Lnext.Onext.Sym === k), nt(k.Onext.Sym.Lnext === k), nt(k.Org === B), k = k.Onext; while (k !== B.anEdge)
                        }
                        for (nt(B.prev === N && null === B.anEdge), F = G, F = G;
                            (k = F.next) !== G; F = k) nt(k.Sym.next === F.Sym), nt(k.Sym !== k), nt(k.Sym.Sym === k), nt(null !== k.Org), nt(null !== k.Dst), nt(k.Lnext.Onext.Sym === k), nt(k.Onext.Sym.Lnext === k);
                        nt(k.Sym.next === F.Sym && k.Sym === this.eHeadSym && k.Sym.Sym === k && null === k.Org && null === k.Dst && null === k.Lface && null === k.Rface)
                    }, i
                }(),
                uD = function() {
                    this.handle = null
                },
                hD = function() {
                    this.key = null, this.node = 0
                },
                yd = function() {
                    function i(_, O) {
                        this.leq = O, this.max = 0, this.nodes = [], this.handles = [], this.initialized = !1, this.freeList = 0, this.size = 0, this.max = _, this.nodes = [], this.handles = [];
                        for (var B = 0; B < _ + 1; B++) this.nodes[B] = new uD, this.handles[B] = new hD;
                        this.initialized = !1, this.nodes[1].handle = 1, this.handles[1].key = null
                    }
                    return i.prototype.floatDown_ = function(_) {
                        var O, B, N, k = this.nodes,
                            F = this.handles;
                        for (O = k[_].handle;;) {
                            if ((N = _ << 1) < this.size && this.leq(F[k[N + 1].handle].key, F[k[N].handle].key) && ++N, nt(N <= this.max), B = k[N].handle, N > this.size || this.leq(F[O].key, F[B].key)) {
                                k[_].handle = O, F[O].node = _;
                                break
                            }
                            k[_].handle = B, F[B].node = _, _ = N
                        }
                    }, i.prototype.floatUp_ = function(_) {
                        var O, B, N, k = this.nodes,
                            F = this.handles;
                        for (O = k[_].handle;;) {
                            if (B = k[N = _ >> 1].handle, 0 === N || this.leq(F[B].key, F[O].key)) {
                                k[_].handle = O, F[O].node = _;
                                break
                            }
                            k[_].handle = B, F[B].node = _, _ = N
                        }
                    }, i.prototype.init = function() {
                        for (var _ = this.size; _ >= 1; --_) this.floatDown_(_);
                        this.initialized = !0
                    }, i.prototype.min = function() {
                        return this.handles[this.nodes[1].handle].key
                    }, i.prototype.insert = function(_) {
                        var O, B, N, k;
                        if (2 * (O = ++this.size) > this.max) {
                            for (this.max *= 2, k = this.nodes.length, this.nodes.length = this.max + 1, N = k; N < this.nodes.length; N++) this.nodes[N] = new uD;
                            for (k = this.handles.length, this.handles.length = this.max + 1, N = k; N < this.handles.length; N++) this.handles[N] = new hD
                        }
                        return 0 === this.freeList ? B = O : (B = this.freeList, this.freeList = this.handles[B].node), this.nodes[O].handle = B, this.handles[B].node = O, this.handles[B].key = _, this.initialized && this.floatUp_(O), B
                    }, i.prototype.extractMin = function() {
                        var _ = this.nodes,
                            O = this.handles,
                            B = _[1].handle,
                            N = O[B].key;
                        return this.size > 0 && (_[1].handle = _[this.size].handle, O[_[1].handle].node = 1, O[B].key = null, O[B].node = this.freeList, this.freeList = B, --this.size, this.size > 0 && this.floatDown_(1)), N
                    }, i.prototype.delete = function(_) {
                        var O, B = this.nodes,
                            N = this.handles;
                        nt(_ >= 1 && _ <= this.max && null !== N[_].key), B[O = N[_].node].handle = B[this.size].handle, N[B[O].handle].node = O, --this.size, O <= this.size && (O <= 1 || this.leq(N[B[O >> 1].handle].key, N[B[O].handle].key) ? this.floatDown_(O) : this.floatUp_(O)), N[_].key = null, N[_].node = this.freeList, this.freeList = _
                    }, i
                }(),
                VS = function() {
                    this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1
                },
                dD = function() {
                    this.key = null, this.next = null, this.prev = null
                },
                yu = function() {
                    function i(_, O) {
                        this.frame = _, this.leq = O, this.head = new dD, this.head.next = this.head, this.head.prev = this.head
                    }
                    return i.prototype.min = function() {
                        return this.head.next
                    }, i.prototype.max = function() {
                        return this.head.prev
                    }, i.prototype.insert = function(_) {
                        return this.insertBefore(this.head, _)
                    }, i.prototype.search = function(_) {
                        var O = this.head;
                        do O = O.next; while (null !== O.key && !this.leq(this.frame, _, O.key));
                        return O
                    }, i.prototype.insertBefore = function(_, O) {
                        do _ = _.prev; while (null !== _.key && !this.leq(this.frame, _.key, O));
                        var B = new dD;
                        return B.key = O, B.next = _.next, _.next.prev = B, B.prev = _, _.next = B, B
                    }, i.prototype.delete = function(_) {
                        _.next.prev = _.prev, _.prev.next = _.next
                    }, i
                }(),
                yp = function() {
                    function i() {}
                    return i.regionBelow = function(_) {
                        return _.nodeUp.prev.key
                    }, i.regionAbove = function(_) {
                        return _.nodeUp.next.key
                    }, i.debugEvent = function(_) {}, i.addWinding = function(_, O) {
                        _.winding += O.winding, _.Sym.winding += O.Sym.winding
                    }, i.edgeLeq = function(_, O, B) {
                        var N = _.event,
                            k = O.eUp,
                            F = B.eUp;
                        return k.Dst === N ? F.Dst === N ? yn.vertLeq(k.Org, F.Org) ? 0 >= yn.edgeSign(F.Dst, k.Org, F.Org) : yn.edgeSign(k.Dst, F.Org, k.Org) >= 0 : 0 >= yn.edgeSign(F.Dst, N, F.Org) : F.Dst === N ? yn.edgeSign(k.Dst, N, k.Org) >= 0 : yn.edgeEval(k.Dst, N, k.Org) >= yn.edgeEval(F.Dst, N, F.Org)
                    }, i.deleteRegion = function(_, O) {
                        O.fixUpperEdge && nt(0 === O.eUp.winding), O.eUp.activeRegion = null, _.dict.delete(O.nodeUp)
                    }, i.fixUpperEdge = function(_, O, B) {
                        nt(O.fixUpperEdge), _.mesh.delete(O.eUp), O.fixUpperEdge = !1, O.eUp = B, B.activeRegion = O
                    }, i.topLeftRegion = function(_, O) {
                        var B, N = O.eUp.Org;
                        do O = i.regionAbove(O); while (O.eUp.Org === N);
                        if (O.fixUpperEdge) {
                            if (null === (B = _.mesh.connect(i.regionBelow(O).eUp.Sym, O.eUp.Lnext))) return null;
                            i.fixUpperEdge(_, O, B), O = i.regionAbove(O)
                        }
                        return O
                    }, i.topRightRegion = function(_) {
                        var O = _.eUp.Dst;
                        do _ = i.regionAbove(_); while (_.eUp.Dst === O);
                        return _
                    }, i.addRegionBelow = function(_, O, B) {
                        var N = new VS;
                        return N.eUp = B, N.nodeUp = _.dict.insertBefore(O.nodeUp, N), N.fixUpperEdge = !1, N.sentinel = !1, N.dirty = !1, B.activeRegion = N, N
                    }, i.isWindingInside = function(_, O) {
                        switch (_.windingRule) {
                            case xp.ODD:
                                return (1 & O) != 0;
                            case xp.NONZERO:
                                return 0 !== O;
                            case xp.POSITIVE:
                                return O > 0;
                            case xp.NEGATIVE:
                                return O < 0;
                            case xp.ABS_GEQ_TWO:
                                return O >= 2 || O <= -2
                        }
                        throw Error("Invalid winding rulle")
                    }, i.computeWinding = function(_, O) {
                        O.windingNumber = i.regionAbove(O).windingNumber + O.eUp.winding, O.inside = i.isWindingInside(_, O.windingNumber)
                    }, i.finishRegion = function(_, O) {
                        var B = O.eUp,
                            N = B.Lface;
                        N.inside = O.inside, N.anEdge = B, i.deleteRegion(_, O)
                    }, i.finishLeftRegions = function(_, O, B) {
                        for (var N, k = null, F = O, U = O.eUp; F !== B;) {
                            if (F.fixUpperEdge = !1, (N = (k = i.regionBelow(F)).eUp).Org != U.Org) {
                                if (!k.fixUpperEdge) {
                                    i.finishRegion(_, F);
                                    break
                                }
                                N = _.mesh.connect(U.Lprev, N.Sym), i.fixUpperEdge(_, k, N)
                            }
                            U.Onext !== N && (_.mesh.splice(N.Oprev, N), _.mesh.splice(U, N)), i.finishRegion(_, F), U = k.eUp, F = k
                        }
                        return U
                    }, i.addRightEdges = function(_, O, B, N, k, F) {
                        var U, j, G, Y, Q = !0;
                        G = B;
                        do nt(yn.vertLeq(G.Org, G.Dst)), i.addRegionBelow(_, O, G.Sym), G = G.Onext; while (G !== N);
                        for (null === k && (k = i.regionBelow(O).eUp.Rprev), j = O, Y = k;
                            (G = (U = i.regionBelow(j)).eUp.Sym).Org === Y.Org;) G.Onext !== Y && (_.mesh.splice(G.Oprev, G), _.mesh.splice(Y.Oprev, G)), U.windingNumber = j.windingNumber - G.winding, U.inside = i.isWindingInside(_, U.windingNumber), j.dirty = !0, !Q && i.checkForRightSplice(_, j) && (i.addWinding(G, Y), i.deleteRegion(_, j), _.mesh.delete(Y)), Q = !1, j = U, Y = G;
                        j.dirty = !0, nt(j.windingNumber - G.winding === U.windingNumber), F && i.walkDirtyRegions(_, j)
                    }, i.spliceMergeVertices = function(_, O, B) {
                        _.mesh.splice(O, B)
                    }, i.vertexWeights = function(_, O, B) {
                        var N = yn.vertL1dist(O, _),
                            k = yn.vertL1dist(B, _),
                            F = .5 * k / (N + k),
                            U = .5 * N / (N + k);
                        _.coords[0] += F * O.coords[0] + U * B.coords[0], _.coords[1] += F * O.coords[1] + U * B.coords[1], _.coords[2] += F * O.coords[2] + U * B.coords[2]
                    }, i.getIntersectData = function(_, O, B, N, k, F) {
                        O.coords[0] = O.coords[1] = O.coords[2] = 0, O.idx = -1, i.vertexWeights(O, B, N), i.vertexWeights(O, k, F)
                    }, i.checkForRightSplice = function(_, O) {
                        var B = i.regionBelow(O),
                            N = O.eUp,
                            k = B.eUp;
                        if (yn.vertLeq(N.Org, k.Org)) {
                            if (yn.edgeSign(k.Dst, N.Org, k.Org) > 0) return !1;
                            yn.vertEq(N.Org, k.Org) ? N.Org !== k.Org && (_.pq.delete(N.Org.pqHandle), i.spliceMergeVertices(_, k.Oprev, N)) : (_.mesh.splitEdge(k.Sym), _.mesh.splice(N, k.Oprev), O.dirty = B.dirty = !0)
                        } else {
                            if (0 > yn.edgeSign(N.Dst, k.Org, N.Org)) return !1;
                            i.regionAbove(O).dirty = O.dirty = !0, _.mesh.splitEdge(N.Sym), _.mesh.splice(k.Oprev, N)
                        }
                        return !0
                    }, i.checkForLeftSplice = function(_, O) {
                        var B, N = i.regionBelow(O),
                            k = O.eUp,
                            F = N.eUp;
                        if (nt(!yn.vertEq(k.Dst, F.Dst)), yn.vertLeq(k.Dst, F.Dst)) {
                            if (0 > yn.edgeSign(k.Dst, F.Dst, k.Org)) return !1;
                            i.regionAbove(O).dirty = O.dirty = !0, B = _.mesh.splitEdge(k), _.mesh.splice(F.Sym, B), B.Lface.inside = O.inside
                        } else {
                            if (yn.edgeSign(F.Dst, k.Dst, F.Org) > 0) return !1;
                            O.dirty = N.dirty = !0, B = _.mesh.splitEdge(F), _.mesh.splice(k.Lnext, F.Sym), B.Rface.inside = O.inside
                        }
                        return !0
                    }, i.checkForIntersect = function(_, O) {
                        var B, N, k = i.regionBelow(O),
                            F = O.eUp,
                            U = k.eUp,
                            j = F.Org,
                            G = U.Org,
                            Y = F.Dst,
                            Q = U.Dst,
                            K = new Xh;
                        if (nt(!yn.vertEq(Q, Y)), nt(0 >= yn.edgeSign(Y, _.event, j)), nt(yn.edgeSign(Q, _.event, G) >= 0), nt(j !== _.event && G !== _.event), nt(!O.fixUpperEdge && !k.fixUpperEdge), j === G || Math.min(j.t, Y.t) > Math.max(G.t, Q.t)) return !1;
                        if (yn.vertLeq(j, G)) {
                            if (yn.edgeSign(Q, j, G) > 0) return !1
                        } else if (0 > yn.edgeSign(Y, G, j)) return !1;
                        return i.debugEvent(_), yn.intersect(Y, j, Q, G, K), nt(Math.min(j.t, Y.t) <= K.t), nt(K.t <= Math.max(G.t, Q.t)), nt(Math.min(Q.s, Y.s) <= K.s), nt(K.s <= Math.max(G.s, j.s)), yn.vertLeq(K, _.event) && (K.s = _.event.s, K.t = _.event.t), B = yn.vertLeq(j, G) ? j : G, yn.vertLeq(B, K) && (K.s = B.s, K.t = B.t), yn.vertEq(K, j) || yn.vertEq(K, G) ? (i.checkForRightSplice(_, O), !1) : !yn.vertEq(Y, _.event) && yn.edgeSign(Y, _.event, K) >= 0 || !yn.vertEq(Q, _.event) && 0 >= yn.edgeSign(Q, _.event, K) ? Q === _.event ? (_.mesh.splitEdge(F.Sym), _.mesh.splice(U.Sym, F), O = i.topLeftRegion(_, O), F = i.regionBelow(O).eUp, i.finishLeftRegions(_, i.regionBelow(O), k), i.addRightEdges(_, O, F.Oprev, F, F, !0), !0) : Y === _.event ? (_.mesh.splitEdge(U.Sym), _.mesh.splice(F.Lnext, U.Oprev), k = O, O = i.topRightRegion(O), N = i.regionBelow(O).eUp.Rprev, k.eUp = U.Oprev, U = i.finishLeftRegions(_, k, null), i.addRightEdges(_, O, U.Onext, F.Rprev, N, !0), !0) : (yn.edgeSign(Y, _.event, K) >= 0 && (i.regionAbove(O).dirty = O.dirty = !0, _.mesh.splitEdge(F.Sym), F.Org.s = _.event.s, F.Org.t = _.event.t), 0 >= yn.edgeSign(Q, _.event, K) && (O.dirty = k.dirty = !0, _.mesh.splitEdge(U.Sym), U.Org.s = _.event.s, U.Org.t = _.event.t), !1) : (_.mesh.splitEdge(F.Sym), _.mesh.splitEdge(U.Sym), _.mesh.splice(U.Oprev, F), F.Org.s = K.s, F.Org.t = K.t, F.Org.pqHandle = _.pq.insert(F.Org), i.getIntersectData(_, F.Org, j, Y, G, Q), i.regionAbove(O).dirty = O.dirty = k.dirty = !0, !1)
                    }, i.walkDirtyRegions = function(_, O) {
                        for (var B, N, k = i.regionBelow(O);;) {
                            for (; k.dirty;) O = k, k = i.regionBelow(k);
                            if (!O.dirty && (k = O, null === (O = i.regionAbove(O)) || !O.dirty)) return;
                            if (O.dirty = !1, B = O.eUp, N = k.eUp, B.Dst !== N.Dst && i.checkForLeftSplice(_, O) && (k.fixUpperEdge ? (i.deleteRegion(_, k), _.mesh.delete(N), N = (k = i.regionBelow(O)).eUp) : O.fixUpperEdge && (i.deleteRegion(_, O), _.mesh.delete(B), B = (O = i.regionAbove(k)).eUp)), B.Org !== N.Org) {
                                if (B.Dst === N.Dst || O.fixUpperEdge || k.fixUpperEdge || B.Dst !== _.event && N.Dst !== _.event) i.checkForRightSplice(_, O);
                                else if (i.checkForIntersect(_, O)) return
                            }
                            B.Org === N.Org && B.Dst === N.Dst && (i.addWinding(N, B), i.deleteRegion(_, O), _.mesh.delete(B), O = i.regionAbove(k))
                        }
                    }, i.connectRightVertex = function(_, O, B) {
                        var N, k = B.Onext,
                            F = i.regionBelow(O),
                            U = O.eUp,
                            j = F.eUp,
                            G = !1;
                        if (U.Dst !== j.Dst && i.checkForIntersect(_, O), yn.vertEq(U.Org, _.event) && (_.mesh.splice(k.Oprev, U), O = i.topLeftRegion(_, O), k = i.regionBelow(O).eUp, i.finishLeftRegions(_, i.regionBelow(O), F), G = !0), yn.vertEq(j.Org, _.event) && (_.mesh.splice(B, j.Oprev), B = i.finishLeftRegions(_, F, null), G = !0), G) {
                            i.addRightEdges(_, O, B.Onext, k, k, !0);
                            return
                        }
                        N = yn.vertLeq(j.Org, U.Org) ? j.Oprev : U, N = _.mesh.connect(B.Lprev, N), i.addRightEdges(_, O, N, N.Onext, N.Onext, !1), N.Sym.activeRegion.fixUpperEdge = !0, i.walkDirtyRegions(_, O)
                    }, i.connectLeftDegenerate = function(_, O, B) {
                        var N, k, F, U, j;
                        if (N = O.eUp, yn.vertEq(N.Org, B)) {
                            nt(!1), i.spliceMergeVertices(_, N, B.anEdge);
                            return
                        }
                        if (!yn.vertEq(N.Dst, B)) {
                            _.mesh.splitEdge(N.Sym), O.fixUpperEdge && (_.mesh.delete(N.Onext), O.fixUpperEdge = !1), _.mesh.splice(B.anEdge, N), i.sweepEvent(_, B);
                            return
                        }
                        nt(!1), O = i.topRightRegion(O), k = U = (F = (j = i.regionBelow(O)).eUp.Sym).Onext, j.fixUpperEdge && (nt(k !== F), i.deleteRegion(_, j), _.mesh.delete(F), F = k.Oprev), _.mesh.splice(B.anEdge, F), yn.edgeGoesLeft(k) || (k = null), i.addRightEdges(_, O, F.Onext, U, k, !0)
                    }, i.connectLeftVertex = function(_, O) {
                        var B, N, k, F, U, j, G = new VS;
                        if (G.eUp = O.anEdge.Sym, B = _.dict.search(G).key, N = i.regionBelow(B)) {
                            if (F = B.eUp, U = N.eUp, 0 === yn.edgeSign(F.Dst, O, F.Org)) {
                                i.connectLeftDegenerate(_, B, O);
                                return
                            }(k = yn.vertLeq(U.Dst, F.Dst) ? B : N, B.inside || k.fixUpperEdge) ? (j = k === B ? _.mesh.connect(O.anEdge.Sym, F.Lnext) : _.mesh.connect(U.Dnext, O.anEdge).Sym, k.fixUpperEdge ? i.fixUpperEdge(_, k, j) : i.computeWinding(_, i.addRegionBelow(_, B, j)), i.sweepEvent(_, O)) : i.addRightEdges(_, B, O.anEdge, O.anEdge, null, !0)
                        }
                    }, i.sweepEvent = function(_, O) {
                        _.event = O, i.debugEvent(_);
                        for (var B = O.anEdge; null === B.activeRegion;)
                            if ((B = B.Onext) === O.anEdge) {
                                i.connectLeftVertex(_, O);
                                return
                            }
                        var N = i.topLeftRegion(_, B.activeRegion);
                        nt(null !== N);
                        var k = i.regionBelow(N),
                            F = k.eUp,
                            U = i.finishLeftRegions(_, k, null);
                        U.Onext === F ? i.connectRightVertex(_, N, U) : i.addRightEdges(_, N, U.Onext, F, F, !0)
                    }, i.addSentinel = function(_, O, B, N) {
                        var k = new VS,
                            F = _.mesh.makeEdge();
                        F.Org.s = B, F.Org.t = N, F.Dst.s = O, F.Dst.t = N, _.event = F.Dst, k.eUp = F, k.windingNumber = 0, k.inside = !1, k.fixUpperEdge = !1, k.sentinel = !0, k.dirty = !1, k.nodeUp = _.dict.insert(k)
                    }, i.initEdgeDict = function(_) {
                        _.dict = new yu(_, i.edgeLeq);
                        var O = _.bmax[0] - _.bmin[0],
                            B = _.bmax[1] - _.bmin[1],
                            N = _.bmin[0] - O,
                            k = _.bmax[0] + O,
                            F = _.bmin[1] - B,
                            U = _.bmax[1] + B;
                        i.addSentinel(_, N, k, F), i.addSentinel(_, N, k, U)
                    }, i.doneEdgeDict = function(_) {
                        for (var O, B = 0; null !== (O = _.dict.min().key);) O.sentinel || (nt(O.fixUpperEdge), nt(1 == ++B)), nt(0 === O.windingNumber), i.deleteRegion(_, O)
                    }, i.removeDegenerateEdges = function(_) {
                        var O, B, N, k = _.mesh.eHead;
                        for (O = k.next; O !== k; O = B) B = O.next, N = O.Lnext, yn.vertEq(O.Org, O.Dst) && O.Lnext.Lnext !== O && (i.spliceMergeVertices(_, N, O), _.mesh.delete(O), N = (O = N).Lnext), N.Lnext === O && (N !== O && ((N === B || N === B.Sym) && (B = B.next), _.mesh.delete(N)), (O === B || O === B.Sym) && (B = B.next), _.mesh.delete(O))
                    }, i.initPriorityQ = function(_) {
                        var O, B, N, k = 0;
                        for (B = (N = _.mesh.vHead).next; B !== N; B = B.next) k++;
                        for (k += 8, O = _.pq = new yd(k, yn.vertLeq), B = (N = _.mesh.vHead).next; B !== N; B = B.next) B.pqHandle = O.insert(B);
                        return B === N && (O.init(), !0)
                    }, i.donePriorityQ = function(_) {
                        _.pq = null
                    }, i.removeDegenerateFaces = function(_, O) {
                        var B, N, k;
                        for (B = O.fHead.next; B !== O.fHead; B = N) N = B.next, nt((k = B.anEdge).Lnext !== k), k.Lnext.Lnext === k && (i.addWinding(k.Onext, k), _.mesh.delete(k));
                        return !0
                    }, i.computeInterior = function(_, O) {
                        var B, N;
                        if (void 0 === O && (O = !0), i.removeDegenerateEdges(_), !i.initPriorityQ(_)) return !1;
                        for (i.initEdgeDict(_); null !== (B = _.pq.extractMin());) {
                            for (; !(null === (N = _.pq.min()) || !yn.vertEq(N, B));) N = _.pq.extractMin(), i.spliceMergeVertices(_, B.anEdge, N.anEdge);
                            i.sweepEvent(_, B)
                        }
                        return _.event = _.dict.min().key.eUp.Org, i.debugEvent(_), i.doneEdgeDict(_), i.donePriorityQ(_), !!i.removeDegenerateFaces(_, _.mesh) && (O && _.mesh.check(), !0)
                    }, i
                }(),
                yf = function() {
                    function i() {
                        this.mesh = new yh, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = xp.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0
                    }
                    return i.prototype.dot_ = function(_, O) {
                        return _[0] * O[0] + _[1] * O[1] + _[2] * O[2]
                    }, i.prototype.normalize_ = function(_) {
                        var O = _[0] * _[0] + _[1] * _[1] + _[2] * _[2];
                        if (!O) throw "Zero-size vector!";
                        O = Math.sqrt(O), _[0] /= O, _[1] /= O, _[2] /= O
                    }, i.prototype.longAxis_ = function(_) {
                        var O = 0;
                        return Math.abs(_[1]) > Math.abs(_[0]) && (O = 1), Math.abs(_[2]) > Math.abs(_[O]) && (O = 2), O
                    }, i.prototype.computeNormal_ = function(_) {
                        var O, B, N, k, F, U, j = [0, 0, 0],
                            G = [0, 0, 0],
                            Y = [0, 0, 0],
                            Q = [0, 0, 0],
                            K = [0, 0, 0],
                            $ = [null, null, null],
                            ee = [null, null, null],
                            et = this.mesh.vHead;
                        O = et.next;
                        for (var ei = 0; ei < 3; ++ei) k = O.coords[ei], G[ei] = k, ee[ei] = O, j[ei] = k, $[ei] = O;
                        for (O = et.next; O !== et; O = O.next)
                            for (var er = 0; er < 3; ++er)(k = O.coords[er]) < G[er] && (G[er] = k, ee[er] = O), k > j[er] && (j[er] = k, $[er] = O);
                        var ea = 0;
                        if (j[1] - G[1] > j[0] - G[0] && (ea = 1), j[2] - G[2] > j[ea] - G[ea] && (ea = 2), G[ea] >= j[ea]) {
                            _[0] = 0, _[1] = 0, _[2] = 1;
                            return
                        }
                        for (U = 0, B = ee[ea], N = $[ea], Y[0] = B.coords[0] - N.coords[0], Y[1] = B.coords[1] - N.coords[1], Y[2] = B.coords[2] - N.coords[2], O = et.next; O !== et; O = O.next) Q[0] = O.coords[0] - N.coords[0], Q[1] = O.coords[1] - N.coords[1], Q[2] = O.coords[2] - N.coords[2], K[0] = Y[1] * Q[2] - Y[2] * Q[1], K[1] = Y[2] * Q[0] - Y[0] * Q[2], K[2] = Y[0] * Q[1] - Y[1] * Q[0], (F = K[0] * K[0] + K[1] * K[1] + K[2] * K[2]) > U && (U = F, _[0] = K[0], _[1] = K[1], _[2] = K[2]);
                        U <= 0 && (_[0] = _[1] = _[2] = 0, _[this.longAxis_(Y)] = 1)
                    }, i.prototype.checkOrientation_ = function() {
                        for (var _, O, B = this.mesh.fHead, N = this.mesh.vHead, k = 0, F = B.next; F !== B; F = F.next)
                            if (!((O = F.anEdge).winding <= 0))
                                do k += (O.Org.s - O.Dst.s) * (O.Org.t + O.Dst.t), O = O.Lnext; while (O !== F.anEdge);
                        if (k < 0) {
                            for (_ = N.next; _ !== N; _ = _.next) _.t = -_.t;
                            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2]
                        }
                    }, i.prototype.projectPolygon_ = function() {
                        var _, O, B = this.mesh.vHead,
                            N = [0, 0, 0],
                            k = !1;
                        N[0] = this.normal[0], N[1] = this.normal[1], N[2] = this.normal[2], N[0] || N[1] || N[2] || (this.computeNormal_(N), k = !0), _ = this.sUnit, O = this.tUnit;
                        var F = this.longAxis_(N);
                        _[F] = 0, _[(F + 1) % 3] = 1, _[(F + 2) % 3] = 0, O[F] = 0, O[(F + 1) % 3] = 0, O[(F + 2) % 3] = N[F] > 0 ? 1 : -1;
                        for (var U = B.next; U !== B; U = U.next) U.s = this.dot_(U.coords, _), U.t = this.dot_(U.coords, O);
                        k && this.checkOrientation_();
                        for (var j = !0, G = B.next; G !== B; G = G.next) j ? (this.bmin[0] = this.bmax[0] = G.s, this.bmin[1] = this.bmax[1] = G.t, j = !1) : (G.s < this.bmin[0] && (this.bmin[0] = G.s), G.s > this.bmax[0] && (this.bmax[0] = G.s), G.t < this.bmin[1] && (this.bmin[1] = G.t), G.t > this.bmax[1] && (this.bmax[1] = G.t))
                    }, i.prototype.addWinding_ = function(_, O) {
                        _.winding += O.winding, _.Sym.winding += O.Sym.winding
                    }, i.prototype.tessellateMonoRegion_ = function(_, O) {
                        var B, N;
                        if (!((B = O.anEdge).Lnext !== B && B.Lnext.Lnext !== B)) throw "Mono region invalid";
                        for (; yn.vertLeq(B.Dst, B.Org); B = B.Lprev);
                        for (; yn.vertLeq(B.Org, B.Dst); B = B.Lnext);
                        for (N = B.Lprev; B.Lnext !== N;)
                            if (yn.vertLeq(B.Dst, N.Org)) {
                                for (; N.Lnext !== B && (yn.edgeGoesLeft(N.Lnext) || 0 >= yn.edgeSign(N.Org, N.Dst, N.Lnext.Dst));) N = _.connect(N.Lnext, N).Sym;
                                N = N.Lprev
                            } else {
                                for (; N.Lnext !== B && (yn.edgeGoesRight(B.Lprev) || yn.edgeSign(B.Dst, B.Org, B.Lprev.Org) >= 0);) B = _.connect(B, B.Lprev).Sym;
                                B = B.Lnext
                            }
                        if (N.Lnext === B) throw "Mono region invalid";
                        for (; N.Lnext.Lnext !== B;) N = _.connect(N.Lnext, N).Sym;
                        return !0
                    }, i.prototype.tessellateInterior_ = function(_) {
                        for (var O, B = _.fHead.next; B !== _.fHead; B = O)
                            if (O = B.next, B.inside && !this.tessellateMonoRegion_(_, B)) return !1;
                        return !0
                    }, i.prototype.discardExterior_ = function(_) {
                        for (var O, B = _.fHead.next; B !== _.fHead; B = O) O = B.next, B.inside || _.zapFace(B)
                    }, i.prototype.setWindingNumber_ = function(_, O, B) {
                        for (var N, k = _.eHead.next; k !== _.eHead; k = N) N = k.next, k.Rface.inside !== k.Lface.inside ? k.winding = k.Lface.inside ? O : -O : B ? _.delete(k) : k.winding = 0
                    }, i.prototype.getNeighbourFace_ = function(_) {
                        return _.Rface && _.Rface.inside ? _.Rface.n : -1
                    }, i.prototype.outputPolymesh_ = function(_, O, B, N) {
                        var k, F, U = 0,
                            j = 0;
                        B > 3 && _.mergeConvexFaces(B);
                        for (var G = _.vHead.next; G !== _.vHead; G = G.next) G.n = -1;
                        for (var Y = _.fHead.next; Y !== _.fHead; Y = Y.next)
                            if (Y.n = -1, Y.inside) {
                                k = Y.anEdge, F = 0;
                                do {
                                    var G = k.Org; - 1 === G.n && (G.n = j, j++), F++, k = k.Lnext
                                } while (k !== Y.anEdge);
                                if (F > B) throw "Face vertex greater that support polygon";
                                Y.n = U, ++U
                            }
                        this.elementCount = U, O === xf.CONNECTED_POLYGONS && (U *= 2), this.elements = [], this.elements.length = U * B, this.vertexCount = j, this.vertices = [], this.vertices.length = j * N, this.vertexIndices = [], this.vertexIndices.length = j;
                        for (var G = _.vHead.next; G !== _.vHead; G = G.next)
                            if (-1 !== G.n) {
                                var Q = G.n * N;
                                this.vertices[Q + 0] = G.coords[0], this.vertices[Q + 1] = G.coords[1], N > 2 && (this.vertices[Q + 2] = G.coords[2]), this.vertexIndices[G.n] = G.idx
                            }
                        for (var K = 0, Y = _.fHead.next; Y !== _.fHead; Y = Y.next)
                            if (Y.inside) {
                                k = Y.anEdge, F = 0;
                                do {
                                    var G = k.Org;
                                    this.elements[K++] = G.n, F++, k = k.Lnext
                                } while (k !== Y.anEdge);
                                for (var $ = F; $ < B; ++$) this.elements[K++] = -1;
                                if (O === xf.CONNECTED_POLYGONS) {
                                    k = Y.anEdge;
                                    do this.elements[K++] = this.getNeighbourFace_(k), k = k.Lnext; while (k !== Y.anEdge);
                                    for (var ee = F; ee < B; ++ee) this.elements[K++] = -1
                                }
                            }
                    }, i.prototype.outputContours_ = function(_, O) {
                        var B, N, k = 0,
                            F = 0;
                        this.vertexCount = 0, this.elementCount = 0;
                        for (var U = _.fHead.next; U !== _.fHead; U = U.next)
                            if (U.inside) {
                                N = B = U.anEdge;
                                do this.vertexCount++, B = B.Lnext; while (B !== N);
                                this.elementCount++
                            }
                        this.elements = [], this.elements.length = 2 * this.elementCount, this.vertices = [], this.vertices.length = this.vertexCount * O, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
                        var j = 0,
                            G = 0,
                            Y = 0;
                        k = 0;
                        for (var U = _.fHead.next; U !== _.fHead; U = U.next)
                            if (U.inside) {
                                F = 0, N = B = U.anEdge;
                                do this.vertices[j++] = B.Org.coords[0], this.vertices[j++] = B.Org.coords[1], O > 2 && (this.vertices[j++] = B.Org.coords[2]), this.vertexIndices[G++] = this.vertexIdCallback ? this.vertexIdCallback(B) : B.Org.idx, F++, B = B.Lnext; while (B !== N);
                                this.elements[Y++] = k, this.elements[Y++] = F, k += F
                            }
                    }, i.prototype.addContour = function(_, O) {
                        null === this.mesh && (this.mesh = new yh), _ < 2 && (_ = 2), _ > 3 && (_ = 3);
                        for (var B = null, N = 0; N < O.length; N += _) null === B ? (B = this.mesh.makeEdge(), this.mesh.splice(B, B.Sym)) : (this.mesh.splitEdge(B), B = B.Lnext), B.Org.coords[0] = O[N + 0], B.Org.coords[1] = O[N + 1], _ > 2 ? B.Org.coords[2] = O[N + 2] : B.Org.coords[2] = 0, B.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(B), B.winding = 1, B.Sym.winding = -1
                    }, i.prototype.tesselate = function(_, O, B, N, k, F) {
                        if (void 0 === _ && (_ = xp.ODD), void 0 === O && (O = xf.POLYGONS), void 0 === F && (F = !0), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, k && (this.normal[0] = k[0], this.normal[1] = k[1], this.normal[2] = k[2]), this.windingRule = _, N < 2 && (N = 2), N > 3 && (N = 3), !this.mesh) return !1;
                        this.projectPolygon_(), yp.computeInterior(this, F);
                        var U = this.mesh;
                        return O === xf.BOUNDARY_CONTOURS ? this.setWindingNumber_(U, 1, !0) : this.tessellateInterior_(U), F && U.check(), O === xf.BOUNDARY_CONTOURS ? this.outputContours_(U, N) : this.outputPolymesh_(U, O, B, N), !0
                    }, i
                }();

            function Es(_) {
                var O = _.windingRule,
                    B = void 0 === O ? xp.ODD : O,
                    N = _.elementType,
                    k = void 0 === N ? xf.POLYGONS : N,
                    F = _.polySize,
                    U = _.vertexSize,
                    j = void 0 === U ? 2 : U,
                    G = _.normal,
                    Y = _.contours,
                    Q = void 0 === Y ? [] : Y,
                    K = _.strict,
                    $ = void 0 === K || K,
                    ee = _.debug;
                if (!Q && $) throw Error("Contours can't be empty");
                if (Q) {
                    var et = new yf;
                    _.edgeCreateCallback && (et.edgeCreateCallback = _.edgeCreateCallback), _.vertexIdCallback && (et.vertexIdCallback = _.vertexIdCallback);
                    for (var ei = 0; ei < Q.length; ei++) et.addContour(j || 2, Q[ei]);
                    return et.tesselate(B, k, void 0 === F ? 3 : F, j, void 0 === G ? [0, 0, 1] : G, $), {
                        vertices: et.vertices,
                        vertexIndices: et.vertexIndices,
                        vertexCount: et.vertexCount,
                        elements: et.elements,
                        elementCount: et.elementCount,
                        mesh: void 0 !== ee && ee ? et.mesh : void 0
                    }
                }
            }
            xp.ODD, xp.NONZERO, xp.POSITIVE, xp.NEGATIVE, xp.ABS_GEQ_TWO, xf.POLYGONS, xf.CONNECTED_POLYGONS, xf.BOUNDARY_CONTOURS;
            var ym = class {
                constructor(_ = 256, O = !1) {
                    this.capacity = _, this.size = 0, this.debug = O, this.debug && console.log(`allocating with cap ${_}`);
                    let B = _ * ym.eSize;
                    this.buffer = new ArrayBuffer(B);
                    let N = Float32Array.BYTES_PER_ELEMENT,
                        k = 0;
                    this.positions = new Float32Array(this.buffer, k * N, 3 * _), k += 3 * _, this.normals = new Float32Array(this.buffer, k * N, 3 * _), k += 3 * _, this.uvs = new Float32Array(this.buffer, k * N, 2 * _)
                }
                realloc(_, O = !1) {
                    if (_ < this.size) throw Error("cannot shrink buffer");
                    if (_ <= this.capacity && !O) return;
                    this.debug && console.log(`resizing from ${this.capacity} \u2192 ${_}`);
                    let B = _ * ym.eSize,
                        N = new ArrayBuffer(B),
                        k = Float32Array.BYTES_PER_ELEMENT,
                        F = 0,
                        U = new Float32Array(N, F * k, 3 * _);
                    F += 3 * _;
                    let j = new Float32Array(N, F * k, 3 * _);
                    F += 3 * _;
                    let G = new Float32Array(N, F * k, 2 * _);
                    O ? (U.set(this.positions.subarray(0, 3 * this.size)), j.set(this.normals.subarray(0, 3 * this.size)), G.set(this.uvs.subarray(0, 2 * this.size))) : (U.set(this.positions), j.set(this.normals), G.set(this.uvs)), this.buffer = N, this.positions = U, this.normals = j, this.uvs = G, this.capacity = _
                }
                get(_ = 1) {
                    let O = this.size + _;
                    if (O > this.capacity) {
                        let _ = this.capacity;
                        for (; O > _;) _ *= 2;
                        this.realloc(_)
                    }
                    let B = this.size;
                    return this.size = O, B
                }
                reserve(_) {
                    let O = this.size + _;
                    O > this.capacity && this.realloc(O)
                }
                shrink() {
                    this.debug && console.log(`shrinking ${this.capacity} \u2192 ${this.size}`), this.realloc(this.size, !0)
                }
            };
            ym.eSize = 8 * Float32Array.BYTES_PER_ELEMENT;
            var yg = pn(i_()),
                yy = {
                    vertices: [160, 160, -160, 160, -160, -160, 160, -160],
                    vertexIndices: [1, 0, 3, 2],
                    vertexCount: 4,
                    elements: [0, 4],
                    elementCount: 1,
                    mesh: void 0
                },
                yx = {
                    vertices: [],
                    vertexIndices: [],
                    vertexCount: 0,
                    elements: [],
                    elementCount: 0,
                    mesh: void 0
                },
                yb = {
                    vertices: [-160, 160, 160, -160, 160, 160, -160, -160],
                    vertexIndices: [1, 3, 0, 2],
                    vertexCount: 4,
                    elements: [0, 1, 2, 1, 0, 3],
                    elementCount: 2,
                    mesh: void 0
                },
                HS = (_, O) => ([B, N]) => (N < B && (N += O), (_ >= B ? _ : _ + O) <= N),
                yw = class extends sK {
                    constructor(_, O, B = 0, N = 12, k = 3, F = xp.ODD, U = !1) {
                        let j, G, Y;
                        super(), this.forPathBevel = U, this.type = "ShapeGeometry", this.vertexCache = {}, this._shape = _, this._depth = O, this._curveSegments = N, this._bevelSegmentsInput = k;
                        let Q = this._shape.extractShapePointsToFlatArray([], N),
                            K = this._shape.shapeHoles.map(_ => {
                                let O = _.extractShapePointsToFlatArray([], N),
                                    B = [];
                                for (let _ = O.length - 1; _ >= 1; _ -= 2) {
                                    let N = O[_ - 1],
                                        k = O[_ - 0];
                                    B.push(N, k)
                                }
                                return B
                            }),
                            $ = [],
                            ee = [];
                        for (let _ = 0; _ < Q.length; _ += 2) ee.push([Q[_], Q[_ + 1]]);
                        $.push(ee);
                        for (let _ = 0; _ < K.length; _++) {
                            let O = K[_],
                                B = [];
                            for (let _ = 0; _ < O.length; _ += 2) B.push([O[_], O[_ + 1]]);
                            $.push(B)
                        }
                        j = _.isText ? .1 * new lC().setFromPoints(_.points.map(_ => _.position)).getSize(new iJ).length() : 0 === $[0].length ? B : (0, yg.default)($).distance, B <= 0 ? (this._bevel = 0, this._bevelSegments = 0) : (this._bevel = Math.min(B, j, O / 2), this._bevelSegments = Math.floor(k));
                        try {
                            G = Es({
                                windingRule: F,
                                elementType: xf.BOUNDARY_CONTOURS,
                                vertexSize: 2,
                                strict: !0,
                                contours: [Q]
                            })
                        } catch {
                            G = yy
                        }
                        try {
                            Y = Es({
                                windingRule: xp.ODD,
                                elementType: xf.BOUNDARY_CONTOURS,
                                vertexSize: 2,
                                strict: !0,
                                contours: [...K]
                            })
                        } catch {
                            Y = yx
                        }
                        if (!G) throw Error("error generating geometry");
                        let et = G.elementCount;
                        if (Y) {
                            G.elementCount += Y.elementCount;
                            for (let _ = 0; _ < Y.elements.length; _++) {
                                let O = Y.elements[_],
                                    B = _ % 2 == 0 ? G.vertexCount : 0;
                                G.elements.push(O + B)
                            }
                            for (let _ = 0; _ < Y.vertexIndices.length; _++) {
                                let O = Y.vertexIndices[_],
                                    B = G.vertexCount;
                                G.vertexIndices.push(O + B)
                            }
                            for (let _ = 0; _ < Y.vertices.length; _++) {
                                let O = Y.vertices[_];
                                G.vertices.push(O)
                            }
                        }
                        let ei = 1 / 0,
                            er = -1 / 0,
                            ea = 1 / 0,
                            en = -1 / 0;
                        for (let _ = 0, O = G.vertexCount; _ < O; _++) {
                            let O = 2 * _,
                                B = G.vertices[O + 0],
                                N = G.vertices[O + 1];
                            B < ei && (ei = B), B > er && (er = B), N < ea && (ea = N), N > en && (en = N)
                        }
                        this._minX = ei, this._minY = ea, this._width = er - ei, this._height = en - ea, this._buffer = new ym(this._computeBufferEstimatedSize(G));
                        let eo = [],
                            el = [];
                        for (let _ = G.elementCount - 1; _ >= 0; _--) {
                            let O = _ >= et,
                                B = 2 * _,
                                k = G.elements[B + 0],
                                F = G.elements[B + 1],
                                Y = k + F,
                                Q = {
                                    start: k,
                                    count: F,
                                    normals: [],
                                    continuous: [],
                                    concave: []
                                },
                                $ = k,
                                ee = Y - 1,
                                ei = k + 1,
                                er = this._shape.roundedCurves.length;
                            do {
                                let _ = $ - k,
                                    B = G.vertices[2 * ee + 0],
                                    N = G.vertices[2 * ee + 1],
                                    U = G.vertices[2 * $ + 0],
                                    j = G.vertices[2 * $ + 1],
                                    K = G.vertices[2 * ei + 0],
                                    et = G.vertices[2 * ei + 1],
                                    ea = U - B,
                                    en = j - N,
                                    eo = Math.sqrt(ea * ea + en * en);
                                ea /= eo, en /= eo;
                                let el = U - K,
                                    eh = j - et,
                                    ec = Math.sqrt(el * el + eh * eh);
                                el /= ec, eh /= ec, Q.normals[2 * _ + 0] = -eh, Q.normals[2 * _ + 1] = el, Q.concave[_] = ea * eh - en * el > 0;
                                let eu = G.vertexIndices[$];
                                if (Array.isArray(eu)) Q.continuous[_] = !1;
                                else {
                                    let [O, B] = this._shape.getCurveIndexFromVertexId(eu - 1, !0);
                                    if (B > 0 && B < 1) Q.continuous[_] = !0;
                                    else {
                                        let N = 1 === B ? O + 1 : O - 1;
                                        N = (N + er) % er;
                                        let k = 1 === B ? 0 : 1,
                                            F = this._shape.roundedCurves[O].getTangent(B),
                                            U = this._shape.roundedCurves[N].getTangent(k);
                                        Q.continuous[_] = F.dot(U) > .95
                                    }
                                }
                                O && (Q.normals[2 * _ + 0] *= -1, Q.normals[2 * _ + 1] *= -1), [ee, $, ei] = [$, ei, ei + 1], ei >= Y && (ei -= F)
                            } while (ei !== k + 1);
                            let ea = [];
                            ea.push({
                                bevelI: 0,
                                angle: 0,
                                size: 0,
                                boundary: {
                                    vertices: G.vertices.slice(2 * k, 2 * Y),
                                    vertexCount: F,
                                    vertexIndices: Array(F).fill(!0).map((_, O) => [O, O]),
                                    elements: [0, F],
                                    elementCount: 1,
                                    mesh: null
                                },
                                reverseMap: [],
                                insetPoints: G.vertices.slice(2 * k, 2 * Y)
                            });
                            let en = 0;
                            for (let _ = 1; _ <= this._bevelSegments; _++) {
                                let B = _ / this._bevelSegments * Math.PI / 2,
                                    k = (1 - Math.cos(B)) * this._bevel,
                                    U = [],
                                    j = [],
                                    Y = [],
                                    K = [],
                                    $ = 0;
                                for (let _ = 0; _ < F; _++) {
                                    let B = 2 * _,
                                        ee = (_ - 1 + F) % F * 2,
                                        et = G.vertices[2 * Q.start + B + 0],
                                        ei = G.vertices[2 * Q.start + B + 1],
                                        er = -Q.normals[ee + 0] * k,
                                        ea = -Q.normals[ee + 1] * k,
                                        en = -Q.normals[B + 0] * k,
                                        eo = -Q.normals[B + 1] * k;
                                    if (Q.concave[_] || !Q.concave[_] && O) {
                                        let B = Math.atan2(ea, er),
                                            F = Math.atan2(eo, en);
                                        F > B && (F -= 2 * Math.PI);
                                        let j = F - B;
                                        if (Q.continuous[_] || O) {
                                            let N = B + j / 2,
                                                F = Math.cos(N) * k,
                                                G = Math.sin(N) * k;
                                            U[2 * $ + 0] = et + F * (O ? -1 : 1), U[2 * $ + 1] = ei + G * (O ? -1 : 1), K[$] = _, $++
                                        } else {
                                            let O = Math.max(1, Math.floor(N / 4 * Math.abs(j) / Math.PI));
                                            for (let N = 0; N <= O; N++) {
                                                let F = B + j * (N / O),
                                                    G = Math.cos(F) * k,
                                                    Y = Math.sin(F) * k;
                                                U[2 * $ + 0] = et + G, U[2 * $ + 1] = ei + Y, K[$] = _, $++
                                            }
                                        }
                                    } else U[2 * $ + 0] = et + er, U[2 * $ + 1] = ei + ea, K[$] = _, j[_] = $, U[2 * ++$ + 0] = et, U[2 * $ + 1] = ei, K[$] = _, U[2 * ++$ + 0] = et + en, U[2 * $ + 1] = ei + eo, K[$] = _, Y[_] = $, $++
                                }
                                let ee = Es({
                                    windingRule: xp.POSITIVE,
                                    elementType: xf.BOUNDARY_CONTOURS,
                                    vertexSize: 2,
                                    strict: !0,
                                    contours: [U],
                                    edgeCreateCallback: _ => {
                                        let O = _.Org.idx,
                                            B = K[O],
                                            N = K[(O + 1) % K.length];
                                        _.idx = [B, N], _.Sym.idx = [N, B]
                                    },
                                    vertexIdCallback: _ => {
                                        let O = _.Lprev.idx;
                                        return [O ? O[1] : 0, _.idx ? _.idx[0] : 0]
                                    }
                                });
                                if (!ee) throw console.log("Error"), Error(`error generating bevel geometry for ${_}'th loop`);
                                if (!ee.vertexCount) {
                                    en = (1 - Math.sin((_ - 1) / this._bevelSegments * Math.PI / 2)) * this._bevel;
                                    break
                                }
                                for (let _ = 0; _ < ee.vertexIndices.length; _++) {
                                    let [O, B] = ee.vertexIndices[_];
                                    if (O === B) continue;
                                    let N = B;
                                    B < O && (N += F);
                                    for (let k = O; k < N; k++) {
                                        let N = k % F,
                                            U = (k + 1) % F;
                                        if (!Q.continuous[N] || !Q.continuous[U]) {
                                            ee.vertexIndices[_] = [O, N], ee.vertexIndices.splice(_ + 1, 0, [U, B]), ee.vertices.splice((_ + 1) * 2, 0, ee.vertices[2 * _], ee.vertices[2 * _ + 1]);
                                            break
                                        }
                                    }
                                }
                                ea.push({
                                    bevelI: _,
                                    angle: B,
                                    size: k,
                                    boundary: ee,
                                    reverseMap: K,
                                    insetPoints: U
                                })
                            }
                            let X = (_, O, B) => {
                                    let N = 0,
                                        k = _.boundary.vertexIndices.length;
                                    for (; N < k && B(_.boundary.vertexIndices[O]);) O = (O + 1) % k, N++;
                                    return N
                                },
                                eh = eo.length;
                            for (let _ = 1; _ < ea.length; _++) {
                                let O = ea[_ - 1],
                                    B = ea[_],
                                    N = O.boundary.vertexIndices.length,
                                    k = B.boundary.vertexIndices.length;
                                if (!N || !k) break;
                                let j = Q.concave.length,
                                    G = 0,
                                    Y = HS(0, F);
                                for (; !O.boundary.vertexIndices.filter(Y).length || !B.boundary.vertexIndices.filter(Y).length;) Y = HS(++G, F);
                                let K = O.boundary.vertexIndices.findIndex(Y),
                                    $ = B.boundary.vertexIndices.findIndex(Y);
                                do K = (K + 1) % N; while (Y(O.boundary.vertexIndices[K]));
                                do $ = ($ + 1) % k; while (Y(B.boundary.vertexIndices[$]));
                                let ee = G = (G + 1) % F,
                                    et = 0,
                                    ei = this._buildBevelVert(Q, O, (K - 1 + N) % N, void 0, et),
                                    er = this._buildBevelVert(Q, B, ($ - 1 + k) % k, void 0, et),
                                    en = ei,
                                    el = er,
                                    eh, ec, eu = !1;
                                do {
                                    et = (G || j) / j;
                                    let _ = X(O, K, Y = HS(G, F)),
                                        ee = X(B, $, Y),
                                        ei = eu;
                                    if (eu = !1, _ && !ee) {
                                        for (let B = 0; B < _; B++) eh = this._buildBevelVert(Q, O, (K + B) % N, B / (_ - 1), et), eo.push(en.topN, eh.topP, el.topN), !1 === U && eo.push(eh.bottomP, en.bottomN, el.bottomN), en = eh;
                                        eu = !0
                                    } else if (!_ && ee)
                                        for (let _ = 0; _ < ee; _++) ec = this._buildBevelVert(Q, B, ($ + _) % k, _ / (ee - 1), et), eo.push(el.topN, en.topP, ec.topP), !1 === U && eo.push(en.bottomP, el.bottomN, ec.bottomP), el = ec;
                                    else if (_ && ee) {
                                        if (eh = this._buildBevelVert(Q, O, K, 0, et), ec = this._buildBevelVert(Q, B, $, 0, et), ei ? (eo.push(en.topN, ec.topP, el.topN), eo.push(en.topN, eh.topP, ec.topP), !1 === U && (eo.push(ec.bottomP, en.bottomN, el.bottomN), eo.push(ec.bottomP, eh.bottomP, en.bottomN))) : (eo.push(el.topN, en.topN, eh.topP), eo.push(el.topN, eh.topP, ec.topP), !1 === U && (eo.push(eh.bottomP, en.bottomN, el.bottomN), eo.push(eh.bottomP, el.bottomN, ec.bottomP))), en = eh, el = ec, _ === ee)
                                            for (let F = 1; F < _; F++) eh = this._buildBevelVert(Q, O, (K + F) % N, F / (_ - 1), et), ec = this._buildBevelVert(Q, B, ($ + F) % k, F / (ee - 1), et), eo.push(en.topN, eh.topP, el.topN), eo.push(el.topN, eh.topP, ec.topP), !1 === U && (eo.push(eh.bottomP, en.bottomN, el.bottomN), eo.push(eh.bottomP, el.bottomN, ec.bottomP)), en = eh, el = ec;
                                        else if (_ > ee) {
                                            let F = _ / ee,
                                                j = 0;
                                            for (let G = 1; G < _; G++) eh = this._buildBevelVert(Q, O, (K + G) % N, G / (_ - 1), et), eo.push(en.topN, eh.topP, el.topN), !1 === U && eo.push(eh.bottomP, en.bottomN, el.bottomN), en = eh, G > (j + 1) * F && (j++, ec = this._buildBevelVert(Q, B, ($ + j) % k, j / (ee - 1), et), eo.push(el.topN, eh.topP, ec.topP), !1 === U && eo.push(eh.bottomP, el.bottomN, ec.bottomP), el = ec)
                                        } else {
                                            let F = ee / _,
                                                j = 0;
                                            for (let G = 1; G < ee; G++) ec = this._buildBevelVert(Q, B, ($ + G) % k, G / (ee - 1), et), eo.push(el.topN, eh.topP, ec.topP), !1 === U && eo.push(eh.bottomP, el.bottomN, ec.bottomP), el = ec, G > (j + 1) * F && (j++, eh = this._buildBevelVert(Q, O, (K + j) % N, j / (_ - 1), et), eo.push(en.topN, eh.topP, el.topN), !1 === U && eo.push(eh.bottomP, en.bottomN, el.bottomN), en = eh)
                                        }
                                    }
                                    K = (K + _) % N, $ = ($ + ee) % k, G = (G + 1) % j
                                } while (G !== ee)
                            }
                            if (!1 === U && this._depth > 2 * this._bevel && this._buildWall(ea, Q, eo), O) {
                                let _ = [];
                                for (let O = eo.length - 1; O >= eh + 2; O -= 3) {
                                    let B = eo[O - 2],
                                        N = eo[O - 1],
                                        k = eo[O - 0];
                                    _.push(k, N, B)
                                }
                                eo.splice(eh, eo.length - eh, ..._)
                            }
                            if (O) {
                                let _ = [];
                                for (let O = ea[ea.length - 1].boundary.vertices.length - 1; O >= 1; O -= 2) {
                                    let B = ea[ea.length - 1].boundary.vertices[O - 1],
                                        N = ea[ea.length - 1].boundary.vertices[O - 0];
                                    _.push(B, N)
                                }
                                el.push(_)
                            }
                            if (!O) {
                                let _ = ea[ea.length - 1],
                                    O;
                                try {
                                    O = Es({
                                        windingRule: ea.length > 1 ? xp.POSITIVE : xp.ODD,
                                        elementType: xf.POLYGONS,
                                        vertexSize: 2,
                                        strict: !0,
                                        contours: [_.insetPoints, ...el]
                                    })
                                } catch {
                                    O = yb
                                }
                                if (!O) throw Error("Error generating geometry for surface");
                                0 === K.length && this._bevel < j && Object.assign(this, {
                                    useNgonForTopBottomFaceDuringBake: !0
                                });
                                for (let _ = 0; _ < 3 * O.elementCount; _ += 3) {
                                    let B = this._buildSurfaceVert(O, O.elements[_ + 0], en),
                                        N = this._buildSurfaceVert(O, O.elements[_ + 1], en),
                                        k = this._buildSurfaceVert(O, O.elements[_ + 2], en);
                                    eo.push(B.top, N.top, k.top), !1 === U && eo.push(k.bottom, N.bottom, B.bottom)
                                }
                            }
                            this.vertexCache = {}
                        }
                        this._buffer.shrink();
                        let eh = new sF(Uint32Array.from(eo), 1),
                            ec = new sF(this._buffer.positions, 3),
                            eu = new sF(this._buffer.normals, 3),
                            ep = new sF(this._buffer.uvs, 2);
                        ec.needsUpdate = !0, eu.needsUpdate = !0, ep.needsUpdate = !0, eh.needsUpdate = !0, this.setAttribute("position", ec), this.setAttribute("normal", eu), this.setAttribute("uv", ep), this.setIndex(eh)
                    }
                    _computeBufferEstimatedSize(_) {
                        return 2 * _.vertexCount * (2 + this._bevelSegments)
                    }
                    _buildWall(_, O, B) {
                        let N = _[0];
                        for (let _ = 0, k = N.boundary.vertexCount; _ < k; _++) {
                            let F = this._buildBevelVert(O, N, _),
                                U = this._buildBevelVert(O, N, (_ + 1) % k);
                            B.push(U.topP, F.topN, F.bottomN), B.push(U.topP, F.bottomN, U.bottomP)
                        }
                    }
                    _buildSurfaceVert(_, O, B) {
                        let N = O.toString();
                        if (N in this.vertexCache) return this.vertexCache[N];
                        let k = _.vertices[2 * O + 0],
                            F = _.vertices[2 * O + 1],
                            U = (k - this._minX) / this._width,
                            j = (F - this._minY) / this._height;
                        this.forPathBevel && (j = 1);
                        let G = this._buffer.get(this.forPathBevel ? 1 : 2),
                            Y = 3 * G,
                            Q = 2 * G,
                            K = {
                                top: G + 0,
                                bottom: G + 1
                            };
                        return this._buffer.positions[Y + 0] = k, this._buffer.positions[Y + 1] = F, this._buffer.positions[Y + 2] = this.forPathBevel ? this._bevel : this._depth - B, this._buffer.normals[Y + 0] = 0, this._buffer.normals[Y + 1] = 0, this._buffer.normals[Y + 2] = 1, this._buffer.uvs[Q + 0] = U, this._buffer.uvs[Q + 1] = j, !1 === this.forPathBevel && (this._buffer.positions[Y + 3] = k, this._buffer.positions[Y + 4] = F, this._buffer.positions[Y + 5] = B, this._buffer.normals[Y + 3] = 0, this._buffer.normals[Y + 4] = 0, this._buffer.normals[Y + 5] = -1, this._buffer.uvs[Q + 2] = U, this._buffer.uvs[Q + 3] = j), this.vertexCache[N] = K, K
                    }
                    _buildBevelVert(_, O, B, N = 1, k) {
                        let F = `${O.bevelI}:${B}`;
                        if (F in this.vertexCache && 0 !== k && 1 !== k && (!k || k === this.vertexCache[F].pathBevelUCoord)) return this.vertexCache[F];
                        let [U, j] = O.boundary.vertexIndices[B], G, Y, Q, K;
                        U !== j ? (Y = U, G = j, K = !1, Q = _.continuous[Y] && _.continuous[G]) : (Y = ((G = U) - 1 + _.count) % _.count, K = _.concave[G] && O.bevelI > 0, Q = _.continuous[G] || K);
                        let $ = Math.cos(O.angle),
                            ee = Math.sin(O.angle),
                            et = 2 * B,
                            ei = 2 * G,
                            er = 2 * Y,
                            ea = O.boundary.vertices[et + 0],
                            en = O.boundary.vertices[et + 1],
                            eo = (1 - ee) * this._bevel,
                            el = (ea - this._minX) / this._width,
                            eh = (en - this._minY) / this._height;
                        this.forPathBevel && (void 0 !== k && (el = k), eh = 1);
                        let ec = _.normals[ei + 0],
                            eu = _.normals[ei + 1],
                            ep = _.normals[er + 0],
                            ef = _.normals[er + 1];
                        if (K) {
                            let _ = ep - ec,
                                O = ef - eu,
                                B = Math.sqrt((ec += _ * (1 - N)) * ec + (eu += O * (1 - N)) * eu);
                            ec /= B, eu /= B
                        }
                        let em = this.forPathBevel ? this._buffer.get(Q ? 1 : 2) : this._buffer.get(Q ? 2 : 4),
                            eg = 3 * em,
                            ev = 2 * em,
                            ex = {
                                i: B,
                                fi: G,
                                topP: em + 0,
                                topN: em + 0,
                                bottomP: em + 1,
                                bottomN: em + 1,
                                pathBevelUCoord: k
                            };
                        return this._buffer.positions[eg + 0] = ea, this._buffer.positions[eg + 1] = en, this._buffer.positions[eg + 2] = (this.forPathBevel ? this._bevel : this._depth) - eo, this._buffer.normals[eg + 0] = ec * $, this._buffer.normals[eg + 1] = eu * $, this._buffer.normals[eg + 2] = ee, this._buffer.uvs[ev + 0] = el, this._buffer.uvs[ev + 1] = eh, !1 === this.forPathBevel && (this._buffer.positions[eg + 3] = ea, this._buffer.positions[eg + 4] = en, this._buffer.positions[eg + 5] = eo, this._buffer.normals[eg + 3] = ec * $, this._buffer.normals[eg + 4] = eu * $, this._buffer.normals[eg + 5] = -ee, this._buffer.uvs[ev + 2] = eh, this._buffer.uvs[ev + 3] = el), Q || (this.forPathBevel ? (em += 1, eg += 3, ev += 2) : (em += 2, eg += 6, ev += 4), ex.topP = em + 0, ex.bottomP = em + 1, this._buffer.positions[eg + 0] = ea, this._buffer.positions[eg + 1] = en, this._buffer.positions[eg + 2] = (this.forPathBevel ? this._bevel : this._depth) - eo, this._buffer.normals[eg + 0] = ep * $, this._buffer.normals[eg + 1] = ef * $, this._buffer.normals[eg + 2] = ee, this._buffer.uvs[ev + 0] = el, this._buffer.uvs[ev + 1] = eh, !1 === this.forPathBevel && (this._buffer.positions[eg + 3] = ea, this._buffer.positions[eg + 4] = en, this._buffer.positions[eg + 5] = eo, this._buffer.normals[eg + 3] = ep * $, this._buffer.normals[eg + 4] = ef * $, this._buffer.normals[eg + 5] = -ee, this._buffer.uvs[ev + 2] = eh, this._buffer.uvs[ev + 3] = el)), this.vertexCache[F] = ex, ex
                    }
                    clone() {
                        let _ = new yw(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
                        return _.userData = Zo(this.userData), _
                    }
                },
                y_ = class extends sK {
                    constructor(_, O = 12, B = {}) {
                        super(), this.type = "ShapeGeometry", this.windingRule = xp.ODD, this.elementType = xf.POLYGONS, this.polySize = 3, this.vertexSize = 2, this.strict = !0, this._shape = _, this._curveSegments = O, this._triangulationOptions = Object.assign({
                            windingRule: xp.ODD,
                            elementType: xf.POLYGONS,
                            polySize: 3,
                            vertexSize: 2,
                            strict: !0
                        }, B);
                        let N = this._shape.extractShapePointsToFlatArray([], this._curveSegments),
                            k = this._shape.shapeHoles.map(_ => _.extractShapePointsToFlatArray([], this._curveSegments)),
                            F, U = !0,
                            j = !0,
                            G, Y;
                        for (let _ = 0, O = N.length / 2; _ < O; _++) {
                            let O = 2 * _,
                                B = N[O + 0],
                                k = N[O + 1];
                            if (void 0 !== G && B !== G && (U = !1), void 0 !== Y && k !== Y && (j = !1), G = B, Y = k, !U && !j) break
                        }
                        if (!U && !j) try {
                            F = Es({
                                contours: [N, ...k],
                                windingRule: this._triangulationOptions.windingRule,
                                elementType: this._triangulationOptions.elementType,
                                polySize: this._triangulationOptions.polySize,
                                vertexSize: this._triangulationOptions.vertexSize,
                                strict: this._triangulationOptions.strict
                            })
                        } catch {
                            F = yy
                        }
                        let Q = F ? .vertexCount ? ? 1,
                            K = F ? .elementCount ? ? 1;
                        if (this._positionAttribute = new sF(new Float32Array(3 * Q), 3), this._normalAttribute = new sF(new Float32Array(3 * Q), 3), this._uvAttribute = new sF(new Float32Array(2 * Q), 2), this._indexAttribute = new sF(new Uint32Array(3 * K), 1), F) {
                            let _ = 1 / 0,
                                O = -1 / 0,
                                B = 1 / 0,
                                N = -1 / 0;
                            for (let k = 0; k < Q; k++) {
                                let U = 2 * k,
                                    j = F.vertices[U + 0],
                                    G = F.vertices[U + 1];
                                j < _ && (_ = j), j > O && (O = j), G < B && (B = G), G > N && (N = G)
                            }
                            let k = O - _,
                                U = N - B;
                            for (let O = 0; O < Q; O++) {
                                let N = 2 * O,
                                    j = F.vertices[N + 0],
                                    G = F.vertices[N + 1],
                                    Y = (j - _) / k,
                                    Q = (G - B) / U;
                                this._positionAttribute.setXYZ(O, j, G, 0), this._normalAttribute.setXYZ(O, 0, 0, 1), this._uvAttribute.setXY(O, Y, Q)
                            }
                            for (let _ = 0; _ < K; _++) {
                                let O = 3 * _,
                                    B = F.elements[O + 0],
                                    N = F.elements[O + 1],
                                    k = F.elements[O + 2];
                                this._indexAttribute.setX(O + 0, B), this._indexAttribute.setX(O + 1, N), this._indexAttribute.setX(O + 2, k)
                            }
                        }
                        this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.setDrawRange(0, (F ? .elementCount ? ? 1) * 3)
                    }
                    clone() {
                        let _ = new y_(this._shape, this._curveSegments);
                        return _.userData = Zo(this.userData), _
                    }
                },
                yS = class extends yw {
                    constructor(_, O, B = 0, N = 12, k = 3, F = xp.ODD) {
                        super(_, O, B, N, k, F), this.type = "ShapeGeometry"
                    }
                    _computeBufferEstimatedSize(_) {
                        return 2 * _.vertexCount * (2 + this._bevelSegments)
                    }
                    _buildWall(_, O, B) {
                        let N = _[0];
                        for (let _ = 0, k = N.boundary.vertexCount; _ < k; _++) {
                            let F = this._buildBevelVert(O, N, _),
                                U = this._buildBevelVert(O, N, (_ + 1) % k);
                            B.push(U.topP, F.topN, F.bottomN), B.push(U.topP, F.bottomN, U.bottomP)
                        }
                    }
                    clone() {
                        let _ = new yS(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
                        return _.userData = Zo(this.userData), _
                    }
                },
                yA = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                                width: 100,
                                subdivisions: 40,
                                roundness: 0,
                                extrudeBevelSize: 0,
                                extrudeBevelSegments: 3,
                                windingRule: xp.ODD
                            }, _.parameters),
                            N = Math.abs(B.width),
                            k = Math.abs(B.height ? ? B.width),
                            F = Math.abs(B.depth ? ? 0),
                            U = _.shape ? ? O ? .shape,
                            j = U ? .roundness ? ? B.roundness;
                        void 0 !== U && (U instanceof ys ? (U.width !== N || U.height !== k) && U.applySize(N, k) : U = new ys(N, k).fromJSON(U), _.parameters ? .roundness !== void 0 && _.parameters ? .roundness > 0 && U.update());
                        let G = U ? ? new ys(N, k);
                        return {
                            parameters: Object.assign(B, {
                                width: N,
                                height: k,
                                depth: F,
                                roundness: j
                            }),
                            shape: G
                        }
                    }
                    static build(_) {
                        let {
                            depth: O,
                            extrudeBevelSize: B,
                            extrudeBevelSegments: N,
                            subdivisions: k,
                            roundness: F,
                            windingRule: U
                        } = _.parameters;
                        return _.shape.roundness = F, Object.assign(O <= 0 ? new y_(_.shape, k, {
                            windingRule: U
                        }) : new yS(_.shape, O, B, k, N, U), {
                            userData: { ..._,
                                type: "VectorGeometry"
                            }
                        })
                    }
                },
                yM = 2 * Math.PI,
                yE = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            depth: 0,
                            spikes: 64,
                            angle: 360,
                            innerRadius: 0,
                            extrudeBevelSize: 0,
                            extrudeBevelSegments: 1
                        }, _.parameters);
                        return B.angle = iK.clamp(B.angle, 0, 360), {
                            shape: _.shape && _.shape instanceof ys ? _.shape : new ys,
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? 0)
                            })
                        }
                    }
                    static build(_) {
                        let O, {
                                width: B,
                                height: N,
                                spikes: k,
                                angle: F,
                                innerRadius: U,
                                depth: j,
                                extrudeBevelSize: G,
                                extrudeBevelSegments: Y
                            } = _.parameters,
                            Q = _.shape,
                            K = function(_, O, B, N, k, F) {
                                if (N >= yM) return k > 30 || k % 4 == 0 ? (function(_, O, B, N = 0, k = 0, F = 0) {
                                    let U = .5522847498 * O,
                                        j = .5522847498 * B;
                                    _.addPoint(Av(k - O, F, k - O, F - j, k - O, F + j)), _.addPoint(Av(k, F + B, k - U, F + B, k + U, F + B)), _.addPoint(Av(k + O, F, k + O, F + j, k + O, F - j)), _.addPoint(Av(k, F - B, k + U, F - B, k - U, F - B)), N > 0 && bD(_, O, B, N)
                                }(_, O, B, F), Math.round(k / 4)) : yD(_, N, k, O, B, F);
                                let U = {
                                        x: 0,
                                        y: B
                                    },
                                    j = (N = Math.max(N, .001)) + .5 * Math.PI,
                                    G = {
                                        x: Math.cos(j) * O,
                                        y: Math.sin(j) * B
                                    },
                                    Y = function({
                                        px: _,
                                        py: O,
                                        cx: B,
                                        cy: N,
                                        rx: k,
                                        ry: F,
                                        largeArcFlag: U,
                                        sweepFlag: j
                                    }) {
                                        var G, Y;
                                        let Q, K, $, ee, et, ei, er, ea, en, eo, el, eh = [];
                                        if (0 === k || 0 === F) return [];
                                        let ec = (_ - B) / 2,
                                            eu = (O - N) / 2;
                                        if (0 === ec && 0 === eu) return [];
                                        let ep = Math.pow(ec, 2) / Math.pow(k = Math.abs(k), 2) + Math.pow(eu, 2) / Math.pow(F = Math.abs(F), 2);
                                        ep > 1 && (k *= Math.sqrt(ep), F *= Math.sqrt(ep));
                                        let ef = (G = k, Y = F, Q = Math.pow(G, 2), K = Math.pow(Y, 2), $ = Math.pow(ec, 2), (et = Q * K - Q * (ee = Math.pow(eu, 2)) - K * $) < 0 && (et = 0), et /= Q * ee + K * $, ei = (et = Math.sqrt(et) * (U === j ? -1 : 1)) * G / Y * eu, er = -(et * Y) / G * ec, eo = aD(1, 0, ea = (ec - ei) / G, en = (eu - er) / Y), el = aD(ea, en, (-ec - ei) / G, (-eu - er) / Y), !j && el > 0 && (el -= ya), j && el < 0 && (el += ya), {
                                                centerx: ei + (_ + B) / 2,
                                                centery: er + (O + N) / 2,
                                                ang1: eo,
                                                ang2: el
                                            }),
                                            {
                                                ang1: em,
                                                ang2: eg
                                            } = ef,
                                            {
                                                centerx: ev,
                                                centery: ex
                                            } = ef,
                                            eb = Math.abs(eg) / (ya / 4);
                                        1e-7 > Math.abs(1 - eb) && (eb = 1);
                                        let e_ = Math.max(Math.ceil(eb), 1);
                                        eg /= e_;
                                        for (let _ = 0; _ < e_; _++) eh.push(function(_, O) {
                                            let B = 1.5707963267948966 === O ? .551915024494 : -1.5707963267948966 === O ? -.551915024494 : 1.3333333333333333 * Math.tan(O / 4),
                                                N = Math.cos(_),
                                                k = Math.sin(_),
                                                F = Math.cos(_ + O),
                                                U = Math.sin(_ + O);
                                            return [{
                                                x: N - k * B,
                                                y: k + N * B
                                            }, {
                                                x: F + U * B,
                                                y: U - F * B
                                            }, {
                                                x: F,
                                                y: U
                                            }]
                                        }(em, eg)), em += eg;
                                        return eh.map(_ => {
                                            let {
                                                x: O,
                                                y: B
                                            } = FS(_[0], k, F, ev, ex), {
                                                x: N,
                                                y: U
                                            } = FS(_[1], k, F, ev, ex), {
                                                x: j,
                                                y: G
                                            } = FS(_[2], k, F, ev, ex);
                                            return {
                                                x1: O,
                                                y1: B,
                                                x2: N,
                                                y2: U,
                                                x: j,
                                                y: G
                                            }
                                        })
                                    }({
                                        px: U.x,
                                        py: U.y,
                                        cx: G.x,
                                        cy: G.y,
                                        rx: O,
                                        ry: B,
                                        largeArcFlag: N > Math.PI,
                                        sweepFlag: !0
                                    });
                                return k > 30 || k % Y.length == 0 ? function(_, O, B, N, k, F, U, j) {
                                    let G = Math.round(k / N.length);
                                    _.addPoint(Zh(O, B));
                                    for (let O = 0, B = N.length; O < B; O++) {
                                        let B = N[O],
                                            k = _.points[O],
                                            F = Zh(B.x, B.y);
                                        k.controls[1].position.set(B.x1, B.y1), F.controls[0].position.set(B.x2, B.y2), _.addPoint(F)
                                    }
                                    return j > 0 ? xD(_, F, U, j) : _.addPoint(Zh(0, 0)), G
                                }(_, U.x, U.y, Y, k, O, B, F) : yD(_, N, k, O, B, F)
                            }(Q, .5 * B, .5 * N, F * Math.PI / 180, k, U);
                        return Q.isClosed = !0, Q.update(), 0 === F ? (O = new sK).setAttribute("position", new sG([], 3)) : O = yA.create({
                            shape: Q,
                            parameters: {
                                subdivisions: K,
                                depth: j,
                                extrudeBevelSize: G,
                                extrudeBevelSegments: Y
                            }
                        }), Object.assign(O, {
                            userData: { ..._,
                                type: "EllipseGeometry"
                            }
                        })
                    }
                };

            function yD(_, O, B, N, k, F) {
                let U = -O / B;
                for (let O = 0; O <= B; O++) {
                    let B = U * O,
                        F = Math.sin(B) * N,
                        j = Math.cos(B) * k;
                    _.addPoint(Zh(F, j))
                }
                return O < yM ? F > 0 ? xD(_, N, k, F) : _.addPoint(Zh(0, 0)) : (_.removePoint(_.points[_.points.length - 1]), F > 0 && bD(_, N, k, F)), 1
            }

            function Zh(_, O) {
                return new vK(iK.generateUUID(), new iJ(_, O))
            }

            function Av(_, O, B, N, k, F) {
                let U = Zh(_, O);
                return U.controls[0].position.set(B, N), U.controls[1].position.set(k, F), U
            }

            function xD(_, O, B, N) {
                wD(_, O, B, N).forEach(O => _.addPoint(O))
            }

            function bD(_, O, B, N) {
                let k = wD(_, O, B, N),
                    F = new ys;
                k.forEach(_ => F.addPoint(_)), F.isClosed = !0, _.shapeHoles.push(F)
            }

            function wD(_, O, B, N) {
                let k = N * O / 100,
                    F = k * (Math.abs(B) / Math.abs(O)),
                    U = new iJ(k / O, F / B),
                    j = _.points.map(_ => {
                        let O = _.clone();
                        return O.uuid = iK.generateUUID(), O
                    }).reverse();
                return j.forEach(_ => {
                    _.position.multiply(U);
                    let O = _.controls[0].position.clone().multiply(U),
                        B = _.controls[1].position.clone().multiply(U);
                    _.controls[0].position.copy(B), _.controls[1].position.copy(O)
                }), j
            }
            var yC = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                                width: 100,
                                revolutions: 2,
                                segments: 40,
                                pathRadius: 10,
                                pathType: 0,
                                pathSegments: 30,
                                cornerRadius: 30,
                                cornerSegments: 4
                            }, _.parameters),
                            N = Math.abs(B.width),
                            k = Math.abs(B.height ? ? N),
                            F = Math.abs(B.depth ? ? N),
                            U = Math.abs(Math.min(N, F)) / 2;
                        return {
                            parameters: Object.assign(B, {
                                width: N,
                                height: k,
                                depth: F,
                                radius: U,
                                segments: Math.round(B.segments),
                                pathSegments: Math.round(B.pathSegments),
                                cornerSegments: Math.round(B.cornerSegments)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            radius: k,
                            revolutions: F,
                            segments: U,
                            pathRadius: j,
                            pathType: G,
                            pathSegments: Y,
                            cornerRadius: Q,
                            cornerSegments: K
                        } = _.parameters;
                        return Object.assign(new yP(!1, O, B, N, k, F, U, j, G, Y, Q, K), {
                            userData: { ..._,
                                type: "HelixGeometry"
                            }
                        })
                    }
                },
                yT = new sj([0, 0, 0], 1),
                yP = class extends sK {
                    constructor(_ = !0, O = 1, B = 1, N = 1, k = 1, F = 1, U = 1, j = 1, G = 1, Y = 1, Q = 1, K = 1) {
                        if (super(), 0 === F) return;
                        let $ = _ && 1 === F;
                        $ && (K = 0), Q > 100 && (Q = 100), 0 === Q && (K = 0);
                        let p = () => new rv,
                            ee = new rv,
                            et = p(),
                            ei = p(),
                            er = p(),
                            ea, en, eo, el, eh, ec, eu, ep, ef = p(),
                            em = p(),
                            eg = p(),
                            ev = p(),
                            ex = p(),
                            eb = p(),
                            e_ = p(),
                            eS = p(),
                            eA = B - 2 * j + .001,
                            eM = eA / F,
                            eE = Math.ceil(U * F),
                            eC = eE + 1,
                            eT = eA / eE,
                            eD = -eA / 2,
                            eP = Y + 1,
                            eI = 2 * Math.PI / Y,
                            eO = Math.PI / 2 / K,
                            eL = Math.min((1 - Q / 100) * j, j - .01),
                            eR = j - eL,
                            eB = 0,
                            eN = 2 * K + 2,
                            ek = eP * eN / 2,
                            eF = ek + eP * eC,
                            eU = Math.max(0, eP * (eC + eN)),
                            [ej, eG, eH] = [3, 3, 2].map(_ => Array(eU * _).fill(0)),
                            eW = [],
                            eq = k - j;

                        function L(O, B) {
                            let N = Math.PI / 2;
                            ep = 2 * Math.PI * ((ec = B * eT) % eM) / eM + N, ec += eD, eu = Math.sin(ep) * eq, eh = Math.cos(ep) * eq, _ ? O.set(eh, eu, ec) : O.set(eh, ec, eu)
                        }
                        L(ee, -.0000000001), L(et, 0), ef.copy(ee), L(ee, 1);
                        let eY = ee.distanceTo(et),
                            eX = $ ? 0 : eR + eL,
                            eQ = eY * eE + 2 * eX,
                            eZ = eQ - eX;
                        for (let O = 0; O <= eE; O++) {
                            L(ei, O), eS.subVectors(ei, ef).normalize(), ef.copy(ei), eb.copy(ei).setComponent(+_ + 1, 0).normalize(), e_.crossVectors(eS, eb).normalize();
                            let B = 0 === O,
                                N = O === eE,
                                k = B ? 3 * Math.PI / 2 : eO,
                                F = B ? eL : eZ,
                                U = B ? eP : eF,
                                G = B ? 0 : eU - eP,
                                Q = eS.clone().multiplyScalar(B ? -eR : eR).add(ei),
                                ea = eS.clone().multiplyScalar(B ? -1 : 1).normalize();
                            for (let _ = 0; _ < eP; _++) {
                                let en = _ * eI;
                                if (em.addVectors(ee.copy(eb).multiplyScalar(j * Math.cos(en)), et.copy(e_).multiplyScalar(j * Math.sin(en))), eg.copy(em).normalize(), B || N) {
                                    $ || (eB = G + _, [0, 1, 2].forEach(_ => {
                                        ej[3 * eB + _] = Q.getComponent(_), eG[3 * eB + _] = ea.getComponent(_)
                                    }), eH[2 * eB] = +N, eH[2 * eB + 1] = _ / Y), et.copy(eg).multiplyScalar(eL), er.addVectors(ei, et);
                                    for (let O = 0; O < K; O++) {
                                        let N = O * eO + k;
                                        ev.addVectors(ee.copy(eS).multiplyScalar(eR * Math.sin(N)), et.copy(eg).multiplyScalar(eR * Math.cos(N))), ex.copy(ev).normalize(), et.addVectors(er, ev), ev.normalize(), eB = U + O * eP + _, [0, 1, 2].forEach(_ => {
                                            ej[3 * eB + _] = et.getComponent(_), eG[3 * eB + _] = ex.getComponent(_)
                                        });
                                        let j = +B + Math.sin(N);
                                        eH[2 * eB] = (F + eR * j) / eQ, eH[2 * eB + 1] = _ / Y
                                    }
                                }
                                et.addVectors(ei, em), eB = ek + O * eP + _, [0, 1, 2].forEach(_ => {
                                    ej[3 * eB + _] = et.getComponent(_), eG[3 * eB + _] = eg.getComponent(_)
                                }), eH[2 * eB] = (eX + O * eY) / eQ, eH[2 * eB + 1] = _ / Y
                            }
                        }
                        let eK = eC + 2 * K + 2,
                            [eJ, e$] = [+$, eK - 1];
                        for (let _ = eJ; _ <= e$ - 1; _++) {
                            let O = $ && _ === e$ - 1;
                            for (let B = 0; B < eP - 1; B++) en = (ea = _ * eP + B) + 1, eo = (O ? B : ea) + eP, el = (O ? B + 1 : en) + eP, 0 === _ ? eW.push(en, el, eo) : _ === eK - 2 ? eW.push(ea, en, eo) : eW.push(ea, en, eo, en, el, eo)
                        }
                        this.setIndex(eW), this.setAttribute("position", new sG(ej, 3)), this.setAttribute("normal", new sG(eG, 3)), this.setAttribute("uv", new sG(eH, 2))
                    }
                    getClosedTorusIndicesForBooleanOrSubdiv() {
                        let _ = this.userData.parameters,
                            O = Math.ceil(_.tubularSegments),
                            B = _.radialSegments + 1,
                            N = Array.from(this.getIndex().array),
                            k, F, U, j, G = 6 * (O - 1) * _.radialSegments,
                            Y = O == O;
                        for (let Q = 0; Q < _.radialSegments; Q++) F = (k = O * B + Q) + 1, U = (Y ? Q : k) + B, j = (Y ? Q + 1 : F) + B, N[G++] = k, N[G++] = F, N[G++] = U, N[G++] = F, N[G++] = j, N[G++] = U;
                        return N.length = G, yT.array = N, yT.count = N.length, yT
                    }
                },
                yO = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            detail: 0,
                            corner: 0,
                            cornerSides: 4
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            detail: k,
                            corner: F,
                            cornerSides: U
                        } = _.parameters, j = 0 === k && 0 !== F ? new yL(.5 * O, F, U) : new o_(.5 * O, k);
                        return j.scale(1, B / O, N / O), Object.assign(j, {
                            userData: { ..._,
                                type: "IcosahedronGeometry"
                            }
                        })
                    }
                },
                yL = class extends vW {
                    constructor(_ = 1, O = .2, B = 4) {
                        let N = (1 + Math.sqrt(5)) / 2,
                            k = "IcosahedronGeometry";
                        super([-1, N, 0, 1, N, 0, -1, -N, 0, 1, -N, 0, 0, -1, N, 0, 1, N, 0, -1, -N, 0, 1, -N, N, 0, -1, N, 0, 1, -N, 0, -1, -N, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], k, _, O, B), this.type = k
                    }
                    static fromJSON(_) {
                        return new yL(_.radius, _.corner, _.cornerSides)
                    }
                },
                yR = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        (_.parameters ? .points ? ? []).forEach(_ => {
                            Array.isArray(_) && (_.x = _[0], _.y = _[1])
                        });
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            segments: 64,
                            verticalSegments: 64,
                            points: [{
                                x: 0,
                                y: -50,
                                id: 0
                            }, {
                                x: 50,
                                y: -50,
                                id: 1
                            }, {
                                x: 50,
                                y: 50,
                                id: 2
                            }, {
                                x: 0,
                                y: 50,
                                id: 3
                            }]
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            points: O,
                            segments: B,
                            verticalSegments: N
                        } = _.parameters, k = new ox;
                        k.moveTo(O[0].x, O[0].y), k.bezierCurveTo(O[1].x, O[1].y, O[2].x, O[2].y, O[3].x, O[3].y);
                        let F = new on(k.extractPoints(N).shape, B);
                        return F.rotateZ(Math.PI), Object.assign(F, {
                            userData: { ..._,
                                type: "LatheGeometry"
                            }
                        })
                    }
                },
                yB = new rJ,
                yN = new sv,
                yk = new rv,
                yF = class extends iq {
                    constructor() {
                        super(), this.uuid = iK.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
                    }
                    applyMatrix4(_) {
                        let O = new i$().getNormalMatrix(_);
                        for (let O = 0, B = this.vertices.length; O < B; O++) this.vertices[O].applyMatrix4(_);
                        for (let _ = 0, B = this.faces.length; _ < B; _++) {
                            let B = this.faces[_];
                            B.normal.applyMatrix3(O).normalize();
                            for (let _ = 0, N = B.vertexNormals.length; _ < N; _++) B.vertexNormals[_].applyMatrix3(O).normalize()
                        }
                        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                    }
                    rotateX(_) {
                        return yB.makeRotationX(_), this.applyMatrix4(yB), this
                    }
                    rotateY(_) {
                        return yB.makeRotationY(_), this.applyMatrix4(yB), this
                    }
                    rotateZ(_) {
                        return yB.makeRotationZ(_), this.applyMatrix4(yB), this
                    }
                    translate(_, O, B) {
                        return yB.makeTranslation(_, O, B), this.applyMatrix4(yB), this
                    }
                    scale(_, O, B) {
                        return yB.makeScale(_, O, B), this.applyMatrix4(yB), this
                    }
                    lookAt(_) {
                        return yN.lookAt(_), yN.updateMatrix(), this.applyMatrix4(yN.matrix), this
                    }
                    fromBufferGeometry(_) {
                        let O = this,
                            B = null !== _.index ? _.index : void 0,
                            N = _.attributes;
                        if (void 0 === N.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                        let k = N.position,
                            F = N.normal,
                            U = N.color,
                            j = N.uv,
                            G = N.uv2;
                        void 0 !== G && (this.faceVertexUvs[1] = []);
                        for (let _ = 0; _ < k.count; _++) O.vertices.push(new rv().fromBufferAttribute(k, _)), void 0 !== U && O.colors.push(new re().fromBufferAttribute(U, _));

                        function c(_, B, N, k) {
                            let Y = void 0 === U ? [] : [O.colors[_].clone(), O.colors[B].clone(), O.colors[N].clone()],
                                Q = void 0 === F ? [] : [new rv().fromBufferAttribute(F, _), new rv().fromBufferAttribute(F, B), new rv().fromBufferAttribute(F, N)],
                                K = new yj(_, B, N, Q, Y, k);
                            O.faces.push(K), void 0 !== j && O.faceVertexUvs[0].push([new iJ().fromBufferAttribute(j, _), new iJ().fromBufferAttribute(j, B), new iJ().fromBufferAttribute(j, N)]), void 0 !== G && O.faceVertexUvs[1].push([new iJ().fromBufferAttribute(G, _), new iJ().fromBufferAttribute(G, B), new iJ().fromBufferAttribute(G, N)])
                        }
                        let Y = _.groups;
                        if (Y.length > 0)
                            for (let _ = 0; _ < Y.length; _++) {
                                let O = Y[_],
                                    N = O.start,
                                    k = O.count;
                                for (let _ = N, F = N + k; _ < F; _ += 3) void 0 !== B ? c(B.getX(_), B.getX(_ + 1), B.getX(_ + 2), O.materialIndex) : c(_, _ + 1, _ + 2, O.materialIndex)
                            } else if (void 0 !== B)
                                for (let _ = 0; _ < B.count; _ += 3) c(B.getX(_), B.getX(_ + 1), B.getX(_ + 2));
                            else
                                for (let _ = 0; _ < k.count; _ += 3) c(_, _ + 1, _ + 2);
                        return this.computeFaceNormals(), null !== _.boundingBox && (this.boundingBox = _.boundingBox.clone()), null !== _.boundingSphere && (this.boundingSphere = _.boundingSphere.clone()), this
                    }
                    center() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(yk).negate(), this.translate(yk.x, yk.y, yk.z), this
                    }
                    normalize() {
                        this.computeBoundingSphere();
                        let _ = this.boundingSphere.center,
                            O = this.boundingSphere.radius,
                            B = 0 === O ? 1 : 1 / O,
                            N = new rJ;
                        return N.set(B, 0, 0, -B * _.x, 0, B, 0, -B * _.y, 0, 0, B, -B * _.z, 0, 0, 0, 1), this.applyMatrix4(N), this
                    }
                    computeFaceNormals() {
                        let _ = new rv,
                            O = new rv;
                        for (let B = 0, N = this.faces.length; B < N; B++) {
                            let N = this.faces[B],
                                k = this.vertices[N.a],
                                F = this.vertices[N.b],
                                U = this.vertices[N.c];
                            _.subVectors(U, F), O.subVectors(k, F), _.cross(O), _.normalize(), N.normal.copy(_)
                        }
                    }
                    computeVertexNormals(_ = !0) {
                        let O = Array(this.vertices.length);
                        for (let _ = 0, B = this.vertices.length; _ < B; _++) O[_] = new rv;
                        if (_) {
                            let _ = new rv,
                                B = new rv;
                            for (let N = 0, k = this.faces.length; N < k; N++) {
                                let k = this.faces[N],
                                    F = this.vertices[k.a],
                                    U = this.vertices[k.b],
                                    j = this.vertices[k.c];
                                _.subVectors(j, U), B.subVectors(F, U), _.cross(B), O[k.a].add(_), O[k.b].add(_), O[k.c].add(_)
                            }
                        } else {
                            this.computeFaceNormals();
                            for (let _ = 0, B = this.faces.length; _ < B; _++) {
                                let B = this.faces[_];
                                O[B.a].add(B.normal), O[B.b].add(B.normal), O[B.c].add(B.normal)
                            }
                        }
                        for (let _ = 0, B = this.vertices.length; _ < B; _++) O[_].normalize();
                        for (let _ = 0, B = this.faces.length; _ < B; _++) {
                            let B = this.faces[_],
                                N = B.vertexNormals;
                            3 === N.length ? (N[0].copy(O[B.a]), N[1].copy(O[B.b]), N[2].copy(O[B.c])) : (N[0] = O[B.a].clone(), N[1] = O[B.b].clone(), N[2] = O[B.c].clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    }
                    computeFlatVertexNormals() {
                        this.computeFaceNormals();
                        for (let _ = 0, O = this.faces.length; _ < O; _++) {
                            let O = this.faces[_],
                                B = O.vertexNormals;
                            3 === B.length ? (B[0].copy(O.normal), B[1].copy(O.normal), B[2].copy(O.normal)) : (B[0] = O.normal.clone(), B[1] = O.normal.clone(), B[2] = O.normal.clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    }
                    computeMorphNormals() {
                        for (let _ = 0, O = this.faces.length; _ < O; _++) {
                            let O = this.faces[_];
                            O.__originalFaceNormal ? O.__originalFaceNormal.copy(O.normal) : O.__originalFaceNormal = O.normal.clone(), O.__originalVertexNormals || (O.__originalVertexNormals = []);
                            for (let _ = 0, B = O.vertexNormals.length; _ < B; _++) O.__originalVertexNormals[_] ? O.__originalVertexNormals[_].copy(O.vertexNormals[_]) : O.__originalVertexNormals[_] = O.vertexNormals[_].clone()
                        }
                        let _ = new yF;
                        _.faces = this.faces;
                        for (let O = 0, B = this.morphTargets.length; O < B; O++) {
                            if (!this.morphNormals[O]) {
                                this.morphNormals[O] = {}, this.morphNormals[O].faceNormals = [], this.morphNormals[O].vertexNormals = [];
                                let _ = this.morphNormals[O].faceNormals,
                                    B = this.morphNormals[O].vertexNormals;
                                for (let O = 0, N = this.faces.length; O < N; O++) {
                                    let O = new rv,
                                        N = {
                                            a: new rv,
                                            b: new rv,
                                            c: new rv
                                        };
                                    _.push(O), B.push(N)
                                }
                            }
                            let B = this.morphNormals[O];
                            _.vertices = this.morphTargets[O].vertices, _.computeFaceNormals(), _.computeVertexNormals();
                            for (let _ = 0, O = this.faces.length; _ < O; _++) {
                                let O = this.faces[_],
                                    N = B.faceNormals[_],
                                    k = B.vertexNormals[_];
                                N.copy(O.normal), k.a.copy(O.vertexNormals[0]), k.b.copy(O.vertexNormals[1]), k.c.copy(O.vertexNormals[2])
                            }
                        }
                        for (let _ = 0, O = this.faces.length; _ < O; _++) {
                            let O = this.faces[_];
                            O.normal = O.__originalFaceNormal, O.vertexNormals = O.__originalVertexNormals
                        }
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new rb), this.boundingBox.setFromPoints(this.vertices)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new rG), this.boundingSphere.setFromPoints(this.vertices)
                    }
                    merge(_, O, B = 0) {
                        if (!(_ && _.isGeometry)) {
                            console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", _);
                            return
                        }
                        let N, k = this.vertices.length,
                            F = this.vertices,
                            U = _.vertices,
                            j = this.faces,
                            G = _.faces,
                            Y = this.colors,
                            Q = _.colors;
                        void 0 !== O && (N = new i$().getNormalMatrix(O));
                        for (let _ = 0, B = U.length; _ < B; _++) {
                            let B = U[_].clone();
                            void 0 !== O && B.applyMatrix4(O), F.push(B)
                        }
                        for (let _ = 0, O = Q.length; _ < O; _++) Y.push(Q[_].clone());
                        for (let _ = 0, O = G.length; _ < O; _++) {
                            let O = G[_],
                                F, U, Y = O.vertexNormals,
                                Q = O.vertexColors,
                                K = new yj(O.a + k, O.b + k, O.c + k);
                            K.normal.copy(O.normal), void 0 !== N && K.normal.applyMatrix3(N).normalize();
                            for (let _ = 0, O = Y.length; _ < O; _++) F = Y[_].clone(), void 0 !== N && F.applyMatrix3(N).normalize(), K.vertexNormals.push(F);
                            K.color.copy(O.color);
                            for (let _ = 0, O = Q.length; _ < O; _++) U = Q[_], K.vertexColors.push(U.clone());
                            K.materialIndex = O.materialIndex + B, j.push(K)
                        }
                        for (let O = 0, B = _.faceVertexUvs.length; O < B; O++) {
                            let B = _.faceVertexUvs[O];
                            void 0 === this.faceVertexUvs[O] && (this.faceVertexUvs[O] = []);
                            for (let _ = 0, N = B.length; _ < N; _++) {
                                let N = B[_],
                                    k = [];
                                for (let _ = 0, O = N.length; _ < O; _++) k.push(N[_].clone());
                                this.faceVertexUvs[O].push(k)
                            }
                        }
                    }
                    mergeMesh(_) {
                        if (!(_ && _.isMesh)) {
                            console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", _);
                            return
                        }
                        _.matrixAutoUpdate && _.updateMatrix(), this.merge(_.geometry, _.matrix)
                    }
                    mergeVertices(_ = 4) {
                        let O = {},
                            B = [],
                            N = [],
                            k = Math.pow(10, _);
                        for (let _ = 0, F = this.vertices.length; _ < F; _++) {
                            let F = this.vertices[_],
                                U = Math.round(F.x * k) + "_" + Math.round(F.y * k) + "_" + Math.round(F.z * k);
                            void 0 === O[U] ? (O[U] = _, B.push(this.vertices[_]), N[_] = B.length - 1) : N[_] = N[O[U]]
                        }
                        let F = [];
                        for (let _ = 0, O = this.faces.length; _ < O; _++) {
                            let O = this.faces[_];
                            O.a = N[O.a], O.b = N[O.b], O.c = N[O.c];
                            let B = [O.a, O.b, O.c];
                            for (let O = 0; O < 3; O++)
                                if (B[O] === B[(O + 1) % 3]) {
                                    F.push(_);
                                    break
                                }
                        }
                        for (let _ = F.length - 1; _ >= 0; _--) {
                            let O = F[_];
                            this.faces.splice(O, 1);
                            for (let _ = 0, B = this.faceVertexUvs.length; _ < B; _++) this.faceVertexUvs[_].splice(O, 1)
                        }
                        let U = this.vertices.length - B.length;
                        return this.vertices = B, U
                    }
                    setFromPoints(_) {
                        this.vertices = [];
                        for (let O = 0, B = _.length; O < B; O++) {
                            let B = _[O];
                            this.vertices.push(new rv(B.x, B.y, B.z || 0))
                        }
                        return this
                    }
                    sortFacesByMaterialIndex() {
                        let _ = this.faces,
                            O = _.length;
                        for (let B = 0; B < O; B++) _[B]._id = B;
                        _.sort(function(_, O) {
                            return _.materialIndex - O.materialIndex
                        });
                        let B = this.faceVertexUvs[0],
                            N = this.faceVertexUvs[1],
                            k, F;
                        B && B.length === O && (k = []), N && N.length === O && (F = []);
                        for (let U = 0; U < O; U++) {
                            let O = _[U]._id;
                            k && k.push(B[O]), F && F.push(N[O])
                        }
                        k && (this.faceVertexUvs[0] = k), F && (this.faceVertexUvs[1] = F)
                    }
                    toJSON() {
                        let _ = {
                            metadata: {
                                version: 4.5,
                                type: "Geometry",
                                generator: "Geometry.toJSON"
                            }
                        };
                        if (_.uuid = this.uuid, _.type = this.type, "" !== this.name && (_.name = this.name), void 0 !== this.parameters) {
                            let O = this.parameters;
                            for (let B in O) void 0 !== O[B] && (_[B] = O[B]);
                            return _
                        }
                        let O = [];
                        for (let _ = 0; _ < this.vertices.length; _++) {
                            let B = this.vertices[_];
                            O.push(B.x, B.y, B.z)
                        }
                        let B = [],
                            N = [],
                            k = {},
                            F = [],
                            U = {},
                            j = [],
                            G = {};
                        for (let _ = 0; _ < this.faces.length; _++) {
                            let O = this.faces[_],
                                N = void 0 !== this.faceVertexUvs[0][_],
                                k = O.normal.length() > 0,
                                F = O.vertexNormals.length > 0,
                                U = 1 !== O.color.r || 1 !== O.color.g || 1 !== O.color.b,
                                j = O.vertexColors.length > 0,
                                G = 0;
                            if (G = c(0, 0, 0), G = c(G, 1, !0), G = c(G, 2, !1), G = c(G, 3, N), G = c(G, 4, k), G = c(G, 5, F), G = c(G, 6, U), G = c(G, 7, j), B.push(G), B.push(O.a, O.b, O.c), B.push(O.materialIndex), N) {
                                let O = this.faceVertexUvs[0][_];
                                B.push(f(O[0]), f(O[1]), f(O[2]))
                            }
                            if (k && B.push(h(O.normal)), F) {
                                let _ = O.vertexNormals;
                                B.push(h(_[0]), h(_[1]), h(_[2]))
                            }
                            if (U && B.push(d(O.color)), j) {
                                let _ = O.vertexColors;
                                B.push(d(_[0]), d(_[1]), d(_[2]))
                            }
                        }

                        function c(_, O, B) {
                            return B ? _ | 1 << O : _ & ~(1 << O)
                        }

                        function h(_) {
                            let O = _.x.toString() + _.y.toString() + _.z.toString();
                            return void 0 !== k[O] || (k[O] = N.length / 3, N.push(_.x, _.y, _.z)), k[O]
                        }

                        function d(_) {
                            let O = _.r.toString() + _.g.toString() + _.b.toString();
                            return void 0 !== U[O] || (U[O] = F.length, F.push(_.getHex())), U[O]
                        }

                        function f(_) {
                            let O = _.x.toString() + _.y.toString();
                            return void 0 !== G[O] || (G[O] = j.length / 2, j.push(_.x, _.y)), G[O]
                        }
                        return _.data = {}, _.data.vertices = O, _.data.normals = N, F.length > 0 && (_.data.colors = F), j.length > 0 && (_.data.uvs = [j]), _.data.faces = B, _
                    }
                    clone() {
                        return new yF().copy(this)
                    }
                    copy(_) {
                        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = _.name;
                        let O = _.vertices;
                        for (let _ = 0, B = O.length; _ < B; _++) this.vertices.push(O[_].clone());
                        let B = _.colors;
                        for (let _ = 0, O = B.length; _ < O; _++) this.colors.push(B[_].clone());
                        let N = _.faces;
                        for (let _ = 0, O = N.length; _ < O; _++) this.faces.push(N[_].clone());
                        for (let O = 0, B = _.faceVertexUvs.length; O < B; O++) {
                            let B = _.faceVertexUvs[O];
                            void 0 === this.faceVertexUvs[O] && (this.faceVertexUvs[O] = []);
                            for (let _ = 0, N = B.length; _ < N; _++) {
                                let N = B[_],
                                    k = [];
                                for (let _ = 0, O = N.length; _ < O; _++) {
                                    let O = N[_];
                                    k.push(O.clone())
                                }
                                this.faceVertexUvs[O].push(k)
                            }
                        }
                        let k = _.morphTargets;
                        for (let _ = 0, O = k.length; _ < O; _++) {
                            let O = {};
                            if (O.name = k[_].name, void 0 !== k[_].vertices) {
                                O.vertices = [];
                                for (let B = 0, N = k[_].vertices.length; B < N; B++) O.vertices.push(k[_].vertices[B].clone())
                            }
                            if (void 0 !== k[_].normals) {
                                O.normals = [];
                                for (let B = 0, N = k[_].normals.length; B < N; B++) O.normals.push(k[_].normals[B].clone())
                            }
                            this.morphTargets.push(O)
                        }
                        let F = _.morphNormals;
                        for (let _ = 0, O = F.length; _ < O; _++) {
                            let O = {};
                            if (void 0 !== F[_].vertexNormals) {
                                O.vertexNormals = [];
                                for (let B = 0, N = F[_].vertexNormals.length; B < N; B++) {
                                    let N = F[_].vertexNormals[B],
                                        k = {};
                                    k.a = N.a.clone(), k.b = N.b.clone(), k.c = N.c.clone(), O.vertexNormals.push(k)
                                }
                            }
                            if (void 0 !== F[_].faceNormals) {
                                O.faceNormals = [];
                                for (let B = 0, N = F[_].faceNormals.length; B < N; B++) O.faceNormals.push(F[_].faceNormals[B].clone())
                            }
                            this.morphNormals.push(O)
                        }
                        let U = _.skinWeights;
                        for (let _ = 0, O = U.length; _ < O; _++) this.skinWeights.push(U[_].clone());
                        let j = _.skinIndices;
                        for (let _ = 0, O = j.length; _ < O; _++) this.skinIndices.push(j[_].clone());
                        let G = _.lineDistances;
                        for (let _ = 0, O = G.length; _ < O; _++) this.lineDistances.push(G[_]);
                        let Y = _.boundingBox;
                        null !== Y && (this.boundingBox = Y.clone());
                        let Q = _.boundingSphere;
                        return null !== Q && (this.boundingSphere = Q.clone()), this.elementsNeedUpdate = _.elementsNeedUpdate, this.verticesNeedUpdate = _.verticesNeedUpdate, this.uvsNeedUpdate = _.uvsNeedUpdate, this.normalsNeedUpdate = _.normalsNeedUpdate, this.colorsNeedUpdate = _.colorsNeedUpdate, this.lineDistancesNeedUpdate = _.lineDistancesNeedUpdate, this.groupsNeedUpdate = _.groupsNeedUpdate, this
                    }
                    toBufferGeometry() {
                        let _ = new yU().fromGeometry(this),
                            O = new sK,
                            B = new Float32Array(3 * _.vertices.length);
                        if (O.setAttribute("position", Ev.call(new sF(B, 3), _.vertices)), _.normals.length > 0) {
                            let B = new Float32Array(3 * _.normals.length);
                            O.setAttribute("normal", Ev.call(new sF(B, 3), _.normals))
                        }
                        if (_.colors.length > 0) {
                            let B = new Float32Array(3 * _.colors.length);
                            O.setAttribute("color", ED.call(new sF(B, 3), _.colors))
                        }
                        if (_.uvs.length > 0) {
                            let B = new Float32Array(2 * _.uvs.length);
                            O.setAttribute("uv", MD.call(new sF(B, 2), _.uvs))
                        }
                        if (_.uvs2.length > 0) {
                            let B = new Float32Array(2 * _.uvs2.length);
                            O.setAttribute("uv2", MD.call(new sF(B, 2), _.uvs2))
                        }
                        for (let B in O.groups = _.groups, _.morphTargets) {
                            let N = [],
                                k = _.morphTargets[B];
                            for (let _ = 0, O = k.length; _ < O; _++) {
                                let O = k[_],
                                    B = new sG(3 * O.data.length, 3);
                                B.name = O.name, N.push(Ev.call(B, O.data))
                            }
                            O.morphAttributes[B] = N
                        }
                        if (_.skinIndices.length > 0) {
                            let B = new sG(4 * _.skinIndices.length, 4);
                            O.setAttribute("skinIndex", TD.call(B, _.skinIndices))
                        }
                        if (_.skinWeights.length > 0) {
                            let B = new sG(4 * _.skinWeights.length, 4);
                            O.setAttribute("skinWeight", TD.call(B, _.skinWeights))
                        }
                        return null !== _.boundingSphere && (O.boundingSphere = _.boundingSphere.clone()), null !== _.boundingBox && (O.boundingBox = _.boundingBox.clone()), O
                    }
                    computeTangents() {
                        console.error("THREE.Geometry: .computeTangents() has been removed.")
                    }
                    computeLineDistances() {
                        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                    }
                    applyMatrix(_) {
                        return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(_)
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    static createBufferGeometryFromObject(_) {
                        let O = new sK,
                            B = _.geometry;
                        if (_.isPoints || _.isLine) {
                            let _ = new sG(3 * B.vertices.length, 3),
                                N = new sG(3 * B.colors.length, 3);
                            if (O.setAttribute("position", Ev.call(_, B.vertices)), O.setAttribute("color", ED.call(N, B.colors)), B.lineDistances && B.lineDistances.length === B.vertices.length) {
                                let _ = new sG(B.lineDistances.length, 1);
                                O.setAttribute("lineDistance", q8.call(_, B.lineDistances))
                            }
                            null !== B.boundingSphere && (O.boundingSphere = B.boundingSphere.clone()), null !== B.boundingBox && (O.boundingBox = B.boundingBox.clone())
                        } else _.isMesh && (O = B.toBufferGeometry());
                        return O
                    }
                };
            yF.prototype.isGeometry = !0;
            var yU = class {
                    constructor() {
                        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
                    }
                    computeGroups(_) {
                        let O = [],
                            B, N, k, F = _.faces;
                        for (N = 0; N < F.length; N++) {
                            let _ = F[N];
                            _.materialIndex !== k && (k = _.materialIndex, void 0 !== B && (B.count = 3 * N - B.start, O.push(B)), B = {
                                start: 3 * N,
                                materialIndex: k
                            })
                        }
                        void 0 !== B && (B.count = 3 * N - B.start, O.push(B)), this.groups = O
                    }
                    fromGeometry(_) {
                        let O = _.faces,
                            B = _.vertices,
                            N = _.faceVertexUvs,
                            k = N[0] && N[0].length > 0,
                            F = N[1] && N[1].length > 0,
                            U = _.morphTargets,
                            j = U.length,
                            G;
                        if (j > 0) {
                            G = [];
                            for (let _ = 0; _ < j; _++) G[_] = {
                                name: U[_].name,
                                data: []
                            };
                            this.morphTargets.position = G
                        }
                        let Y = _.morphNormals,
                            Q = Y.length,
                            K;
                        if (Q > 0) {
                            K = [];
                            for (let _ = 0; _ < Q; _++) K[_] = {
                                name: Y[_].name,
                                data: []
                            };
                            this.morphTargets.normal = K
                        }
                        let $ = _.skinIndices,
                            ee = _.skinWeights,
                            et = $.length === B.length,
                            ei = ee.length === B.length;
                        B.length > 0 && 0 === O.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                        for (let _ = 0; _ < O.length; _++) {
                            let er = O[_];
                            this.vertices.push(B[er.a], B[er.b], B[er.c]);
                            let ea = er.vertexNormals;
                            if (3 === ea.length) this.normals.push(ea[0], ea[1], ea[2]);
                            else {
                                let _ = er.normal;
                                this.normals.push(_, _, _)
                            }
                            let en = er.vertexColors;
                            if (3 === en.length) this.colors.push(en[0], en[1], en[2]);
                            else {
                                let _ = er.color;
                                this.colors.push(_, _, _)
                            }
                            if (!0 === k) {
                                let O = N[0][_];
                                void 0 !== O ? this.uvs.push(O[0], O[1], O[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", _), this.uvs.push(new iJ, new iJ, new iJ))
                            }
                            if (!0 === F) {
                                let O = N[1][_];
                                void 0 !== O ? this.uvs2.push(O[0], O[1], O[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", _), this.uvs2.push(new iJ, new iJ, new iJ))
                            }
                            for (let _ = 0; _ < j; _++) {
                                let O = U[_].vertices;
                                G[_].data.push(O[er.a], O[er.b], O[er.c])
                            }
                            for (let O = 0; O < Q; O++) {
                                let B = Y[O].vertexNormals[_];
                                K[O].data.push(B.a, B.b, B.c)
                            }
                            et && this.skinIndices.push($[er.a], $[er.b], $[er.c]), ei && this.skinWeights.push(ee[er.a], ee[er.b], ee[er.c])
                        }
                        return this.computeGroups(_), this.verticesNeedUpdate = _.verticesNeedUpdate, this.normalsNeedUpdate = _.normalsNeedUpdate, this.colorsNeedUpdate = _.colorsNeedUpdate, this.uvsNeedUpdate = _.uvsNeedUpdate, this.groupsNeedUpdate = _.groupsNeedUpdate, null !== _.boundingSphere && (this.boundingSphere = _.boundingSphere.clone()), null !== _.boundingBox && (this.boundingBox = _.boundingBox.clone()), this
                    }
                },
                yj = class {
                    constructor(_, O, B, N, k, F = 0) {
                        this.a = _, this.b = O, this.c = B, this.normal = N && N.isVector3 ? N : new rv, this.vertexNormals = Array.isArray(N) ? N : [], this.color = k && k.isColor ? k : new re, this.vertexColors = Array.isArray(k) ? k : [], this.materialIndex = F
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(_) {
                        this.a = _.a, this.b = _.b, this.c = _.c, this.normal.copy(_.normal), this.color.copy(_.color), this.materialIndex = _.materialIndex;
                        for (let O = 0, B = _.vertexNormals.length; O < B; O++) this.vertexNormals[O] = _.vertexNormals[O].clone();
                        for (let O = 0, B = _.vertexColors.length; O < B; O++) this.vertexColors[O] = _.vertexColors[O].clone();
                        return this
                    }
                };

            function q8(_) {
                return this.array.set(_), this
            }

            function ED(_) {
                let O = this.array,
                    B = 0;
                for (let N = 0, k = _.length; N < k; N++) {
                    let k = _[N];
                    void 0 === k && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", N), k = new re), O[B++] = k.r, O[B++] = k.g, O[B++] = k.b
                }
                return this
            }

            function MD(_) {
                let O = this.array,
                    B = 0;
                for (let N = 0, k = _.length; N < k; N++) {
                    let k = _[N];
                    void 0 === k && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", N), k = new iJ), O[B++] = k.x, O[B++] = k.y
                }
                return this
            }

            function Ev(_) {
                let O = this.array,
                    B = 0;
                for (let N = 0, k = _.length; N < k; N++) {
                    let k = _[N];
                    void 0 === k && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", N), k = new rv), O[B++] = k.x, O[B++] = k.y, O[B++] = k.z
                }
                return this
            }

            function TD(_) {
                let O = this.array,
                    B = 0;
                for (let N = 0, k = _.length; N < k; N++) {
                    let k = _[N];
                    void 0 === k && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", N), k = new rl), O[B++] = k.x, O[B++] = k.y, O[B++] = k.z, O[B++] = k.w
                }
                return this
            }
            var yG = ["a", "b", "c"];

            function QS(_, O, B) {
                let N = Math.min(_, O),
                    k = Math.max(_, O);
                return B.get(N + "_" + k)
            }

            function KS(_, O, B, N, k, F) {
                let U = Math.min(_, O),
                    j = Math.max(_, O),
                    G = U + "_" + j,
                    Y;
                N.has(G) ? Y = N.get(G) : (Y = {
                    a: B[U],
                    b: B[j],
                    newEdge: null,
                    faces: []
                }, N.set(G, Y)), Y.faces.push(k), F[_].edges.push(Y), F[O].edges.push(Y)
            }

            function Mv(_, O, B, N, k) {
                _.push(new yj(O, B, N, void 0, void 0, k))
            }

            function ed(_, O) {
                return Math.abs(O - _) / 2 + Math.min(_, O)
            }

            function Tv(_, O, B, N) {
                _.push([O.clone(), B.clone(), N.clone()])
            }
            var yH = class {
                    constructor(_ = 1) {
                        this.subdivisions = _
                    }
                    modify(_) {
                        (_ = _ instanceof sK ? new yF().fromBufferGeometry(_) : _.clone()).mergeVertices();
                        let O = this.subdivisions;
                        for (; O-- > 0;) this._smooth(_);
                        return _.computeFaceNormals(), _.computeVertexNormals(), _
                    }
                    _smooth(_) {
                        let O = new rv,
                            B, N, k, F, U, j = _.vertices,
                            G = _.faces,
                            Y = _.faceVertexUvs[0],
                            Q = void 0 !== Y && Y.length > 0,
                            K = [],
                            $ = new Map;
                        ! function(_, O, B, N) {
                            let k, F, U;
                            for (k = 0, F = _.length; k < F; k++) B[k] = {
                                edges: []
                            };
                            for (k = 0, F = O.length; k < F; k++) KS((U = O[k]).a, U.b, _, N, U, B), KS(U.b, U.c, _, N, U, B), KS(U.c, U.a, _, N, U, B)
                        }(j, G, K, $);
                        let ee = [],
                            et, ei, er, ea, en, eo, el;
                        for (let _ of Array.from($.keys())) {
                            for (ei = $.get(_), er = new rv, en = 3 / 8, eo = 1 / 8, 2 != (el = ei.faces.length) && (en = .5, eo = 0), er.addVectors(ei.a, ei.b).multiplyScalar(en), O.set(0, 0, 0), F = 0; F < el; F++) {
                                for (ea = ei.faces[F], U = 0; U < 3 && !((et = j[function(_, O) {
                                        switch (O) {
                                            case "c":
                                                return _.c;
                                            case "b":
                                                return _.b;
                                            default:
                                                return _.a
                                        }
                                    }(ea, yG[U])]) !== ei.a && et !== ei.b); U++);
                                et && O.add(et)
                            }
                            O.multiplyScalar(eo), er.add(O), ei.newEdge = ee.length, ee.push(er)
                        }
                        let eh, ec, eu, ep, ef, em, eg, ev = [];
                        for (N = 0, k = j.length; N < k; N++) {
                            for (em = j[N], 3 == (B = (ef = K[N].edges).length) ? eh = 3 / 16 : B > 3 && (eh = 3 / (8 * B)), ec = 1 - B * Number(eh), eu = eh, B <= 2 && 2 == B && (ec = 3 / 4, eu = 1 / 8), eg = em.clone().multiplyScalar(ec), O.set(0, 0, 0), F = 0; F < B; F++) et = (ep = ef[F]).a !== em ? ep.a : ep.b, O.add(et);
                            O.multiplyScalar(Number(eu)), eg.add(O), ev.push(eg)
                        }
                        let ex = ev.concat(ee),
                            eb = ev.length,
                            e_, eS, eA, eM = [],
                            eE = [],
                            eC, eT, eD, eP, eI = new iJ,
                            eO = new iJ,
                            eL = new iJ;
                        for (N = 0, k = G.length; N < k; N++) Mv(eM, e_ = Number(QS((ea = G[N]).a, ea.b, $).newEdge) + eb, eS = Number(QS(ea.b, ea.c, $).newEdge) + eb, eA = Number(QS(ea.c, ea.a, $).newEdge) + eb, ea.materialIndex), Mv(eM, ea.a, e_, eA, ea.materialIndex), Mv(eM, ea.b, eS, e_, ea.materialIndex), Mv(eM, ea.c, eA, eS, ea.materialIndex), Q && (eT = (eC = Y[N])[0], eD = eC[1], eP = eC[2], eI.set(ed(eT.x, eD.x), ed(eT.y, eD.y)), eO.set(ed(eD.x, eP.x), ed(eD.y, eP.y)), eL.set(ed(eT.x, eP.x), ed(eT.y, eP.y)), Tv(eE, eI, eO, eL), Tv(eE, eT, eI, eL), Tv(eE, eD, eO, eI), Tv(eE, eP, eL, eO));
                        _.vertices = ex, _.faces = eM, Q && (_.faceVertexUvs[0] = eE)
                    }
                },
                yW = new rv,
                yY = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = _.geometry ? ? O ? .geometry ? ? new sK().copy(new ai(100, 100, 100)),
                            N;
                        void 0 === O ? (B.computeBoundingBox(), B.boundingBox.getSize(yW), N = {
                            width: yW.x,
                            height: yW.y,
                            depth: yW.z,
                            subdivisions: 0
                        }) : N = O.parameters;
                        let k = { ...N,
                            ..._.parameters
                        };
                        return {
                            parameters: {
                                width: Math.abs(k.width),
                                height: Math.abs(k.height),
                                depth: Math.abs(k.depth),
                                subdivisions: Math.abs(k.subdivisions)
                            },
                            geometry: B
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            subdivisions: k
                        } = _.parameters, F = _.geometry ? ? new sK().copy(new ai(100, 100, 100)), U = F.userData.parameters;
                        void 0 === U ? (F.computeBoundingBox(), F.boundingBox.getSize(yW)) : yW.set(U.width, U.height, U.depth), (O !== yW.x || B !== yW.y || N !== yW.z) && F.scale(0 === yW.x ? 1 : O / yW.x, 0 === yW.y ? 1 : B / yW.y, 0 === yW.z ? 1 : N / yW.z);
                        let j = F.originalGeometry;
                        try {
                            k > 0 ? (void 0 === j || U ? .subdivisions !== k) && (void 0 === j && (j = F), F = new yH(k).modify(j).toBufferGeometry()) : (void 0 !== j && (F = j), j = void 0, void 0 === F.getAttribute("normal") && F.computeVertexNormals())
                        } catch {
                            void 0 !== j && (F = j), j = void 0, void 0 === F.getAttribute("normal") && F.computeVertexNormals()
                        }
                        return void 0 !== j && Object.assign(F, {
                            originalGeometry: j
                        }), delete _.geometry, Object.assign(F, {
                            userData: { ..._,
                                type: "NonParametricGeometry"
                            }
                        })
                    }
                    static loadFromUrl(_, O, B) {
                        new lr(B).load(_, _ => {
                            let B = this.normalizeInputs({
                                geometry: _
                            });
                            _.boundingBox.getSize(yW);
                            let N = 100 / yW.x;
                            Object.assign(B.parameters, {
                                width: 100,
                                height: yW.y * N,
                                depth: yW.z * N
                            }), O(this.build(B))
                        })
                    }
                },
                yX = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            depth: 0,
                            spikes: 5,
                            cornerRadius: 0,
                            extrudeBevelSize: 0,
                            extrudeBevelSegments: 3
                        }, _.parameters);
                        return {
                            shape: _.shape && _.shape instanceof ys ? _.shape : new ys,
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? 0)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            spikes: N,
                            cornerRadius: k,
                            depth: F,
                            extrudeBevelSize: U,
                            extrudeBevelSegments: j
                        } = _.parameters, G = _.shape, Y = .5 * O, Q = .5 * B, K = 2 * Math.PI / N;
                        for (let _ = 0; _ < N; _++) {
                            let O = K * _,
                                B = 0 + Math.sin(O) * Y,
                                N = 0 + Math.cos(O) * Q;
                            G.addPoint(G.createPoint(B, N))
                        }
                        G.isClosed = !0;
                        for (let _ = 0, O = G.points.length; _ < O; _++) G.points[_].roundness = k;
                        return G.roundness = k, G.update(), Object.assign(yA.create({
                            shape: G,
                            parameters: {
                                roundness: k,
                                depth: F,
                                extrudeBevelSize: U,
                                extrudeBevelSegments: j
                            }
                        }), {
                            userData: { ..._,
                                type: "PolygonGeometry"
                            }
                        })
                    }
                },
                yQ = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            radialSegments: 4,
                            heightSegments: 1,
                            cornerRadius: 0,
                            cornerSegments: 8,
                            openEnded: !1
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            radialSegments: k,
                            heightSegments: F,
                            openEnded: U,
                            cornerRadius: j,
                            cornerSegments: G
                        } = _.parameters, Y = new yZ(.5 * O, B, k, F, U, j, G);
                        return Y.scale(1, 1, N / O), Object.assign(Y, {
                            userData: { ..._,
                                type: "PyramidGeometry"
                            }
                        })
                    }
                };

            function Rp(_, O, B) {
                B.x = _.x * O.x, B.y = _.y, B.z = _.x * O.y
            }

            function ZS(_, O, B, N, k, F) {
                let U = O.clone().sub(_),
                    j = B.clone().sub(_),
                    G = U.angleTo(j);
                if (U.normalize(), j.normalize(), N === k) {
                    let O = U.add(j).normalize();
                    F.copy(_).addScaledVector(O, N / Math.sin(G / 2))
                } else {
                    let O = U.angleTo(j);
                    F.copy(_), F.addScaledVector(U, k / Math.sin(O)), F.addScaledVector(j, N / Math.sin(O))
                }
            }
            var yZ = class extends sK {
                    constructor(_ = .5, O = 1, B = 4, N = 1, k = !1, F = 0, U = 4) {
                        let j;
                        super(), B = Math.floor(Math.max(3, B)), N = Math.floor(N), U = Math.floor(U);
                        let G = [],
                            Y = [],
                            Q = [],
                            K = [],
                            $ = 0,
                            ee = O / 2,
                            et = Math.PI / B,
                            ei = _ * Math.cos(Math.PI / B),
                            er = 2 * Math.PI / B,
                            ea = Math.PI - (B - 2) * Math.PI / B,
                            en = new rv(0, -ee, 0),
                            eo = new rv(0, ee, 0),
                            el = new iJ(_, -ee),
                            eh = new iJ(ei, -ee),
                            ec = new iJ(0, eo.y).sub(eh),
                            eu = new iJ(0, eo.y).sub(el),
                            ep = new iJ(ec.y, -ec.x).normalize(),
                            ef = new iJ(eu.y, -eu.x).normalize();
                        F = Math.min(F, _ * Math.cos(Math.PI / B) * Math.tan((Math.PI - ec.angle()) / 2) - 1e-8); {
                            let _ = new rv(ep.x, ep.y, 0),
                                O = new rv(Math.cos(er) * _.x, _.y, Math.sin(er) * _.x);
                            j = _.angleTo(O)
                        }
                        let em = F / Math.tan((Math.PI - ec.angle()) / 2),
                            eg = F / Math.tan((Math.PI - j) / 2),
                            ev = new rv;
                        if (!k) {
                            Y.push(en.x, en.y, en.z), Q.push(0, -1, 0), K.push(0, 0);
                            let _ = $++,
                                O = [],
                                N = el.clone(),
                                k = em / Math.cos(Math.PI / B);
                            N.x -= k;
                            for (let _ = 0; _ < B; _++) {
                                let k = _ / B * Math.PI * 2 + et;
                                Rp(N, new iJ(Math.sin(k), Math.cos(k)), ev), Y.push(ev.x, ev.y, ev.z), Q.push(0, -1, 0), K.push(0, 0), O.push($++)
                            }
                            for (let B = 0; B < O.length; B++) G.push(O[B], _, O[(B + 1) % O.length])
                        }
                        let ex = []; {
                            let _ = new rv,
                                O = new rv,
                                N = new rv,
                                k = new rv,
                                ee = new rv,
                                ei = new rv;
                            for (let er = 0; er < B; er++) {
                                let eh = er / B * Math.PI * 2 + et,
                                    ev = (er + .5) / B * Math.PI * 2 + et,
                                    eb = (er + 1) / B * Math.PI * 2 + et,
                                    e_ = new iJ(Math.sin(eh), Math.cos(eh)),
                                    eS = new iJ(Math.sin(ev), Math.cos(ev)),
                                    eA = new iJ(Math.sin(eb), Math.cos(eb));
                                Rp(el, e_, O), Rp(el, eA, N), Rp(ep, eS, _), ZS(eo, O, N, eg, eg, k), Y.push(k.x, k.y, k.z), ZS(O, eo, N, eg, em, ee), Y.push(ee.x, ee.y, ee.z), ZS(N, O, eo, em, eg, ei), Y.push(ei.x, ei.y, ei.z), Q.push(_.x, _.y, _.z), Q.push(_.x, _.y, _.z), Q.push(_.x, _.y, _.z), K.push(0, 0), K.push(0, 0), K.push(0, 0);
                                let eM = $++,
                                    eE = $++,
                                    eC = $++;
                                if (G.push(eM, eE, eC), F > 0) {
                                    let et, er; {
                                        let _ = O.clone().add(N).multiplyScalar(.5),
                                            B = eo.clone().sub(_).normalize(),
                                            k = en.clone().sub(_).normalize().add(B).normalize().multiplyScalar(-1);
                                        V(_, ei.clone().sub(ee), k, ec.angle())
                                    } {
                                        let _ = new rv;
                                        Rp(ef, eA, _);
                                        let O = ei.clone().add(k).multiplyScalar(.5);
                                        O = function(_, O, B) {
                                            let N = _.clone().sub(O),
                                                k = B.clone().sub(O);
                                            return N.projectOnVector(k), N.add(O)
                                        }(O, N, eo);
                                        let B = ei.clone().sub(k);
                                        [et, er] = V(O, B, _, j, k.y)
                                    } {
                                        let _ = et,
                                            O = _.clone().setY(0).normalize(),
                                            B = new rv(0, -1, 0),
                                            N = O.clone().cross(B);
                                        ! function(_, O, B, N) {
                                            let k = Math.PI / 2,
                                                j = eu.angle() - k,
                                                ee = [],
                                                et = new rv,
                                                ei = new rv;
                                            for (let G = 0; G <= U; G++) {
                                                let er = [],
                                                    en = G / U;
                                                for (let U = 0; U <= G; U++) {
                                                    let ee = ((G ? U / G : 0) - .5) * ea,
                                                        eo = Math.cos(ee),
                                                        el = Math.sin(ee),
                                                        eh = (k + Math.atan(Math.tan(j) * eo)) * en,
                                                        ec = Math.cos(eh),
                                                        eu = Math.sin(eh);
                                                    et.set(0, 0, 0), et.addScaledVector(O, eu * eo), et.addScaledVector(B, ec), et.addScaledVector(N, eu * el), ei.copy(_).addScaledVector(et, F), Y.push(ei.x, ei.y, ei.z), Q.push(et.x, et.y, et.z), K.push(0, 0), er.push($++)
                                                }
                                                ee.push(er)
                                            }
                                            let er = ee.length - 1;
                                            for (let _ = 0; _ < er; _++) {
                                                let O = ee[_],
                                                    B = ee[_ + 1],
                                                    N = O.length - 1;
                                                G.push(O[0], B[1], B[0]);
                                                for (let _ = 1; _ <= N; _++) G.push(O[_ - 1], O[_], B[_]), G.push(O[_], B[_ + 1], B[_])
                                            }
                                        }(_, O, B, N)
                                    }
                                    ex.concat(er); {
                                        let O = ec.angle(),
                                            N = Math.PI - O,
                                            k = eo.clone();
                                        k.y -= F / Math.sin(O - Math.PI / 2);
                                        let j = new rv,
                                            ee = [];
                                        for (let O = 0; O < U; O++) {
                                            let G = [],
                                                et = Math.PI / 2 - N * O / U,
                                                ei = Math.cos(et),
                                                er = Math.sin(et),
                                                ea = ev;
                                            for (let N = 0; N <= O; N++) {
                                                let N = Math.cos(ea),
                                                    U = Math.sin(ea);
                                                _.x = ei * U, _.y = er, _.z = ei * N, j.copy(k).addScaledVector(_, F), Y.push(j.x, j.y, j.z), Q.push(_.x, _.y, _.z), K.push(0, 0), G.push($++), ea += 2 * Math.PI / O / B
                                            }
                                            ee.push(G)
                                        }
                                        er.reverse(), ee.push(er);
                                        let et = ee.length - 1;
                                        for (let _ = 0; _ < et; _++) {
                                            let O = ee[_],
                                                B = ee[_ + 1],
                                                N = O.length - 1;
                                            G.push(B[1], O[0], B[0]);
                                            for (let _ = 1; _ <= N; _++) G.push(O[_], O[_ - 1], B[_]), G.push(B[_ + 1], O[_], B[_])
                                        }
                                    }
                                }
                            }
                        }

                        function V(_, O, B, N, k) {
                            let j = -N / 2,
                                ee = (Math.PI - N) / 2,
                                et = O.clone().normalize().cross(B);
                            _.addScaledVector(B, -F / Math.sin(ee));
                            let ei = new rv,
                                er = new rv,
                                ea = $,
                                en = [];
                            for (let G = 0; G <= U; G++) {
                                let ee = j + G / U * N;
                                er.set(0, 0, 0), er.addScaledVector(et, Math.sin(ee)), er.addScaledVector(B, Math.cos(ee));
                                for (let B = 0; B <= 1; B++) {
                                    let N = B / 1 - .5;
                                    if (ei.copy(_), ei.addScaledVector(O, N), ei.addScaledVector(er, F), null != k) {
                                        let _ = Math.max(0, ei.y - k);
                                        ei.addScaledVector(O, -_ / O.y)
                                    }
                                    Y.push(ei.x, ei.y, ei.z), Q.push(er.x, er.y, er.z), K.push(0, 0), 0 === B && en.push($), $++
                                }
                            }
                            for (let _ = 0; _ < U; _++)
                                for (let O = 0; O < 1; O++) {
                                    let B = ea + O + 2 * _,
                                        N = B + 2,
                                        k = N + 1,
                                        F = B + 1;
                                    G.push(B, N, F), G.push(N, k, F)
                                }
                            return [_.clone().addScaledVector(O, .5), en]
                        }
                        this.setIndex(G), this.setAttribute("position", new sG(Y, 3)), this.setAttribute("normal", new sG(Q, 3)), this.setAttribute("uv", new sG(K, 2))
                    }
                },
                yK = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                                width: 100,
                                depth: 0,
                                cornerRadius: [0, 0, 0, 0],
                                cornerType: 1,
                                extrudeBevelSize: 0,
                                extrudeBevelSegments: 1
                            }, _.parameters),
                            N = Object.assign(O ? .ui ? ? {
                                enabledIndieCorners: !1
                            }, _.ui);
                        return {
                            shape: _.shape && _.shape instanceof ys ? _.shape : new ys,
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? 0)
                            }),
                            ui: N
                        }
                    }
                    static build(_) {
                        let O = _.shape,
                            {
                                width: B,
                                height: N,
                                cornerRadius: k,
                                cornerType: F,
                                depth: U,
                                extrudeBevelSize: j,
                                extrudeBevelSegments: G
                            } = _.parameters,
                            Y = {
                                x: .5 * B,
                                y: .5 * N
                            },
                            Q = {
                                x: -Y.x,
                                y: -Y.y
                            },
                            K = {
                                x: Y.x,
                                y: Y.y
                            };

                        function d(_, O, k) {
                            return O > B && k > N ? Math.min(_ * B / O, _ * N / k) : O > B ? _ * B / O : k > N ? _ * N / k : _
                        }
                        let $ = [];
                        $[0] = 0 === k[0] ? 0 : d(k[0], k[0] + k[3], k[0] + k[1]), $[1] = 0 === k[1] ? 0 : d(k[1], k[1] + k[2], k[1] + k[0]), $[2] = 0 === k[2] ? 0 : d(k[2], k[2] + k[1], k[2] + k[3]), $[3] = 0 === k[3] ? 0 : d(k[3], k[3] + k[0], k[3] + k[2]);
                        let ee = Q.x,
                            et = K.x,
                            ei = K.y,
                            er = Q.y;
                        O.addPoint(O.createPoint(ee, ei)), O.addPoint(O.createPoint(et, ei)), O.addPoint(O.createPoint(et, er)), O.addPoint(O.createPoint(ee, er)), O.isClosed = !0;
                        let ea = !0;
                        for (let _ = 0, B = O.points.length; _ < B; _++) O.points[_].roundness = $[_], _ > 0 && $[_] !== $[_ - 1] && (ea = !1);
                        return ea && (O.roundness = $[0]), O.useCubicForRoundedCorners = 1 !== F, O.update(), Object.assign(yA.create({
                            shape: O,
                            parameters: {
                                depth: U,
                                extrudeBevelSize: j,
                                extrudeBevelSegments: G
                            }
                        }), {
                            userData: { ..._,
                                type: "RectangleGeometry"
                            }
                        })
                    }
                },
                yJ = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            widthSegments: 64,
                            heightSegments: 64,
                            phiStart: 0,
                            phiLength: 2 * Math.PI,
                            thetaStart: 0,
                            thetaLength: 180
                        }, _.parameters);
                        return B.thetaLength = iK.clamp(B.thetaLength, 0, 180), {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O = 100,
                            height: B = O,
                            depth: N = O,
                            widthSegments: k = 64,
                            heightSegments: F = 64,
                            phiStart: U,
                            phiLength: j,
                            thetaStart: G,
                            thetaLength: Y
                        } = _.parameters, Q;
                        return 0 === Y ? (Q = new sK).setAttribute("position", new sG([], 3)) : Q = new oS(.5 * O, k, F, U, j, G, Y * iK.DEG2RAD), Q.scale(1, B / O, N / O), Object.assign(Q, {
                            userData: { ..._,
                                type: "SphereGeometry"
                            }
                        })
                    }
                },
                y$ = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            depth: 0,
                            widthSegments: 8,
                            heightSegments: 8
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: 0
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O = 100,
                            height: B = O,
                            widthSegments: N = 8,
                            heightSegments: k = 8
                        } = _.parameters, F = new a_(O, B, N, k);
                        return F.scale(1, 1, 1), Object.assign(F, {
                            userData: { ..._,
                                type: "PlaneGeometry"
                            }
                        })
                    }
                },
                y0 = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            angle: 90,
                            cornerRadius: 24,
                            cornerSegments: 8
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            angle: k,
                            cornerRadius: F,
                            cornerSegments: U
                        } = _.parameters;
                        return Object.assign(new y3(O, B, N, k, F, U), {
                            userData: { ..._,
                                type: "BackdropGeometry"
                            }
                        })
                    }
                },
                y3 = class extends sK {
                    constructor(_ = 1, O = 1, B = 1, N = 90, k = 10, F = 24) {
                        super(), this.type = "BackdropGeometry";
                        let U = [],
                            j = [],
                            G = [];
                        0 == k && (F = 1), F = Math.max(1, Math.floor(F)), k = Math.min(k, 100), N = Math.min(179.999, N) * (Math.PI / 180);
                        let Y = [],
                            Q = Math.PI / 2,
                            f = (_ = 0, O = 0, B = 0) => new rv(_, O, B),
                            K = f(),
                            $ = f(),
                            [ee, et, ei] = [O / 2, _ / 2, B / 2],
                            er = -et,
                            ea = +et,
                            [en, eo, el] = [f(er, -ee, +ei), f(er, -ee, -ei), f(er, +ee, -ei)],
                            b = (_, O = !1) => Math.sin(_ - Math.PI / (1 + +O)),
                            M = (_, O = !1) => Math.cos(_ - Math.PI / (1 + +O));
                        el.y = Math.sin(N) * O - ee;
                        let eh = Math.cos(N) * O - ei,
                            ec = en.z - .001;
                        N <= Q ? (el.z = Math.min(eh, ec), el.z == ec && (el.y -= (eh - ec) / Math.tan(Q - N))) : eo.z = Math.min(eo.z - eh - ei, en.z - .001), K.subVectors(en, eo), $.subVectors(el, eo);
                        let eu = Math.min(K.length(), $.length()) * k / 100,
                            ep = eu * Math.tan(N / 2),
                            ef = eu / Math.cos(N / 2),
                            em = K.clone().normalize().add($.normalize()).setLength(ef).add(eo);
                        K.set(0, b(N, !0), M(N, !0)), Y.push([el, K.clone()]);
                        let eg = (Math.PI - N) / F;
                        for (let _ = 0; _ <= F; _++) {
                            let O = Q + N + _ * eg;
                            K.set(0, Math.sin(O) * ep, Math.cos(O) * ep), K.add(em), $.set(0, b(O), M(O)), Y.push([K.clone(), $.clone()])
                        }
                        Y.push([en, f(0, 1, 0)]);
                        let ev = Math.sin(eg / 2) * ep * 2,
                            ex = Y.length - 1,
                            eb = Y[0][0].distanceTo(Y[1][0]),
                            e_ = eb + ev * F + Y[ex - 1][0].distanceTo(Y[ex][0]);
                        Y[0].push(1);
                        for (let _ = 0; _ <= F; _++) Y[_ + 1].push(1 - (eb + _ * ev) / e_);
                        Y[ex].push(0);
                        let [eS, eA, eM] = Y[0], eE, eC, eT;
                        for (let _ = 1; _ < Y.length; _++)[eE, eC, eT] = Y[_], U.push(er, eS.y, eS.z, er, eE.y, eE.z, ea, eS.y, eS.z, ea, eS.y, eS.z, er, eE.y, eE.z, ea, eE.y, eE.z), j.push(0, eA.y, eA.z, 0, eC.y, eC.z, 0, eA.y, eA.z, 0, eA.y, eA.z, 0, eC.y, eC.z, 0, eC.y, eC.z), G.push(0, eM, 0, eT, 1, eM, 1, eM, 0, eT, 1, eT), [eS, eA, eM] = [eE, eC, eT];
                        this.setAttribute("position", new sG(U, 3)), this.setAttribute("normal", new sG(j, 3)), this.setAttribute("uv", new sG(G, 2))
                    }
                },
                y4 = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            depth: 0,
                            innerRadiusPercent: 38.19,
                            spikes: 5,
                            cornerRadius: 0,
                            angle: 360,
                            extrudeBevelSize: 0,
                            extrudeBevelSegments: 1
                        }, _.parameters);
                        return {
                            shape: _.shape && _.shape instanceof ys ? _.shape : new ys,
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? 0)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            innerRadiusPercent: N,
                            spikes: k,
                            cornerRadius: F,
                            angle: U,
                            depth: j,
                            extrudeBevelSize: G,
                            extrudeBevelSegments: Y
                        } = _.parameters, Q = _.shape, K = .5 * O, $ = .5 * B, ee = U * Math.PI / 360 / k, et = -(Math.PI / 2 * 3), ei = K * N / 100, er = $ * N / 100;
                        if (3 === k && 50 === N) {
                            ee = 2 * Math.PI / k;
                            for (let _ = 0; _ < k; _++) {
                                let O = ee * _,
                                    B = 0 + Math.sin(O) * K,
                                    N = 0 + Math.cos(O) * $;
                                Q.addPoint(Q.createPoint(B, N))
                            }
                        } else
                            for (let _ = 0; _ < k; _++) {
                                let _ = 0 + Math.cos(et) * K,
                                    O = 0 + Math.sin(et) * $;
                                Q.addPoint(Q.createPoint(_, O)), et += ee, _ = 0 + Math.cos(et) * ei, O = 0 + Math.sin(et) * er, Q.addPoint(Q.createPoint(_, O)), et += ee
                            }
                        Q.isClosed = !0;
                        for (let _ = 0, O = Q.points.length; _ < O; _++) Q.points[_].roundness = F;
                        return Q.roundness = F, Q.update(), Object.assign(yA.create({
                            shape: Q,
                            parameters: {
                                roundness: F,
                                depth: j,
                                extrudeBevelSize: G,
                                extrudeBevelSegments: Y
                            }
                        }), {
                            userData: { ..._,
                                type: "StarGeometry"
                            }
                        })
                    }
                },
                y5 = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            depth: 0
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? 0)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B
                        } = _.parameters;
                        return Object.assign(new a_(O, B), {
                            userData: { ..._,
                                type: "TextFrameGeometry"
                            }
                        })
                    }
                },
                y6 = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                                width: 100,
                                radialSegments: 32,
                                tubularSegments: 64,
                                arc: 360,
                                cornerRadius: 30,
                                cornerSegments: 8
                            }, _.parameters),
                            N = Math.abs(B.width),
                            k = Math.abs(B.height ? ? B.width),
                            F = Math.round(Math.abs(B.depth ? ? .25 * B.width));
                        return {
                            parameters: Object.assign(B, {
                                width: N,
                                height: k,
                                depth: F
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            height: B,
                            depth: N,
                            radialSegments: k,
                            tubularSegments: F,
                            arc: U,
                            cornerRadius: j,
                            cornerSegments: G
                        } = _.parameters, Y = function(_, O, B, N, k, F, U, j, G, Y, Q) {
                            [O, B] = [B, O], U = O / 2;
                            let K = iK.clamp(k / 360, 0, 1);
                            if (0 === K) {
                                let _ = new sK;
                                return _.setAttribute("position", new sG([], 3)), _
                            }
                            return 1 === K && (Y = 0), new yP(!0, _, O, B, N, K, F, U, 0, G, Y, Q)
                        }(O, B, N, .5 * O, U, F, 0, 0, k, j, G);
                        return Y.scale(1, B / O, 1), Object.assign(Y, {
                            userData: { ..._,
                                type: "TorusGeometry"
                            }
                        })
                    }
                },
                y8 = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            tubularSegments: 64,
                            radialSegments: 32,
                            p: 2,
                            q: 3
                        }, _.parameters);
                        return {
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width),
                                depth: Math.abs(B.depth ? ? B.width),
                                tube: B.tube ? ? .125 * B.width
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O,
                            tube: B,
                            tubularSegments: N,
                            radialSegments: k,
                            p: F,
                            q: U
                        } = _.parameters, j = .5 * O;
                        return j !== B && (j -= B), Object.assign(new oA(j, B, N, k, F, U), {
                            userData: { ..._,
                                type: "TorusKnotGeometry"
                            }
                        })
                    }
                },
                y9 = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                            width: 100,
                            depth: 0,
                            spikes: 5,
                            cornerRadius: 0,
                            extrudeBevelSize: 0,
                            extrudeBevelSegments: 1,
                            isRect: !1
                        }, _.parameters);
                        return {
                            shape: _.shape && _.shape instanceof ys ? _.shape : new ys,
                            parameters: Object.assign(B, {
                                width: Math.abs(B.width),
                                height: Math.abs(B.height ? ? B.width * (B.isRect ? 1 : Math.sqrt(3) / 2)),
                                depth: Math.abs(B.depth ? ? 0)
                            })
                        }
                    }
                    static build(_) {
                        let {
                            width: O = 100,
                            height: B,
                            cornerRadius: N,
                            depth: k,
                            extrudeBevelSize: F,
                            extrudeBevelSegments: U,
                            isRect: j
                        } = _.parameters, G = _.shape, Y = .5 * O, Q = .5 * B;
                        j ? G.addPoint(G.createPoint(-Y, Q)) : G.addPoint(G.createPoint(0, Q)), G.addPoint(G.createPoint(Y, -Q)), G.addPoint(G.createPoint(-Y, -Q)), G.isClosed = !0;
                        for (let _ = 0, O = G.points.length; _ < O; _++) G.points[_].roundness = N;
                        return G.roundness = N, G.update(), Object.assign(yA.create({
                            shape: G,
                            parameters: {
                                roundness: N,
                                depth: k,
                                extrudeBevelSize: F,
                                extrudeBevelSegments: U
                            }
                        }), {
                            userData: { ..._,
                                type: "TriangleGeometry"
                            }
                        })
                    }
                },
                y7 = class {
                    add(_, O, B) {
                        if ("string" != typeof arguments[0])
                            for (let _ in arguments[0]) this.add(_, arguments[0][_], arguments[1]);
                        else(Array.isArray(_) ? _ : [_]).forEach(function(_) {
                            this[_] = this[_] || [], O && this[_][B ? "unshift" : "push"](O)
                        }, this)
                    }
                    run(_, O) {
                        this[_] = this[_] || [], this[_].forEach(function(_) {
                            _.call(O && O.context ? O.context : O, O)
                        })
                    }
                },
                xe = class {
                    constructor(_) {
                        this.jsep = _, this.registered = {}
                    }
                    register(..._) {
                        _.forEach(_ => {
                            if ("object" != typeof _ || !_.name || !_.init) throw Error("Invalid JSEP plugin format");
                            this.registered[_.name] || (_.init(this.jsep), this.registered[_.name] = _)
                        })
                    }
                },
                xt = class {
                    static get version() {
                        return "1.3.8"
                    }
                    static toString() {
                        return "JavaScript Expression Parser (JSEP) v" + xt.version
                    }
                    static addUnaryOp(_) {
                        return xt.max_unop_len = Math.max(_.length, xt.max_unop_len), xt.unary_ops[_] = 1, xt
                    }
                    static addBinaryOp(_, O, B) {
                        return xt.max_binop_len = Math.max(_.length, xt.max_binop_len), xt.binary_ops[_] = O, B ? xt.right_associative.add(_) : xt.right_associative.delete(_), xt
                    }
                    static addIdentifierChar(_) {
                        return xt.additional_identifier_chars.add(_), xt
                    }
                    static addLiteral(_, O) {
                        return xt.literals[_] = O, xt
                    }
                    static removeUnaryOp(_) {
                        return delete xt.unary_ops[_], _.length === xt.max_unop_len && (xt.max_unop_len = xt.getMaxKeyLen(xt.unary_ops)), xt
                    }
                    static removeAllUnaryOps() {
                        return xt.unary_ops = {}, xt.max_unop_len = 0, xt
                    }
                    static removeIdentifierChar(_) {
                        return xt.additional_identifier_chars.delete(_), xt
                    }
                    static removeBinaryOp(_) {
                        return delete xt.binary_ops[_], _.length === xt.max_binop_len && (xt.max_binop_len = xt.getMaxKeyLen(xt.binary_ops)), xt.right_associative.delete(_), xt
                    }
                    static removeAllBinaryOps() {
                        return xt.binary_ops = {}, xt.max_binop_len = 0, xt
                    }
                    static removeLiteral(_) {
                        return delete xt.literals[_], xt
                    }
                    static removeAllLiterals() {
                        return xt.literals = {}, xt
                    }
                    get char() {
                        return this.expr.charAt(this.index)
                    }
                    get code() {
                        return this.expr.charCodeAt(this.index)
                    }
                    constructor(_) {
                        this.expr = _, this.index = 0
                    }
                    static parse(_) {
                        return new xt(_).parse()
                    }
                    static getMaxKeyLen(_) {
                        return Math.max(0, ...Object.keys(_).map(_ => _.length))
                    }
                    static isDecimalDigit(_) {
                        return _ >= 48 && _ <= 57
                    }
                    static binaryPrecedence(_) {
                        return xt.binary_ops[_] || 0
                    }
                    static isIdentifierStart(_) {
                        return _ >= 65 && _ <= 90 || _ >= 97 && _ <= 122 || _ >= 128 && !xt.binary_ops[String.fromCharCode(_)] || xt.additional_identifier_chars.has(String.fromCharCode(_))
                    }
                    static isIdentifierPart(_) {
                        return xt.isIdentifierStart(_) || xt.isDecimalDigit(_)
                    }
                    throwError(_) {
                        let O = Error(_ + " at character " + this.index);
                        throw O.index = this.index, O.description = _, O
                    }
                    runHook(_, O) {
                        if (xt.hooks[_]) {
                            let B = {
                                context: this,
                                node: O
                            };
                            return xt.hooks.run(_, B), B.node
                        }
                        return O
                    }
                    searchHook(_) {
                        if (xt.hooks[_]) {
                            let O = {
                                context: this
                            };
                            return xt.hooks[_].find(function(_) {
                                return _.call(O.context, O), O.node
                            }), O.node
                        }
                    }
                    gobbleSpaces() {
                        let _ = this.code;
                        for (; _ === xt.SPACE_CODE || _ === xt.TAB_CODE || _ === xt.LF_CODE || _ === xt.CR_CODE;) _ = this.expr.charCodeAt(++this.index);
                        this.runHook("gobble-spaces")
                    }
                    parse() {
                        this.runHook("before-all");
                        let _ = this.gobbleExpressions(),
                            O = 1 === _.length ? _[0] : {
                                type: xt.COMPOUND,
                                body: _
                            };
                        return this.runHook("after-all", O)
                    }
                    gobbleExpressions(_) {
                        let O = [],
                            B, N;
                        for (; this.index < this.expr.length;)
                            if ((B = this.code) === xt.SEMCOL_CODE || B === xt.COMMA_CODE) this.index++;
                            else if (N = this.gobbleExpression()) O.push(N);
                        else if (this.index < this.expr.length) {
                            if (B === _) break;
                            this.throwError('Unexpected "' + this.char + '"')
                        }
                        return O
                    }
                    gobbleExpression() {
                        let _ = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
                        return this.gobbleSpaces(), this.runHook("after-expression", _)
                    }
                    gobbleBinaryOp() {
                        this.gobbleSpaces();
                        let _ = this.expr.substr(this.index, xt.max_binop_len),
                            O = _.length;
                        for (; O > 0;) {
                            if (xt.binary_ops.hasOwnProperty(_) && (!xt.isIdentifierStart(this.code) || this.index + _.length < this.expr.length && !xt.isIdentifierPart(this.expr.charCodeAt(this.index + _.length)))) return this.index += O, _;
                            _ = _.substr(0, --O)
                        }
                        return !1
                    }
                    gobbleBinaryExpression() {
                        let _, O, B, N, k, F, U, j, G;
                        if (!(F = this.gobbleToken()) || !(O = this.gobbleBinaryOp())) return F;
                        for (k = {
                                value: O,
                                prec: xt.binaryPrecedence(O),
                                right_a: xt.right_associative.has(O)
                            }, (U = this.gobbleToken()) || this.throwError("Expected expression after " + O), N = [F, k, U]; O = this.gobbleBinaryOp();) {
                            if (0 === (B = xt.binaryPrecedence(O))) {
                                this.index -= O.length;
                                break
                            }
                            k = {
                                value: O,
                                prec: B,
                                right_a: xt.right_associative.has(O)
                            }, G = O;
                            let c = _ => k.right_a && _.right_a ? B > _.prec : B <= _.prec;
                            for (; N.length > 2 && c(N[N.length - 2]);) U = N.pop(), O = N.pop().value, F = N.pop(), _ = {
                                type: xt.BINARY_EXP,
                                operator: O,
                                left: F,
                                right: U
                            }, N.push(_);
                            (_ = this.gobbleToken()) || this.throwError("Expected expression after " + G), N.push(k, _)
                        }
                        for (j = N.length - 1, _ = N[j]; j > 1;) _ = {
                            type: xt.BINARY_EXP,
                            operator: N[j - 1].value,
                            left: N[j - 2],
                            right: _
                        }, j -= 2;
                        return _
                    }
                    gobbleToken() {
                        let _, O, B, N;
                        if (this.gobbleSpaces(), N = this.searchHook("gobble-token")) return this.runHook("after-token", N);
                        if (_ = this.code, xt.isDecimalDigit(_) || _ === xt.PERIOD_CODE) return this.gobbleNumericLiteral();
                        if (_ === xt.SQUOTE_CODE || _ === xt.DQUOTE_CODE) N = this.gobbleStringLiteral();
                        else if (_ === xt.OBRACK_CODE) N = this.gobbleArray();
                        else {
                            for (B = (O = this.expr.substr(this.index, xt.max_unop_len)).length; B > 0;) {
                                if (xt.unary_ops.hasOwnProperty(O) && (!xt.isIdentifierStart(this.code) || this.index + O.length < this.expr.length && !xt.isIdentifierPart(this.expr.charCodeAt(this.index + O.length)))) {
                                    this.index += B;
                                    let _ = this.gobbleToken();
                                    return _ || this.throwError("missing unaryOp argument"), this.runHook("after-token", {
                                        type: xt.UNARY_EXP,
                                        operator: O,
                                        argument: _,
                                        prefix: !0
                                    })
                                }
                                O = O.substr(0, --B)
                            }
                            xt.isIdentifierStart(_) ? (N = this.gobbleIdentifier(), xt.literals.hasOwnProperty(N.name) ? N = {
                                type: xt.LITERAL,
                                value: xt.literals[N.name],
                                raw: N.name
                            } : N.name === xt.this_str && (N = {
                                type: xt.THIS_EXP
                            })) : _ === xt.OPAREN_CODE && (N = this.gobbleGroup())
                        }
                        return N ? (N = this.gobbleTokenProperty(N), this.runHook("after-token", N)) : this.runHook("after-token", !1)
                    }
                    gobbleTokenProperty(_) {
                        this.gobbleSpaces();
                        let O = this.code;
                        for (; O === xt.PERIOD_CODE || O === xt.OBRACK_CODE || O === xt.OPAREN_CODE || O === xt.QUMARK_CODE;) {
                            let B;
                            if (O === xt.QUMARK_CODE) {
                                if (this.expr.charCodeAt(this.index + 1) !== xt.PERIOD_CODE) break;
                                B = !0, this.index += 2, this.gobbleSpaces(), O = this.code
                            }
                            this.index++, O === xt.OBRACK_CODE ? (_ = {
                                type: xt.MEMBER_EXP,
                                computed: !0,
                                object: _,
                                property: this.gobbleExpression()
                            }, this.gobbleSpaces(), (O = this.code) !== xt.CBRACK_CODE && this.throwError("Unclosed ["), this.index++) : O === xt.OPAREN_CODE ? _ = {
                                type: xt.CALL_EXP,
                                arguments: this.gobbleArguments(xt.CPAREN_CODE),
                                callee: _
                            } : (O === xt.PERIOD_CODE || B) && (B && this.index--, this.gobbleSpaces(), _ = {
                                type: xt.MEMBER_EXP,
                                computed: !1,
                                object: _,
                                property: this.gobbleIdentifier()
                            }), B && (_.optional = !0), this.gobbleSpaces(), O = this.code
                        }
                        return _
                    }
                    gobbleNumericLiteral() {
                        let _ = "",
                            O, B;
                        for (; xt.isDecimalDigit(this.code);) _ += this.expr.charAt(this.index++);
                        if (this.code === xt.PERIOD_CODE)
                            for (_ += this.expr.charAt(this.index++); xt.isDecimalDigit(this.code);) _ += this.expr.charAt(this.index++);
                        if ("e" === (O = this.char) || "E" === O) {
                            for (_ += this.expr.charAt(this.index++), ("+" === (O = this.char) || "-" === O) && (_ += this.expr.charAt(this.index++)); xt.isDecimalDigit(this.code);) _ += this.expr.charAt(this.index++);
                            xt.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) || this.throwError("Expected exponent (" + _ + this.char + ")")
                        }
                        return B = this.code, xt.isIdentifierStart(B) ? this.throwError("Variable names cannot start with a number (" + _ + this.char + ")") : (B === xt.PERIOD_CODE || 1 === _.length && _.charCodeAt(0) === xt.PERIOD_CODE) && this.throwError("Unexpected period"), {
                            type: xt.LITERAL,
                            value: parseFloat(_),
                            raw: _
                        }
                    }
                    gobbleStringLiteral() {
                        let _ = "",
                            O = this.index,
                            B = this.expr.charAt(this.index++),
                            N = !1;
                        for (; this.index < this.expr.length;) {
                            let O = this.expr.charAt(this.index++);
                            if (O === B) {
                                N = !0;
                                break
                            }
                            if ("\\" === O) switch (O = this.expr.charAt(this.index++)) {
                                case "n":
                                    _ += `
`;
                                    break;
                                case "r":
                                    _ += "\r";
                                    break;
                                case "t":
                                    _ += "	";
                                    break;
                                case "b":
                                    _ += "\b";
                                    break;
                                case "f":
                                    _ += "\f";
                                    break;
                                case "v":
                                    _ += "\v";
                                    break;
                                default:
                                    _ += O
                            } else _ += O
                        }
                        return N || this.throwError('Unclosed quote after "' + _ + '"'), {
                            type: xt.LITERAL,
                            value: _,
                            raw: this.expr.substring(O, this.index)
                        }
                    }
                    gobbleIdentifier() {
                        let _ = this.code,
                            O = this.index;
                        for (xt.isIdentifierStart(_) ? this.index++ : this.throwError("Unexpected " + this.char); this.index < this.expr.length && (_ = this.code, xt.isIdentifierPart(_));) this.index++;
                        return {
                            type: xt.IDENTIFIER,
                            name: this.expr.slice(O, this.index)
                        }
                    }
                    gobbleArguments(_) {
                        let O = [],
                            B = !1,
                            N = 0;
                        for (; this.index < this.expr.length;) {
                            this.gobbleSpaces();
                            let k = this.code;
                            if (k === _) {
                                B = !0, this.index++, _ === xt.CPAREN_CODE && N && N >= O.length && this.throwError("Unexpected token " + String.fromCharCode(_));
                                break
                            }
                            if (k === xt.COMMA_CODE) {
                                if (this.index++, ++N !== O.length) {
                                    if (_ === xt.CPAREN_CODE) this.throwError("Unexpected token ,");
                                    else if (_ === xt.CBRACK_CODE)
                                        for (let _ = O.length; _ < N; _++) O.push(null)
                                }
                            } else if (O.length !== N && 0 !== N) this.throwError("Expected comma");
                            else {
                                let _ = this.gobbleExpression();
                                _ && _.type !== xt.COMPOUND || this.throwError("Expected comma"), O.push(_)
                            }
                        }
                        return B || this.throwError("Expected " + String.fromCharCode(_)), O
                    }
                    gobbleGroup() {
                        this.index++;
                        let _ = this.gobbleExpressions(xt.CPAREN_CODE);
                        if (this.code === xt.CPAREN_CODE) return this.index++, 1 === _.length ? _[0] : !!_.length && {
                            type: xt.SEQUENCE_EXP,
                            expressions: _
                        };
                        this.throwError("Unclosed (")
                    }
                    gobbleArray() {
                        return this.index++, {
                            type: xt.ARRAY_EXP,
                            elements: this.gobbleArguments(xt.CBRACK_CODE)
                        }
                    }
                };
            Object.assign(xt, {
                hooks: new y7,
                plugins: new xe(xt),
                COMPOUND: "Compound",
                SEQUENCE_EXP: "SequenceExpression",
                IDENTIFIER: "Identifier",
                MEMBER_EXP: "MemberExpression",
                LITERAL: "Literal",
                THIS_EXP: "ThisExpression",
                CALL_EXP: "CallExpression",
                UNARY_EXP: "UnaryExpression",
                BINARY_EXP: "BinaryExpression",
                ARRAY_EXP: "ArrayExpression",
                TAB_CODE: 9,
                LF_CODE: 10,
                CR_CODE: 13,
                SPACE_CODE: 32,
                PERIOD_CODE: 46,
                COMMA_CODE: 44,
                SQUOTE_CODE: 39,
                DQUOTE_CODE: 34,
                OPAREN_CODE: 40,
                CPAREN_CODE: 41,
                OBRACK_CODE: 91,
                CBRACK_CODE: 93,
                QUMARK_CODE: 63,
                SEMCOL_CODE: 59,
                COLON_CODE: 58,
                unary_ops: {
                    "-": 1,
                    "!": 1,
                    "~": 1,
                    "+": 1
                },
                binary_ops: {
                    "||": 1,
                    "&&": 2,
                    "|": 3,
                    "^": 4,
                    "&": 5,
                    "==": 6,
                    "!=": 6,
                    "===": 6,
                    "!==": 6,
                    "<": 7,
                    ">": 7,
                    "<=": 7,
                    ">=": 7,
                    "<<": 8,
                    ">>": 8,
                    ">>>": 8,
                    "+": 9,
                    "-": 9,
                    "*": 10,
                    "/": 10,
                    "%": 10
                },
                right_associative: new Set,
                additional_identifier_chars: new Set(["$", "_"]),
                literals: {
                    true: !0,
                    false: !1,
                    null: null
                },
                this_str: "this"
            }), xt.max_unop_len = xt.getMaxKeyLen(xt.unary_ops), xt.max_binop_len = xt.getMaxKeyLen(xt.binary_ops);
            var mc = _ => new xt(_).parse();
            Object.getOwnPropertyNames(xt).forEach(_ => {
                void 0 === mc[_] && "prototype" !== _ && (mc[_] = xt[_])
            }), mc.Jsep = xt, mc.plugins.register({
                name: "ternary",
                init(_) {
                    _.hooks.add("after-expression", function(O) {
                        if (O.node && this.code === _.QUMARK_CODE) {
                            this.index++;
                            let B = O.node,
                                N = this.gobbleExpression();
                            if (N || this.throwError("Expected expression"), this.gobbleSpaces(), this.code === _.COLON_CODE) {
                                this.index++;
                                let k = this.gobbleExpression();
                                if (k || this.throwError("Expected expression"), O.node = {
                                        type: "ConditionalExpression",
                                        test: B,
                                        consequent: N,
                                        alternate: k
                                    }, B.operator && _.binary_ops[B.operator] <= .9) {
                                    let N = B;
                                    for (; N.right.operator && _.binary_ops[N.right.operator] <= .9;) N = N.right;
                                    O.node.test = N.right, N.right = O.node, O.node = B
                                }
                            } else this.throwError("Expected :")
                        }
                    })
                }
            });
            var xi = ["+", "-", "*", "/", "(", ")", "==", "!=", ">", "<", ">=", "<=", "and", "or", "!", "%", "^", ","],
                xs = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."],
                xa = ["sin", "cos", "tan", "asin", "acos", "atan", "atan2", "sqrt", "abs", "log", "exp", "floor", "ceil", "round", "min", "max", "random"];

            function Ov(_, O, B = "number") {
                let N, k, F = "";
                for (let N = 0; N < _.length; N++) {
                    var U;
                    let k = _[N];
                    if ("id" in k) {
                        let U = _[N - 1];
                        if (N > 0 && "id" in U) {
                            console.error("Two variables in a row", _);
                            return
                        }
                        let j = O.getVariable(k.id),
                            G = gL.getDisplayedValue(j);
                        "number" === B && gL.isTextValue(j) && Array.isArray(j.textValue) && 1 === j.textValue.length ? G = parseFloat(G).toString() : "boolean" === B && gL.isBoolean(j) ? G = j ? "true" : "false" : "boolean" === B && gL.isTextValue(j) && !Array.isArray(j.textValue) && (G = '"' + G + '"'), F += G;
                        continue
                    }
                    if ("string" === B) {
                        '"' !== k.name && "+" !== k.name && (F += k.name), "+" === k.name && "\\" === F[F.length - 1] && (F = F.slice(0, -1) + k.name);
                        continue
                    }
                    if ("and" === k.name) {
                        F += "&&";
                        continue
                    }
                    if ("or" === k.name) {
                        F += "||";
                        continue
                    }
                    if ("True" === k.name) {
                        F += "true";
                        continue
                    }
                    if ("False" === k.name) {
                        F += "false";
                        continue
                    }
                    if ("boolean" === B && !("string" == typeof(U = k.name) && !isNaN(U) && !isNaN(parseFloat(U))) && !xs.includes(k.name) && !xi.includes(k.name) && !xa.includes(k.name.replace(/\($/g, ""))) {
                        F += '"' + k.name + '"';
                        continue
                    }
                    F += k.name
                }
                if ("string" === B) return F;
                if (0 === _.length) {
                    if ("number" === B) return 0;
                    if ("boolean" === B) return !1
                }
                try {
                    N = mc(F)
                } catch (_) {
                    console.error(F, _);
                    return
                }
                try {
                    k = function Dt(_) {
                        switch (_.type) {
                            case "BinaryExpression":
                                switch (_.operator) {
                                    case "==":
                                        return Number(Dt(_.left) === Dt(_.right));
                                    case "!=":
                                        return Number(Dt(_.left) !== Dt(_.right));
                                    case ">":
                                        return Number(Dt(_.left) > Dt(_.right));
                                    case ">=":
                                        return Number(Dt(_.left) >= Dt(_.right));
                                    case "<":
                                        return Number(Dt(_.left) < Dt(_.right));
                                    case "<=":
                                        return Number(Dt(_.left) <= Dt(_.right));
                                    case "+":
                                        return Dt(_.left) + Dt(_.right);
                                    case "-":
                                        return Dt(_.left) - Dt(_.right);
                                    case "*":
                                        return Dt(_.left) * Dt(_.right);
                                    case "/":
                                        return Dt(_.left) / Dt(_.right);
                                    case "%":
                                        return Dt(_.left) % Dt(_.right);
                                    case "&&":
                                        return Dt(_.left) && Dt(_.right);
                                    case "||":
                                        return Dt(_.left) || Dt(_.right);
                                    case "^":
                                        return Math.pow(Dt(_.left), Dt(_.right));
                                    default:
                                        throw Error("Unknown operator: " + _.operator)
                                }
                            case "UnaryExpression":
                                switch (_.operator) {
                                    case "-":
                                        return -Dt(_.argument);
                                    case "!":
                                        return Number(!Dt(_.argument));
                                    default:
                                        throw Error("Unknown operator: " + _.operator)
                                }
                            case "Identifier":
                                throw Error("Unknown identifier: " + _.name);
                            case "Literal":
                                return _.value;
                            case "CallExpression":
                                if ("Identifier" === _.callee.type) {
                                    if ("random" === _.callee.name) {
                                        let O = 0,
                                            B = 1;
                                        if (_.arguments.length >= 1) try {
                                            O = Dt(_.arguments[0])
                                        } catch (_) {
                                            console.warn(_)
                                        }
                                        if (_.arguments.length >= 2) try {
                                            B = Dt(_.arguments[1])
                                        } catch (_) {
                                            console.warn(_)
                                        }
                                        return O = Math.min(B, O), B = Math.max(B, O), O + Math.random() * (B - O)
                                    }
                                    return Math[_.callee.name].apply(null, _.arguments.map(Dt))
                                }
                                throw Error("Unknown node");
                            default:
                                throw Error("Unknown node type: " + _.type)
                        }
                    }(N)
                } catch (_) {
                    console.error(F, N, _)
                }
                return k
            }
            mc.addBinaryOp("^", 11, !0);
            var xn = new rJ,
                xo = new rJ,
                xl = class {
                    static create(_) {
                        return this.build(this.normalizeInputs(_))
                    }
                    static normalizeInputs(_, O) {
                        let B = Object.assign({}, O ? .parameters ? ? {
                                width: 100,
                                height: 100,
                                depth: 1,
                                subdivisions: 12,
                                roundness: 0,
                                extrudeBevelSize: 0,
                                extrudeBevelSegments: 3
                            }, _.parameters),
                            N = Math.abs(B.width),
                            k = Math.abs(B.height ? ? B.width),
                            F = Math.abs(B.depth ? ? 0),
                            U = O ? .shapeData ? ? yE.create({
                                parameters: mt
                            }).userData.shape;
                        return {
                            path: _.path ? ? m3.defaultData(),
                            parameters: Object.assign(B, {
                                width: N,
                                height: k,
                                depth: F,
                                extrusion: { ...mi,
                                    ...B.extrusion
                                }
                            }),
                            shapeData: U
                        }
                    }
                    static build(_) {
                        return _.path.points.length >= 2 ? Object.assign(new xh(_), {
                            userData: { ..._,
                                type: "PathGeometry"
                            }
                        }) : Object.assign(new sK, {
                            userData: { ..._,
                                type: "PathGeometry"
                            }
                        })
                    }
                },
                xh = class extends sK {
                    constructor(_) {
                        super(), this.type = "PathExtrusionGeometry", this.inputs = _, this.build()
                    }
                    _isGeometryClosed() {
                        return this.inputs.path.isClosed && 1 === this.inputs.parameters.extrusion.depth
                    }
                    _isOpenEnded() {
                        let _, O = this.inputs.parameters.extrusion;
                        return !(this.inputs.path.isClosed && 1 === O.depth) || (O.twist % (_ = 2 * Math.PI) + _) % _ != (0 % _ + _) % _ || O.startScale !== O.endScale
                    }
                    build() {
                        let _ = this._extractPathPoints();
                        if (_.length < 2) return;
                        let O = this._computeBasisMatrices(_),
                            {
                                depth: B,
                                offset: N
                            } = this.inputs.parameters.extrusion;
                        B = Math.max(0, Math.min(B, 1)), N = Math.max(0, Math.min(N, 1));
                        let k = this.inputs.path.isClosed ? _.length : _.length - 1,
                            F = Math.floor(N * k),
                            U = Math.min(Math.max(2, (this.inputs.path.isClosed ? Math.ceil((B + N) * k) : Math.ceil(Math.min(1, B + N) * k)) - F + 1), k + 2),
                            j = [],
                            G = [];
                        for (let B = 0; B < U; B++) {
                            let N = this.inputs.path.isClosed ? (B + F) % _.length : Math.min(B + F, _.length - 1);
                            j.push(_[N].clone()), G.push(O[N].clone())
                        }
                        let d = (_, O, B) => {
                                var N, k;
                                let F, U;
                                j[_] = j[_].clone().lerp(j[O], B), G[_] = (N = G[_], k = G[O], F = [new rv, new rv, new rv], U = [new rv, new rv, new rv], N.extractBasis(F[0], F[1], F[2]), k.extractBasis(U[0], U[1], U[2]), F.forEach((_, O) => {
                                    let N = U[O],
                                        k = iK.lerp(_.length(), N.length(), B);
                                    _.lerp(N, B).setLength(k)
                                }), new rJ().makeBasis(F[0], F[1], F[2]))
                            },
                            Y = 0,
                            Q = N * k % 1;
                        (!this.inputs.path.isClosed || B <= 1) && (Q || 0 === N) && d(0, 1, Y = Q);
                        let K = 0,
                            $ = (N + B) * k % 1;
                        if ((this.inputs.path.isClosed && B <= 1 || !this.inputs.path.isClosed && N + B < 1) && $ && (K = $, d(j.length - 1, j.length - 2, 1 - K)), 0 === B) {
                            let _ = j.length - 1;
                            j[_].copy(j[0]), G[_].copy(G[0])
                        }
                        this._applyPathModifiers(G, Y, K);
                        let {
                            bevel: ee,
                            bevelSides: et
                        } = this.inputs.parameters.extrusion, ei = ee > 0 ? this.inputs.parameters.extrusion.capType : "flat", er = 5;
                        "Custom" === this.inputs.parameters.extrusion.shape.type && (er = "low" === this.inputs.parameters.extrusion.shape.shapeQuality ? 5 : 12);
                        let {
                            regions: ea,
                            infos: en,
                            vertices: eo
                        } = this._computeShapePoints(er), el = 0, eh;
                        "round" === ei && (el = (eh = new yw(this.inputs.shapeData, 2 * ee, ee, er, et, void 0, !0)).getAttribute("position").count);
                        let ec = 0,
                            eu = 0;
                        en.sort((_, O) => _.start - O.start), en.forEach(_ => {
                            _.verticesStart = ec, _.verticesCount = _.continuous.reduce((_, O, B) => _ + (0 !== B && O ? 1 : 2), 0), eu += _.verticesCount, ec = eu
                        });
                        let ep = eu * U,
                            ef, em = 0;
                        if (this._isOpenEnded() && "flat" === ei) {
                            try {
                                ef = Es({
                                    windingRule: xp.ODD,
                                    elementType: xf.POLYGONS,
                                    polySize: 3,
                                    vertexSize: 2,
                                    strict: !0,
                                    contours: ea
                                })
                            } catch {
                                ef = yb
                            }
                            em = ef.vertexCount
                        }
                        let eg = ep + 2 * em + 2 * el,
                            ev = ep + 2 * em,
                            ex = {
                                positions: new Float32Array(3 * eg),
                                normals: new Float32Array(3 * eg),
                                uvs: new Float32Array(2 * eg)
                            },
                            eb = [];
                        if (en.forEach(_ => {
                                this._extrudeRegion(_, eo, G, j, ex, eb, this._isGeometryClosed() && !this._isOpenEnded())
                            }), ef && (this._closeEnd(ef, ep, eb, ex, G[0], j[0], !1), this._closeEnd(ef, ep + em, eb, ex, G[G.length - 1], j[j.length - 1], !0)), eh) {
                            ex.positions.set(eh.getAttribute("position").array, 3 * ev), ex.normals.set(eh.getAttribute("normal").array, 3 * ev), ex.uvs.set(eh.getAttribute("uv").array, 2 * ev);
                            let _ = eb.length;
                            eb.push(...eh.getIndex().array.map(_ => _ + ev)), ev += el, ex.positions.set(eh.getAttribute("position").array, 3 * ev), ex.normals.set(eh.getAttribute("normal").array, 3 * ev), ex.uvs.set(eh.getAttribute("uv").array, 2 * ev);
                            let O = eb.length;
                            eb.push(...eh.getIndex().array.map(_ => _ + ev)), this.setAttribute("position", new sF(ex.positions, 3)), this.setAttribute("normal", new sF(ex.normals, 3)), this.setAttribute("uv", new sF(ex.uvs, 2)), this.setIndex(eb), xn.copy(G[G.length - 1]).setPosition(j[j.length - 1]), this.applyMatrix4OnRange(xn, ev, eg), xn.copy(G[0]).setPosition(j[0]).multiply(xo.makeScale(1, 1, -1)), this.applyMatrix4OnRange(xn, ev - el, ev), this.reverseIndicesOnRange(_, O)
                        } else this.setAttribute("position", new sF(ex.positions, 3)), this.setAttribute("normal", new sF(ex.normals, 3)), this.setAttribute("uv", new sF(ex.uvs, 2)), this.setIndex(eb)
                    }
                    _extractPathPoints() {
                        let _ = yv(this.inputs.path).getPoints(this.inputs.path.subdivisions);
                        if (_.length < 2) return [];
                        let O = [_[0]];
                        return _.forEach(_ => {
                            O[O.length - 1].distanceToSquared(_) > .001 && O.push(_)
                        }), this.inputs.path.isClosed && .001 > O[O.length - 1].distanceTo(O[0]) && O.pop(), O
                    }
                    _computeBasisMatrices(_) {
                        let O = [],
                            B = _.length,
                            N = this.inputs.path.isClosed,
                            k = new rv,
                            F = new rv,
                            U = new rv,
                            j = new rv,
                            G = new rv(0, 1, 0);
                        for (let Y = 0; Y < B; Y++) {
                            let Q, K = _[Y],
                                $;
                            $ = 0 === Y ? N ? _[_.length - 2] : K.clone().multiplyScalar(2).sub(_[1]) : _[Y - 1], Q = Y === B - 1 ? N ? _[1] : K.clone().multiplyScalar(2).sub(_[Y - 1]) : _[Y + 1];
                            let ee = K.clone().sub($).normalize(),
                                et = Q.clone().sub(K).normalize(),
                                ei = ee.clone().add(et).normalize();
                            U.copy(ei), 0 === Y && (ei.equals(G) || ei.clone().negate().equals(G)) && G.set(0, 0, 1);
                            let er = G.clone().cross(ei).normalize(),
                                ea = ei.clone().cross(er).normalize();
                            G.copy(ea), j.copy(er), 0 === Y && (k.copy(ea), F.copy(ei));
                            let en = new rJ().makeBasis(er, ea, ei);
                            O.push(en)
                        }
                        let Y = N ? F : U,
                            Q = N ? k : new rv(0, 1, 0),
                            K = Y.clone().cross(j).normalize(),
                            $ = Math.acos(Q.dot(K));
                        if (isNaN($)) return O;
                        let ee = Q.clone().cross(K);
                        Y.dot(ee) > 0 && ($ *= -1);
                        for (let _ = 1; _ < O.length; _++) {
                            let B = new rJ().makeRotationZ($ * _ / O.length);
                            O[_].multiply(B)
                        }
                        return O
                    }
                    _applyPathModifiers(_, O, B) {
                        let N = _.length,
                            {
                                angle: k,
                                twist: F,
                                startScale: U,
                                endScale: j
                            } = this.inputs.parameters.extrusion,
                            G = new rJ,
                            Y = new rJ;
                        return _.forEach((_, Q) => {
                            let K = 0 === Q ? 0 : Q === N - 1 ? 1 : (Q - O) / (N - (0 === B ? 0 : 1) - (O + (1 - B)));
                            G.makeRotationZ(iK.lerp(k, k + F, K) * iK.DEG2RAD);
                            let $ = iK.lerp(U, j, K);
                            Y.makeScale($, $, $), _.multiply(G).multiply(Y)
                        }), _
                    }
                    _computeShapePoints(_ = 12, O = xp.ODD) {
                        let B, N = this.inputs.shapeData,
                            k = N.extractShapePointsToFlatArray([], _),
                            F = N.shapeHoles.map(O => {
                                let B = O.extractShapePointsToFlatArray([], _),
                                    N = [];
                                for (let _ = B.length - 1; _ >= 1; _ -= 2) {
                                    let O = B[_ - 1],
                                        k = B[_ - 0];
                                    N.push(O, k)
                                }
                                return N
                            }),
                            U;
                        try {
                            U = Es({
                                windingRule: O,
                                elementType: xf.BOUNDARY_CONTOURS,
                                vertexSize: 2,
                                strict: !0,
                                contours: [k]
                            })
                        } catch {
                            U = yy
                        }
                        try {
                            B = Es({
                                windingRule: xp.ODD,
                                elementType: xf.BOUNDARY_CONTOURS,
                                vertexSize: 2,
                                strict: !0,
                                contours: [...F]
                            })
                        } catch {
                            B = yx
                        }
                        if (!U) throw Error("error generating geometry");
                        let j = U.elementCount;
                        if (B) {
                            U.elementCount += B.elementCount;
                            for (let _ = 0; _ < B.elements.length; _++) {
                                let O = B.elements[_],
                                    N = _ % 2 == 0 ? U.vertexCount : 0;
                                U.elements.push(O + N)
                            }
                            for (let _ = 0; _ < B.vertexIndices.length; _++) {
                                let O = B.vertexIndices[_],
                                    N = U.vertexCount;
                                U.vertexIndices.push(O + N)
                            }
                            for (let _ = 0; _ < B.vertices.length; _++) {
                                let O = B.vertices[_];
                                U.vertices.push(O)
                            }
                        }
                        let G = 1 / 0,
                            Y = -1 / 0,
                            Q = 1 / 0,
                            K = -1 / 0;
                        for (let _ = 0, O = U.vertexCount; _ < O; _++) {
                            let O = 2 * _,
                                B = U.vertices[O + 0],
                                N = U.vertices[O + 1];
                            B < G && (G = B), B > Y && (Y = B), N < Q && (Q = N), N > K && (K = N)
                        }
                        let $ = [];
                        for (let _ = U.elementCount - 1; _ >= 0; _--) {
                            let O = _ >= j,
                                B = 2 * _,
                                k = U.elements[B + 0],
                                F = U.elements[B + 1],
                                G = k + F,
                                Y = {
                                    start: k,
                                    count: F,
                                    normals: [],
                                    isHole: O,
                                    continuous: [],
                                    verticesStart: 0,
                                    verticesCount: 0
                                };
                            $.push(Y);
                            let Q = k,
                                K = G - 1,
                                ee = k + 1,
                                et = N.roundedCurves.length;
                            do {
                                let _ = Q - k,
                                    B = U.vertices[2 * K + 0],
                                    j = U.vertices[2 * K + 1],
                                    $ = U.vertices[2 * Q + 0],
                                    ei = U.vertices[2 * Q + 1],
                                    er = U.vertices[2 * ee + 0],
                                    ea = U.vertices[2 * ee + 1],
                                    en = $ - B,
                                    eo = ei - j,
                                    el = Math.sqrt(en * en + eo * eo);
                                en /= el, eo /= el;
                                let eh = $ - er,
                                    ec = ei - ea,
                                    eu = Math.sqrt(eh * eh + ec * ec);
                                eh /= eu, ec /= eu, Y.normals[2 * _ + 0] = -ec, Y.normals[2 * _ + 1] = eh;
                                let ep = U.vertexIndices[Q];
                                if (Array.isArray(ep)) Y.continuous[_] = !1;
                                else {
                                    let [O, B] = N.getCurveIndexFromVertexId(ep - 1, !0);
                                    if (B > 0 && B < 1) Y.continuous[_] = !0;
                                    else {
                                        let k = 1 === B ? O + 1 : O - 1;
                                        k = (k + et) % et;
                                        let F = 1 === B ? 0 : 1,
                                            U = N.roundedCurves[O].getTangent(B),
                                            j = N.roundedCurves[k].getTangent(F);
                                        Y.continuous[_] = U.dot(j) > .95
                                    }
                                }
                                O && (Y.normals[2 * _ + 0] *= -1, Y.normals[2 * _ + 1] *= -1), [K, Q, ee] = [Q, ee, ee + 1], ee >= G && (ee -= F)
                            } while (ee !== k + 1)
                        }
                        return {
                            regions: [k, ...F],
                            infos: $,
                            vertices: U.vertices
                        }
                    }
                    _insertVertex(_, O, B, N, k) {
                        let F = 2 * O,
                            U = 3 * O;
                        _.positions[U + 0] = B.x, _.positions[U + 1] = B.y, _.positions[U + 2] = B.z, _.normals[U + 0] = N.x, _.normals[U + 1] = N.y, _.normals[U + 2] = N.z, _.uvs[F + 0] = k.x, _.uvs[F + 1] = k.y
                    }
                    _extrudeRegion(_, O, B, N, k, F, U) {
                        let j = new rv,
                            G = new rv,
                            Y = new rv,
                            Q = new rv,
                            K = new iJ;
                        B.forEach((F, U) => {
                            let $ = N[U],
                                ee = _.verticesStart * B.length + _.verticesCount * U;
                            for (let N = 0; N < _.count; N++) {
                                let et = (_.start + N) * 2;
                                if (j.set(O[et + 0], O[et + 1], 0), Y.copy(j).applyMatrix4(F).add($), _.continuous[N]) Q.set(_.normals[2 * N + 0], _.normals[2 * N + 1], 0);
                                else {
                                    let B = 0 === N ? (_.start + _.count - 1) * 2 : et - 2;
                                    G.set(O[B + 0], O[B + 1], 0), Q.copy(j).sub(G), Q.set(-Q.y, Q.x, 0), _.isHole || Q.negate()
                                }
                                if (Q.applyMatrix4(F).normalize(), K.set(0 === N ? 1 : N / _.count, U / (B.length - 1)), this._insertVertex(k, ee, Y, Q, K), ee++, !_.continuous[N] || 0 === N) {
                                    if (0 === N) Q.set(_.normals[2 * N + 0], _.normals[2 * N + 1], 0), K.set(0, U / (B.length - 1));
                                    else {
                                        let B = N === _.count - 1 ? 2 * _.start : et + 2;
                                        G.set(O[B + 0], O[B + 1], 0), Q.copy(G).sub(j), Q.set(-Q.y, Q.x, 0), _.isHole || Q.negate()
                                    }
                                    Q.applyMatrix4(F).normalize(), this._insertVertex(k, ee, Y, Q, K), ee++
                                }
                            }
                        });
                        let $ = B.length - 1;
                        for (let O = 0; O < $; O++) {
                            let N = _.verticesStart * B.length + _.verticesCount * O,
                                k = _.verticesStart * B.length + _.verticesCount * (O + 1),
                                U = 0;
                            for (let O = 0; O < _.count; O++) {
                                (!_.continuous[O] || 0 === O) && U++;
                                let B = O === _.count - 1 ? 0 : U + 1,
                                    j = N + U,
                                    G = N + B,
                                    Y = k + B,
                                    Q = k + U;
                                _.isHole ? F.push(j, Y, G, j, Q, Y) : F.push(j, G, Y, j, Y, Q), U++
                            }
                        }
                    }
                    _closeEnd(_, O, B, N, k, F, U) {
                        let j = _.vertexCount,
                            G = new rv(0, 0, U ? -1 : 1).applyMatrix4(k),
                            Y = new rv,
                            Q = new iJ;
                        for (let B = 0; B < j; B++) {
                            let U = 2 * B;
                            Y.set(_.vertices[U + 0], _.vertices[U + 1], 0).applyMatrix4(k).add(F), this._insertVertex(N, O + B, Y, G, Q)
                        }
                        let K = _.elements;
                        for (let N = 0; N < _.elementCount; N++) {
                            let _ = 3 * N,
                                k = K[_ + 0] + O,
                                F = K[_ + (U ? 1 : 2)] + O,
                                j = K[_ + (U ? 2 : 1)] + O;
                            B.push(k, F, j)
                        }
                    }
                    applyMatrix4OnRange(_, O, B) {
                        let N = _.elements,
                            k = new i$().getNormalMatrix(_).elements,
                            F, U, j, G, Y = this.attributes.position,
                            Q = this.attributes.normal;
                        if (!Y || !Q) return;
                        let K = Y.array,
                            $ = Q.array,
                            ee = Y.itemSize;
                        for (let _ = O * ee, Y = B * ee; _ < Y; _ += ee) F = K[_ + 0], U = K[_ + 1], j = K[_ + 2], G = 1 / (N[3] * F + N[7] * U + N[11] * j + N[15]), K[_ + 0] = (N[0] * F + N[4] * U + N[8] * j + N[12]) * G, K[_ + 1] = (N[1] * F + N[5] * U + N[9] * j + N[13]) * G, K[_ + 2] = (N[2] * F + N[6] * U + N[10] * j + N[14]) * G, F = $[_ + 0], U = $[_ + 1], j = $[_ + 2], $[_ + 0] = k[0] * F + k[3] * U + k[6] * j, $[_ + 1] = k[1] * F + k[4] * U + k[7] * j, $[_ + 2] = k[2] * F + k[5] * U + k[8] * j;
                        Y.needsUpdate = !0, Q.needsUpdate = !0
                    }
                    reverseIndicesOnRange(_, O) {
                        let B = this.index;
                        if (B) {
                            for (let N = _; N < O; N += 3) {
                                let _ = B.getX(N),
                                    O = B.getX(N + 1),
                                    k = B.getX(N + 2);
                                B.setXYZ(N, k, O, _)
                            }
                            B.needsUpdate = !0
                        }
                    }
                };

            function VD() {
                let _ = new sK;
                return _.setAttribute("position", new sF(new Float32Array([]), 3)), _.setIndex(new sF(new Uint16Array([]), 1)), _
            }
            var xc, xd, xu, xp, xf, xm, xg = VD().attributes,
                xv = class extends sK {
                    constructor(_, O) {
                        super(), this.charWidths = [], this.charCoords = [], this.wrappedText = [], this.isLowResolution = !1, this.vectorShapes = [], Object.assign(this.attributes, xg), this.userData = {
                            parameters: _,
                            type: "TextGeometry"
                        };
                        let B = O.getFont(_.font);
                        B ? .isLoaded ? (this.font = B, this.update(_)) : this.updateFont(_.font, O).then(() => {
                            this.update(_), O ? .requestRender()
                        })
                    }
                    async updateFont(_, O) {
                        let B = O.getFont(_);
                        B && (this.font = B, await B.loadingPromise)
                    }
                    update(_) {
                        let O = this.font;
                        if (this.userData = {
                                parameters: _,
                                type: "TextGeometry"
                            }, !O ? .isLoaded) {
                            console.warn("Cannot update text because its font is not loaded");
                            return
                        }
                        let {
                            width: B,
                            height: N,
                            depth: k,
                            extrudeBevelSize: F,
                            extrudeBevelSegments: U,
                            text: j,
                            textTransform: G
                        } = _, Y = gL.getDisplayedValue(j), Q = function(_, O, B) {
                            let N = [""],
                                k = "";
                            for (let F of B) k += F, " " === F || F === `
` ? (N[N.length - 1] += k, k = "", F === `
` && N.push("")) : O.getTextWidth(N[N.length - 1] + k, _) > _.width && (N[N.length - 1].length && N.push(""), O.getTextWidth(N[N.length - 1] + k, _) > _.width && (1 === k.length ? (N[N.length - 1] += k, k = "") : (N[N.length - 1] += k.slice(0, -1), k = k[k.length - 1], N.push(""))));
                            return N[N.length - 1] += k, N
                        }(_, O, 2 === G ? Y.toUpperCase() : 3 === G ? Y.toLowerCase() : Y), {
                            shapes: K,
                            charWidths: $,
                            charCoords: ee
                        } = O.generateShapes(Q, _), et = ("number" == typeof B ? B : 1) * .5, ei = ("number" == typeof N ? N : 1) * .5, er = K.map(_ => new ys().fromShape(_, !0));
                        this.vectorShapes = er;
                        let ea = er.map(_ => yA.create({
                                shape: _,
                                parameters: {
                                    depth: k,
                                    extrudeBevelSegments: U,
                                    extrudeBevelSize: F,
                                    windingRule: k <= 0 ? xp.NONZERO : xp.ODD,
                                    subdivisions: this.isLowResolution && k > 0 ? 1 : 12
                                }
                            })),
                            en = ea.length ? ws(ea) : VD();
                        en.translate(-et, ei, 0), this.dispose(), this.wrappedText = Q, this.charCoords = ee, this.charWidths = $, this.deleteAttribute("extrudeNormal"), Object.entries(en.attributes).forEach(([_, O]) => {
                            this.setAttribute(_, O)
                        }), this.setIndex(en.index), this.computeBoundingSphere()
                    }
                    clone() {
                        let _ = ui(new sK, xv.prototype);
                        return _.copy(this), console.log("CloneGeometry", this, _), _
                    }
                    copy(_) {
                        return Object.entries(_.attributes).forEach(([_, O]) => {
                            this.setAttribute(_, O)
                        }), this.setIndex(_.index), this.userData = {
                            parameters: { ..._.userData.parameters
                            },
                            type: "TextGeometry"
                        }, this
                    }
                    async setText(_) {
                        this.font && await this.font.loadingPromise, await this.update({ ...this.userData.parameters,
                            text: _
                        })
                    }
                    get text() {
                        return this.userData.parameters.text ? ? ""
                    }
                },
                xx = new Promise(_ => {
                    xm = _
                }),
                x_ = !1;

            function gc(_, O, B, N) {
                let k, F, U, j;
                for (let B of ("PathGeometry" === _.type ? (F = JSON.parse(JSON.stringify(_)), U = [
                        [],
                        ["extrusion"]
                    ]) : (F = { ..._
                    }, U = [
                        []
                    ]), U)) {
                    let _ = F;
                    for (let O of B) _ = _[O];
                    for (k in _) {
                        let F = _[k];
                        "string" == typeof F && 36 === F.length && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(F) && (_[k] = O.getVariable(F, [N.uuid, "geometry", ...B, k]))
                    }
                }
                let G = {
                    parameters: F,
                    type: F.type
                };
                if ("PathGeometry" === F.type) G.path = F.path;
                else if ("VectorGeometry" === F.type) {
                    let _ = ys.createFromState(F.shape, F.width, F.height);
                    G.shape = _
                } else if ("NonParametricGeometry" === F.type) F.data.groups && F.data.groups ? .forEach(_ => _.materialIndex = Math.max(_.materialIndex ? ? 0, 0)), G.geometry = new lr().parse(F);
                else if ("SubdivGeometry" === F.type) {
                    let O = new xN(F, B);
                    return O.data = _, O
                } else if ("TextGeometry" === F.type) return new xv(F, O);
                try {
                    j = nA(G)
                } catch (_) {
                    console.error(_)
                }
                if (!j) {
                    let _ = ys.createFromState(m2.defaultData(), 100, 100);
                    G.shape = _, j = nA(G)
                }
                return j
            }
            var xS = new rJ;

            function Lp(_, O, B, N) {
                let k = _.position.array,
                    F = _.normal.array,
                    U = xS.makeScale(O, B, N).invert().elements,
                    j, G, Y;
                for (var Q = 0, K = k.length; Q < K; Q += 3) k[Q] *= O, k[Q + 1] *= B, k[Q + 2] *= N, j = F[Q], G = F[Q + 1], Y = F[Q + 2], F[Q] = U[0] * j + U[4] * G + U[8] * Y, F[Q + 1] = U[1] * j + U[5] * G + U[9] * Y, F[Q + 2] = U[2] * j + U[6] * G + U[10] * Y;
                _.position.needsUpdate = !0, _.normal.needsUpdate = !0
            }
            var xA, xM, xC = new rb,
                xO = new rv;
            xx.then(_ => {
                xM = _
            });
            var xL = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]),
                xB = new Uint32Array([0, 1, 2, 3]),
                xz = new Uint8Array([4]),
                xN = class extends sK {
                    constructor(_, O) {
                        super(), this.data = _, this.flatShading = O, this.subdivPointer = 0, this.rebuild(), this.freeSubdivPointer()
                    }
                    mutateDirectlyScaleBaked(_, O) {
                        this.freeSubdivPointer();
                        let B = this.data.scaleBaked,
                            N = fk.div(O, B);
                        this.subdividedGeometry && Lp(this.subdividedGeometry.attributes, ...N), this.originalGeometry && Lp(this.originalGeometry.attributes, ...N), this.data = _;
                        let k = this.userData.parameters;
                        this.userData.parameters = {
                            width: k.width * N[0],
                            height: k.height * N[1],
                            depth: k.depth * N[2]
                        }, this.originalGeometry.boundingSphere.center.multiply(xO.fromArray(N));
                        let F = xO.set(k.width, k.height, k.depth).length();
                        this.originalGeometry.boundingSphere.radius = F / 2
                    }
                    ensureSubdivPointer() {
                        return 0 === this.subdivPointer && this.rebuild(), this.subdivPointer
                    }
                    rebuild() {
                        let _, O, B;
                        try {
                            ({
                                originalGeometry: _,
                                subdividedGeometry: O,
                                subdivPointer: B
                            } = xN.build(this.data, void 0, !this.flatShading, void 0))
                        } catch {
                            _ = new ai(100, 100, 100), B = 0
                        }
                        this.subdivPointer = B, this.originalGeometry = _, this.subdividedGeometry = O ? ? void 0, Object.assign(this, this.subdividedGeometry ? ? this.originalGeometry), this.calcBoundingBox()
                    }
                    freeSubdivPointer() {
                        this.subdivPointer && (xN.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0)
                    }
                    dispose() {
                        super.dispose(), this.freeSubdivPointer()
                    }
                    calcBoundingBox() {
                        let _ = this.originalGeometry;
                        null === _.boundingSphere && (_.boundingSphere = new rG, this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = _.boundingSphere));
                        let O = _.attributes.position,
                            B = _.boundingSphere.center;
                        xC.setFromBufferAttribute(O), xC.getCenter(B), _.boundingSphere.radius = B.distanceTo(xC.max), isNaN(_.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), xC.getSize(xO);
                        let N = {
                            width: xO.x,
                            height: xO.y,
                            depth: xO.z
                        };
                        return this.userData.parameters = N, N
                    }
                    static build(_, O, B, N) {
                        let k, F, U, j = _ ? .phongAngle ? ? 35;
                        !1 === B && (j = -1), O && (xM.free_bvh(O), xM.free_subdivision_surface(O));
                        try {
                            k = xN.allocate(_, N)
                        } catch (O) {
                            console.error(O, _), k = xN.allocate({
                                positionWASM: xL,
                                indexWASM: xB,
                                verticesPerFaceWASM: xz
                            }, N)
                        }
                        if (xM.set_destination_refinement_level(k, 0), F = xN.buildLevel(k, !0, j), _.subdivisions > 0) try {
                            xM.set_destination_refinement_level(k, _.subdivisions), U = xN.buildLevel(k, !1, j)
                        } catch {
                            try {
                                xM.set_destination_refinement_level(k, _.subdivisions - 1), U = xN.buildLevel(k, !1, j)
                            } catch {
                                U = null
                            }
                        } else U = null;
                        return {
                            subdivPointer: k,
                            originalGeometry: F,
                            subdividedGeometry: U
                        }
                    }
                    static primitiveToQuads(_, O, B) {
                        let N, k, F, U, j;
                        _.widthSegments > 16 && (_.widthSegments = 16), _.heightSegments > 16 && (_.heightSegments = 16), _.depthSegments > 16 && (_.depthSegments = 16), _.radialSegments > 16 && (_.radialSegments = 16), "DodecahedronGeometry" === _.type && (_.detail = 0);
                        let G = void 0 !== _.shape || void 0 !== _.path ? O.geometry : gc(_, B, !1),
                            Y;
                        if (Y = "TorusGeometry" === _.type && _.arc === 2 * Math.PI ? G.getClosedTorusIndicesForBooleanOrSubdiv() : G.getIndex(), {
                                positions: N,
                                triIndices: U
                            } = yc(G.getAttribute("position"), Y), "CylinderGeometry" === _.type && 0 === _.cornerRadius && 0 === _.hollow && !1 === _.openEnded) {
                            let O = _.radialSegments * _.heightSegments * 6,
                                B = O + 3 * _.radialSegments;
                            j = [O, B]
                        }
                        return {
                            indices: k,
                            verticesPerFace: F
                        } = aA(N, U, G, j), {
                            positions: N,
                            indices: k,
                            verticesPerFace: F
                        }
                    }
                    static allocate(_, O) {
                        let B, N, k, F, U = [],
                            j = [];
                        _.positionWASM && _.positionWASM.length > 0 ? (N = _.positionWASM, k = _.indexWASM, F = _.verticesPerFaceWASM) : (N = xL, k = xB, F = xz);
                        let G = N.length,
                            Y = k.length,
                            Q = F.length,
                            K = N.length + U.length + j.length,
                            $ = k.length + F.length,
                            ee = K * Float32Array.BYTES_PER_ELEMENT + $ * Uint32Array.BYTES_PER_ELEMENT,
                            et = K * Float32Array.BYTES_PER_ELEMENT,
                            ei = (Uint32Array.BYTES_PER_ELEMENT, xM._malloc(ee)),
                            er = new Float32Array(xM.HEAPF32.buffer, ei, K),
                            ea = new Uint32Array(xM.HEAPU32.buffer, ei + et, $);
                        er.set(N, 0), er.set(U, N.length), er.set(j, N.length + U.length), ea.set(k, 0), ea.set(F, k.length), _ ? .scaleBaked ? .some(_ => 1 !== _) && (B = new rJ().makeScale(..._.scaleBaked)), O && (B ? B.premultiply(O) : B = O);
                        let en = B ? xM.alloc_subdivision_surface2(ei, G, ei + et, Y, ei + et + k.length * Uint32Array.BYTES_PER_ELEMENT, Q, B.elements) : xM.alloc_subdivision_surface(ei, G, ei + et, Y, ei + et + k.length * Uint32Array.BYTES_PER_ELEMENT, Q);
                        return xM._free(ei), en
                    }
                    static buildLevel(_, O, B, N, k) {
                        let F = k ? xM.get_mesh_data2(_, O ? xM.Level.CONTROL : xM.Level.REFINED, B, k.elements) : xM.get_mesh_data(_, O ? xM.Level.CONTROL : xM.Level.REFINED, B),
                            U = xM.HEAPU32.subarray(F >> 2, (F >> 2) + 8),
                            j = U.subarray(4, 8),
                            G = 0,
                            Y = xM.HEAPU32[U[G] >> 2],
                            Q = xM.HEAPF32.subarray(Y >> 2, (Y >> 2) + j[G]);
                        G++;
                        let K = xM.HEAPU32[U[G] >> 2],
                            $ = xM.HEAPF32.subarray(K >> 2, (K >> 2) + j[G]);
                        G++;
                        let ee = xM.HEAPU32[U[G] >> 2],
                            et = xM.HEAPU32.subarray(ee >> 2, (ee >> 2) + j[G]);
                        G++;
                        let ei = xM.HEAPU32[U[G] >> 2],
                            er = xM.HEAPU32.subarray(ei >> 2, (ei >> 2) + j[G]);
                        if (G++, void 0 === N) {
                            let _ = new sK;
                            if (_.setIndex(new sj(er, 1)), _.setAttribute("position", new sG(Q, 3)), _.setAttribute("normal", new sG($, 3)), O) {
                                _.setAttribute("faceMap", new sj(et, 1));
                                let O = new Float32Array($.length / 3 * 4).fill(0);
                                _.setAttribute("color", new sF(O, 4))
                            }
                            return xM.free_mesh_data(F), _.userData.type = "SubdivGeometry", _
                        }
                        N.getAttribute("position").copyArray(Q), N.getAttribute("normal").copyArray($), N.attributes.position.needsUpdate = !0, N.attributes.normal.needsUpdate = !0, xM.free_mesh_data(F)
                    }
                    static freeSubdivPointer(_) {
                        xM.free_bvh(_), xM.free_subdivision_surface(_)
                    }
                    static buildControlCageWireframe(_, O, B) {
                        let N = xM.get_wireframe_data_for_base_level(_),
                            k = xM.HEAPU32.subarray(N >> 2, (N >> 2) + 4),
                            F = k.subarray(2, 4),
                            U = 0,
                            j = xM.HEAPU32[k[U] >> 2],
                            G = xM.HEAPF32.subarray(j >> 2, (j >> 2) + F[U]);
                        U++;
                        let Y = xM.HEAPU32[k[U] >> 2],
                            Q = xM.HEAPU32.subarray(Y >> 2, (Y >> 2) + F[U]);
                        if (void 0 === O) {
                            let _ = new sK;
                            _.setAttribute("position", new sG(G, 3));
                            let O = new Float32Array(G.length);
                            for (let _ = 0, N = G.length; _ < N;) O[_++] = B.r, O[_++] = B.g, O[_++] = B.b;
                            return _.setAttribute("color", new sF(O, 3)), _.setIndex(new sj(Q, 1)), xM.free_wireframe_data_for_base_level(N), _
                        }
                        O.getAttribute("position").copyArray(G), O.attributes.position.needsUpdate = !0, xM.free_wireframe_data_for_base_level(N)
                    }
                    static updateCollabMesh(_, O, B) {
                        let N = 0 === O;
                        N || xM.set_destination_refinement_level(_, O);
                        let k = B ? xM.get_topological_data2(_, N ? xM.Level.CONTROL : xM.Level.REFINED, B.elements) : xM.get_topological_data(_, N ? xM.Level.CONTROL : xM.Level.REFINED),
                            F = xM.HEAPU32.subarray(k >> 2, (k >> 2) + 6),
                            U = F.subarray(3, 6),
                            j = 0,
                            G = xM.HEAPU32[F[j] >> 2],
                            Y = new Float32Array(xM.HEAPF32.subarray(G >> 2, (G >> 2) + U[j]));
                        j++;
                        let Q = xM.HEAPU32[F[j] >> 2],
                            K = new Uint32Array(xM.HEAPU32.subarray(Q >> 2, (Q >> 2) + U[j]));
                        j++;
                        let $ = xM.HEAPU32[F[j] >> 2],
                            ee = new Uint8Array(xM.HEAPU32.subarray($ >> 2, ($ >> 2) + U[j]));
                        return xM.free_topological_data(k), {
                            positions: Y,
                            indices: K,
                            verticesPerFace: ee
                        }
                    }
                },
                xk = ["getX", "getY", "getZ"];

            function yc(_, O) {
                let B = {},
                    N = O ? O.count : _.count,
                    k = 0,
                    F = [],
                    U = [];
                for (let j = 0; j < N; j++) {
                    let N = O ? O.getX(j) : j,
                        G = "";
                    for (let O = 0; O < 3; O++) G += `${~~(1e4*_[xk[O]](N))},`;
                    if (G in B) F.push(B[G]);
                    else {
                        for (let O = 0; O < 3; O++) U.push(_[xk[O]](N));
                        B[G] = k, F.push(k), k++
                    }
                }
                let j = [];
                for (let _ = 0; _ < F.length; _ += 3) F[_] === F[_ + 1] || F[_] === F[_ + 2] || F[_ + 1] === F[_ + 2] || j.push(F[_], F[_ + 1], F[_ + 2]);
                return {
                    positions: U,
                    triIndices: j
                }
            }
            var xF = new rv,
                xU = new rv,
                xj = new rv,
                xG = new rv;

            function aA(_, O, B, N) {
                let k = [],
                    F = [];
                if (void 0 !== B.userData.shape && 0 === B.userData.parameters.depth && 0 === B.userData.shape.shapeHoles.length) {
                    let O = B.userData.shape.extractShapePointsToFlatArray([]),
                        N = B.userData.parameters.spikes;
                    if ("EllipseGeometry" === B.userData.type && N <= 24 && N % 4 == 0 && B.userData.parameters.angle >= 360) {
                        let _ = O.length / 2 / N;
                        O = O.filter((O, B) => Math.floor(B / 2) % _ == 0)
                    }
                    let U = 0;
                    for (let _ = 0; _ < O.length; _ += 2) U += (O[_] - O[(0 === _ ? O.length : _) - 2]) * (O[_ + 1] + O[(0 === _ ? O.length : _) - 1]);
                    _.length = 0;
                    let j = 0;
                    if (U < 0)
                        for (let B = 0; B < O.length; B += 2) _.push(O[B], O[B + 1], 0), k.push(j++);
                    else
                        for (let B = O.length - 2; B >= 0; B -= 2) _.push(O[B], O[B + 1], 0), k.push(j++);
                    return F.push(j), {
                        indices: k,
                        verticesPerFace: F
                    }
                }
                let U = new Float32Array([B.userData.parameters.depth])[0],
                    j = 0;
                for (; j < O.length;) {
                    if (B.useNgonForTopBottomFaceDuringBake) {
                        let B = 0;
                        if ((_[3 * O[j] + 2] === U || 0 === _[3 * O[j] + 2]) && B++, (_[3 * O[j + 1] + 2] === U || 0 === _[3 * O[j + 1] + 2]) && B++, (_[3 * O[j + 2] + 2] === U || 0 === _[3 * O[j + 2] + 2]) && B++, 3 === B) break
                    }
                    O[j + 1] === O[j + 3] && O[j + 2] === O[j + 5] || O[j + 0] === O[j + 3] && O[j + 2] === O[j + 4] ? (xF.set(_[3 * O[j]], _[3 * O[j] + 1], _[3 * O[j] + 2]), xU.set(_[3 * O[j + 1]], _[3 * O[j + 1] + 1], _[3 * O[j + 1] + 2]), xj.set(_[3 * O[j + 4]], _[3 * O[j + 4] + 1], _[3 * O[j + 4] + 2]), xG.set(_[3 * O[j + 5]], _[3 * O[j + 5] + 1], _[3 * O[j + 5] + 2]), xU.sub(xF).normalize(), xj.sub(xF).normalize(), xG.sub(xF).normalize(), Math.abs(xU.cross(xj).dot(xG)) > .005 || N && N.some((_, O) => O % 2 != 1 && j >= N[O] && j < N[O + 1]) ? (k.push(O[j], O[j + 1], O[j + 2]), F.push(3), j += 3) : (k.push(O[j], O[j + 1], O[j + 4], O[j + 5]), F.push(4), j += 6)) : (k.push(O[j], O[j + 1], O[j + 2]), F.push(3), j += 3)
                }
                if (B.useNgonForTopBottomFaceDuringBake) {
                    let O = [],
                        N = [],
                        j = 0;
                    for (let B = 0, k = 0; B < _.length; B += 3, k++) 0 === _[B + 2] && (O.push(k), j++), _[B + 2] === U && N.push(k);
                    if (0 === B.userData.parameters.extrudeBevelSize) {
                        let _ = N[0];
                        N[0] = N[1], N[1] = _
                    }
                    O.reverse(), k.push(...O, ...N), F.push(j, j)
                }
                return {
                    indices: k,
                    verticesPerFace: F
                }
            }
            var xH = {};

            function KD(_) {
                let O = _.length,
                    B = O * Uint32Array.BYTES_PER_ELEMENT,
                    N = O * Float32Array.BYTES_PER_ELEMENT,
                    k = Number.isInteger(_[0]) ? B : N,
                    F = wd._malloc(k);
                return (Number.isInteger(_[0]) ? new Uint32Array(wd.HEAPU32.buffer, F, O) : new Float32Array(wd.HEAPF32.buffer, F, O)).set(_, 0), F
            }

            function ZD(_) {
                switch (_) {
                    case 0:
                        return wd.OP.UNION;
                    case 1:
                        return wd.OP.INTERSECTION;
                    case 2:
                        return wd.OP.A_MINUS_B;
                    case 3:
                        return wd.OP.B_MINUS_A;
                    case 4:
                        return wd.OP.SYMMETRIC_DIFFERENCE;
                    case 5:
                        return wd.OP.ALL;
                    default:
                        throw Error("Unknown boolean operation " + _)
                }
            }

            function mq(_, O) {
                void 0 === wu && (wu = wd.init_csg());
                let B = KD(_),
                    N = wd.csg_calc_topological(wu, B, _.length, ZD(O));
                wd._free(B);
                let k = wd.HEAPU32.subarray(N >> 2, (N >> 2) + 6),
                    F = k.subarray(3, 6),
                    U = 0,
                    j = wd.HEAPU32[k[U] >> 2],
                    G = new Float32Array(wd.HEAPF32.subarray(j >> 2, (j >> 2) + F[U]));
                U++;
                let Y = wd.HEAPU32[k[U] >> 2],
                    Q = new Uint32Array(wd.HEAPU32.subarray(Y >> 2, (Y >> 2) + F[U]));
                U++;
                let K = wd.HEAPU32[k[U] >> 2],
                    $ = new Uint8Array(wd.HEAPU32.subarray(K >> 2, (K >> 2) + F[U]));
                return wd.free_mesh_data(N), {
                    positions: G,
                    indices: Q,
                    verticesPerFace: $
                }
            }

            function gq(_, O, B, N) {
                void 0 === wu && (wu = wd.init_csg());
                let k = KD(_),
                    F = wd.csg_calc(wu, k, _.length, N, ZD(O));
                wd._free(k);
                let U = wd.HEAPU32.subarray(F >> 2, (F >> 2) + 5),
                    j = U.subarray(2, 5),
                    G = 0,
                    Y = wd.HEAPU32[U[G] >> 2],
                    Q = wd.HEAPF32.subarray(Y >> 2, (Y >> 2) + j[G]);
                G++;
                let K = wd.HEAPU32[U[G] >> 2],
                    $ = wd.HEAPF32.subarray(K >> 2, (K >> 2) + j[G]),
                    ee = j[++G];
                B.setAttribute("position", new sG(Q, 3)), B.setAttribute("normal", new sG($, 3));
                let et = wd.HEAPF32.subarray((F >> 2) + 5, (F >> 2) + 5 + 6);
                return null === B.boundingSphere && (B.boundingSphere = new rG), B.boundingSphere.radius = -1, B.userData.parameters = {
                    width: 2 * et[3],
                    height: 2 * et[4],
                    depth: 2 * et[5]
                }, wd.free_mesh_data(F), ee
            }

            function yq(_, O, B) {
                let N, k, F;
                if (void 0 === wd) return -1;
                if (O && void 0 !== _.userData.positions) {
                    let O = _.userData;
                    F = O.verticesPerFace.length, N = O.positions, k = Array(O.verticesPerFace.reduce((_, O) => _ + O, 0) + F);
                    for (let _ = 0, B = 0, N = 0; _ < O.verticesPerFace.length; _++) {
                        k[N++] = O.verticesPerFace[_];
                        for (let F = 0; F < O.verticesPerFace[_]; F++) k[N++] = O.indices[B++]
                    }
                } else({
                    positions: N,
                    faceIndices: k,
                    nFaces: F
                } = function(_, O, B) {
                    let N, k;
                    k = "TorusGeometry" === _.userData.parameters.type && _.userData.parameters.arc === 2 * Math.PI ? _.getClosedTorusIndicesForBooleanOrSubdiv() : _.getIndex();
                    let {
                        positions: F,
                        triIndices: U
                    } = yc(_.getAttribute("position"), k), j;
                    if (O && B) {
                        let {
                            indices: O,
                            verticesPerFace: B
                        } = aA(F, U, _);
                        j = B.length, N = [];
                        for (let _ = 0, k = 0; _ < j; _++) {
                            N.push(B[_]);
                            for (let F = 0; F < B[_]; F++) N.push(O[k++])
                        }
                    } else {
                        let _ = U.length;
                        N = Array(_ + _ / 3), j = 0;
                        for (let _ = 0, O = 0; O < N.length;) N[O++] = 3, j++, N[O++] = U[_++], N[O++] = U[_++], N[O++] = U[_++]
                    }
                    return {
                        positions: F,
                        faceIndices: N,
                        nFaces: j
                    }
                }(_, O, B));
                let U = N.length,
                    j = k.length,
                    G = N.length,
                    Y = k.length,
                    Q = G * Float32Array.BYTES_PER_ELEMENT + Y * Uint32Array.BYTES_PER_ELEMENT,
                    K = G * Float32Array.BYTES_PER_ELEMENT,
                    $ = (Uint32Array.BYTES_PER_ELEMENT, wd._malloc(Q)),
                    ee = new Float32Array(wd.HEAPF32.buffer, $, G),
                    et = new Uint32Array(wd.HEAPU32.buffer, $ + K, Y);
                ee.set(N, 0), et.set(k, 0);
                let ei = wd.get_csg_mesh($, U, $ + K, j, F);
                return wd._free($), ei
            }

            function vq(_) {
                return wd.has_open_edges(_)
            }

            function xq(_, O) {
                wd.transform_csg_mesh(_, O.elements)
            }

            function bq(_) {
                wd.free_csg_mesh(_)
            }((_, O) => {
                for (var B in O) ic(_, B, {
                    get: O[B],
                    enumerable: !0
                })
            })(xH, {
                calcBoolean: () => gq,
                calcBooleanTopological: () => mq,
                freeMeshSet: () => bq,
                getMeshSet: () => yq,
                hasOpenEdges: () => vq,
                transformMeshSet: () => xq
            }), new Promise(_ => {
                wo = _
            }).then(_ => wd = _);
            var xW = {
                    ConeGeometry: vU,
                    CubeGeometry: vj,
                    CylinderGeometry: vk,
                    DodecahedronGeometry: vY,
                    EllipseGeometry: yE,
                    HelixGeometry: yC,
                    IcosahedronGeometry: yO,
                    LatheGeometry: yR,
                    NonParametricGeometry: yY,
                    PolygonGeometry: yX,
                    PyramidGeometry: yQ,
                    RectangleGeometry: yK,
                    SphereGeometry: yJ,
                    PlaneGeometry: y$,
                    BackdropGeometry: y0,
                    StarGeometry: y4,
                    TextFrameGeometry: y5,
                    TorusGeometry: y6,
                    TorusKnotGeometry: y8,
                    TriangleGeometry: y9,
                    PathGeometry: xl,
                    VectorGeometry: yA
                },
                nA = _ => xW[_.type].create(_);

            function sd(_) {
                return null !== _ && "booleanOp" in _
            }
            var xY = class extends jh(at) {
                    constructor() {
                        super(...arguments), this.booleanMeshSetAddress = -1, this.booleanWasTransformed = !1, this.booleanMatrixInvOld = new rJ
                    }
                    updateVisible(_) {
                        super.updateVisible(_), this.visible = !sd(this.parent) && this.visible, sd(this.parent) && this.parent.invalidateDownstreamBooleanData()
                    }
                    freeBooleanPointer() {
                        -1 !== this.booleanMeshSetAddress && (xH.freeMeshSet(this.booleanMeshSetAddress), this.booleanMeshSetAddress = -1)
                    }
                    invalidateDownstreamBooleanData(_ = !1) {
                        return _ ? this.booleanWasTransformed = !0 : this.freeBooleanPointer(), sd(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this
                    }
                    invalidateUpstreamBooleanData() {
                        for (let _ of (this.freeBooleanPointer(), this.children)) _ instanceof xY && (_.freeBooleanPointer(), sd(_) && _.invalidateUpstreamBooleanData())
                    }
                    updateTransformState(_, O) {
                        let B = super.updateTransformState(_, O);
                        return B && sd(this.parent) && this.invalidateDownstreamBooleanData(!0), B
                    }
                    onVariableUpdate(_ = !1) {
                        super.onVariableUpdate(_), sd(this.parent) && this.invalidateDownstreamBooleanData(!0)
                    }
                },
                xX = new rb;

            function Np(_, O = 0, B = _.count, N, k) {
                let F = 1 / 0,
                    U = 1 / 0,
                    j = 1 / 0,
                    G = -1 / 0,
                    Y = -1 / 0,
                    Q = -1 / 0;
                for (let N = O; N < B; N++) {
                    let O = _.getX(N),
                        B = _.getY(N),
                        k = _.getZ(N);
                    O < F && (F = O), B < U && (U = B), k < j && (j = k), O > G && (G = O), B > Y && (Y = B), k > Q && (Q = k)
                }
                xX.min.set(F, U, j), xX.max.set(G, Y, Q), xX.getCenter(N), xX.getSize(k).multiplyScalar(.5)
            }
            var xQ = new sK,
                xZ = new sz,
                xK = class extends xY {
                    constructor(_, O) {
                        super(xQ, xZ), this.super_Entity(_, O)
                    }
                    updateState(_, O) {
                        this.updateState_Entity(_, O)
                    }
                    updateEntityBoxSize(_, O) {
                        let B = this.geometry.getAttribute("position");
                        void 0 !== B ? Np(B, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : B.count, _, O) : super.updateEntityBoxSize(_, O)
                    }
                },
                xJ = class {
                    constructor(_) {
                        _ = _ ? ? {}, this.name = _.name, this.type = _.type, this.node = _.node, this.size = _.size, this.needsUpdate = _.needsUpdate
                    }
                    get value() {
                        return this.node.value
                    }
                    set value(_) {
                        this.node.value = _
                    }
                },
                x$ = class {
                    constructor(_) {
                        this.hashProperties = void 0, this.isNode = !0, this.shortcuts = {}, this.uuid = iK.generateUUID(), this.type = _, this.name = ""
                    }
                    analyze(_, O) {
                        O = O ? ? {}, _.analyzing = !0, this.build(_.addFlow(O.slot, O.cache, O.context), "v4"), _.clearVertexNodeCode(), _.clearFragmentNodeCode(), _.removeFlow(), _.analyzing = !1
                    }
                    analyzeAndFlow(_, O, B) {
                        return B = B ? ? {}, this.analyze(_, B), this.flow(_, O, B)
                    }
                    flow(_, O, B) {
                        B = B ? ? {}, _.addFlow(B.slot, B.cache, B.context);
                        let N = {
                            result: this.build(_, O),
                            code: _.clearNodeCode(),
                            extra: _.context.extra
                        };
                        return _.removeFlow(), N
                    }
                    build(_, O, B) {
                        O = O ? ? this.getType(_, O);
                        let N = _.getNodeData(B ? ? this);
                        return _.analyzing && this.appendDepsNode(_, N, O), -1 === _.nodes.indexOf(this) && _.nodes.push(this), void 0 !== this.updateFrame && -1 === _.updaters.indexOf(this) && _.updaters.push(this), this.generate(_, O, B)
                    }
                    updateFrame(_) {}
                    generateReadonly(_, O, B, N, k, F) {
                        return ""
                    }
                    generate(_, O, B, N, k) {
                        return ""
                    }
                    parse(_, O, B, N) {}
                    appendDepsNode(_, O, B) {
                        O.deps = (O.deps || 0) + 1;
                        let N = _.getTypeLength(B);
                        (N > (O.outputMax || 0) || this.getType(_, B)) && (O.outputMax = N, O.output = B)
                    }
                    setName(_) {
                        this.name = _
                    }
                    getName() {
                        return this.name
                    }
                    getType(_, O) {
                        return "sampler2D" === O || "samplerCube" === O ? O : this.type
                    }
                    getHash() {
                        let _ = "{",
                            O, B;
                        for (O in this)(B = this[O]) instanceof x$ && (_ += '"' + O + '":' + B.getHash() + ",");
                        if (this.hashProperties)
                            for (let N = 0; N < this.hashProperties.length; N++) B = this[O = this.hashProperties[N]], _ += '"' + O + '":"' + String(B) + '",';
                        return _ + '"id":"' + this.uuid + '"}'
                    }
                },
                x0 = new class {
                    constructor() {
                        this.nodes = {}, this.keywords = {}
                    }
                    add(_) {
                        this.nodes[_.name] = _
                    }
                    addKeyword(_, O, B) {
                        B = void 0 === B || B, this.keywords[_] = {
                            callback: O,
                            cache: B
                        }
                    }
                    remove(_) {
                        delete this.nodes[_.name]
                    }
                    removeKeyword(_) {
                        delete this.keywords[_]
                    }
                    get(_) {
                        return this.nodes[_]
                    }
                    getKeyword(_, O) {
                        return this.keywords[_].callback(O)
                    }
                    getKeywordData(_) {
                        return this.keywords[_]
                    }
                    contains(_) {
                        return void 0 !== this.nodes[_]
                    }
                    containsKeyword(_) {
                        return void 0 !== this.keywords[_]
                    }
                },
                x3 = class extends x$ {
                    constructor(_, O) {
                        super(_), this.scope = "", O = O ? ? {}, this.shared = void 0 === O.shared || O.shared, this.unique = void 0 !== O.unique && O.unique
                    }
                    build(_, O, B, N) {
                        if (O = O ? ? this.getType(_), this.getShared(_, O)) {
                            let k = this.getUnique(_, O);
                            k && void 0 === this.uuid && (this.uuid = iK.generateUUID()), B = _.getUUID(B ? ? this.getUUID(), !k);
                            let F = _.getNodeData(B),
                                U = F.output || this.getType(_);
                            if (_.analyzing) return (F.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(_, F, O), this.generate(_, O, B)) : super.build(_, O, B);
                            if (k) return F.name = F.name || super.build(_, O, B), F.name;
                            if (!this.getLabel() && (!this.getShared(_, U) || _.context.ignoreCache || 1 === F.deps)) return super.build(_, O, B);
                            B = this.getUUID(!1);
                            let j = this.getTemp(_, B);
                            if (j) return _.format(j, U, O); {
                                j = super.generate(_, O, B, F.output, N);
                                let k = this.generate(_, U, B);
                                return _.addNodeCode(j + " = " + k + ";"), _.format(j, U, O)
                            }
                        }
                        return super.build(_, O, B)
                    }
                    getShared(_, O) {
                        return "sampler2D" !== O && "samplerCube" !== O && this.shared
                    }
                    getUnique(_, O) {
                        return this.unique
                    }
                    setLabel(_) {
                        return this.label = _, this
                    }
                    getLabel() {
                        return this.label
                    }
                    getUUID(_) {
                        let O = this.uuid;
                        return "string" == typeof this.scope && (O = this.scope + "-" + O), O
                    }
                    getTemp(_, O) {
                        O = O || this.uuid;
                        let B = _.getVars()[O];
                        return B ? B.name : void 0
                    }
                    generate(_, O, B, N, k) {
                        return this.getShared(_, O) || console.error("TempNode is not shared"), B = B ? ? this.uuid, _.getTempVar(B, N ? ? this.getType(_), k, this.getLabel()).name
                    }
                },
                x4 = class extends x3 {
                    constructor(_, O) {
                        (O = O ? ? {}).shared = void 0 !== O.shared && O.shared, super(_, O), this.readonly = !1
                    }
                    setReadonly(_) {
                        return this.readonly = _, this.hashProperties = this.readonly ? ["value"] : void 0, this
                    }
                    getReadonly() {
                        return this.readonly
                    }
                    generate(_, O, B, N, k, F) {
                        B = _.getUUID(B ? ? this.getUUID()), N = N ? ? this.getType(_);
                        let U = _.getNodeData(B);
                        return this.getReadonly() && void 0 !== this.generateReadonly ? this.generateReadonly(_, O, B, N, k, F) : _.isShader("vertex") ? (U.vertex || (U.vertex = _.createVertexUniform(N, this, k, F, this.getLabel())), _.format(U.vertex.name, N, O)) : (U.fragment || (U.fragment = _.createFragmentUniform(N, this, k, F, this.getLabel())), _.format(U.fragment.name, N, O))
                    }
                },
                x5 = class extends x4 {
                    constructor(_ = 0, O) {
                        super("v2"), this.nodeType = "Vector2", this.value = _ instanceof iJ ? _ : new iJ(_, O)
                    }
                    get x() {
                        return this.value.x
                    }
                    set x(_) {
                        this.value.x = _
                    }
                    get y() {
                        return this.value.y
                    }
                    set y(_) {
                        this.value.y = _
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format("vec2(" + this.value.x + ", " + this.value.y + ")", N, O)
                    }
                },
                x6 = class extends x4 {
                    constructor(_ = 0, O, B) {
                        super("v3"), this.nodeType = "Vector3", this.value = _ instanceof rv ? _ : new rv(_, O, B)
                    }
                    get x() {
                        return this.value.x
                    }
                    set x(_) {
                        this.value.x = _
                    }
                    get y() {
                        return this.value.y
                    }
                    set y(_) {
                        this.value.y = _
                    }
                    get z() {
                        return this.value.z
                    }
                    set z(_) {
                        this.value.z = _
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", N, O)
                    }
                },
                x8 = class extends re {
                    constructor(_, O, B, N) {
                        super(_, O, B), this.isColorA = !0, this.a = N
                    }
                    setRGBA(_, O, B, N) {
                        super.setRGB(_, O, B), this.a = N
                    }
                    copy(_) {
                        return super.copy(_), this.a = "a" in _ ? _.a : 1, this
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b, this.a)
                    }
                    setStyle(_, O = "srgb") {
                        let B;
                        if ("transparent" === _) return this.setRGBA(0, 0, 0, 0), this;
                        if (B = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(_)) {
                            let N, k = B[1],
                                F = B[2];
                            switch (k) {
                                case "rgb":
                                case "rgba":
                                    if (N = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(F)) return this.a = "rgba" === k ? parseFloat(N[4]) : 1, super.setStyle(_, O);
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (N = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(F)) return this.a = "hsla" === k ? parseFloat(N[4]) : 1, super.setStyle(_, O)
                            }
                        }
                        return super.setStyle(_, O)
                    }
                    get x() {
                        return this.r
                    }
                    get y() {
                        return this.g
                    }
                    get z() {
                        return this.b
                    }
                    get w() {
                        return this.a
                    }
                    set x(_) {
                        this.r = _
                    }
                    set y(_) {
                        this.g = _
                    }
                    set z(_) {
                        this.b = _
                    }
                    set w(_) {
                        this.a = _
                    }
                },
                x9 = class extends x4 {
                    constructor(_) {
                        super("v4"), this.nodeType = "Vector4", this.value = _ instanceof x8 ? _ : new x8(_.r, _.g, _.b, _.a)
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format("vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")", N, O)
                    }
                },
                x7 = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
                be = /[a-z_0-9]+/gi,
                bt = class extends x3 {
                    constructor(_, O, B, N, k) {
                        super(k), this.src = "", this.nodeType = "Function", this.useKeywords = !0, this.includes = [], this.extensions = {}, this.keywords = {}, this.isMethod = void 0 === k, this.isInterface = !1, this.parse(_, O, B, N)
                    }
                    getShared(_, O) {
                        return !this.isMethod
                    }
                    getType(_) {
                        return _.getTypeByFormat(this.type)
                    }
                    getInputByName(_) {
                        if (this.inputs) {
                            let O = this.inputs.length;
                            for (; O--;)
                                if (this.inputs[O].name === _) return this.inputs[O]
                        }
                    }
                    getIncludeByName(_) {
                        if (this.includes) {
                            let O = this.includes.length;
                            for (; O--;)
                                if (this.includes[O].name === _) return this.includes[O]
                        }
                    }
                    generate(_, O, B, N, k) {
                        let F, U = 0,
                            j = this.src;
                        if (this.includes)
                            for (let O = 0; O < this.includes.length; O++) _.include(this.includes[O], this);
                        for (let O in this.extensions) _.extensions[O] = !0;
                        let G = [];
                        for (; F = be.exec(this.src);) G.push(F);
                        for (let O = 0; O < G.length; O++) {
                            let B = G[O],
                                N = B[0],
                                k = !this.isMethod || !this.getInputByName(N),
                                F = N;
                            if (this.keywords[N] || this.useKeywords && k && x0.containsKeyword(N)) {
                                let O = this.keywords[N];
                                if (!O) {
                                    let B = x0.getKeywordData(N);
                                    B.cache && (O = _.keywords[N]), O = O || x0.getKeyword(N, _), B.cache && (_.keywords[N] = O)
                                }
                                F = O.build(_)
                            }
                            N !== F && "." !== j[B.index + U - 1] && (j = j.substring(0, B.index + U) + F + j.substring(B.index + N.length + U), U += F.length - N.length), void 0 === this.getIncludeByName(F) && x0.contains(F) && _.include(x0.get(F))
                        }
                        return "source" === O ? j : this.isMethod ? (this.isInterface || _.include(this, void 0, j), this.name) : _.format("( " + j + " )", this.getType(_), O)
                    }
                    parse(_, O, B, N) {
                        if (this.src = _ || "", this.includes = O ? ? [], this.extensions = B ? ? {}, this.keywords = N ? ? {}, this.isMethod) {
                            let _ = x7.exec(this.src);
                            if (this.inputs = [], _ && 4 == _.length) {
                                this.type = _[1], this.name = _[2];
                                let O = _[3].match(be);
                                if (O) {
                                    let _ = 0;
                                    for (; _ < O.length;) {
                                        let B = O[_++],
                                            N;
                                        "in" === B || "out" === B || "inout" === B ? N = O[_++] : (N = B, B = "");
                                        let k = O[_++];
                                        this.inputs.push({
                                            name: k,
                                            type: N,
                                            qualifier: B
                                        })
                                    }
                                }
                                this.isInterface = -1 === this.src.indexOf("{")
                            } else this.type = "", this.name = ""
                        }
                    }
                },
                bi = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,
                br = class extends x3 {
                    constructor(_ = "", O) {
                        super(), this.src = "", this.useDefine = !1, this.nodeType = "Const", this.parse(_ || br.PI, void 0, void 0, void 0, O)
                    }
                    getType(_) {
                        return _.getTypeByFormat(this.type)
                    }
                    parse(_, O, B, N, k) {
                        this.src = _ || "";
                        let F, U, j = "",
                            G = bi.exec(_);
                        this.useDefine = k ? ? "#" === this.src.charAt(0), G && G.length > 1 ? (U = G[1], F = G[2], j = G[3]) : (F = this.src, U = "f"), this.name = F, this.type = U, this.value = j
                    }
                    build(_, O) {
                        if ("source" === O) {
                            if (this.value) return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";";
                            if (this.useDefine) return this.src
                        }
                        return _.include(this), _.format(this.name, this.getType(_), O)
                    }
                    generate(_, O, B, N, k) {
                        return _.format(this.name, this.getType(_), O)
                    }
                };
            br.PI = "PI", br.PI2 = "PI2", br.RECIPROCAL_PI = "RECIPROCAL_PI", br.RECIPROCAL_PI2 = "RECIPROCAL_PI2", br.LOG2 = "LOG2", br.EPSILON = "EPSILON";
            var bs = RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim"),
                ba = RegExp("s*(w*?)s*(w*?)(=|;)", "gim"),
                bn = class extends x3 {
                    constructor(_ = "") {
                        super(), this.inputs = [], this.src = "", this.nodeType = "Struct", this.parse(_)
                    }
                    getType(_) {
                        return _.getTypeByFormat(this.name)
                    }
                    getInputByName(_) {
                        let O = this.inputs.length;
                        for (; O--;)
                            if (this.inputs[O].name === _) return this.inputs[O]
                    }
                    generate(_, O, B, N, k) {
                        return "source" === O ? this.src + ";" : _.format("( " + this.src + " )", this.getType(_), O)
                    }
                    parse(_ = "") {
                        this.src = _, this.inputs = [];
                        let O = bs.exec(_);
                        if (O) {
                            let _ = O[2],
                                B;
                            for (; B = ba.exec(_);) this.inputs.push({
                                type: B[1],
                                name: B[2]
                            });
                            this.name = O[1]
                        } else this.name = "";
                        this.type = this.name
                    }
                },
                bo = class extends x3 {
                    constructor(_) {
                        super("v2", {
                            shared: !1
                        }), this.nodeType = "UV", this.index = _ ? ? 0
                    }
                    generate(_, O) {
                        _.requires.uv[this.index] = !0;
                        let B = this.index > 0 ? this.index + 1 : "",
                            N = _.isShader("vertex") ? "uv" + B : "vUv" + B;
                        return _.format(N, this.getType(_), O)
                    }
                };
            x0.addKeyword("uv", function() {
                return new bo
            }), x0.addKeyword("uv2", function() {
                return new bo(1)
            });
            var bl = class extends x3 {
                constructor(_, O) {
                    super("v4"), this.nodeType = "ColorSpace", this.input = _, this.method = O ? ? bl.LINEAR_TO_LINEAR, this.hashProperties = ["method"]
                }
                static getEncodingComponents(_) {
                    switch (_) {
                        case 3e3:
                            return ["Linear"];
                        case 3001:
                            return ["sRGB"];
                        default:
                            return []
                    }
                }
                generate(_, O) {
                    let B = this.input.build(_, "v4"),
                        N = this.getType(_),
                        k = bl.Nodes[this.method],
                        F = _.include(k);
                    if (F === bl.LINEAR_TO_LINEAR) return _.format(B, N, O);
                    if (k.inputs ? .length !== 2) return _.format(F + "( " + B + " )", N, O); {
                        let k = this.factor.build(_, "f");
                        return _.format(F + "( " + B + ", " + k + " )", N, O)
                    }
                }
                fromEncoding(_) {
                    let O = bl.getEncodingComponents(_);
                    this.method = "LinearTo" + O[0], this.factor = O[1]
                }
                fromDecoding(_) {
                    let O = bl.getEncodingComponents(_);
                    this.method = O[0] + "ToLinear", this.factor = O[1]
                }
            };
            bl.Nodes = {
                LinearToLinear: new bt(["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)),
                sRGBToLinear: new bt(["vec4 sRGBToLinear( in vec4 value ) {", "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );", "}"].join(`
`)),
                LinearTosRGB: new bt(["vec4 LinearTosRGB( in vec4 value ) {", "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );", "}"].join(`
`))
            }, bl.LINEAR_TO_LINEAR = "LinearToLinear", bl.SRGB_TO_LINEAR = "sRGBToLinear", bl.LINEAR_TO_SRGB = "LinearTosRGB";
            var bh = class extends bt {
                    constructor(_ = "", O, B, N, k) {
                        super(_, k, N, B, O), this.nodeType = "Expression"
                    }
                },
                bc = class extends x4 {
                    constructor(_ = new ro, O, B, N) {
                        super("v4", {
                            shared: !0
                        }), this.nodeType = "Texture", this.value = _, this.uv = O ? ? new bo, this.bias = B, this.project = void 0 !== N && N
                    }
                    getTexture(_, O) {
                        return super.generate(_, O, this.value.uuid, "t")
                    }
                    generate(_, O) {
                        let B, N;
                        if ("sampler2D" === O) return this.getTexture(_, O);
                        let k = this.getTexture(_, O),
                            F = this.uv.build(_, this.project ? "v4" : "v2"),
                            U = this.bias ? this.bias.build(_, "f") : void 0;
                        void 0 === U && _.context.bias && (U = _.context.bias.setTexture(this).build(_, "f")), B = this.project ? "texture2DProj" : U ? "tex2DBias" : "tex2D", N = U ? B + "( " + k + ", " + F + ", " + U + " )" : B + "( " + k + ", " + F + " )";
                        let j = {
                                include: _.isShader("vertex"),
                                ignoreCache: !0
                            },
                            G = this.getType(_);
                        return _.addContext(j), this.colorSpace = this.colorSpace ? ? new bl(new bh("", G)), this.colorSpace.fromDecoding(_.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(N), N = this.colorSpace.build(_, G), _.removeContext(), _.format(N, G, O)
                    }
                },
                bd = class extends x4 {
                    constructor(_) {
                        super("f"), this.nodeType = "Float", this.value = _ ? ? 0
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format(this.value + (this.value % 1 ? "" : ".0"), N, O)
                    }
                },
                bu = class extends x3 {
                    constructor(_, O) {
                        super(), this.inputs = [], this.nodeType = "FunctionCall", this.value = _, this.inputs = O ? ? []
                    }
                    getFunction() {
                        return this.value
                    }
                    getType(_) {
                        return this.value.getType(_)
                    }
                    generate(_, O, B, N, k) {
                        N = this.getType(_);
                        let F = this.value,
                            U = F.build(_, O) + "( ",
                            j = [];
                        if (F.inputs) {
                            for (let O = 0; O < F.inputs.length; O++) {
                                let B = F.inputs[O],
                                    N = this.inputs[O] || this.inputs[B.name];
                                j.push(N.build(_, _.getTypeByFormat(B.type)))
                            }
                            U += j.join(", ") + " )"
                        }
                        return _.format(U, N, O)
                    }
                },
                bp = class extends x3 {
                    constructor(_, O, B = bp.ADD) {
                        super(), this.nodeType = "Operator", this.type = _.type, this.a = _, this.b = O, this.op = B
                    }
                    getType(_) {
                        let O = this.a.getType(_),
                            B = this.b.getType(_);
                        return _.isTypeMatrix(O) ? "v4" : _.getTypeLength(B) > _.getTypeLength(O) ? B : O
                    }
                    generate(_, O) {
                        let B = this.getType(_);
                        this.type = B;
                        let N = this.a.build(_, B),
                            k = this.b.build(_, B);
                        return _.format("( " + N + " " + this.op + " " + k + " )", B, O)
                    }
                };
            bp.ADD = "+", bp.SUB = "-", bp.MUL = "*", bp.DIV = "/";
            var bf = class extends x3 {
                constructor(_, O = bf.ABS, B, N) {
                    super(), this.nodeType = "Math", this.a = _, "string" != typeof O ? this.b = O : N = O, "string" != typeof B ? this.c = B : N = B, this.method = N, this.hashProperties = ["method"]
                }
                getNumInputs(_) {
                    switch (this.method) {
                        case bf.MIX:
                        case bf.CLAMP:
                        case bf.REFRACT:
                        case bf.SMOOTHSTEP:
                        case bf.FACEFORWARD:
                            return 3;
                        case bf.MIN:
                        case bf.MAX:
                        case bf.MOD:
                        case bf.STEP:
                        case bf.REFLECT:
                        case bf.DISTANCE:
                        case bf.DOT:
                        case bf.CROSS:
                        case bf.POW:
                            return 2;
                        default:
                            return 1
                    }
                }
                getInputType(_) {
                    let O = _.getTypeLength(this.a.getType(_)),
                        B = this.b ? _.getTypeLength(this.b.getType(_)) : 0,
                        N = this.c ? _.getTypeLength(this.c.getType(_)) : 0;
                    return O > B && O > N ? this.a.getType(_) : B > N ? this.b.getType(_) : this.c.getType(_)
                }
                getType(_) {
                    switch (this.method) {
                        case bf.LENGTH:
                        case bf.DISTANCE:
                        case bf.DOT:
                            return "f";
                        case bf.CROSS:
                            return "v3"
                    }
                    return this.getInputType(_)
                }
                generate(_, O) {
                    let B, N, k, F = this.a ? _.getTypeLength(this.a.getType(_)) : 0,
                        U = this.b ? _.getTypeLength(this.b.getType(_)) : 0,
                        j = this.c ? _.getTypeLength(this.c.getType(_)) : 0,
                        G = this.getInputType(_),
                        Y = this.getType(_);
                    switch (this.type = Y, this.method) {
                        case bf.NEGATE:
                            return _.format("( -" + this.a.build(_, G) + " )", G, O);
                        case bf.INVERT:
                            return _.format("( 1.0 - " + this.a.build(_, G) + " )", G, O);
                        case bf.CROSS:
                            B = this.a.build(_, "v3"), N = this.b.build(_, "v3");
                            break;
                        case bf.STEP:
                            B = this.a.build(_, 1 === F ? "f" : G), N = this.b.build(_, G);
                            break;
                        case bf.MIN:
                        case bf.MAX:
                        case bf.MOD:
                            B = this.a.build(_, G), N = this.b.build(_, 1 === U ? "f" : G);
                            break;
                        case bf.REFRACT:
                            B = this.a.build(_, G), N = this.b.build(_, G), k = this.c.build(_, "f");
                            break;
                        case bf.MIX:
                            B = this.a.build(_, G), N = this.b.build(_, G), k = this.c.build(_, 1 === j ? "f" : G);
                            break;
                        default:
                            B = this.a.build(_, G), this.b && (N = this.b.build(_, G)), this.c && (k = this.c.build(_, G))
                    }
                    let Q = [];
                    Q.push(B), N && Q.push(N), k && Q.push(k);
                    let K = this.getNumInputs(_);
                    if (Q.length !== K) throw Error(`Arguments not match used in "${this.method}". Require ${K}, currently ${Q.length}.`);
                    return _.format(this.method + "( " + Q.join(", ") + " )", Y, O)
                }
            };
            bf.RAD = "radians", bf.DEG = "degrees", bf.EXP = "exp", bf.EXP2 = "exp2", bf.LOG = "log", bf.LOG2 = "log2", bf.SQRT = "sqrt", bf.INV_SQRT = "inversesqrt", bf.FLOOR = "floor", bf.CEIL = "ceil", bf.NORMALIZE = "normalize", bf.FRACT = "fract", bf.SATURATE = "saturate", bf.SIN = "sin", bf.COS = "cos", bf.TAN = "tan", bf.ASIN = "asin", bf.ACOS = "acos", bf.ARCTAN = "atan", bf.ABS = "abs", bf.SIGN = "sign", bf.LENGTH = "length", bf.NEGATE = "negate", bf.INVERT = "invert", bf.MIN = "min", bf.MAX = "max", bf.MOD = "mod", bf.STEP = "step", bf.REFLECT = "reflect", bf.DISTANCE = "distance", bf.DOT = "dot", bf.CROSS = "cross", bf.POW = "pow", bf.MIX = "mix", bf.CLAMP = "clamp", bf.REFRACT = "refract", bf.SMOOTHSTEP = "smoothstep", bf.FACEFORWARD = "faceforward";
            var bm = class extends x3 {
                constructor(_, O, B) {
                    super("v4"), this.nodeType = "TextureCubeUV", this.value = _, this.uv = O, this.bias = B
                }
                bilinearCubeUV(_, O, B, N) {
                    let k = new bu(bm.Nodes.bilinearCubeUV, [O, B, N]);
                    this.colorSpaceTL = this.colorSpaceTL ? ? new bl(new bh("", "v4")), this.colorSpaceTL.fromDecoding(_.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(k.build(_) + ".tl"), this.colorSpaceTR = this.colorSpaceTR ? ? new bl(new bh("", "v4")), this.colorSpaceTR.fromDecoding(_.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(k.build(_) + ".tr"), this.colorSpaceBL = this.colorSpaceBL ? ? new bl(new bh("", "v4")), this.colorSpaceBL.fromDecoding(_.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(k.build(_) + ".bl"), this.colorSpaceBR = this.colorSpaceBR ? ? new bl(new bh("", "v4")), this.colorSpaceBR.fromDecoding(_.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(k.build(_) + ".br");
                    let F = {
                        include: _.isShader("vertex"),
                        ignoreCache: !0
                    };
                    _.addContext(F), this.colorSpaceTLExp = new bh(this.colorSpaceTL.build(_, "v4"), "v4"), this.colorSpaceTRExp = new bh(this.colorSpaceTR.build(_, "v4"), "v4"), this.colorSpaceBLExp = new bh(this.colorSpaceBL.build(_, "v4"), "v4"), this.colorSpaceBRExp = new bh(this.colorSpaceBR.build(_, "v4"), "v4"), _.removeContext();
                    let U = new bh("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4");
                    return U.keywords.cubeUV_TL = this.colorSpaceTLExp, U.keywords.cubeUV_TR = this.colorSpaceTRExp, U.keywords.cubeUV_BL = this.colorSpaceBLExp, U.keywords.cubeUV_BR = this.colorSpaceBRExp, U.keywords.cubeUV = k, U
                }
                generate(_, O) {
                    if (!_.isShader("fragment")) return console.warn("TextureCubeUVNode is not compatible with " + _.shader + " shader."), _.format("vec4( 0.0 )", this.getType(_), O); {
                        let B = this.uv,
                            N = this.bias || _.context.roughness,
                            k = new bu(bm.Nodes.roughnessToMip, [N]),
                            F = new bf(k, bm.Nodes.m0, bm.Nodes.cubeUV_maxMipLevel, bf.CLAMP),
                            U = new bf(F, bf.FLOOR),
                            j = new bf(F, bf.FRACT),
                            G = this.bilinearCubeUV(_, this.value, B, U),
                            Y = this.bilinearCubeUV(_, this.value, B, new bp(U, new bd(1).setReadonly(!0), bp.ADD)),
                            Q = new bf(G, Y, j, bf.MIX);
                        return _.format(Q.build(_), "v4", O)
                    }
                }
            };
            bm.Nodes = (eK = new bn(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`), eJ = new br("float cubeUV_maxMipLevel 8.0", !0), e$ = new br("float cubeUV_minMipLevel 4.0", !0), e0 = new br("float cubeUV_maxTileSize 256.0", !0), e1 = new br("float cubeUV_minTileSize 16.0", !0), (e2 = new bt(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`)).useKeywords = !1, (e3 = new bt(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`)).useKeywords = !1, (e4 = new bt(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [eK, e2, e3, eJ, e$, e0, e1])).useKeywords = !1, e5 = new br("float r0 1.0", !0), e6 = new br("float v0 0.339", !0), e8 = new br("float m0 -2.0", !0), e9 = new br("float r1 0.8", !0), e7 = new br("float v1 0.276", !0), te = new br("float m1 -1.0", !0), tt = new br("float r4 0.4", !0), ti = new br("float v4 0.046", !0), tr = new br("float m4 2.0", !0), ts = new br("float r5 0.305", !0), ta = new br("float v5 0.016", !0), to = new br("float m5 3.0", !0), tl = new br("float r6 0.21", !0), th = new br("float v6 0.0038", !0), tc = new br("float m6 4.0", !0), {
                bilinearCubeUV: e4,
                roughnessToMip: new bt(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, [e5, e6, e8, e9, e7, te, tt, ti, tr, ts, ta, to, tl, th, tc]),
                m0: e8,
                cubeUV_maxMipLevel: eJ
            });
            var bg = class extends x3 {
                constructor(_) {
                    super("v3"), this.nodeType = "Normal", this.scope = _ ? ? bg.VIEW
                }
                getShared() {
                    return this.scope === bg.WORLD
                }
                build(_, O, B, N) {
                    let k = _.context[this.scope + "Normal"];
                    return k ? k.build(_, O, B, N) : super.build(_, O, B)
                }
                generate(_, O, B, N, k) {
                    let F;
                    switch (this.scope) {
                        case bg.VIEW:
                            F = _.isShader("vertex") ? "transformedNormal" : "geometryNormal";
                            break;
                        case bg.LOCAL:
                            _.isShader("vertex") ? F = "objectNormal" : (_.requires.normal = !0, F = "vObjectNormal");
                            break;
                        case bg.WORLD:
                            _.isShader("vertex") ? F = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (_.requires.worldNormal = !0, F = "vWNormal")
                    }
                    return _.format(F, this.getType(_), O)
                }
            };
            bg.LOCAL = "local", bg.WORLD = "world", bg.VIEW = "view", bg.NORMAL = "normal", x0.addKeyword("viewNormal", function() {
                return new bg(bg.VIEW)
            }), x0.addKeyword("localNormal", function() {
                return new bg(bg.NORMAL)
            }), x0.addKeyword("worldNormal", function() {
                return new bg(bg.WORLD)
            });
            var bv = class extends x3 {
                constructor(_) {
                    super("v3"), this.nodeType = "Position", this.scope = _ ? ? bv.LOCAL
                }
                getType() {
                    return this.scope === bv.PROJECTION ? "v4" : this.type
                }
                getShader() {
                    switch (this.scope) {
                        case bv.LOCAL:
                        case bv.WORLD:
                            return !1
                    }
                    return !0
                }
                generate(_, O, B, N, k) {
                    let F;
                    switch (this.scope) {
                        case bv.LOCAL:
                            _.isShader("vertex") ? F = "transformed" : (_.requires.position = !0, F = "vPosition");
                            break;
                        case bv.WORLD:
                            if (_.isShader("vertex")) return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
                            _.requires.worldPosition = !0, F = "vWPosition";
                            break;
                        case bv.VIEW:
                            F = _.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
                            break;
                        case bv.PROJECTION:
                            F = _.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )"
                    }
                    return _.format(F, this.getType(), O)
                }
            };
            bv.LOCAL = "local", bv.WORLD = "world", bv.VIEW = "view", bv.PROJECTION = "projection", x0.addKeyword("position", function() {
                return new bv
            }), x0.addKeyword("worldPosition", function() {
                return new bv(bv.WORLD)
            }), x0.addKeyword("viewPosition", function() {
                return new bv(bv.VIEW)
            });
            var bx = class extends x3 {
                constructor(_) {
                    super("v3"), this.nodeType = "Reflect", this.scope = _ ? ? bx.CUBE
                }
                getUnique(_) {
                    return !_.context.viewNormal
                }
                getType() {
                    return this.scope === bx.SPHERE ? "v2" : this.type
                }
                generate(_, O) {
                    let B = this.getUnique(_);
                    if (!_.isShader("fragment")) return console.warn("ReflectNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.type, O); {
                        let N;
                        switch (this.scope) {
                            case bx.VECTOR:
                                {
                                    let O = new bg(bg.VIEW),
                                        k = _.context.roughness,
                                        F = O.build(_, "v3"),
                                        U = new bv(bv.VIEW).build(_, "v3"),
                                        j = k ? k.build(_, "f") : void 0,
                                        G = `reflect( -normalize( ${U} ), ${F} )`;j && (G = `normalize( mix( ${G}, ${F}, ${j} * ${j} ) )`);
                                    let Y = `inverseTransformDirection( ${G}, viewMatrix )`;B ? (_.addNodeCode(`vec3 reflectVec = ${Y};`), N = "reflectVec") : N = Y;
                                    break
                                }
                            case bx.CUBE:
                                {
                                    let O = new bx(bx.VECTOR).build(_, "v3"),
                                        k = "vec3( -" + O + ".x, " + O + ".yz )";B ? (_.addNodeCode(`vec3 reflectCubeVec = ${k};`), N = "reflectCubeVec") : N = k;
                                    break
                                }
                            case bx.SPHERE:
                                {
                                    let O = "normalize( ( viewMatrix * vec4( " + new bx(bx.VECTOR).build(_, "v3") + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";B ? (_.addNodeCode(`vec2 reflectSphereVec = ${O};`), N = "reflectSphereVec") : N = O
                                }
                        }
                        return _.format(N, this.getType(), O)
                    }
                }
            };
            bx.CUBE = "cube", bx.SPHERE = "sphere", bx.VECTOR = "vector";
            var bb = class extends x3 {
                    constructor(_ = new bc, O, B) {
                        super("v4"), this.nodeType = "TextureCube", this.value = _, this.radianceNode = new bm(this.value, O ? ? new bx(bx.VECTOR), B), this.irradianceNode = new bm(this.value, new bg(bg.WORLD), new bd(1).setReadonly(!0))
                    }
                    generate(_, O) {
                        return _.isShader("fragment") ? (_.require("irradiance"), _.context.bias && _.context.bias.setTexture(this.value), ("irradiance" === _.slot ? this.irradianceNode : this.radianceNode).build(_, O)) : (console.warn("TextureCubeNode is not compatible with " + _.shader + " shader."), _.format("vec4( 0.0 )", this.getType(_), O))
                    }
                },
                bw = class extends x4 {
                    constructor(_ = new ac, O, B) {
                        super("v4", {
                            shared: !0
                        }), this.nodeType = "CubeTexture", this.value = _, this.uv = O ? ? new bx, this.bias = B
                    }
                    getTexture(_, O) {
                        return super.generate(_, O, this.value.uuid, "tc")
                    }
                    generate(_, O) {
                        let B;
                        if ("samplerCube" === O) return this.getTexture(_, O);
                        let N = this.getTexture(_, O),
                            k = this.uv ? .build(_, "v3"),
                            F = this.bias ? this.bias.build(_, "f") : void 0;
                        void 0 === F && _.context.bias && (F = _.context.bias.setTexture(this).build(_, "f")), B = F ? "texCubeBias( " + N + ", " + k + ", " + F + " )" : "texCube( " + N + ", " + k + " )";
                        let U = {
                                include: _.isShader("vertex"),
                                ignoreCache: !0
                            },
                            j = this.getType(_);
                        return _.addContext(U), this.colorSpace = this.colorSpace ? ? new bl(new bh("", j)), this.colorSpace.fromDecoding(_.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(B), B = this.colorSpace.build(_, j), _.removeContext(), _.format(B, j, O)
                    }
                },
                b_ = `
uniform int frameIndex;
uniform vec2 resolution;
uniform mat4 previousModelViewMatrix;
uniform mat4 previousProjectionMatrix;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
`,
                bS = `
layout(location = 1) out vec4 gVelocity;

uniform int frameIndex;
uniform vec2 resolution;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;

const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos) {
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

`,
                bA = `
// TODO: This could be generated CPU side and passed to the shader every frame
const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

// TODO: Pass correct view size
vec2 offset = haltonSequence[frameIndex];
offset.x /= resolution.x;
offset.y /= resolution.y;

vec4 currentPosition = gl_Position;
vec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);

// We want to calculate the velocity with unjittered positions
// so that things that are not moving get a velocity = 0
vCurrentPosition = currentPosition;
vPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);
#ifdef OUTLINE_COMPENSATION
vPreviousPosition.xy += OUTLINE_COMPENSATION;
#endif
gl_Position = currentPositionJittered;

`,
                bM = `
vec2 oldPos = vPreviousPosition.xy;
    oldPos /= vPreviousPosition.w;
    oldPos.xy = (oldPos.xy+1.)/2.0;

vec2 newPos = vCurrentPosition.xy;
    newPos /= vCurrentPosition.w;
    newPos.xy = (newPos.xy+1.)/2.0;

vec2 velocity = (newPos - oldPos);

// Discard fully transparent pixels 
if (gl_FragColor.a <= 0.0) discard;

gVelocity = vec4(velocity, 0.0, 1.0);
`,
                bC = ["x", "y", "z", "w"],
                bT = ["float", "vec2", "vec3", "vec4"],
                bI = {
                    float: "f",
                    vec2: "v2",
                    vec3: "v3",
                    vec4: "v4",
                    mat4: "v4",
                    int: "i",
                    bool: "b",
                    "float[]": "f[]",
                    "vec4[]": "v4[]"
                },
                bO = {
                    t: "sampler2D",
                    tc: "samplerCube",
                    b: "bool",
                    i: "int",
                    f: "float",
                    c: "vec3",
                    v2: "vec2",
                    v3: "vec3",
                    v4: "vec4",
                    m3: "mat3",
                    m4: "mat4",
                    "f[]": "float[]",
                    "v4[]": "vec4[]"
                },
                bL = class {
                    constructor() {
                        this.includes = {
                            consts: {},
                            functions: {},
                            structs: {}
                        }, this.cache = "", this.slot = "", this.shader = "", this.context = {}, this.needsJitter = !0, this.getIncludesCode = function() {
                            function t(_, O) {
                                return _.deps.length - O.deps.length
                            }
                            return function(_, O) {
                                let B = this.getIncludes(_, O);
                                if (!B) return "";
                                let N = "";
                                B = B.sort(t);
                                for (let _ = 0; _ < B.length; _++) B[_].src && (N += B[_].src + `
`);
                                return N
                            }
                        }(), this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.fragmentParsVariables = {}, this.vertexParsVariables = {}, this.requires = {
                            uv: [],
                            color: [],
                            transparent: !1,
                            irradiance: !1,
                            position: !1,
                            worldPosition: !1,
                            normal: !1,
                            worldNormal: !1,
                            vWorldViewDir: !1,
                            modelMatrix: !1,
                            viewMatrix: !1,
                            projectionMatrix: !1
                        }, this.includes = {
                            consts: [],
                            functions: [],
                            structs: []
                        }, this.attributes = {}, this.prefixCode = ["#ifdef TEXTURE_LOD_EXT", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)", "#else", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCube(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2D(a, b, c)", "#endif", `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`, "#include <packing>", "#include <common>"].join(`
`), this.parsCode = {
                            vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`),
                            fragment: ["float accumAlpha = 0.0;", `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`, ""].join(`
`)
                        }, this.code = {
                            vertex: "",
                            fragment: ""
                        }, this.nodeCode = {
                            vertex: "",
                            fragment: ""
                        }, this.resultCode = {
                            vertex: "",
                            fragment: ""
                        }, this.finalCode = {
                            vertex: "",
                            fragment: ""
                        }, this.inputs = {
                            uniforms: {
                                list: [],
                                vertex: [],
                                fragment: []
                            },
                            arrayUniforms: {
                                list: [],
                                vertex: [],
                                fragment: []
                            },
                            vars: {
                                varying: [],
                                vertex: [],
                                fragment: []
                            }
                        }, this.defines = {}, this.uniforms = {}, this.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1
                        }, this.updaters = [], this.nodes = [], this.analyzing = !1
                    }
                    build(_, O) {
                        this.addVertexParsCode(b_), this.addFragmentParsCode(bS), this.buildShader("vertex", _), this.buildShader("fragment", O);
                        for (let _ = 0; _ < this.requires.uv.length; _++)
                            if (this.requires.uv[_]) {
                                let O = _ > 0 ? _ + 1 : "";
                                this.addVaryCode("varying vec2 vUv" + O + ";"), _ > 0 && this.addVertexParsCode("attribute vec2 uv" + O + ";"), this.addVertexFinalCode("vUv" + O + " = uv" + O + ";")
                            }
                        return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition, this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.modelMatrix && this.addFragmentParsCode("uniform mat4 modelMatrix;"), this.requires.viewMatrix && this.addFragmentParsCode("uniform mat4 viewMatrix;"), this.requires.projectionMatrix && this.addFragmentParsCode("uniform mat4 projectionMatrix;"), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this.needsJitter && (this.addVertexFinalCode(bA), this.addFragmentFinalCode(bM)), this
                    }
                    buildShader(_, O) {
                        this.resultCode[_] = O.build(this.setShader(_), "v4")
                    }
                    setMaterial(_, O) {
                        return this.defines = {}, this
                    }
                    addFlow(_, O, B) {
                        return this.addSlot(_).addCache(O).addContext(B)
                    }
                    removeFlow() {
                        return this.removeSlot().removeCache().removeContext()
                    }
                    addCache(_) {
                        return this.cache = _ ? ? "", this.caches.push(this.cache), this
                    }
                    removeCache() {
                        return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this
                    }
                    addContext(_) {
                        return this.context = Object.assign({}, this.context, _), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this
                    }
                    removeContext() {
                        return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this
                    }
                    addSlot(_) {
                        return this.slot = _ || "", this.slots.push(this.slot), this
                    }
                    removeSlot() {
                        return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this
                    }
                    addFragmentVariable(_, O) {
                        void 0 === this.fragmentVariables[_] && (this.addFragmentCode(`${O} ${_};`), this.fragmentVariables[_] = "")
                    }
                    addFragmentParsVariable(_, O) {
                        void 0 === this.fragmentParsVariables[_] && (this.addFragmentParsCode(`${O} ${_};`), this.fragmentParsVariables[_] = "")
                    }
                    addVertexParsVariable(_, O) {
                        void 0 === this.vertexParsVariables[_] && (this.addVertexParsCode(`${O} ${_};`), this.vertexParsVariables[_] = "")
                    }
                    addVertexCode(_) {
                        this.addCode(_, "vertex")
                    }
                    addFragmentCode(_) {
                        this.addCode(_, "fragment")
                    }
                    addCode(_, O) {
                        this.code[O ? ? this.shader] += _ + `
`
                    }
                    addVertexNodeCode(_) {
                        this.addNodeCode(_, "vertex")
                    }
                    addFragmentNodeCode(_) {
                        this.addNodeCode(_, "fragment")
                    }
                    addNodeCode(_, O) {
                        this.nodeCode[O ? ? this.shader] += _ + `
`
                    }
                    clearNodeCode(_) {
                        _ = _ ? ? this.shader;
                        let O = this.nodeCode[_];
                        return this.nodeCode[_] = "", O
                    }
                    clearVertexNodeCode() {
                        return this.clearNodeCode("vertex")
                    }
                    clearFragmentNodeCode() {
                        return this.clearNodeCode("fragment")
                    }
                    addVertexFinalCode(_) {
                        this.addFinalCode(_, "vertex")
                    }
                    addFragmentFinalCode(_) {
                        this.addFinalCode(_, "fragment")
                    }
                    addFinalCode(_, O) {
                        this.finalCode[O ? ? this.shader] += _ + `
`
                    }
                    addVertexParsCode(_) {
                        this.addParsCode(_, "vertex")
                    }
                    addFragmentParsCode(_) {
                        this.addParsCode(_, "fragment")
                    }
                    addParsCode(_, O) {
                        this.parsCode[O ? ? this.shader] += _ + `
`
                    }
                    addVaryCode(_) {
                        this.addVertexParsCode(_), this.addFragmentParsCode(_)
                    }
                    isCache(_) {
                        return -1 !== this.caches.indexOf(_)
                    }
                    isSlot(_) {
                        return -1 !== this.slots.indexOf(_)
                    }
                    define(_, O) {
                        this.defines[_] = void 0 === O ? 1 : O
                    }
                    require(_) {
                        this.requires[_] = !0
                    }
                    isDefined(_) {
                        return void 0 !== this.defines[_]
                    }
                    getVar(_, O, B, N = "varying", k = "V", F = "") {
                        let U = this.getVars(N),
                            j = U[_];
                        if (!j) {
                            let N = U.length;
                            j = {
                                name: B || "node" + k + N + (F ? "_" + F : ""),
                                type: O
                            }, U.push(j), U[_] = j
                        }
                        return j
                    }
                    getTempVar(_, O, B, N) {
                        return this.getVar(_, O, B, this.shader, "T", N)
                    }
                    getAttribute(_, O) {
                        if (!this.attributes[_]) {
                            let B = this.getVar(_, O);
                            this.addVertexParsCode("attribute " + O + " " + _ + ";"), this.addVertexFinalCode(B.name + " = " + _ + ";"), this.attributes[_] = {
                                varying: B,
                                name: _,
                                type: O
                            }
                        }
                        return this.attributes[_]
                    }
                    getCode(_) {
                        return [this.prefixCode, this.parsCode[_], this.getVarListCode(this.getVars("varying"), "varying"), this.getVarListCode(this.inputs.uniforms[_], "uniform"), this.getVarListCode(this.inputs.arrayUniforms[_], "uniform"), this.getIncludesCode("consts", _), this.getIncludesCode("structs", _), this.getIncludesCode("functions", _), "void main() {", this.getVarListCode(this.getVars(_)), this.code[_], this.resultCode[_], this.finalCode[_], "}"].join(`
`)
                    }
                    getVarListCode(_, O) {
                        O = O ? ? "";
                        let B = "";
                        for (let N = 0, k = _.length; N < k; ++N) {
                            let k = _[N],
                                F = k.type,
                                U = k.name,
                                j = k.size,
                                G = this.getFormatByType(F);
                            if (void 0 === G) throw Error("Node pars " + G + " not found.");
                            G.includes("[]") ? B += O + " " + G.substring(0, G.length - 2) + " " + U + `[${j}];
` : B += O + " " + G + " " + U + `;
`
                        }
                        return B
                    }
                    getVars(_) {
                        return this.inputs.vars[_ ? ? this.shader]
                    }
                    getNodeData(_) {
                        let O = _ instanceof x$ ? _.uuid : _;
                        return this.nodeData[O] = this.nodeData[O] || {}
                    }
                    createUniform(_, O, B, N, k, F) {
                        if (O.includes("[]")) {
                            let U = this.inputs.arrayUniforms,
                                j = U.list.length,
                                G = new xJ({
                                    type: O,
                                    size: B.size,
                                    name: N || "nodeUA" + j + (F ? "_" + F : ""),
                                    node: B,
                                    needsUpdate: k
                                });
                            return U.list.push(G), U[_].push(G), U[_][G.name] = G, this.uniforms[G.name] = G, G
                        } {
                            let U = this.inputs.uniforms,
                                j = U.list.length,
                                G = new xJ({
                                    type: O,
                                    name: N || "nodeU" + j + (F ? "_" + F : ""),
                                    node: B,
                                    needsUpdate: k
                                });
                            return U.list.push(G), U[_].push(G), U[_][G.name] = G, this.uniforms[G.name] = G, G
                        }
                    }
                    createVertexUniform(_, O, B, N, k) {
                        return this.createUniform("vertex", _, O, B, N, k)
                    }
                    createFragmentUniform(_, O, B, N, k) {
                        return this.createUniform("fragment", _, O, B, N, k)
                    }
                    include(_, O, B) {
                        let N;
                        if (_ = "string" == typeof _ ? x0.get(_) : _, !1 === this.context.include) return _.name;
                        _ instanceof bt ? N = this.includes.functions : _ instanceof br ? N = this.includes.consts : _ instanceof bn && (N = this.includes.structs);
                        let k = N[this.shader] = N[this.shader] || [];
                        if (_) {
                            let N = k[_.name];
                            if (N || (N = k[_.name] = {
                                    node: _,
                                    deps: []
                                }, k.push(N), N.src = _.build(this, "source")), _ instanceof bt && O && k[O.name] && -1 === k[O.name].deps.indexOf(_) && (k[O.name].deps.push(_), _.includes ? .length)) {
                                let B = 0;
                                do this.include(_.includes[B++], O); while (B < _.includes.length)
                            }
                            return B && (N.src = B), _.name
                        }
                        throw Error("Include not found.")
                    }
                    colorToVectorProperties(_) {
                        return _.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w")
                    }
                    colorToVector(_) {
                        return _.replace(/c/g, "v3")
                    }
                    getIncludes(_, O) {
                        return this.includes[_][O || this.shader]
                    }
                    getConstructorFromLength(_) {
                        return bT[_ - 1]
                    }
                    isTypeMatrix(_) {
                        return /^m/.test(_)
                    }
                    getTypeLength(_) {
                        return "f" === _ ? 1 : parseInt(this.colorToVector(_).substr(1))
                    }
                    getTypeFromLength(_) {
                        return 1 === _ ? "f" : "v" + _
                    }
                    findNode(..._) {
                        for (let O = 0; O < arguments.length; O++) {
                            let B = _[O];
                            if (B ? .isNode) return B
                        }
                    }
                    resolve(..._) {
                        for (let O = 0; O < arguments.length; O++) {
                            let B = _[O];
                            if (void 0 !== B) {
                                if (B.isNode) return B;
                                if (B.isTexture) switch (B.mapping) {
                                    case 301:
                                    case 302:
                                        return new bw(B);
                                    case 306:
                                        return new bb(new bc(B));
                                    default:
                                        return new bc(B)
                                } else {
                                    if (B.isVector2) return new x5(B);
                                    if (B.isVector3) return new x6(B);
                                    if (B.isVector4) return new x9(B)
                                }
                            }
                        }
                    }
                    format(_, O, B) {
                        switch (this.colorToVector(B + " <- " + O)) {
                            case "f <- v2":
                            case "f <- v3":
                            case "f <- v4":
                                return _ + ".x";
                            case "f <- i":
                            case "f <- b":
                                return "float( " + _ + " )";
                            case "v2 <- f":
                                return "vec2( " + _ + " )";
                            case "v2 <- v3":
                            case "v2 <- v4":
                                return _ + ".xy";
                            case "v2 <- i":
                            case "v2 <- b":
                            case "v3 <- i":
                            case "v3 <- b":
                                return "vec2( float( " + _ + " ) )";
                            case "v3 <- f":
                                return "vec3( " + _ + " )";
                            case "v3 <- v2":
                                return "vec3( " + _ + ", 0.0 )";
                            case "v3 <- v4":
                                return _ + ".xyz";
                            case "v4 <- f":
                                return "vec4( " + _ + " )";
                            case "v4 <- v2":
                                return "vec4( " + _ + ", 0.0, 1.0 )";
                            case "v4 <- v3":
                                return "vec4( " + _ + ", 1.0 )";
                            case "v4 <- i":
                            case "v4 <- b":
                                return "vec4( float( " + _ + " ) )";
                            case "i <- f":
                            case "i <- b":
                                return "int( " + _ + " )";
                            case "i <- v2":
                            case "i <- v3":
                            case "i <- v4":
                                return "int( " + _ + ".x )";
                            case "b <- f":
                                return "( " + _ + " != 0.0 )";
                            case "b <- v2":
                                return "( " + _ + " != vec2( 0.0 ) )";
                            case "b <- v3":
                                return "( " + _ + " != vec3( 0.0 ) )";
                            case "b <- v4":
                                return "( " + _ + " != vec4( 0.0 ) )";
                            case "b <- i":
                                return "( " + _ + " != 0 )"
                        }
                        return _
                    }
                    getTypeByFormat(_) {
                        return bI[_] || _
                    }
                    getFormatByType(_) {
                        return bO[_] || _
                    }
                    getUUID(_, O) {
                        return (O = void 0 === O || O) && this.cache && (_ = this.cache + "-" + _), _
                    }
                    getElementByIndex(_) {
                        return bC[_]
                    }
                    getIndexByElement(_) {
                        return bC.indexOf(_)
                    }
                    isShader(_) {
                        return this.shader === _
                    }
                    setShader(_) {
                        return this.shader = _, this
                    }
                    mergeDefines(_) {
                        for (let O in _) this.defines[O] = _[O];
                        return this.defines
                    }
                    mergeUniform(_) {
                        for (let O in _) this.uniforms[O] = _[O];
                        return this.uniforms
                    }
                    getTextureEncodingFromMap(_) {
                        let O;
                        return _ ? _.isTexture && (O = _.encoding) : O = 3e3, 3e3 === O && this.context.gamma && (O = 3001), O
                    }
                },
                bB = class extends x4 {
                    constructor(_ = 0, O, B, N) {
                        super("c"), this.nodeType = "Color", this.value = _ instanceof x8 ? _ : new x8(_ || 0, O, B, N)
                    }
                    setRGBA(_) {
                        this.value.setRGBA(_.r, _.g, _.b, _.a)
                    }
                    generate(_, O, B, N, k, F) {
                        B = _.getUUID(B ? ? this.getUUID()), N = N ? ? this.getType(_);
                        let U = _.getNodeData(B),
                            j = this.getReadonly() && void 0 !== this.generateReadonly;
                        if (this.alpha) {
                            let O = this.alpha.build(_, "f");
                            _.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${O};`)
                        }
                        return j ? this.generateReadonly(_, O, B, N, k, F) : _.isShader("vertex") ? (U.vertex || (U.vertex = _.createVertexUniform(N, this, k, F, this.getLabel())), _.format(U.vertex.name, N, O)) : (U.fragment || (U.fragment = _.createFragmentUniform(N, this, k, F, this.getLabel())), _.format(U.fragment.name, N, O))
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", N, O)
                    }
                },
                bz = class extends x4 {
                    constructor(_) {
                        super("i"), this.nodeType = "Int", this.value = Math.floor(_ ? ? 0)
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format(this.value.toString(), N, O)
                    }
                },
                bN = class extends x4 {
                    constructor(_) {
                        super("b"), this.nodeType = "Bool", this.value = _ ? ? !1
                    }
                    generateReadonly(_, O, B, N) {
                        return _.format(this.value ? "true" : "false", N, O)
                    }
                },
                bk = class extends x4 {
                    constructor(_ = 1, O) {
                        super("f[]"), this.nodeType = "FloatArray", this.size = _, this.value = Array.isArray(O) ? O : "number" == typeof O ? Array(_).fill(O) : Array(_).fill(0)
                    }
                },
                bF = class extends x4 {},
                bU = class extends bF {
                    constructor(_) {
                        super("v3"), this.image = _, this._value = new rv
                    }
                    get value() {
                        return this._value.x = this.image.isVideo ? this.image.img.videoWidth ? ? 0 : this.image.img.width, this._value.y = this.image.isVideo ? this.image.img.videoHeight ? ? 0 : this.image.img.height, this._value
                    }
                },
                bj = class extends bF {
                    constructor(_, O) {
                        super("t"), this.image = _, this.wrap = O
                    }
                    get value() {
                        return this.image.getTexture(this.wrap)
                    }
                },
                bG = class extends x4 {
                    constructor(_) {
                        super("m3"), this.nodeType = "Matrix3", this.value = _ ? ? new i$
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format("mat3(" + this.value.elements.join(", ") + ")", N, O)
                    }
                    get elements() {
                        return this.value.elements
                    }
                    set elements(_) {
                        this.value.fromArray(_)
                    }
                },
                bH = class extends x4 {
                    constructor(_) {
                        super("m4"), this.nodeType = "Matrix4", this.value = _ ? ? new rJ
                    }
                    generateReadonly(_, O, B, N, k, F) {
                        return _.format("mat4(" + this.value.elements.join(", ") + ")", N, O)
                    }
                    get elements() {
                        return this.value.elements
                    }
                    set elements(_) {
                        this.value.fromArray(_)
                    }
                };

            function iI(_, O, B) {
                _.setUvTransform(B[0], B[1], O[0], O[1], 0, 0, 0)
            }
            var bW = class extends bG {
                    constructor(_, O) {
                        super(new i$), this.repeat = _, this.offset = O, iI(this.value, _, O)
                    }
                    updateMatrix() {
                        iI(this.value, this.repeat, this.offset)
                    }
                },
                bY = class extends x4 {
                    constructor(_ = 1, O) {
                        super("v4[]"), this.nodeType = "Vector4Array", this.size = _, this.value = Array.isArray(O) ? O : O instanceof rl ? Array(_).fill(O) : Array(_).fill(new rl(0))
                    }
                },
                bX = class extends x3 {
                    constructor(_, O, B, N) {
                        super("v3"), this.nodeType = "Blend", this.a = _, this.b = O, this.alpha = B, this.mode = N
                    }
                    generate(_, O) {
                        if (!_.isShader("fragment")) return console.warn("BlendNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                            let B = [];
                            return B.push(this.a.build(_, "c")), B.push(this.b.build(_, "c")), B.push(this.alpha.build(_, "f")), B.push(this.mode.build(_, "i")), _.format("spe_blend(" + B.join(",") + ")", this.getType(_), O)
                        }
                    }
                },
                bQ = class extends x3 {
                    constructor(_, O) {
                        super("v3"), this.nodeType = "CustomColor", this.color = _, this.alpha = O, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                    }
                    generate(_, O) {
                        if (!_.isShader("fragment")) return console.warn("CustomColorNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                            let B = _.include(bQ.Nodes.customColor);
                            _.addFragmentVariable(this.calpha, "float");
                            let N = [];
                            return N.push(this.color.build(_, "v3")), N.push(this.mask ? `luminance(${this.mask.build(_,"v3")})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                        }
                    }
                };
            bQ.Nodes = {
                customColor: new bt(`vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color;
			}`)
            };
            var bZ = class extends x3 {
                constructor(_, O) {
                    super("v3"), this.nodeType = "CustomNormal", this.cnormal = _, this.alpha = O, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    if (!_.isShader("fragment")) return console.warn("CustomNormalNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                        let B = _.include(bZ.Nodes.customNormal);
                        _.addFragmentVariable(this.calpha, "float");
                        let N = [];
                        return N.push(this.cnormal.build(_, "v3")), N.push("normal"), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            bZ.Nodes = {
                customNormal: new bt(`vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return normal;
			}`)
            };
            var bK = class extends x3 {
                constructor(_, O, B, N, k, F, U, j, G, Y, Q, K) {
                    super("v3"), this.nodeType = "CustomTexture", this.texture = _, this.textureSize = O, this.crop = B, this.projection = N, this.axis = k, this.side = F, this.size = U, this.blending = j, this.mat = G, this.isMask = K, this.alpha = Y, this.mode = Q, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    _.require("position"), _.require("normal"), _.require("uv"), _.requires.uv = [!0], _.extensions.shaderTextureLOD = !0, _.extensions.derivatives = !0;
                    let B = `g${this.uuid.toString().replace(/-/g,"")}`,
                        N;
                    switch (this.projection.value) {
                        case 3:
                            N = _.include(bK.Nodes.cylindrical);
                            break;
                        case 2:
                            N = _.include(bK.Nodes.spherical);
                            break;
                        case 1:
                            let k = ["vec3(1.0, 0.0, 0.0)", "vec3(0.0, 1.0, 0.0)", "vec3(0.0, 0.0, 1.0)"][this.axis.value],
                                F = ["zy", "xz", "xy"][this.axis.value],
                                U = new bt(`
		vec3 ${B}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 projected = (1. + (position.${F})) / 2.;
				vec2 uvs = ( mat * vec3( (projected * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${2===this.side.value?"":`lalpha *= step(0.0, ${1===this.side.value?"-1.0 * ":""}dot(vObjectNormal, ${k}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`);
                            N = _.include(U);
                            break;
                        case 4:
                            N = _.include(bK.Nodes.triplanar);
                            break;
                        default:
                            N = _.include(bK.Nodes.uv)
                    }
                    _.addFragmentVariable(this.calpha, "float");
                    let j = [];
                    if (j.push("normal"), j.push(this.texture.generate(_, "t")), j.push(this.textureSize.build(_, "v2")), j.push(this.crop.build(_, "f")), j.push(this.mat.build(_, "mat3")), j.push(this.size.build(_, "v2")), j.push(this.blending.build(_, "f")), j.push(this.isMask.build(_, "b")), j.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), j.push(this.alpha.build(_, "f")), j.push(this.mode.build(_, "i")), j.push(this.calpha), 4 === this.projection.value) {
                        let O = `${B}_writeUvs`,
                            N = O + "0",
                            k = O + "1",
                            F = O + "2",
                            U = `${B}_triplanarWeights`;
                        _.addFragmentVariable(N, "vec2"), _.addFragmentVariable(k, "vec2"), _.addFragmentVariable(F, "vec2"), _.addFragmentVariable(U, "vec3"), j.push(N), j.push(k), j.push(F), j.push(U)
                    } else {
                        let O = `${B}_writeUvs`;
                        _.addFragmentVariable(O, "vec2"), j.push(O)
                    }
                    return _.format(N + "(" + j.join(",") + ")", this.getType(_), O)
                }
            };
            bK.Nodes = {
                cylindrical: new bt(`
vec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
                spherical: new bt(`
vec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
                uv: new bt(`vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`),
                triplanar: new bt(`vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUvs0, out vec2 writeUvs1, out vec2 writeUvs2, out vec3 writeWeights) {
				vec3 p = position;
				vec2 uv0 = (1.0 + p.xy) / 2.0;     
				vec2 uv1 = (1.0 + p.zy) / 2.0;		
				vec2 uv2 = (1.0 + p.xz) / 2.0;		
	
				uv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;

				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));

				// Write out all sets of UVs that we generated
				writeUvs0 = uv0;
				writeUvs1 = uv1;
				writeUvs2 = uv2;
				writeWeights = weights;

				// Derivatives for LOD
				vec2 df0 = fwidth(uv0);
				vec2 df1 = fwidth(uv1);
				vec2 df2 = fwidth(uv2);
				if (df0.x > 0.5) df0.x = 0.0;
				if (df1.x > 0.5) df1.x = 0.0;
				if (df2.x > 0.5) df2.x = 0.0;

				#ifdef GL_EXT_shader_texture_lod
                	vec4 tmp = 
						texture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						texture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						texture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#else
                	vec4 tmp = 
						textureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						textureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						textureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;

				// Apply cropping across all 3 planes
				if ( crop > 0.5 ) {
					if ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;//n * 0.5 + 0.5;
			}			
			`)
            };
            var bJ = class extends x3 {
                constructor(_, O, B, N, k, F, U, j, G, Y, Q, K) {
                    super("v3"), this.nodeType = "Depth", this.gradientType = _, this.smooth = O, this.near = B, this.far = N, this.isVector = k, this.isWorldSpace = F, this.origin = U, this.direction = j, this.colors = G, this.steps = Y, this.isMask = K, this.alpha = Q, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    let B = `g${this.uuid.toString().replace(/-/g,"")}`,
                        N = new bt(`vec3 ${B}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${B}_MAX_COLORS], float steps[${B}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${B}_IS_VECTOR
                   #ifdef ${B}_LINEAR
                       #ifdef ${B}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${B}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${B}_SMOOTH
				for ( int i = 1; i < ${B}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${B}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a * mask;
               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
			   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
			   
               return color.rgb;
			}`, [bJ.Nodes.vectorLinearWorldSpaceDepth, bJ.Nodes.vectorLinearObjectSpaceDepth, bJ.Nodes.vectorSphericalObjectSpaceDepth, bJ.Nodes.vectorSphericalWorldSpaceDepth]);
                    if (!_.isShader("fragment")) return console.warn("DepthNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                        _.define(`${B}_MAX_COLORS`, this.colors.value.length), this.smooth.value && _.define(`${B}_SMOOTH`), this.isVector.value > .5 && _.define(`${B}_IS_VECTOR`), 0 === this.gradientType.value && _.define(`${B}_LINEAR`), this.isWorldSpace.value > .5 && _.define(`${B}_WORLDSPACE`), _.require("worldPosition"), _.addFragmentVariable(this.calpha, "float");
                        let k = _.include(N),
                            F = [];
                        return F.push(this.near.build(_, "f")), F.push(this.far.build(_, "f")), F.push(this.origin.build(_, "v3")), F.push(this.direction.build(_, "v3")), F.push(this.colors.build(_, "v4[]")), F.push(this.steps.build(_, "f[]")), F.push(this.isMask.build(_, "b")), F.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), F.push(this.alpha.build(_, "f")), F.push(this.calpha), _.format(k + "(" + F.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            bJ.Nodes = {
                vectorLinearWorldSpaceDepth: new bt(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
                vectorLinearObjectSpaceDepth: new bt(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
                vectorSphericalWorldSpaceDepth: new bt(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),
                vectorSphericalObjectSpaceDepth: new bt(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`)
            };
            var b$ = class extends x3 {
                    constructor(_, O, B, N, k, F, U, j) {
                        super("v3"), this.nodeType = "Fresnel", this.color = _, this.bias = O, this.scale = B, this.intensity = N, this.factor = k, this.isMask = j, this.alpha = F, this.mode = U, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                    }
                    generate(_, O) {
                        if (_.require("vWorldViewDir"), _.require("worldNormal"), !_.isShader("fragment")) return console.warn("FresnelNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                            _.addFragmentVariable(this.calpha, "float");
                            let B = new bt(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {
					float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

					float lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return color;
				}`),
                                N = _.include(B),
                                k = [];
                            return k.push(this.color.build(_, "c")), k.push(this.bias.build(_, "f")), k.push(this.scale.build(_, "f")), k.push(this.intensity.build(_, "f")), k.push(this.factor.build(_, "f")), k.push(this.isMask.build(_, "b")), k.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), k.push(this.alpha.build(_, "f")), k.push(this.mode.build(_, "i")), k.push(this.calpha), _.format(N + "(" + k.join(",") + ")", this.getType(_), O)
                        }
                    }
                },
                b0 = class extends x3 {
                    constructor(_, O, B, N, k, F, U, j, G) {
                        super("v3"), this.nodeType = "Gradient", this.gradientType = _, this.smooth = O, this.colors = B, this.steps = N, this.offset = k, this.morph = F, this.angle = U, this.isMask = G, this.alpha = j, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                    }
                    generate(_, O) {
                        if (!_.isShader("fragment")) return console.warn("GradientNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                            _.define("GRAD_MAX", 10), _.require("uv"), _.requires.uv = [!0], _.addFragmentVariable(this.calpha, "float");
                            let B = _.include(b0.Nodes.gradient),
                                N = [];
                            return N.push(this.gradientType.build(_, "i")), N.push(this.smooth.build(_, "b")), N.push(this.colors.build(_, "v4[]")), N.push(this.steps.build(_, "f[]")), N.push(this.offset.build(_, "v2")), N.push(this.morph.build(_, "v2")), N.push(this.angle.build(_, "f")), N.push(this.isMask.build(_, "b")), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                        }
                    }
                };
            b0.Nodes = {
                gradient: new bt(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
				
				return color.xyz;
			}`)
            };
            var b3 = class extends x3 {
                constructor(_, O, B, N) {
                    super("v3"), this.nodeType = "Matcap", this.texture = _, this.isMask = N, this.alpha = O, this.mode = B, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    if (!_.isShader("fragment")) return console.warn("MatcapNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                        _.addFragmentVariable(this.calpha, "float");
                        let B = _.include(b3.Nodes.matcap);
                        _.require("normal"), _.requires.normal = !0;
                        let N = [];
                        return N.push(this.texture.generate(_, "t")), N.push("normal"), N.push(this.isMask.build(_, "b")), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.mode.build(_, "i")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            b3.Nodes = {
                matcap: new bt(`vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {
					vec3 viewDir = normalize( vViewPosition );
					vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
					vec3 y = cross( viewDir, x );
					vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
					vec4 matcapColor = texture2D( matcapTex, uv );

					float lalpha = alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
					
					return matcapColor.rgb;
            	}`)
            };
            var b4 = ((wl = b4 || {}).SIMPLEX = "simplex3d", wl.SIMPLEX_FRACTAL = "simplex3dFractal", wl.ASHIMA = "simplexAshima", wl.FBM = "fbm", wl.PERLIN = "perlin", wl.VORONOI = "voronoi", wl),
                b5 = (td = new bt(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`), (tu = new bt(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [td])).keywords.F3 = new br("float F3 0.3333333"), tu.keywords.G3 = new br("float G3 0.1666667"), tp = new bt(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [tu]), tf = new bt("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"), tm = new bt("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"), tg = new bt(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [tf, tm]), tx = new bt("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"), tb = new bt("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [tx]), t_ = new bt(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [tb]), (tS = new bt(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [t_])).keywords.NUM_OCTAVES = new br("int NUM_OCTAVES 5"), tA = new bt("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"), tM = new bt(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [tf, tm, tA]), tE = new bt(`float hashwithoutsine13(vec3 p3)
		{
			p3  = fract(p3 * .1031);
			p3 += dot(p3, p3.yzx + 33.33);
			return fract((p3.x + p3.y) * p3.z);
		}`), tC = new bt(`vec3 hashwithoutsine33(vec3 p3)
		{
			p3 = fract(p3 * vec3(.1031, .1030, .0973));
			p3 += dot(p3, p3.yxz+33.33);
			return fract((p3.xxy + p3.yxx)*p3.zyx);
		}`), tT = new bt(`float metric(in vec3 p)
		{
			// L2 
			return length(p);

			// Chebyshev 
			// vec3 a = abs(p);
			// return max(a.x, max(a.y, a.z));
		}`), tD = new bt(`float smin( float a, float b, float k )
		{
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);
			float correction = k * h * (1.0 - h);
			return mix(b, a, h) - correction;
		}`), tP = new bt(`float smax( float a, float b, float k )
		{
			float h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);
			float correction = k * h * (1.0 - h);
			return mix(a, b, h) + correction;
		}`), tI = new bt(`float remap(float value, float input_min, float input_max, float output_min, float output_max) {
			// Compute width of each interval
			float input_width = input_max - input_min;
			float output_width = output_max - output_min;
		
			// Convert input range into a 0-1 range 
			float scaled = (value - input_min) / input_width;
		
			// Convert the 0-1 range into a value in output range
			return output_min + (scaled * output_width);
		}`), {
                    simplex: tu,
                    simplexFractal: tp,
                    simplexAshima: tg,
                    fbm: tS,
                    perlin: tM,
                    voronoi: new bt(`float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) 
		{
			// Integer and fractional parts of this point's coordinates
			ivec3 p = ivec3(floor(x));
			vec3 f = fract(x);

			// Different variables that we will use to construct noise:
			//
			// f1: distance to the closest feature point
			// f2: distance to the second closest feature point
			// e: distance to the closest edge (cell boundary)
			//
			// We also compute "smooth" versions of all of the above quantites, essentially
			// replacing "hard" minimums with "smooth" minimums (described by IQ)
			float f1_smooth = 8.0;
			float f1 = 8.0;
			float f2_smooth = 8.0;
			float f2 = 8.0;
			float e_smooth = 8.0;
			float e = 8.0;

			// Variables stored from closest cell
			ivec3 mb;
			vec3 mr; 

			int steps = quality;
			
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				ivec3 b = ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d = length(r);
				
				f1_smooth = smin(d, f1_smooth, smoothness);

				// Store un-smoothed distances too 
				if (d < f1) 
				{
					f2 = f1;
					f1 = d;

					mb = ivec3(x, y, z);
					mr = r;
				} 
				else if (d < f2) 
				{
					f2 = d;
				}
			}	
			
			float id = hashwithoutsine13(vec3(p + mb) + seed);

			// Second pass for edge distance  
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				// Start search at the cell that contains the closest point to "x" (found in 1st pass)
				ivec3 b = mb + ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d1 = dot(0.5 * (mr + r), (r - mr)); 				// IQ normalizes "r - mr" but that breaks things for the smooth version?
				float d2 = dot(0.5 * (mr + r), normalize(r - mr));

				e_smooth = smin(d1, e_smooth, smoothness);

				e = min(e, d2);

				// Also compute a smooth version of F2 in this pass
				{
					ivec3 b = ivec3(x, y, z);
					if (b != mb) 
					{
						vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
						float d = length(r);

						f2_smooth = smin(d, f2_smooth, smoothness);
					}
				}
			}

			// Different visualization modes 
			if (style == 0) 
			{
				return f1_smooth;
			}
			if (style == 1) 
			{
				return f2_smooth;
			}
			if (style == 2) 
			{
				return f2_smooth - f1_smooth;
				
				// "Pebbles" also cool
				//return step(0.2, f2_smooth - f1_smooth);
			}
			if (style == 3) 
			{
				// This one is really good for rock / stone effects
				float a = f1; 
				float b = f2;
				float k = 3.0;
				float h = max(k - abs(a - b), 0.0) / k;
				float final = min(a, b) - h * h * k * (1.0 / 4.0);
				return final;
			}
			if (style == 4) 
			{
				// Some random adjustments to make this style stand out more 
				return exp(5.0 * e_smooth);
			}
			if (style == 5) 
			{
				return pow(f1_smooth, 3.0);
			}
			if (style == 6) 
			{				
				const float eps = 0.0125;

				// Thicker lines as the user increases the smoothness slider
				float thickness = smoothness * 0.25 + eps;

				// Blurrier lines as the user increases the smoothness slider
				float blur = pow(smoothness, 3.0) * 0.25 + eps;

				return smoothstep(
					thickness - thickness * blur, 
					thickness + thickness * blur, 
					e
				);
			}
			if (style == 7) 
			{
				return hashwithoutsine13(vec3(p + mb) + seed);
			}
		}
	`, [tE, tC, tT, tD, tP, tI])
                }),
                b6 = class extends x3 {
                    constructor(_, O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei, er, ea, en) {
                        super("v3"), this.nodeType = "Noise", this.scale = _, this.size = O, this.move = B, this.fA = N, this.fB = k, this.distortion = F, this.colorA = U, this.colorB = j, this.colorC = G, this.colorD = Y, this.noiseType = K, this.voronoiStyle = ee, this.highCut = et, this.lowCut = ei, this.smoothness = er, this.seed = ea, this.quality = en, this.isMask = $, this.alpha = Q, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                    }
                    generate(_, O, B, N, k) {
                        _.require("uv"), _.requires.uv = [!0], _.addFragmentVariable(this.calpha, "float");
                        let F = Object.values(b4)[this.noiseType.value],
                            U = "voronoi" == F ? `
		float v = ${F}(st + move, voronoiStyle, smoothness, seed, quality);

		// Apply clipping to colors
		v = remap(v, lowCut, highCut, 0.0, 1.0);
		v = smax(v, 0.0, smoothness * 0.25);
		v = smin(v, 1.0, smoothness * 0.25);

		// Note that the voronoi mode only uses colors "A" and "C" from the UI 
		vec4 color = mix(colorA, colorC, v); 
		` : `
		vec3 q = vec3(${F}(st),
					   ${F}(st + vec3(1.0)),
					   ${F}(st + vec3(1.0)));
		vec3 r = vec3(${F}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
					  ${F}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
					  ${F}(st * q));
		float f = ${F}(st + r);
		vec4 color;
		color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
		color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
		color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));
		`,
                            j = new bt(`vec3 ${F}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) 
			{
                // Prevent scale of zero 
				scale = max(abs(scale), 0.001);

				vec3 st = position / size;
				st /= scale;

				${U}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return clamp(color, 0.0, 1.0).rgb;
			}`, [b5.simplex, b5.simplexFractal, b5.simplexAshima, b5.fbm, b5.perlin, b5.voronoi]),
                            G = _.include(j),
                            Y = [];
                        return Y.push(this.scale.build(_, "f")), Y.push(this.size.build(_, "v3")), Y.push(this.move.build(_, "f")), Y.push(this.fA.build(_, "v2")), Y.push(this.fB.build(_, "v2")), Y.push(this.distortion.build(_, "v2")), Y.push(this.colorA.build(_, "v4")), Y.push(this.colorB.build(_, "v4")), Y.push(this.colorC.build(_, "v4")), Y.push(this.colorD.build(_, "v4")), Y.push(this.voronoiStyle.build(_, "i")), Y.push(this.highCut.build(_, "f")), Y.push(this.lowCut.build(_, "f")), Y.push(this.smoothness.build(_, "f")), Y.push(this.seed.build(_, "f")), Y.push(this.quality.build(_, "i")), Y.push(this.isMask.build(_, "b")), Y.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), Y.push(this.alpha.build(_, "f")), Y.push(this.calpha), _.format(G + "(" + Y.join(",") + ")", this.getType(_), O)
                    }
                };
            b6.numOctaves = 5;
            var b8 = class extends x3 {
                constructor(_, O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei) {
                    super("v3"), this.nodeType = "Outline", this.firstTime = !0, this.outlineColor = _, this.contourColor = O, this.outlineWidth = B, this.contourWidth = N, this.contourThreshold = k, this.outlineThreshold = F, this.contourFrequency = U, this.outlineSmoothing = j, this.contourDirection = G, this.positionalLines = Y, this.compensation = Q, this.resolution = K, this.normalMap = $, this.depthMap = ee, this.pixelRatio = et, this.alpha = ei, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    let B = `g${this.uuid.toString().replace(/-/g,"")}`;
                    if (_.require("vWorldViewDir"), _.require("worldNormal"), _.extensions.derivatives = !0, this.compensation.value && _.define("OUTLINE_COMPENSATION", `${B}_offset`), this.firstTime) {
                        let O = this.outlineWidth.build(_, "f"),
                            N = this.resolution.build(_, "v2"),
                            k = this.compensation.build(_, "b"),
                            F = this.pixelRatio.build(_, "f");
                        _.addVertexParsVariable("randomColor", "attribute vec3"), _.addVertexParsVariable("extrudeNormal", "attribute vec3"), _.addVertexParsVariable(O, "uniform float"), _.addVertexParsVariable(N, "uniform vec2"), _.addVertexParsVariable(k, "uniform bool"), _.addVertexParsVariable(F, "uniform float"), _.addVertexParsVariable("vID", "flat out float"), _.addFragmentParsVariable("vID", "flat in float"), _.addVertexFinalCode(`
                vID = randomColor.r;
                vec2 ${B}_offset = vec2(0.0);
                if (${k}) {
                    vec4 ${B}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${B}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    ${B}_offset = normalize(${B}_clipNormal.xy) / ${N} * (${O} / 2.0) * ${B}_clipPosition.w * 2.0 * ${F};
                    ${B}_clipPosition.xy += ${B}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${B}_clipPosition;
                }
            `)
                    }
                    if (!_.isShader("fragment")) return console.warn("OutlineNode is not compatible with " + _.shader + " shader."), ""; {
                        _.require("uv"), _.requires.uv = [!0], _.addFragmentVariable(this.calpha, "float");
                        let B = _.include(b8.Nodes.outline),
                            N = [];
                        return N.push(this.outlineColor.build(_, "c")), N.push(this.contourColor.build(_, "c")), N.push(this.outlineWidth.build(_, "f")), N.push(this.contourWidth.build(_, "f")), N.push(this.contourThreshold.build(_, "f")), N.push(this.outlineThreshold.build(_, "f")), N.push(this.contourFrequency.build(_, "f")), N.push(this.outlineSmoothing.build(_, "f")), N.push(this.contourDirection.build(_, "v3")), N.push(this.positionalLines.build(_, "b")), N.push(this.resolution.build(_, "v2")), N.push(this.normalMap.getTexture(_, "t")), N.push(this.depthMap.getTexture(_, "t")), N.push(this.pixelRatio.build(_, "f")), N.push(this.compensation.build(_, "b")), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), this.firstTime = !this.firstTime, _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            b8.Nodes = (tR = new bt(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    vec2 texelSize = (vec2(1.0) / resolution);
    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);
	uvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);
	uvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);
	uvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);
	uvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);
	uvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);
	uvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);
  	vec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`), {
                outline: new bt(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                //resultAlpha = 1.0;
                //result = vec3(sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha * mask;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				 
                 return result;
             }`, [tR])
            });
            var b9 = class extends x3 {
                constructor(_, O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei, er, ea) {
                    super("v3"), this.nodeType = "Pattern", this.style = _, this.projection = O, this.axis = B, this.blending = N, this.offset = k, this.colorA = F, this.colorB = U, this.frequency = j, this.size = G, this.variation = Y, this.smoothness = Q, this.zigzag = K, this.rotation = $, this.vertical = ee, this.horizontal = et, this.sides = ei, this.isMask = ea, this.alpha = er, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    if (!_.isShader("fragment")) return console.warn("PatterNode is not compatible with " + _.shader + " shader."), _.format("vec3(0.0)", this.getType(_), O); {
                        let B;
                        switch (_.require("position"), _.require("uv"), _.requires.uv = [!0], _.require("normal"), _.requires.normal = !0, _.addFragmentVariable(this.calpha, "float"), this.style.value) {
                            case 0:
                            default:
                                B = "circle";
                                break;
                            case 1:
                                B = "ring";
                                break;
                            case 2:
                                B = "polygon";
                                break;
                            case 3:
                                B = "xcross";
                                break;
                            case 4:
                                B = "diamond";
                                break;
                            case 5:
                                B = "checkerboard";
                                break;
                            case 6:
                                B = "line";
                                break;
                            case 7:
                                B = "wave"
                        }
                        let N = `g${this.uuid.toString().replace(/-/g,"")}`,
                            k = new bt(`float hashwithoutsine12(vec2 p)
				{
					vec3 p3 = fract(vec3(p.xyx) * .1031);
					p3 += dot(p3, p3.yzx + 33.33);
					return fract((p3.x + p3.y) * p3.z);
				}`),
                            F = new bt(`vec2 rotate_uv(in vec2 uv, float a, bool repeat) 
				{
					const float mid = 0.5;
					float radians = a * (PI / 180.0);
					vec2 rotated = vec2(
						cos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,
						cos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid
					);
					return repeat ? fract(rotated): rotated;
				}`),
                            U = "";
                        if (4 === this.projection.value) {
                            let _ = 2 === this.style.value ? `${B}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${B}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
                                O = 2 === this.style.value ? `${B}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${B}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
                                N = 2 === this.style.value ? `${B}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${B}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`;
                            U = `
				vec3 p = position;
				float factor = 0.0125;
				vec2 uv0 = fract(p.xy * factor);
				vec2 uv1 = fract(p.zy * factor);
				vec2 uv2 = fract(p.xz * factor);
				
				uv0 = rotate_uv(uv0 + offset, rotation, true);
				uv1 = rotate_uv(uv1 + offset, rotation, true);
				uv2 = rotate_uv(uv2 + offset, rotation, true);
	
				float d0 = ${_};
				float d1 = ${O};
				float d2 = ${N};
				
				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));
				d0 *= weights.z;
				d1 *= weights.x;
				d2 *= weights.y;
				float draw = d0 + d1 + d2;
	
				vec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;
				`
                        } else {
                            let _ = 2 === this.style.value ? `${B}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${B}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
                                O = "";
                            0 === this.axis.value ? O = `float radius = length(p);
					float theta = atan(p.y, p.z);
					float phi = acos(p.x / radius);` : 1 === this.axis.value ? O = `float radius = length(p);
					float theta = atan(p.x, p.z);
					float phi = acos(p.y / radius);` : (this.axis.value, O = `float radius = length(p);
					float theta = atan(p.y, p.x);
					float phi = acos(p.z / radius);`);
                            let N = "";
                            switch (this.projection.value) {
                                case 0:
                                    N = "custom_uv = vUv.st;";
                                    break;
                                case 1:
                                case 3:
                                    break;
                                case 2:
                                    N = `
							vec3 p = position;
							${O}
							custom_uv = vec2(theta, phi);
							custom_uv /= PI;
							`
                            }
                            U = `
				vec2 custom_uv;
				${N}
	
				custom_uv += offset;
				custom_uv = fract(custom_uv);
				custom_uv = rotate_uv(custom_uv, rotation, true);
	
				float draw = ${_};
				`
                        }
                        let j = new bt(`vec3 ${N}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {
					const float TWO_PI = PI * 2.0;
					float smoothness_remapped = pow(smoothness, 5.0);	

					${U}

					// Construct final output color
					vec4 color = mix(colorA, colorB, draw);
					color.a = clamp(color.a, 0.0, 1.0);

					// Apply cuts
					color.a *= 
						step(vertical.x, custom_uv.y) * 
						step(custom_uv.y, vertical.y);
					color.a *= 
						step(horizontal.x, abs(custom_uv.x)) * 
						step(abs(custom_uv.x), horizontal.y);

					// Accumulate alpha 
					float lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return clamp(color, 0.0, 1.0).rgb;
				}`, [F, k, b9.DrawFunctions.circle, b9.DrawFunctions.ring, b9.DrawFunctions.polygon, b9.DrawFunctions.cross, b9.DrawFunctions.diamond, b9.DrawFunctions.checkerboard, b9.DrawFunctions.line, b9.DrawFunctions.wave]),
                            G = _.include(j),
                            Y = [];
                        return Y.push("normal"), Y.push(this.blending.build(_, "f")), Y.push(this.style.build(_, "i")), Y.push(this.offset.build(_, "v2")), Y.push(this.colorA.build(_, "v4")), Y.push(this.colorB.build(_, "v4")), Y.push(this.frequency.build(_, "v2")), Y.push(this.size.build(_, "f")), Y.push(this.variation.build(_, "f")), Y.push(this.smoothness.build(_, "f")), Y.push(this.zigzag.build(_, "f")), Y.push(this.rotation.build(_, "f")), Y.push(this.vertical.build(_, "v2")), Y.push(this.horizontal.build(_, "v2")), Y.push(this.sides.build(_, "i")), Y.push(this.isMask.build(_, "b")), Y.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), Y.push(this.alpha.build(_, "f")), Y.push(this.calpha), _.format(G + "(" + Y.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            b9.DrawFunctions = (tB = new bt(`float hashwithoutsine12(vec2 p) {
				vec3 p3 = fract(vec3(p.xyx) * 0.1031);
				p3 += dot(p3, p3.yzx + 33.33);
				return fract((p3.x + p3.y) * p3.z);
			}`), tN = new bt(`vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {
                // Create tiles in UV-space
                uv *= frequency;

                // Integer coords
                vec2 i = floor(uv);

                // Offset every other row based on zigzag param, then compute fractional coords
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = fract(uv);

				// Rotate the tile itself:
				// const float mid = 0.5;
				// f = vec2(
				// 	cos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,
				// 	cos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid
				// );
				// f = fract(f);

                f = f * 2.0 - 1.0;

				// Recompute integer coords after shifting - then, random value per tile 
				i = floor(uv);
				float rand = (hashwithoutsine12(i) * 5.0 + 1.0);
				float jitter = mix(1.0, rand, variation);
				f *= jitter;

                return f;
            }`, [tB]), tk = new bt(`float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(
                    -smoothness, 
                     smoothness, 
                     length(f) - size
                );
            }`, [tN]), tF = new bt(`float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);

				float d = length(f);
                const float inner_width = 0.5;

                float outer = smoothstep(-smoothness, smoothness, d - size);
                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);
				return outer + (1.0 - inner);   
            }`, [tN]), tU = new bt(`float sdf_ngon(in vec2 p, in float r, in int n) {
                float an = (PI * 2.0) / float(n);
                float he = r * tan(0.5 * an);
                
                // Rotate to first sector
                p = -p.yx; 
                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);
                vec2  cs = vec2(cos(bn), sin(bn));
                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;
            
                // Side of polygon
                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);
            }
            
            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));
            }`, [tN]), tj = new bt(`float sdf_cross(in vec2 p, in vec2 b, float r ) {
                p = abs(p); 
				p = (p.y > p.x) ? p.yx : p.xy;
                vec2  q = p - b;
                float k = max(q.y, q.x);
                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);
                return sign(k) * length(max(w, 0.0)) + r;
            }
            
            // Avoid namespace conflicts 
            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));
            }`, [tN]), tG = new bt(`float ndot(vec2 a, vec2 b) { 
                return a.x*b.x - a.y*b.y; 
            }
            
            float sdf_diamond(in vec2 p, in vec2 b) {
                p = abs(p);
                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
            }

            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
	            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));
            }`, [tN]), tH = new bt(`float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                uv *= frequency;
                vec2 i = floor(uv);

                float offset = mod(i.y, 2.0);

                uv.x += offset + zigzag * offset;
                float x = floor(uv.x);
                
                return mod(x, 2.0);
            }`), tW = new bt(`float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);
				
				// Different approach for variation param here
				float row = floor(uv * frequency).y;
				float rand = hashwithoutsine12(vec2(row));
				float s = mix(size, size * rand, variation);

				return smoothstep(
					s - smoothness, 
					s + smoothness, 
					abs(f.y)
				);
            }`, [tN]), {
                tileAndCenter: tN,
                circle: tk,
                ring: tF,
                polygon: tU,
                cross: tj,
                diamond: tG,
                checkerboard: tH,
                line: tW,
                wave: new bt(`// Uses bisection 
            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {
                // Convert all data to a primitive cosine wave
                p = c * (p - vec2(d, a));
                
                const float TWO_PI = PI * 2.0;

                // Reduce to principal half cycle
                p.x = mod(p.x, TWO_PI); 
                if (p.x > PI) {
                    p.x = TWO_PI - p.x;
                }
            
                // Find zero of derivative (minimize distance)
                float xa = 0.0;
                float xb = TWO_PI;

                // 24 bit precision
                for (int i = 0; i < 24; i++) {
                    float x = 0.5 * (xa + xb);
                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));
                    if (y < 0.0) xa = x; 
                    else xb = x;
                }
                float x = 0.5 * (xa + xb);
                
                // Compute distance    
                vec2 q = vec2(x, b * c * cos(x));
                return length(p - q) / c;
            }

            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                float repeat = frequency.x;
                uv *= repeat;
                vec2 i = floor(uv);
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = vec2(uv.x, fract(uv.y));

                // Generalized cosine: y(x) = a + b * cos(cx + d)
                const float amplitude = 0.125;
                float wave_frequency = frequency.y * 0.1;
                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);

				// Different approach for variation param here
				float rand = hashwithoutsine12(vec2(i.y));
				float s = mix(size, size * rand, variation);

                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);
            }`)
            });
            var b7 = class extends x3 {
                constructor(_, O, B, N, k, F, U, j) {
                    super("v3"), this.nodeType = "Rainbow", this.filmThickness = _, this.movement = O, this.wavelengths = B, this.noiseStrength = N, this.noiseScale = k, this.offset = F, this.isMask = j, this.alpha = U, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    if (_.require("vWorldViewDir"), _.require("worldNormal"), !_.isShader("fragment")) return console.warn("RainbowNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                        _.require("uv"), _.requires.uv = [!0], _.addFragmentVariable(this.calpha, "float");
                        let B = _.include(b7.Nodes.rainbow),
                            N = [];
                        return N.push(this.filmThickness.build(_, "f")), N.push(this.movement.build(_, "f")), N.push(this.wavelengths.build(_, "v3")), N.push(this.noiseStrength.build(_, "f")), N.push(this.noiseScale.build(_, "f")), N.push(this.offset.build(_, "v3")), N.push(this.isMask.build(_, "b")), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            b7.Nodes = (tq = new bt(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`, [b5.simplex]), {
                rainbow: new bt(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {
				vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

				float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);

				float lalpha = alpha * rainbowContribution * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return res;
             }`, [tq])
            });
            var we = class extends x3 {
                constructor(_, O, B, N, k, F, U, j, G, Y) {
                    super("v3"), this.nodeType = "Toon", this.positioning = _, this.colors = O, this.steps = B, this.source = N, this.isWorldSpace = k, this.noiseStrength = F, this.noiseScale = U, this.shadowColor = j, this.offset = G, this.alpha = Y, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                }
                generate(_, O) {
                    if (_.require("worldNormal"), _.require("worldPosition"), !_.isShader("fragment")) return console.warn("ToonNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                        _.define("COLORS_MAX", 10), _.addFragmentVariable(this.calpha, "float");
                        let B = _.include(we.Nodes.toon),
                            N = [];
                        return N.push(this.positioning.build(_, "i")), N.push(this.colors.build(_, "v4[]")), N.push(this.steps.build(_, "f[]")), N.push(this.source.build(_, "v3")), N.push(this.isWorldSpace.build(_, "b")), N.push(this.noiseStrength.build(_, "f")), N.push(this.noiseScale.build(_, "f")), N.push(this.shadowColor.build(_, "v4")), N.push(this.offset.build(_, "v3")), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                    }
                }
            };
            we.Nodes = (tY = new bt(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`), tX = new bt(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`), tQ = new bt(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`, [tX]), tZ = new bt(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`), tK = new bt(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`, [tZ]), {
                toon: new bt(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`, [b5.simplex, tY, tQ, tK])
            });
            var wt = {
                    textureBicubic: new bt(`float w0( float a ) {
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
        }
    
        float w1( float a ) {
            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
        }
    
        float w2( float a ){
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
        }
    
        float w3( float a ) {
            return ( 1.0 / 6.0 ) * ( a * a * a );
        }
    
        // g0 and g1 are the two amplitude functions
        float g0( float a ) {
            return w0( a ) + w1( a );
        }
    
        float g1( float a ) {
            return w2( a ) + w3( a );
        }
    
        // h0 and h1 are the two offset functions
        float h0( float a ) {
            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
        }
    
        float h1( float a ) {
            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
        }
    
        vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
            uv = uv * texelSize.zw + 0.5;
    
            vec2 iuv = floor( uv );
            vec2 fuv = fract( uv );
    
            float g0x = g0( fuv.x );
            float g1x = g1( fuv.x );
            float h0x = h0( fuv.x );
            float h1x = h1( fuv.x );
            float h0y = h0( fuv.y );
            float h1y = h1( fuv.y );
    
            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    
            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + 
                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
        }

        vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
            vec2 fLodSizeInv = 1.0 / fLodSize;
            vec2 cLodSizeInv = 1.0 / cLodSize;
            vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
            vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
            return mix( fSample, cSample, fract( lod ) );
        }`)
                },
                wi = class extends x3 {
                    constructor(_, O, B, N, k, F, U, j) {
                        super("v3"), this.nodeType = "Transmission", this.thickness = _, this.ior = O, this.roughness = B, this.transmissionSamplerSize = N, this.transmissionSamplerMap = k, this.transmissionDepthMap = F, this.aspectRatio = U, this.alpha = j, this.calpha = `g${this.uuid.toString().replace(/-/g,"")}_calpha`
                    }
                    generate(_, O) {
                        if (_.extensions.shaderTextureLOD = !0, _.extensions.derivatives = !0, !_.isShader("fragment")) return console.warn("TransmissionNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                            _.define("NUM_SAMPLES", 6), _.define("BLUR_SLOD", Math.pow(2, wn.transmissionLod.value)), _.require("worldPosition"), _.requires.worldNormal = !0, _.requires.modelMatrix = !0, _.requires.projectionMatrix = !0, _.addFragmentVariable(this.calpha, "float");
                            let B = _.include(wi.Nodes.transmission),
                                N = [];
                            return N.push(this.thickness.build(_, "f")), N.push(this.ior.build(_, "f")), N.push(this.roughness.build(_, "f")), N.push(this.transmissionSamplerSize.build(_, "v2")), N.push(this.transmissionSamplerMap.getTexture(_, "t")), N.push(this.transmissionDepthMap.getTexture(_, "t")), N.push(this.aspectRatio.build(_, "v2")), N.push("normal"), N.push(this.mask ? `luminance(${this.mask.flow(_,"v3").result})` : "1.0"), N.push(this.alpha.build(_, "f")), N.push(this.calpha), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                        }
                    }
                };
            wi.Nodes = (tJ = new bt(`vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

				// Special case for blur == 0.0
				if (lod == 0.0) {
					#ifdef TEXTURE_LOD_EXT
					return texture2DLodEXT( sp, U, 0.0).rgb;
					#else
					return textureLod( sp, U, 0.0).rgb;
					#endif
				}
				
				vec2 texelSize = vec2(1.0) / resolution;
                vec2 halton = haltonSequence[frameIndex];
                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
                float temporalAngle  = temporalOffset * PI2;
				vec3 res = vec3(0.0);
                vec2 uv = vec2(0.0);
                vec2 offset = vec2(0.0);
                vec2 vogelSample = vec2(0.0);
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;
                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20
                    uv = U + offset;
                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    res += textureLod(sp, uv, lod).rgb;
                }
                return res / float(NUM_SAMPLES);
            }`), t$ = new bt(`vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        
				// Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		        // The thickness is specified in local space
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`), t0 = new bt(`float applyIorToRoughness( float roughness, float ior ) {
				// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
				// an IOR of 1.5 results in the default amount of microfacet refraction.
				return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
			}`), t2 = new bt(`vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
				// Threejs exports do not pass a depth map to this shader, so we have to fallback to the "Threejs method of blurring" - see
				// also the code in convertTransmission.ts, which runs during export
				#ifdef IS_THREEJS_EXPORT
					float lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);
					return textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;
				#else
					float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
					float lod = applyIorToRoughness(roughness, ior);
					return blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
				#endif
			}`, [wt.textureBicubic, t0, tJ]), t3 = new bt(`vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
				vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
				unrefractedCoords += 1.0;
				unrefractedCoords /= 2.0;

				// Sample framebuffer to get pixel the refracted ray hits.
				return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    		}`, [t2, t$]), {
                transmission: new bt(`vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return transmission;
            }`, [t3])
            });
            var wr = ((wh = wr || {}).NOISE = "noise", wh.MAP = "map", wh),
                wa = class extends x3 {
                    constructor(_, O, B, N, k, F, U, j, G, Y, Q) {
                        super("v3"), this.displacementTypeIndex = new bz(0), this.nodeType = "VertexDisplacement", this.intensity = _, this.movementOrTexture = O, "map" === Object.values(wr)[this.displacementTypeIndex.value] && (this.mat = new bG(this.movementOrTexture.value.matrix)), this.cropOrOffset = B, this.scale = Y, this.noiseFunctionIndex = Q, this.voronoiStyle = N, this.smoothness = k, this.seed = F, this.highCut = U, this.lowCut = j, this.quality = G
                    }
                    generate(_, O) {
                        if (!_.isShader("vertex")) return console.warn("VertexDisplacementNode is not compatible with " + _.shader + " shader."), _.format("vec3( 0.0 )", this.getType(_), O); {
                            _.define("USE_LAYER_DISPLACE");
                            let B, N = [];
                            switch (N.push("displaced_position"), N.push("displaced_normal"), Object.values(wr)[this.displacementTypeIndex.value]) {
                                case "map":
                                    B = _.include(wa.Nodes.map), N.push(this.movementOrTexture.getTexture(_, "t")), N.push("uv"), N.push(this.cropOrOffset.build(_, "f")), this.mat && N.push(this.mat.build(_, "mat3"));
                                    break;
                                case "noise":
                                    {
                                        let O = Object.values(b4)[this.noiseFunctionIndex.value],
                                            k = new bt(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),
                                            F = "voronoi" == O ? `
					float v = ${O}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);
					v = remap(v, lowCut, highCut, 0.0, 1.0);
					v = smax(v, 0.0, smoothness * 0.25);
					v = smin(v, 1.0, smoothness * 0.25);

					return p + n * v * intensity;
					` : `
					return p + n * ${O}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
					`,
                                            U = new bt(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {
							${F}
						}`, [b5.simplex, b5.simplexFractal, b5.simplexAshima, b5.fbm, b5.perlin, b5.voronoi]),
                                            j = new bt(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [U, k]);B = _.include(j),
                                        N.push(this.scale.build(_, "f")),
                                        N.push(this.cropOrOffset.build(_, "v3")),
                                        N.push(this.movementOrTexture.build(_, "f")),
                                        N.push(this.voronoiStyle.build(_, "i")),
                                        N.push(this.smoothness.build(_, "f")),
                                        N.push(this.seed.build(_, "f")),
                                        N.push(this.highCut.build(_, "f")),
                                        N.push(this.lowCut.build(_, "f")),
                                        N.push(this.quality.build(_, "i"))
                                    }
                            }
                            return N.push(this.intensity.build(_, "f")), N.push("displaced_normal"), _.format(B + "(" + N.join(",") + ")", this.getType(_), O)
                        }
                    }
                };
            wa.Nodes = (t4 = new bt(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`), t5 = new bt(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`), {
                map: new bt(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [t4, t5])
            });
            var wn = {
                normalRenderTarget: new bc,
                normalRenderTargetDepth: new bc,
                transmissionRenderTarget: new bc,
                aspectRatio: new x5,
                transmissionSize: new x5(2048, 2048),
                transmissionRenderTargetDepth: new bc,
                aoRenderTarget: new bc,
                aoEnabled: new bN,
                pixelRatioNode: new bd(1),
                resolution: new x5,
                penumbraSize: new bk(5, .5),
                frameIndex: new bz(0),
                transmissionLod: new bz(2)
            };
            for (let _ of Object.values(wn)) _.isRenderGlobal = !0;
            var wo, wl, wh, wc, wd, wu, wp, wf = class extends x$ {
                    constructor() {
                        super("basic"), this.nodeType = "Basic", this.color = new bB(5526619), this.shadingAlpha = new bd(1), this.shadingBlend = new bz(0), this.previousModelViewMatrix = new bH, this.previouseProjectionMatrix = new bH
                    }
                    get category() {
                        return "phong"
                    }
                    generate(_) {
                        let O;
                        if (_.isShader("vertex")) {
                            let B = this.position ? this.position.analyzeAndFlow(_, "v3", {
                                cache: "position"
                            }) : void 0;
                            _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                resolution: wn.resolution
                            }), _.mergeUniform({
                                previousModelViewMatrix: this.previousModelViewMatrix
                            }), _.mergeUniform({
                                previousProjectionMatrix: this.previouseProjectionMatrix
                            }), _.mergeUniform(ar.merge([aE.fog])), _.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>"].join(`
`));
                            let N = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
                            B && N.push(B.code, B.result ? "displaced_position = " + B.result + ";" : ""), N.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), N.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), N.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), O = N.join(`
`)
                        } else {
                            void 0 === this.color && (this.color = new bB(5526619)), this.color.analyze(_, {
                                slot: "color"
                            }), this.alpha && this.alpha.analyze(_), this.afterColor && this.afterColor.analyze(_, {
                                slot: "afterColor"
                            });
                            let B = this.color.flow(_, "c", {
                                    slot: "color"
                                }),
                                N = this.alpha ? this.alpha.flow(_, "f") : void 0,
                                k = this.alphaOverride ? this.alphaOverride.flow(_, "f") : void 0,
                                F = this.afterColor ? this.afterColor.flow(_, "c", {
                                    slot: "afterColor"
                                }) : void 0;
                            _.requires.transparent = void 0 !== N, _.addParsCode(["varying vec3 vWPosition;", "#include <fog_pars_fragment>", "#include <dithering_pars_fragment>", "varying vec3 vViewPosition;", "#include <normal_pars_fragment>"].join(`
`));
                            let U = ["#include <normal_fragment_begin>", B.code];
                            N && U.push(N.code, "#ifdef ALPHATEST", " if ( " + N.result + " <= ALPHATEST ) discard;", "#endif"), F ? U.push(F.code, `vec3 outgoingLight = ${B.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${F.result}, 1.0, SPE_BLENDING_NORMAL);`) : U.push(`vec3 finalColor = ${B.result};`);
                            let j = "1.0";
                            this.mask && (this.mask.analyze(_), j = `luminance(${this.mask.flow(_,"v3").result})`), N ? U.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${N.result} * ${j} );`) : U.push("gl_FragColor = vec4(" + B.result + ", 1.0 );"), k && U.push(`gl_FragColor.a *= ${k.result};`), U.push("#include <fog_fragment>", "#include <dithering_fragment>"), O = U.join(`
`)
                        }
                        return O
                    }
                },
                wm = class extends x$ {
                    constructor() {
                        super("lambert"), this.nodeType = "Lambert", this.color = new bB(5526619), this.emissive = new bB(0), this.emissiveIntensity = new bd(1), this.previousModelViewMatrix = new bH, this.previouseProjectionMatrix = new bH, this.shadingAlpha = new bd(1), this.shadingBlend = new bz(0), this.occlusion = new bN(!0)
                    }
                    get category() {
                        return "lambert"
                    }
                    build(_) {
                        let O;
                        if (_.define("LAMBERT"), _.requires.lights = !0, _.extensions.derivatives = !0, _.isShader("vertex")) {
                            let B = this.position ? this.position.analyzeAndFlow(_, "v3", {
                                cache: "position"
                            }) : void 0;
                            _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                resolution: wn.resolution
                            }), _.mergeUniform({
                                previousModelViewMatrix: this.previousModelViewMatrix
                            }), _.mergeUniform({
                                previousProjectionMatrix: this.previouseProjectionMatrix
                            }), _.mergeUniform(ar.merge([aE.fog, aE.lights])), _.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <color_pars_vertex>", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                            let N = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
                            B && N.push(B.code, B.result ? "displaced_position = " + B.result + ";" : ""), N.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), N.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
				`), N.push(`
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), N.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), O = N.join(`
`)
                        } else {
                            _.mergeUniform({
                                penumbraSize: wn.penumbraSize
                            }), _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                aoMap: wn.aoRenderTarget
                            }), _.mergeUniform({
                                aoEnabled: wn.aoEnabled
                            }), void 0 === this.color && (this.color = new bB(5526619)), this.color.analyze(_, {
                                slot: "color"
                            }), this.shadingAlpha.analyze(_), this.shadingBlend.analyze(_), this.afterColor && this.afterColor.analyze(_, {
                                slot: "afterColor"
                            }), this.alpha && this.alpha.analyze(_);
                            let B = this.color.flow(_, "c", {
                                    slot: "color"
                                }),
                                N = this.emissive.flow(_, "c", {
                                    slot: "emissive"
                                }),
                                k = this.emissiveIntensity.flow(_, "f", {
                                    slot: "emissive"
                                }),
                                F = this.occlusion.flow(_, "b", {
                                    slot: "occlusion"
                                }),
                                U = this.shadingAlpha.flow(_, "f"),
                                j = this.shadingBlend.flow(_, "i"),
                                G = this.afterColor ? this.afterColor.flow(_, "c", {
                                    slot: "afterColor"
                                }) : void 0,
                                Y = this.alpha ? this.alpha.flow(_, "f") : void 0,
                                Q = this.alphaOverride ? this.alphaOverride.flow(_, "f") : void 0;
                            _.requires.transparent = void 0 !== Y, _.addParsCode(["uniform float penumbraSize[5];", "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#include <normal_pars_fragment>", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <fog_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <shadowmask_pars_fragment>", "#include <clipping_planes_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
                            let K = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`, "#include <clipping_planes_fragment>"];
                            K.push(B.code, "vec3 diffuseColor = " + B.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"), Y && K.push(Y.code, "#ifdef ALPHATEST", "if ( " + Y.result + " <= ALPHATEST ) discard;", "#endif"), K.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"), N && K.push(N.code, "reflectedLight.directDiffuse += " + N.result + " * " + k.result + ";"), K.push("vec3 ao = aoEnabled && " + F.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;");
                            let $ = "1.0";
                            this.mask && (this.mask.analyze(_), $ = `luminance(${this.mask.flow(_,"v3").result})`), K.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${U.result} * ${$} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${U.result} * ${$}, ${j.result} );

					outgoingLight *= ao;
				}
				`), G && K.push(G.code, `outgoingLight = spe_blend(outgoingLight, ${G.result}, 1.0, SPE_BLENDING_NORMAL);`), Y ? K.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${Y.result} );`) : K.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), Q && K.push(`gl_FragColor.a *= ${Q.result};`), K.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), O = K.join(`
`)
                        }
                        return O
                    }
                },
                wg = {
                    dHdxy: new bt(`vec2 dHdxy(sampler2D bumpMap, vec2 bumpMapUv, float bumpScale) {

            // Gradient of UVs w.r.t. X coordinate (in screen-space)
            vec2 dSTdx = dFdx(bumpMapUv);

            // Gradient of UVs w.r.t. Y coordinate (in screen-space)
            vec2 dSTdy = dFdy(bumpMapUv);
            
            // Forward differencing
            float Hll = bumpScale * luminance(texture(bumpMap, bumpMapUv).rgb);
            float dBx = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdx).rgb) - Hll;
            float dBy = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdy).rgb) - Hll;
            
            return vec2( dBx, dBy );
        }`),
                    perturbNormalArb: new bt(`vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
            vec3 vSigmaX = dFdx( surf_pos.xyz );
            vec3 vSigmaY = dFdy( surf_pos.xyz );
            vec3 vN = surf_norm; // normalized
            
            vN = normalize(vN);

            vec3 R1 = cross( vSigmaY, vN );
            vec3 R2 = cross( vN, vSigmaX );

            R1 = normalize(R1);
            R2 = normalize(R2);
    
            float fDet = dot( vSigmaX, R1 ) * faceDirection;
    
            vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
            return normalize( abs( fDet ) * vN - vGrad );
        }`)
                },
                wv = class extends x$ {
                    constructor() {
                        super("phong"), this.nodeType = "Phong", this.color = new bB(5526619), this.specular = new bB(1118481), this.shininess = new bd(30), this.previousModelViewMatrix = new bH, this.previouseProjectionMatrix = new bH, this.shadingAlpha = new bd(1), this.shadingBlend = new bz(0), this.occlusion = new bN(!0)
                    }
                    get category() {
                        return "phong"
                    }
                    build(_) {
                        let O;
                        if (_.define("PHONG"), _.requires.lights = !0, _.extensions.derivatives = !0, _.isShader("vertex")) {
                            let B = this.position ? this.position.analyzeAndFlow(_, "v3", {
                                cache: "position"
                            }) : void 0;
                            _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                resolution: wn.resolution
                            }), _.mergeUniform({
                                previousModelViewMatrix: this.previousModelViewMatrix
                            }), _.mergeUniform({
                                previousProjectionMatrix: this.previouseProjectionMatrix
                            }), _.mergeUniform(ar.merge([aE.fog, aE.lights])), _.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <skinning_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                            let N = ["#include <beginnormal_vertex>", `
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = objectNormal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
                            B && N.push(B.code, B.result ? "displaced_position = " + B.result + ";" : ""), N.push("transformed = displaced_position;", "#include <skinning_vertex>", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), N.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), N.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), O = N.join(`
`)
                        } else {
                            _.mergeUniform({
                                penumbraSize: wn.penumbraSize
                            }), _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                aoMap: wn.aoRenderTarget
                            }), _.mergeUniform({
                                aoEnabled: wn.aoEnabled
                            }), void 0 === this.color && (this.color = new bB(5526619)), this.color.analyze(_, {
                                slot: "color"
                            }), this.specular.analyze(_), this.shininess.analyze(_);
                            let B = this.occlusion.flow(_, "b", {
                                slot: "occlusion"
                            });
                            this.shadingAlpha.analyze(_), this.shadingBlend.analyze(_), this.afterColor && this.afterColor.analyze(_, {
                                slot: "afterColor"
                            }), this.alpha && this.alpha.analyze(_);
                            let N = this.color.flow(_, "c", {
                                    slot: "color"
                                }),
                                k = this.specular.flow(_, "c"),
                                F = this.shininess.flow(_, "f"),
                                U = this.shadingAlpha.flow(_, "f"),
                                j = this.shadingBlend.flow(_, "i"),
                                G = this.afterColor ? this.afterColor.flow(_, "c", {
                                    slot: "afterColor"
                                }) : void 0,
                                Y = this.alpha ? this.alpha.flow(_, "f") : void 0,
                                Q = this.alphaOverride ? this.alphaOverride.flow(_, "f") : void 0;
                            _.requires.transparent = void 0 !== Y, _.addParsCode(["varying vec3 vWPosition;", "uniform vec3 emissive;", "uniform float penumbraSize[5];", "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "#include <normal_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
                            let K = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	BlinnPhongMaterial material;"];
                            if (this.bumpMap) {
                                _.include(wg.dHdxy), _.include(wg.perturbNormalArb);
                                let O = this.bumpMap.texture.flow(_, "t"),
                                    B = this.bumpMap.flow(_, "v3"),
                                    N = this.bumpMapIntensity ? this.bumpMapIntensity.flow(_, "f").result : "1.0",
                                    k = "";
                                k = 4 === this.bumpMap.projection.value ? `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;

						vec2 grad0 = dHdxy(${O.result}, uv0, ${N});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${O.result}, uv1, ${N});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${O.result}, uv2, ${N});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					` : `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs;
					vec2 grad = dHdxy(${O.result}, bumpMapCachedUv, ${N});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`, K.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${B.result};
					${k}
					`)
                            }
                            K.push(N.code, "	vec3 diffuseColor = " + N.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", k.code, "	vec3 specular = " + k.result + ";", F.code, "	float shininess = max( 0.0001, " + F.result + " );", "	float specularStrength = 1.0;"), Y && K.push(Y.code, "#ifdef ALPHATEST", "if ( " + Y.result + " <= ALPHATEST ) discard;", "#endif"), K.push("material.diffuseColor = diffuseColor;"), K.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), K.push("vec3 ao = aoEnabled && " + B.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;");
                            let $ = "1.0";
                            this.mask && (this.mask.analyze(_), $ = `luminance(${this.mask.flow(_,"v3").result})`), K.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${U.result} * ${$} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${U.result} * ${$}, ${j.result} );
					
					outgoingLight *= ao;
				}
				`), G && K.push(G.code, `outgoingLight = spe_blend(outgoingLight, ${G.result}, 1.0, SPE_BLENDING_NORMAL);`), Y ? K.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${Y.result});`) : K.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), Q && K.push(`gl_FragColor.a *= ${Q.result};`), K.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), O = K.join(`
`)
                        }
                        return O
                    }
                },
                wy = class extends x$ {
                    constructor() {
                        super("standard"), this.nodeType = "Standard", this.color = new bB(5526619), this.roughness = new bd(.3), this.metalness = new bd(0), this.reflectivity = new bd(.5), this.previousModelViewMatrix = new bH, this.previouseProjectionMatrix = new bH, this.shadingAlpha = new bd(1), this.shadingBlend = new bz(0), this.occlusion = new bN(!0)
                    }
                    get category() {
                        return "physical"
                    }
                    build(_) {
                        let O;
                        if (_.define("STANDARD"), _.requires.lights = !0, _.extensions.derivatives = !0, _.extensions.shaderTextureLOD = !0, _.isShader("vertex")) {
                            let B = this.position ? this.position.analyzeAndFlow(_, "v3", {
                                cache: "position"
                            }) : void 0;
                            _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                resolution: wn.resolution
                            }), _.mergeUniform({
                                previousModelViewMatrix: this.previousModelViewMatrix
                            }), _.mergeUniform({
                                previousProjectionMatrix: this.previouseProjectionMatrix
                            }), _.mergeUniform(ar.merge([aE.fog, aE.lights])), aE.LTC_1 && (_.uniforms.ltc_1 = {
                                value: void 0
                            }, _.uniforms.ltc_2 = {
                                value: void 0
                            }), _.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                            let N = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
                            B && N.push(B.code, B.result ? "displaced_position = " + B.result + ";" : ""), N.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), N.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), N.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), O = N.join(`
`)
                        } else {
                            _.mergeUniform({
                                penumbraSize: wn.penumbraSize
                            }), _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                aoMap: wn.aoRenderTarget
                            }), _.mergeUniform({
                                aoEnabled: wn.aoEnabled
                            });
                            let B = {
                                gamma: !0
                            };
                            void 0 === this.color && (this.color = new bB(5526619)), this.color.analyze(_, {
                                slot: "color",
                                context: B
                            }), this.roughness.analyze(_), this.metalness.analyze(_);
                            let N = this.occlusion.flow(_, "b", {
                                slot: "occlusion"
                            });
                            this.shadingAlpha.analyze(_), this.shadingBlend.analyze(_), this.afterColor && this.afterColor.analyze(_, {
                                slot: "afterColor"
                            }), this.alpha && this.alpha.analyze(_), this.reflectivity && this.reflectivity.analyze(_);
                            let k = this.color.flow(_, "c", {
                                    slot: "color",
                                    context: B
                                }),
                                F = this.roughness.flow(_, "f"),
                                U = this.metalness.flow(_, "f"),
                                j = this.shadingAlpha.flow(_, "f"),
                                G = this.shadingBlend.flow(_, "i"),
                                Y = this.afterColor ? this.afterColor.flow(_, "c", {
                                    slot: "afterColor"
                                }) : void 0,
                                Q = this.alpha ? this.alpha.flow(_, "f") : void 0,
                                K = this.alphaOverride ? this.alphaOverride.flow(_, "f") : void 0,
                                $ = this.reflectivity ? this.reflectivity.flow(_, "f") : void 0;
                            _.requires.transparent = void 0 !== Q, _.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "uniform float penumbraSize[5];", "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "#include <normal_pars_fragment>", "#include <dithering_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_physical_pars_fragment>", "#include <shadowmap_pars_fragment>"].join(`
`));
                            let ee = ["#include <clipping_planes_fragment>", "	#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	PhysicalMaterial material;", "	material.diffuseColor = vec3( 1.0 );"];
                            if (this.bumpMap) {
                                _.include(wg.dHdxy), _.include(wg.perturbNormalArb);
                                let O = this.bumpMap.texture.flow(_, "t"),
                                    B = this.bumpMap.flow(_, "v3"),
                                    N = this.bumpMapIntensity ? this.bumpMapIntensity.flow(_, "f").result : "1.0",
                                    k = "";
                                k = 4 === this.bumpMap.projection.value ? `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;

						vec2 grad0 = dHdxy(${O.result}, uv0, ${N});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${O.result}, uv1, ${N});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${O.result}, uv2, ${N});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					` : `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs;
					vec2 grad = dHdxy(${O.result}, bumpMapCachedUv, ${N});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`, ee.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${B.result};
					${k}
					`)
                            }
                            if (ee.push(k.code, "	vec3 diffuseColor = " + k.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", U.code, "	float metalnessFactor = " + U.result + ";"), this.roughnessMap) {
                                let O = this.roughnessMap.texture.flow(_, "t"),
                                    B = this.roughnessMap.flow(_, "v3"),
                                    N = "";
                                N = 4 === this.roughnessMap.projection.value ? `
					float roughnessChange = 1.0;
					{
						vec2 uv0 = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs0;
						vec2 uv1 = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs1;
						vec2 uv2 = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs2;
						vec3 weights = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;

						float r0 = luminance(texture(${O.result}, uv0).rgb) * roughnessScale;
						float r1 = luminance(texture(${O.result}, uv1).rgb) * roughnessScale;
						float r2 = luminance(texture(${O.result}, uv2).rgb) * roughnessScale;

						roughnessChange = (r0 * weights.z + r1 * weights.x + r2 * weights.y);
					}
					float roughnessFactor = roughnessChange * ${F.result};
					` : `
					vec2 roughnessMapCachedUv = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs;

					vec4 vals = texture(${O.result},  roughnessMapCachedUv);
					float roughnessFactor = luminance(vals.rgb) * ${F.result};
					`, ee.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${B.result};

					const float roughnessScale = 1.0;

					${N}
				`)
                            } else ee.push(F.code, "	float roughnessFactor = " + F.result + ";");
                            Q && ee.push(Q.code, "#ifdef ALPHATEST", "	if ( " + Q.result + " <= ALPHATEST ) discard;", "#endif"), ee.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), ee.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );", "material.roughness = max( roughnessFactor, 0.0525 );", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"), $ ? ee.push($.code, "material.specularColor = mix( vec3( 0.16 * pow2( " + $.result + " ) ), diffuseColor, metalnessFactor );") : ee.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"), ee.push("#include <lights_fragment_begin>"), ee.push("#include <lights_fragment_end>"), ee.push("vec3 ao = aoEnabled && " + N.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;");
                            let et = "1.0";
                            this.mask && (this.mask.analyze(_), et = `luminance(${this.mask.flow(_,"v3").result})`), ee.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${j.result} * ${et} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${j.result} * ${et}, ${G.result} );
					
					outgoingLight *= ao;
				}
				`), Y && ee.push(Y.code, `outgoingLight = spe_blend(outgoingLight, ${Y.result}, 1.0, SPE_BLENDING_NORMAL);`), Q ? ee.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${Q.result} );`) : ee.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), K && ee.push(`gl_FragColor.a *= ${K.result};`), ee.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), O = ee.join(`
`)
                        }
                        return O
                    }
                },
                wx = class extends x$ {
                    constructor() {
                        super("toon"), this.nodeType = "Toon", this.color = new bB(5526619), this.specular = new bB(1118481), this.shininess = new bd(30), this.previousModelViewMatrix = new bH, this.previouseProjectionMatrix = new bH, this.shadingAlpha = new bd(1), this.shadingBlend = new bz(0)
                    }
                    get category() {
                        return "toon"
                    }
                    build(_) {
                        let O;
                        if (_.define("TOON"), _.requires.lights = !0, _.extensions.derivatives = !0, _.isShader("vertex")) {
                            let B = this.position ? this.position.analyzeAndFlow(_, "v3", {
                                cache: "position"
                            }) : void 0;
                            _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                resolution: wn.resolution
                            }), _.mergeUniform({
                                previousModelViewMatrix: this.previousModelViewMatrix
                            }), _.mergeUniform({
                                previousProjectionMatrix: this.previouseProjectionMatrix
                            }), _.mergeUniform(ar.merge([aE.fog, aE.lights])), _.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
                            let N = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
                            B && N.push(B.code, B.result ? "displaced_position = " + B.result + ";" : ""), N.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), N.push("	#include <project_vertex>", "	#include <fog_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), N.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), O = N.join(`
`)
                        } else {
                            _.mergeUniform({
                                penumbraSize: wn.penumbraSize
                            }), _.mergeUniform({
                                frameIndex: wn.frameIndex
                            }), _.mergeUniform({
                                aoMap: wn.aoRenderTarget
                            }), _.mergeUniform({
                                aoEnabled: wn.aoEnabled
                            }), void 0 === this.color && (this.color = new bB(5526619)), this.color.analyze(_, {
                                slot: "color"
                            }), this.specular.analyze(_), this.shininess.analyze(_), this.shadingAlpha.analyze(_), this.shadingBlend.analyze(_), this.afterColor && this.afterColor.analyze(_, {
                                slot: "afterColor"
                            }), this.alpha && this.alpha.analyze(_);
                            let B = this.color.flow(_, "c", {
                                    slot: "color"
                                }),
                                N = this.specular.flow(_, "c"),
                                k = this.shininess.flow(_, "f"),
                                F = this.shadingAlpha.flow(_, "f"),
                                U = this.shadingBlend.flow(_, "i"),
                                j = this.afterColor ? this.afterColor.flow(_, "c", {
                                    slot: "afterColor"
                                }) : void 0,
                                G = this.alpha ? this.alpha.flow(_, "f") : void 0,
                                Y = this.alphaOverride ? this.alphaOverride.flow(_, "f") : void 0;
                            _.requires.transparent = void 0 !== G, _.addParsCode(["uniform float penumbraSize[5];", "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "varying vec3 vWPosition;", "#include <normal_pars_fragment>", "#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <dithering_pars_fragment>", `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`, "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>"].join(`
`));
                            let Q = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	ToonMaterial material;"];
                            if (this.bumpMap) {
                                _.include(wg.dHdxy), _.include(wg.perturbNormalArb);
                                let O = this.bumpMap.texture.flow(_, "t"),
                                    B = this.bumpMap.flow(_, "v3"),
                                    N = this.bumpMapIntensity ? this.bumpMapIntensity.flow(_, "f").result : "1.0",
                                    k = "";
                                k = 4 === this.bumpMap.projection.value ? `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;

						vec2 grad0 = dHdxy(${O.result}, uv0, ${N});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${O.result}, uv1, ${N});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${O.result}, uv2, ${N});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					` : `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs;
					vec2 grad = dHdxy(${O.result}, bumpMapCachedUv, ${N});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`, Q.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${B.result};
					${k}
					`)
                            }
                            Q.push(B.code, "	vec3 diffuseColor = " + B.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", N.code, "	vec3 specular = " + N.result + ";", k.code, "	float shininess = max( 0.0001, " + k.result + " );", "	float specularStrength = 1.0;"), G && Q.push(G.code, "#ifdef ALPHATEST", "if ( " + G.result + " <= ALPHATEST ) discard;", "#endif"), Q.push("material.diffuseColor = diffuseColor;"), Q.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), Q.push("vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;");
                            let K = "1.0";
                            this.mask && (this.mask.analyze(_), K = `luminance(${this.mask.flow(_,"v3").result})`), Q.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${F.result} * ${K} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${F.result} * ${K}, ${U.result} );
				}
				`), j && Q.push(j.code, `outgoingLight = spe_blend(outgoingLight, ${j.result}, 1.0, SPE_BLENDING_NORMAL);`), G ? Q.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${G.result} );`) : Q.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), Y && Q.push(`gl_FragColor.a *= ${Y.result};`), Q.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), O = Q.join(`
`)
                        }
                        return O
                    }
                },
                wb = class {
                    constructor(_ = 1e4) {
                        this.timeout = _, this.cache = new Map, this.head = {
                            data: null,
                            time: 0,
                            src: null,
                            next: null,
                            prev: null
                        }, this.tail = {
                            data: null,
                            time: 1 / 0,
                            src: null,
                            next: null,
                            prev: null
                        }, this.hasClean = !1, this.head.next = this.tail, this.tail.prev = this.head
                    }
                    log(..._) {}
                    remove(_) {
                        let O = this.cache.get(_);
                        O && (this.dispose(_, O.data), this.cache.delete(_), O.prev.next = O.next, O.next.prev = O.prev)
                    }
                    scheduleCleanup() {
                        this.hasClean || (this.log("scheduled cleanup"), this.hasClean = !0, setTimeout(() => {
                            this.hasClean = !1, this.log("cleaning");
                            let _ = Date.now(),
                                O = this.head.next;
                            for (; O.time < _ - this.timeout;) this.dispose(O.src, O.data), this.cache.delete(O.src), (O = O.next).prev = this.head, this.head.next = O;
                            this.head.next !== this.tail ? this.scheduleCleanup() : this.log("no more cleanup")
                        }, this.timeout + 1e3))
                    }
                    has(_) {
                        return this.cache.get(_) ? .data
                    }
                    load(_) {
                        let O = Date.now(),
                            B = this.cache.get(_);
                        return void 0 === B ? (B = {
                            data: this.create(_),
                            src: _,
                            time: O,
                            next: null,
                            prev: null
                        }, this.cache.set(_, B)) : (B.time = O, B.prev.next = B.next, B.next.prev = B.prev), B.prev = this.tail.prev, B.next = this.tail, this.tail.prev.next = B, this.tail.prev = B, this.scheduleCleanup(), B.data
                    }
                },
                w_ = class extends wb {
                    create(_) {
                        return URL.createObjectURL(new Blob([_]))
                    }
                    dispose(_, O) {
                        URL.revokeObjectURL(O)
                    }
                },
                wS = class {
                    constructor(_, O) {
                        this.data = _, this.cache = O, this.refCount = 0
                    }
                    deref() {
                        this.refCount, this.refCount -= 1, 0 === this.refCount && (this.cache.remove(this), this.dispose())
                    }
                    dispose() {
                        this.refCount
                    }
                },
                wA = class {
                    constructor() {
                        this.cache = new Map
                    }
                    remove(_) {
                        this.cache.delete(_.data)
                    }
                    load(_) {
                        let O = this.cache.get(_);
                        return void 0 === O && (O = this.create(_), this.cache.set(_, O)), O.refCount += 1, O
                    }
                },
                wM = class extends wS {
                    constructor(_, O) {
                        super(_, O.imageHolderCache), this.data = _, this.shared = O, this.loaded = !1, this.isVideo = !1, this.isVideo = "video" === _.type, this.updateSrc(_.data)
                    }
                    async updateSrc(_) {
                        if (typeof document > "u") return;
                        this.disposeTextures(), this.loaded = !1;
                        let r = () => {
                            for (let _ of (this.loaded = !0, [1e3, 1001, 1002])) {
                                let O = this[_];
                                O && (O.image = this.img, O.needsUpdate = !0)
                            }
                            this.shared.requestRender()
                        };
                        if (this.isVideo) {
                            if (this.img = document.createElement("video"), this.img.preload = "auto", this.img.playsInline = !0, this.img.currentTime = .01, "string" != typeof _) {
                                let B;
                                var O = new FileReader;
                                O.readAsDataURL(new Blob([_], {
                                    type: "video/mp4"
                                })), await new Promise(_ => {
                                    O.onloadend = O => {
                                        B = O.target ? .result, _(null)
                                    }
                                }), this.img.src = B
                            } else this.img.src = _;
                            this.img.onloadeddata = () => {
                                r()
                            }
                        } else this.img = new Image, this.img.src = "string" == typeof _ ? _ : (wp || (wp = new w_), wp.load(_)), this.img.onload = r
                    }
                    getTexture(_) {
                        let O = this[_];
                        if (O) return O; {
                            let O;
                            return O = this.isVideo ? new nQ(this.img, void 0, _, _) : new ro(this.img, void 0, _, _), this.loaded && (O.needsUpdate = !0), this[_] = O, O
                        }
                    }
                    disposeTextures() {
                        this[1e3] ? .dispose(), this[1e3] = void 0, this[1001] ? .dispose(), this[1001] = void 0, this[1002] ? .dispose(), this[1002] = void 0
                    }
                    dispose() {
                        super.dispose(), this.disposeTextures()
                    }
                },
                wC = class extends wM {},
                wT = {
                    year: 0,
                    month: 1,
                    day: 2,
                    hour: 3,
                    minute: 4,
                    second: 5
                },
                wO = {};

            function qv(_, O, B, N, k, F, U) {
                var j = new Date(0);
                return j.setUTCFullYear(_, O, B), j.setUTCHours(N, k, F, U), j
            }
            var wL = {
                timezoneZ: /^(Z)$/,
                timezoneHH: /^([+-]\d{2})$/,
                timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
            };

            function jp(_, O, B) {
                if (!_ || (N = wL.timezoneZ.exec(_))) return 0;
                if (N = wL.timezoneHH.exec(_)) return cI(F = parseInt(N[1], 10)) ? -(36e5 * F) : NaN;
                if (N = wL.timezoneHHMM.exec(_)) {
                    F = parseInt(N[1], 10);
                    var N, k, F, U = parseInt(N[2], 10);
                    return cI(F, U) ? (k = 36e5 * Math.abs(F) + 6e4 * U, F > 0 ? -k : k) : NaN
                }
                if (function(_) {
                        if (wB[_]) return !0;
                        try {
                            return new Intl.DateTimeFormat(void 0, {
                                timeZone: _
                            }), wB[_] = !0, !0
                        } catch {
                            return !1
                        }
                    }(_)) {
                    O = new Date(O || Date.now());
                    var j = MA(B ? O : qv(O.getFullYear(), O.getMonth(), O.getDate(), O.getHours(), O.getMinutes(), O.getSeconds(), O.getMilliseconds()), _);
                    return -(B ? j : function(_, O, B) {
                        var N = _.getTime() - O,
                            k = MA(new Date(N), B);
                        if (O === k) return O;
                        N -= k - O;
                        var F = MA(new Date(N), B);
                        return k === F ? k : Math.max(k, F)
                    }(O, j, _))
                }
                return NaN
            }

            function MA(_, O) {
                var B, N, k, F = (k = function(_) {
                        if (!wO[_]) {
                            var O = new Intl.DateTimeFormat("en-US", {
                                hour12: !1,
                                timeZone: "America/New_York",
                                year: "numeric",
                                month: "numeric",
                                day: "2-digit",
                                hour: "2-digit",
                                minute: "2-digit",
                                second: "2-digit"
                            }).format(new Date("2014-06-25T04:00:00.123Z"));
                            wO[_] = "06/25/2014, 00:00:00" === O || "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00" === O ? new Intl.DateTimeFormat("en-US", {
                                hour12: !1,
                                timeZone: _,
                                year: "numeric",
                                month: "numeric",
                                day: "2-digit",
                                hour: "2-digit",
                                minute: "2-digit",
                                second: "2-digit"
                            }) : new Intl.DateTimeFormat("en-US", {
                                hourCycle: "h23",
                                timeZone: _,
                                year: "numeric",
                                month: "numeric",
                                day: "2-digit",
                                hour: "2-digit",
                                minute: "2-digit",
                                second: "2-digit"
                            })
                        }
                        return wO[_]
                    }(O)).formatToParts ? function(_, O) {
                        try {
                            for (var B = _.formatToParts(O), N = [], k = 0; k < B.length; k++) {
                                var F = wT[B[k].type];
                                F >= 0 && (N[F] = parseInt(B[k].value, 10))
                            }
                            return N
                        } catch (_) {
                            if (_ instanceof RangeError) return [NaN];
                            throw _
                        }
                    }(k, _) : (B = k.format(_).replace(/\u200E/g, ""), [(N = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(B))[3], N[1], N[2], N[4], N[5], N[6]]),
                    U = qv(F[0], F[1] - 1, F[2], F[3] % 24, F[4], F[5], 0).getTime(),
                    j = _.getTime(),
                    G = j % 1e3;
                return U - (j -= G >= 0 ? G : 1e3 + G)
            }

            function cI(_, O) {
                return -23 <= _ && _ <= 23 && (null == O || 0 <= O && O <= 59)
            }
            var wB = {},
                wz = pn(iS(), 1),
                wN = pn(iA(), 1),
                wk = {
                    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
                    datePattern: /^([0-9W+-]+)(.*)/,
                    YY: /^(\d{2})$/,
                    YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
                    YYYY: /^(\d{4})/,
                    YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
                    MM: /^-(\d{2})$/,
                    DDD: /^-?(\d{3})$/,
                    MMDD: /^-?(\d{2})-?(\d{2})$/,
                    Www: /^-?W(\d{2})$/,
                    WwwD: /^-?W(\d{2})-?(\d{1})$/,
                    HH: /^(\d{2}([.,]\d*)?)$/,
                    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
                    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
                    timeZone: /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/
                };

            function yI(_, O, B) {
                O = O || 0, B = B || 0;
                var N = new Date(0);
                N.setUTCFullYear(_, 0, 4);
                var k = 7 * O + B + 1 - (N.getUTCDay() || 7);
                return N.setUTCDate(N.getUTCDate() + k), N
            }
            var wF = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                wU = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

            function wI(_) {
                return _ % 400 == 0 || _ % 4 == 0 && _ % 100 != 0
            }

            function vI(_, O, B) {
                if (O < 0 || O > 11) return !1;
                if (null != B) {
                    if (B < 1) return !1;
                    var N = wI(_);
                    if (N && B > wU[O] || !N && B > wF[O]) return !1
                }
                return !0
            }

            function xI(_, O, B) {
                return !(O < 0 || O > 52 || null != B && (B < 0 || B > 6))
            }

            function CA(_, O, B) {
                return !(null != _ && (_ < 0 || _ >= 25) || null != O && (O < 0 || O >= 60) || null != B && (B < 0 || B >= 60))
            }

            function zn(_, O) {
                return O.color(_)
            }

            function IA(_ = new Date, O) {
                var B, N, k, F, U, j;
                let G, Y, Q = O.format,
                    K = _.getSeconds(),
                    $ = _;
                O && null !== O.timeZone && (B = new Date, N = O.timeZone, k = function(_, O) {
                    if (arguments.length < 1) throw TypeError("1 argument required, but only " + arguments.length + " present");
                    if (null === _) return new Date(NaN);
                    var B = O || {},
                        N = null == B.additionalDigits ? 2 : (0, wz.default)(B.additionalDigits);
                    if (2 !== N && 1 !== N && 0 !== N) throw RangeError("additionalDigits must be 0, 1 or 2");
                    if (_ instanceof Date || "object" == typeof _ && "[object Date]" === Object.prototype.toString.call(_)) return new Date(_.getTime());
                    if ("number" == typeof _ || "[object Number]" === Object.prototype.toString.call(_)) return new Date(_);
                    if (!("string" == typeof _ || "[object String]" === Object.prototype.toString.call(_))) return new Date(NaN);
                    var k = function(_) {
                            var O, B = {},
                                N = wk.dateTimePattern.exec(_);
                            if (N ? (B.date = N[1], O = N[3]) : (N = wk.datePattern.exec(_)) ? (B.date = N[1], O = N[2]) : (B.date = null, O = _), O) {
                                var k = wk.timeZone.exec(O);
                                k ? (B.time = O.replace(k[1], ""), B.timeZone = k[1].trim()) : B.time = O
                            }
                            return B
                        }(_),
                        F = function(_, O) {
                            var B, N = wk.YYY[O],
                                k = wk.YYYYY[O];
                            if (B = wk.YYYY.exec(_) || k.exec(_)) {
                                var F = B[1];
                                return {
                                    year: parseInt(F, 10),
                                    restDateString: _.slice(F.length)
                                }
                            }
                            if (B = wk.YY.exec(_) || N.exec(_)) {
                                var U = B[1];
                                return {
                                    year: 100 * parseInt(U, 10),
                                    restDateString: _.slice(U.length)
                                }
                            }
                            return {
                                year: null
                            }
                        }(k.date, N),
                        U = F.year,
                        j = function(_, O) {
                            if (null === O) return null;
                            if (0 === _.length) return (N = new Date(0)).setUTCFullYear(O), N;
                            if (B = wk.MM.exec(_)) return N = new Date(0), vI(O, k = parseInt(B[1], 10) - 1) ? (N.setUTCFullYear(O, k), N) : new Date(NaN);
                            if (B = wk.DDD.exec(_)) {
                                N = new Date(0);
                                var B, N, k, F, U = parseInt(B[1], 10);
                                return ! function(_, O) {
                                    if (O < 1) return !1;
                                    var B = wI(_);
                                    return !(B && O > 366 || !B && O > 365)
                                }(O, U) ? new Date(NaN) : (N.setUTCFullYear(O, 0, U), N)
                            }
                            if (B = wk.MMDD.exec(_)) {
                                N = new Date(0), k = parseInt(B[1], 10) - 1;
                                var j = parseInt(B[2], 10);
                                return vI(O, k, j) ? (N.setUTCFullYear(O, k, j), N) : new Date(NaN)
                            }
                            if (B = wk.Www.exec(_)) return xI(O, F = parseInt(B[1], 10) - 1) ? yI(O, F) : new Date(NaN);
                            if (B = wk.WwwD.exec(_)) {
                                F = parseInt(B[1], 10) - 1;
                                var G = parseInt(B[2], 10) - 1;
                                return xI(O, F, G) ? yI(O, F, G) : new Date(NaN)
                            }
                            return null
                        }(F.restDateString, U);
                    if (isNaN(j) || !j) return new Date(NaN);
                    var G, Y = j.getTime(),
                        Q = 0;
                    if (k.time && isNaN(Q = function(_) {
                            var O, B, N;
                            if (O = wk.HH.exec(_)) return CA(B = parseFloat(O[1].replace(",", "."))) ? B % 24 * 36e5 : NaN;
                            if (O = wk.HHMM.exec(_)) return CA(B = parseInt(O[1], 10), N = parseFloat(O[2].replace(",", "."))) ? B % 24 * 36e5 + 6e4 * N : NaN;
                            if (O = wk.HHMMSS.exec(_)) {
                                B = parseInt(O[1], 10), N = parseInt(O[2], 10);
                                var k = parseFloat(O[3].replace(",", "."));
                                return CA(B, N, k) ? B % 24 * 36e5 + 6e4 * N + 1e3 * k : NaN
                            }
                            return null
                        }(k.time))) return new Date(NaN);
                    if (k.timeZone || B.timeZone) {
                        if (isNaN(G = jp(k.timeZone || B.timeZone, new Date(Y + Q)))) return new Date(NaN)
                    } else G = (0, wN.default)(new Date(Y + Q)), G = (0, wN.default)(new Date(Y + Q + G));
                    return new Date(Y + Q + G)
                }(B, void 0), F = jp(N, k, !0), U = new Date(k.getTime() - F), (j = new Date(0)).setFullYear(U.getUTCFullYear(), U.getUTCMonth(), U.getUTCDate()), j.setHours(U.getUTCHours(), U.getUTCMinutes(), U.getUTCSeconds(), U.getUTCMilliseconds()), $ = j);
                let ee = $.getHours(),
                    et = $.getMinutes(),
                    ei;
                "12ampm" === O.format12h24h && (ei = ee >= 12 ? "PM" : "AM");
                let er = ee;
                switch ("24" !== O.format12h24h && 0 == (er = ee % 12) && (er = 12), Q) {
                    case "HH:mm:ss":
                        G = [er, et, K];
                        break;
                    case "HH:mm":
                        G = [er, et];
                        break;
                    case "HH":
                        G = [er], ei = void 0;
                        break;
                    case "mm":
                        G = [et], ei = void 0;
                        break;
                    case "ss":
                        G = [K], ei = void 0;
                        break;
                    case "year":
                        Y = $.getFullYear();
                        break;
                    case "month":
                        Y = $.getMonth() + 1;
                        break;
                    case "dayOfYear":
                        Y = Math.floor(($.getTime() - new Date($.getFullYear(), 0, 0).getTime()) / 864e5);
                        break;
                    case "dayOfMonth":
                        Y = $.getDate();
                        break;
                    case "secondOfDay":
                        Y = 3600 * ee + 60 * et + K;
                        break;
                    default:
                        console.error("Unknown time format", Q), Y = 0
                }
                return void 0 !== G ? {
                    textValue: G,
                    suffix: ei
                } : Y
            }

            function Ps(_, O) {
                let {
                    alpha: B,
                    mode: N,
                    isMask: k
                } = _, F = "string" == typeof B ? (Number(O.getVariable(B)) ? ? 100) / 100 : B;
                return {
                    type: _.type,
                    alpha: F,
                    mode: N,
                    isMask: k
                }
            }
            var wj = class extends x8 {},
                wG = {
                    noise: ["noiseType"],
                    texture: ["projection", "axis", "side"],
                    video: ["projection", "axis", "side"],
                    displace: ["noiseType"],
                    light: ["roughnessMap", "bumpMap"],
                    depth: ["smooth", "isWorldSpace", "gradientType", "isVector"],
                    pattern: ["style", "projection", "axis"]
                },
                wH = {
                    depth: ["colors"]
                };

            function LA(_, O, B) {
                let N = B.uniforms[`f${B.id}_texture`];
                if (!N) return !1;
                if ("image" in _) {
                    let B = _.image,
                        k = O.image(B);
                    N.image instanceof wC || N.image.deref(), N.image = k
                }
                if ("video" in _) {
                    let B = _.video,
                        k = O.video(B);
                    N.image instanceof wC || N.image.deref(), N.image = k
                }
                if ("wrapping" in _ && (N.wrap = _.wrapping), "repeat" in _ || "offset" in _) {
                    let O = B.uniforms[`f${B.id}_mat`];
                    "repeat" in _ && (O.repeat = _.repeat), "offset" in _ && (O.offset = _.offset), O.updateMatrix()
                }
                return !1
            }
            var ml = (_, O, B) => Math.max(0, Math.min(1, Number(O.getVariable("number" == typeof _ ? 100 * _ : _, B) ? ? 100) / 100)) ? ? 1,
                wW = class {
                    constructor(_, O, B, N, k) {
                        for (let k in this.id = _, this.uuid = O, this.data = B, this.uniforms = {}, N) this.uniforms[`f${this.id}_${k}`] = N[k];
                        for (let _ in B) NA(_, this, B, k)
                    }
                    get type() {
                        return this.data.type
                    }
                    static create(_, O, B, N) {
                        if ("light" === B.type) return wX.createLigherLayer(_, O, B, N);
                        if ("texture" === B.type || "video" === B.type) {
                            let k = "texture" === B.type ? N.image(B.texture.image) : N.video(B.texture.video),
                                F = new bj(k, B.texture.wrapping),
                                U = new bU(k),
                                j = new bW(B.texture.repeat, B.texture.offset),
                                G = new bd(B.crop ? 1 : 0),
                                Y = new bz(B.projection ? ? 0),
                                Q = new bz(["x", "y", "z"].indexOf(B.axis) ? ? 0),
                                K = new bz(B.side ? ? 0),
                                $ = new x5(B.size ? new iJ(B.size[0], B.size[1]) : new iJ(100, 100)),
                                ee = new bd(B.blending ? ? 0),
                                et = new bd(ml(B.alpha, N)),
                                ei = new bz(B.mode ? ? 0),
                                er = new bN(B.isMask ? ? !1),
                                ea = new bK(F, U, G, Y, Q, K, $, ee, j, et, ei, er),
                                en = new bh(ea.calpha, "f");
                            return new wq(_, O, B, {
                                texture: F,
                                textureSize: U,
                                crop: G,
                                projection: Y,
                                axis: Q,
                                side: K,
                                size: $,
                                blending: ee,
                                mat: j,
                                alpha: et,
                                mode: ei,
                                isMask: er
                            }, ea, ei, en, er, N)
                        }
                        if ("matcap" === B.type) {
                            let k = N.image(B.texture.image),
                                F = new bj(k, B.texture.wrapping),
                                U = new bd(ml(B.alpha, N)),
                                j = new bz(B.mode ? ? 0),
                                G = new bN(B.isMask ? ? !1),
                                Y = new b3(F, U, j, G),
                                Q = new bh(Y.calpha, "f");
                            return new wq(_, O, B, {
                                texture: F,
                                alpha: U,
                                mode: j,
                                isMask: G
                            }, Y, j, Q, G, N)
                        }
                        if ("displace" !== B.type) {
                            let k;
                            return k = function(_, O) {
                                    switch (_.type) {
                                        case "fresnel":
                                            return function(_, O) {
                                                let {
                                                    bias: B,
                                                    scale: N,
                                                    intensity: k,
                                                    factor: F,
                                                    color: U
                                                } = _;
                                                return { ...Ps(_, O),
                                                    color: zn(U, O),
                                                    bias: B,
                                                    scale: N,
                                                    intensity: k,
                                                    factor: F
                                                }
                                            }(_, O);
                                        case "gradient":
                                            return function(_, O) {
                                                let {
                                                    gradientType: B,
                                                    smooth: N,
                                                    colors: k,
                                                    steps: F,
                                                    angle: U,
                                                    offset: j,
                                                    morph: G
                                                } = _;
                                                return { ...Ps(_, O),
                                                    gradientType: B,
                                                    smooth: N,
                                                    colors: k.map(_ => new rl(_[0], _[1], _[2], _[3])),
                                                    num: k.length,
                                                    steps: F,
                                                    offset: new iJ(...j),
                                                    morph: new iJ(...G),
                                                    angle: U
                                                }
                                            }(_, O);
                                        case "depth":
                                            return function(_, O) {
                                                let {
                                                    gradientType: B,
                                                    near: N,
                                                    far: k,
                                                    isVector: F,
                                                    isWorldSpace: U,
                                                    origin: j,
                                                    direction: G,
                                                    colors: Y,
                                                    steps: Q,
                                                    smooth: K
                                                } = _;
                                                return { ...Ps(_, O),
                                                    gradientType: B,
                                                    near: N,
                                                    far: k,
                                                    isVector: F,
                                                    isWorldSpace: U,
                                                    origin: new rv(...j),
                                                    direction: G ? new rv(...G) : new rv(1, 0, 0),
                                                    colors: Y.map(_ => void 0 !== _ ? new rl(_[0], _[1], _[2], _[3]) : new rl(0, 0, 0, 0)),
                                                    steps: Q.slice(0, Y.length),
                                                    smooth: K
                                                }
                                            }(_, O);
                                        case "normal":
                                            return function(_, O) {
                                                let {
                                                    cnormal: B
                                                } = _;
                                                return { ...Ps(_, O),
                                                    cnormal: new rv(B[0], B[1], B[2])
                                                }
                                            }(_, O);
                                        case "noise":
                                            return { ...Ps(_, O),
                                                scale: _.scale,
                                                move: _.move,
                                                fA: new iJ(..._.fA),
                                                fB: new iJ(..._.fB),
                                                size: new rv(..._.size),
                                                distortion: new iJ(..._.distortion),
                                                colorA: zn(_.colorA, O),
                                                colorB: zn(_.colorB, O),
                                                colorC: zn(_.colorC, O),
                                                colorD: zn(_.colorD, O),
                                                noiseType: _.noiseType,
                                                voronoiStyle: _.voronoiStyle,
                                                highCut: _.highCut,
                                                lowCut: _.lowCut,
                                                smoothness: _.smoothness,
                                                seed: _.seed,
                                                quality: _.quality
                                            };
                                        case "rainbow":
                                            return { ...Ps(_, O),
                                                filmThickness: _.filmThickness,
                                                movement: _.movement,
                                                wavelengths: new rv(..._.wavelengths),
                                                noiseStrength: _.noiseStrength,
                                                noiseScale: _.noiseScale,
                                                offset: new rv(..._.offset)
                                            };
                                        case "toon":
                                            return { ...Ps(_, O),
                                                positioning: _.positioning,
                                                colors: _.colors.map(_ => new rl(_[0], _[1], _[2], _[3])),
                                                num: _.colors.length,
                                                steps: _.steps,
                                                source: new rv(..._.source),
                                                isWorldSpace: _.isWorldSpace,
                                                noiseStrength: _.noiseStrength,
                                                noiseScale: _.noiseScale,
                                                shadowColor: zn(_.shadowColor, O),
                                                offset: new rv(..._.offset)
                                            };
                                        case "outline":
                                            return { ...Ps(_, O),
                                                outlineColor: zn(_.outlineColor, O),
                                                contourColor: zn(_.contourColor, O),
                                                outlineWidth: _.outlineWidth,
                                                contourWidth: _.contourWidth,
                                                outlineThreshold: _.outlineThreshold,
                                                contourThreshold: _.contourThreshold,
                                                outlineSmoothing: _.outlineSmoothing,
                                                contourFrequency: _.contourFrequency,
                                                contourDirection: new rv(..._.contourDirection),
                                                positionalLines: _.positionalLines,
                                                compensation: _.compensation
                                            };
                                        case "transmission":
                                            return { ...Ps(_, O),
                                                thickness: _.thickness,
                                                ior: _.ior,
                                                roughness: _.roughness
                                            };
                                        case "color":
                                            return { ...Ps(_, O),
                                                color: zn(_.color, O)
                                            };
                                        case "pattern":
                                            return { ...Ps(_, O),
                                                style: _.style,
                                                projection: _.projection,
                                                axis: _.axis,
                                                blending: _.blending,
                                                offset: new iJ(..._.offset),
                                                colorA: zn(_.colorA, O),
                                                colorB: zn(_.colorB, O),
                                                frequency: new iJ(..._.frequency),
                                                size: _.size,
                                                variation: _.variation,
                                                smoothness: _.smoothness,
                                                zigzag: _.zigzag,
                                                rotation: _.rotation,
                                                vertical: new iJ(..._.vertical),
                                                horizontal: new iJ(..._.horizontal),
                                                sides: _.sides
                                            }
                                    }
                                }(B, N),
                                function(_, O, B, N, k) {
                                    switch (_.type) {
                                        case "color":
                                            {
                                                let F = new bB(N.color ? ? 5526619),
                                                    U = es(N),
                                                    j = new bQ(F, U.alpha),
                                                    G = new bh(j.calpha, "f");
                                                return new wq(O, B, _, {
                                                    color: F,
                                                    ...U
                                                }, j, U.mode, G, U.isMask, k)
                                            }
                                        case "fresnel":
                                            {
                                                let F = new bB(N.color ? ? 16777215),
                                                    U = new bd(N.bias ? ? .1),
                                                    j = new bd(N.scale ? ? 1),
                                                    G = new bd(N.intensity ? ? 2),
                                                    Y = new bd(N.factor ? ? 1),
                                                    Q = es(N),
                                                    K = new b$(F, U, j, G, Y, Q.alpha, Q.mode, Q.isMask),
                                                    $ = new bh(K.calpha, "f");
                                                return new wq(O, B, _, {
                                                    color: F,
                                                    bias: U,
                                                    scale: j,
                                                    intensity: G,
                                                    factor: Y,
                                                    ...Q
                                                }, K, Q.mode, $, Q.isMask, k)
                                            }
                                        case "rainbow":
                                            {
                                                let F = new bd(N.filmThickness ? ? 30),
                                                    U = new bd(N.movement ? ? 0),
                                                    j = new x6(N.wavelengths ? ? new rv(0, 0, 0)),
                                                    G = new bd(N.noiseStrength ? ? 0),
                                                    Y = new bd(N.noiseScale ? ? 1),
                                                    Q = new x6(N.offset ? ? new rv(0, 0, 0)),
                                                    K = es(N),
                                                    $ = new b7(F, U, j, G, Y, Q, K.alpha, K.isMask),
                                                    ee = new bh($.calpha, "f");
                                                return new wq(O, B, _, {
                                                    filmThickness: F,
                                                    movement: U,
                                                    wavelengths: j,
                                                    noiseStrength: G,
                                                    noiseScale: Y,
                                                    offset: Q,
                                                    ...K
                                                }, $, K.mode, ee, K.isMask, k)
                                            }
                                        case "transmission":
                                            {
                                                let F = new bd(N.thickness ? ? 10),
                                                    U = new bd(N.ior ? ? 1.5),
                                                    j = new bd(N.roughness ? ? .5),
                                                    G = wn.transmissionSize,
                                                    Y = wn.transmissionRenderTarget,
                                                    Q = wn.transmissionRenderTargetDepth,
                                                    K = window.innerWidth,
                                                    $ = window.innerHeight,
                                                    ee = K >= $ ? new x5($ / K, 1) : new x5(1, K / $),
                                                    et = es(N),
                                                    ei = new wi(F, U, j, G, Y, Q, ee, et.alpha),
                                                    er = new bh(ei.calpha, "f");
                                                return new wq(O, B, _, {
                                                    thickness: F,
                                                    ior: U,
                                                    roughness: j,
                                                    aspectRatio: ee,
                                                    ...et
                                                }, ei, et.mode, er, et.isMask, k)
                                            }
                                        case "toon":
                                            {
                                                let F, U = new bz(N.positioning ? ? 0),
                                                    j;N.colors ? j = new bY(N.colors.length, N.colors) : (j = new bY(10, new rl(0, 0, 0, 1))).value[1] = new rl(1, 1, 1, 1),
                                                N.steps ? F = new bk(N.steps.length, N.steps) : (F = new bk(10, 1)).value[0] = 0;
                                                let G = new x6(N.source ? ? new rv(0, 0, 0)),
                                                    Y = new bN(N.isWorldSpace ? ? !0),
                                                    Q = new bd(N.noiseStrength ? ? 0),
                                                    K = new bd(N.noiseScale ? ? 1),
                                                    $ = new x9(N.shadowColor),
                                                    ee = new x6(N.offset ? ? new rv(0, 0, 0)),
                                                    et = es(N),
                                                    ei = new we(U, j, F, G, Y, Q, K, $, ee, et.alpha),
                                                    er = new bh(ei.calpha, "f");
                                                return new wq(O, B, _, {
                                                    positioning: U,
                                                    colors: j,
                                                    steps: F,
                                                    source: G,
                                                    isWorldSpace: Y,
                                                    noiseStrength: Q,
                                                    noiseScale: K,
                                                    shadowColor: $,
                                                    offset: ee,
                                                    ...et
                                                }, ei, et.mode, er, et.isMask, k)
                                            }
                                        case "outline":
                                            {
                                                let F = new bB(N.outlineColor ? ? 16777215),
                                                    U = new bB(N.contourColor ? ? 16777215),
                                                    j = new bd(N.outlineWidth ? ? .1),
                                                    G = new bd(N.contourWidth ? ? .1),
                                                    Y = new bd(N.outlineThreshold ? ? .1),
                                                    Q = new bd(N.contourThreshold ? ? .1),
                                                    K = new bd(N.outlineSmoothing ? ? .1),
                                                    $ = new bd(N.contourFrequency ? ? .1),
                                                    ee = new x6(N.contourDirection ? ? new rv(0, 1, 0)),
                                                    et = new bN(N.positionalLines ? ? !1),
                                                    ei = new bN(N.compensation ? ? !0),
                                                    er = wn.normalRenderTarget,
                                                    ea = wn.normalRenderTargetDepth,
                                                    en = wn.pixelRatioNode,
                                                    eo = wn.resolution,
                                                    el = es(N),
                                                    eh = new b8(F, U, j, G, Y, Q, K, $, ee, et, ei, eo, er, ea, en, el.alpha),
                                                    ec = new bh(eh.calpha, "f");
                                                return new wq(O, B, _, {
                                                    outlineColor: F,
                                                    contourColor: U,
                                                    outlineWidth: j,
                                                    contourWidth: G,
                                                    outlineThreshold: Y,
                                                    contourThreshold: Q,
                                                    outlineSmoothing: K,
                                                    contourFrequency: $,
                                                    contourDirection: ee,
                                                    positionalLines: et,
                                                    compensation: ei,
                                                    ...el
                                                }, eh, el.mode, ec, el.isMask, k)
                                            }
                                        case "depth":
                                            {
                                                let F, U = new bz(N.gradientType ? ? 0),
                                                    j = new bN(N.smooth ? ? !1),
                                                    G = new bd(N.near ? ? 50),
                                                    Y = new bd(N.far ? ? 200),
                                                    Q = new bd(N.isVector ? ? 1),
                                                    K = new bd(N.isWorldSpace ? ? 0),
                                                    $ = new x6(N.origin ? ? new rv),
                                                    ee = new x6(N.direction ? ? new rv),
                                                    et;N.colors ? et = new bY(N.colors.length, N.colors) : (et = new bY(2, new rl(0, 0, 0, 1))).value[1] = new rl(1, 1, 1, 1),
                                                N.steps ? F = new bk(N.steps.length, N.steps) : (F = new bk(2, 1)).value[0] = 0;
                                                let ei = es(N),
                                                    er = new bJ(U, j, G, Y, Q, K, $, ee, et, F, ei.alpha, ei.isMask),
                                                    ea = new bh(er.calpha, "f");
                                                return new wq(O, B, _, {
                                                    gradientType: U,
                                                    smooth: j,
                                                    near: G,
                                                    far: Y,
                                                    isVector: Q,
                                                    isWorldSpace: K,
                                                    origin: $,
                                                    direction: ee,
                                                    colors: et,
                                                    steps: F,
                                                    ...ei
                                                }, er, ei.mode, ea, ei.isMask, k)
                                            }
                                        case "noise":
                                            {
                                                let F = new bd(N.scale ? ? 1),
                                                    U = new x6(N.size ? ? new rv(100, 100, 100)),
                                                    j = new bd(N.move ? ? 1),
                                                    G = new x5(N.fA ? ? new iJ(1.7, 9.2)),
                                                    Y = new x5(N.fB ? ? new iJ(8.3, 2.8)),
                                                    Q = new x5(N.distortion ? ? new iJ(1, 1)),
                                                    K = new x9(N.colorA),
                                                    $ = new x9(N.colorB),
                                                    ee = new x9(N.colorC),
                                                    et = new x9(N.colorD),
                                                    ei = new bz(N.noiseType ? ? 0),
                                                    er = new bz(N.voronoiStyle ? ? 0),
                                                    ea = new bd(N.highCut ? ? 1),
                                                    en = new bd(N.lowCut ? ? 0),
                                                    eo = new bd(N.smoothness ? ? .5),
                                                    el = new bd(N.seed ? ? .5),
                                                    eh = new bz(N.quality ? ? 1),
                                                    ec = es(N),
                                                    eu = new b6(F, U, j, G, Y, Q, K, $, ee, et, ec.alpha, ei, ec.isMask, er, ea, en, eo, el, eh),
                                                    ep = new bh(eu.calpha, "f");
                                                return new wq(O, B, _, {
                                                    scale: F,
                                                    size: U,
                                                    move: j,
                                                    fA: G,
                                                    fB: Y,
                                                    distortion: Q,
                                                    colorA: K,
                                                    colorB: $,
                                                    colorC: ee,
                                                    colorD: et,
                                                    noiseType: ei,
                                                    ...ec,
                                                    voronoiStyle: er,
                                                    highCut: ea,
                                                    lowCut: en,
                                                    smoothness: eo,
                                                    seed: el,
                                                    quality: eh
                                                }, eu, ec.mode, ep, ec.isMask, k)
                                            }
                                        case "normal":
                                            {
                                                let F = new x6(N.cnormal ? ? new rv(1, 1, 1)),
                                                    U = es(N),
                                                    j = new bZ(F, U.alpha),
                                                    G = new bh(j.calpha, "f");
                                                return new wq(O, B, _, {
                                                    cnormal: F,
                                                    ...U
                                                }, j, U.mode, G, U.isMask, k)
                                            }
                                        case "gradient":
                                            {
                                                let F, U = new bz(N.gradientType ? ? 0),
                                                    j = new bN(N.smooth ? ? !1),
                                                    G;N.colors ? G = new bY(N.colors.length, N.colors) : (G = new bY(10, new rl(0, 0, 0, 1))).value[1] = new rl(1, 1, 1, 1),
                                                N.steps ? F = new bk(N.steps.length, N.steps) : (F = new bk(10, 1)).value[0] = 0;
                                                let Y = new x5(N.offset ? ? new iJ(0, 0)),
                                                    Q = new x5(N.morph ? ? new iJ(0, 0)),
                                                    K = new bd(N.angle ? ? 0),
                                                    $ = es(N),
                                                    ee = new b0(U, j, G, F, Y, Q, K, $.alpha, $.isMask),
                                                    et = new bh(ee.calpha, "f");
                                                return new wq(O, B, _, {
                                                    gradientType: U,
                                                    smooth: j,
                                                    colors: G,
                                                    steps: F,
                                                    offset: Y,
                                                    morph: Q,
                                                    angle: K,
                                                    ...$
                                                }, ee, $.mode, et, $.isMask, k)
                                            }
                                        case "pattern":
                                            {
                                                let F = new bz(N.style ? ? 0),
                                                    U = new bz(N.projection ? ? 0),
                                                    j = new bz(["x", "y", "z"].indexOf(N.axis) ? ? 0),
                                                    G = new bd(N.blending ? ? 0),
                                                    Y = new x5(N.offset ? ? new iJ(0, 0)),
                                                    Q = new x9(N.colorA),
                                                    K = new x9(N.colorB),
                                                    $ = new x5(N.frequency ? ? new iJ(10, 10)),
                                                    ee = new bd(N.size ? ? .5),
                                                    et = new bd(N.variation ? ? 0),
                                                    ei = new bd(N.smoothness ? ? .5),
                                                    er = new bd(N.zigzag ? ? 0),
                                                    ea = new bd(N.rotation ? ? 0),
                                                    en = new x5(N.vertical ? ? new iJ(0, 1)),
                                                    eo = new x5(N.horizontal ? ? new iJ(0, 1)),
                                                    el = new bz(N.sides ? ? 6),
                                                    eh = es(N),
                                                    ec = new b9(F, U, j, G, Y, Q, K, $, ee, et, ei, er, ea, en, eo, el, eh.alpha, eh.isMask),
                                                    eu = new bh(ec.calpha, "f");
                                                return new wq(O, B, _, {
                                                    style: F,
                                                    projection: U,
                                                    axis: j,
                                                    blending: G,
                                                    offset: Y,
                                                    colorA: Q,
                                                    colorB: K,
                                                    frequency: $,
                                                    size: ee,
                                                    variation: et,
                                                    smoothness: ei,
                                                    zigzag: er,
                                                    rotation: ea,
                                                    vertical: en,
                                                    horizontal: eo,
                                                    sides: el,
                                                    ...eh
                                                }, ec, eh.mode, eu, eh.isMask, k)
                                            }
                                        default:
                                            {
                                                let F = new bB(1, 0, 0, 1),
                                                    U = es(N),
                                                    j = new bQ(F, U.alpha),
                                                    G = new bh(j.calpha, "f");
                                                return new wq(O, B, _, {
                                                    color: F,
                                                    ...U
                                                }, j, U.mode, G, U.isMask, k)
                                            }
                                    }
                                }(B, _, O, k, N)
                        }
                        if ("noise" === B.displacementType) {
                            let k = new x6(new rv(...B.offset)),
                                F = new bd(B.scale ? ? 10),
                                U = new bd(B.intensity ? ? 8),
                                j = new bd(B.movement ? ? 1),
                                G = new bz(B.noiseType ? ? 0),
                                Y = new bz(B.voronoiStyle ? ? 0),
                                Q = new bd(B.smoothness ? ? .5),
                                K = new bd(B.seed ? ? 0),
                                $ = new bd(B.highCut ? ? 1),
                                ee = new bd(B.lowCut ? ? 0),
                                et = new bz(B.quality ? ? 1),
                                ei = new wa(U, j, k, Y, Q, K, $, ee, et, F, G);
                            return new wY(_, O, B, {
                                offset: k,
                                scale: F,
                                intensity: U,
                                movement: j,
                                noiseType: G,
                                voronoiStyle: Y,
                                smoothness: Q,
                                seed: K,
                                highCut: $,
                                lowCut: ee,
                                quality: et
                            }, ei, N)
                        }
                        throw Error()
                    }
                    updateByOp(_, O, B) {
                        if (void 0 === _.path[0]) {
                            if (0 === _.type) return "type" in _.props || "category" in _.props || "visible" in _.props ? (B.scene.markNeedsUpdateRendererDirty(), !0) : function(_, O, B, N) {
                                let k = !1;
                                for (let [F, U] of Object.entries(_)) {
                                    if ("bumpMap" === F || "roughnessMap" === F) {
                                        k = !0;
                                        continue
                                    }
                                    if (!F || void 0 === U) continue;
                                    if (NA(F, B, N, O)) {
                                        "visible" === F && "light" === B.type && (k = !0);
                                        continue
                                    }
                                    B.visible = N.visible;
                                    let _ = B.uniforms[`f${B.id}_${F}`];
                                    if (_ && !(_ instanceof bF)) switch (k = k || function(_, O, B) {
                                        if ("isMask" === O) return !0;
                                        let N = wG[_.type],
                                            k = wH[_.type];
                                        if (void 0 !== k) {
                                            let N = _.color;
                                            if (k.includes(O)) {
                                                let _ = N[O] ? .value ? .length;
                                                if (void 0 !== _ && _ !== B.length) return !0
                                            }
                                        }
                                        return void 0 !== N && N.includes(O)
                                    }(B, F, U), _.constructor) {
                                        case bB:
                                            if ("string" == typeof U) {
                                                let B = O.getColor(U);
                                                B && (_.value = B);
                                                break
                                            }
                                            _.value instanceof wj ? _.value = new x8(U.r, U.g, U.b, U.a) : _.setRGBA(U);
                                            break;
                                        case x9:
                                            if ("string" == typeof U) {
                                                let B = O.getColor(U);
                                                B && (_.value = B);
                                                break
                                            }
                                            _.value instanceof wj ? _.value = new x8(U.r, U.g, U.b, U.a) : _.value.setRGBA(U.r, U.g, U.b, U.a);
                                            break;
                                        case x5:
                                            _.value.setX(U[0]), _.value.setY(U[1]);
                                            break;
                                        case x6:
                                            _.value.setX(U[0]), _.value.setY(U[1]), _.value.setZ(U[2]);
                                            break;
                                        case bc:
                                            LA(U, O, B);
                                            break;
                                        case bY:
                                            _.value = U.map(_ => new rl(..._));
                                            break;
                                        default:
                                            _.value = U
                                    }
                                }
                                return k
                            }(_.props, B.shared, this, O)
                        } else if ("texture" === _.path[0]) return !("texture" in O) && !("video" in O) || LA(_.props, B.shared, this);
                        return !1
                    }
                    dispose() {
                        let _;
                        if ("texture" === (_ = this instanceof wW ? this.type : this) || "video" === _ || "displace_map" === _ || "matcap" === _) {
                            let _ = this.uniforms[`f${this.id}_texture`];
                            if (!_) return !1;
                            _.image instanceof wC || _.image.deref()
                        }
                    }
                    hasValueByKey(_) {
                        return void 0 !== this.uniforms[_]
                    }
                    hasValue(_) {
                        return this.hasValueByKey(`f${this.id}_${_}`)
                    }
                    setValue(_, O) {
                        let B = `f${this.id}_${_}`;
                        this.hasValueByKey(B) && void 0 !== O && (this.uniforms[B].value = O)
                    }
                    getNode(_) {
                        let O = `f${this.id}_${_}`;
                        if (this.hasValueByKey(O)) return this.uniforms[O]
                    }
                    getValue(_) {
                        let O = `f${this.id}_${_}`;
                        if (this.hasValueByKey(O)) return this.uniforms[O].value
                    }
                    getName(_) {
                        let O = /f\d+_(.*)/.exec(_);
                        if (O && O.length > 1) return O[1];
                        console.log(`Layer.getName: error ${_}`)
                    }
                    getNames() {
                        let _ = [];
                        for (let O in this.uniforms) {
                            let B = this.getName(O);
                            B && _.push(B)
                        }
                        return _
                    }
                },
                wq = class extends wW {
                    constructor(_, O, B, N, k, F, U, j, G) {
                        super(_, O, B, N, G), this.params = N, this.color = k, this.mode = F, this.alpha = U, this.isMask = j
                    }
                },
                wY = class extends wW {
                    constructor(_, O, B, N, k, F) {
                        super(_, O, B, N, F), this.position = k
                    }
                },
                wX = class extends wW {
                    constructor(_, O, B, N, k, F) {
                        super(_, O, B, k, F), this.node = N
                    }
                    static createLigherLayer(_, O, B, N) {
                        let k, F = new bd(ml(B.alpha, N)),
                            U = new bz(B.mode),
                            j = new bd(B.bumpMapIntensity),
                            G = new bd(ml(B.alphaOverride, N)),
                            Y;
                        if (B.visible) {
                            if ("lambert" === B.category) {
                                k = new wm;
                                let _ = new bB(N.color(B.emissive) ? ? 0),
                                    O = new bN(B.occlusion ? ? !0);
                                Y = {
                                    emissive: _,
                                    occlusion: O
                                }, k.emissive = _, k.occlusion = O
                            } else if ("toon" === B.category) {
                                k = new wx;
                                let _ = new bd(B.shininess ? ? 30),
                                    O = new bB(N.color(B.specular) ? ? 1118481);
                                Y = {
                                    shininess: _,
                                    specular: O
                                }, k.shininess = _, k.specular = O
                            } else if ("physical" === B.category) {
                                k = new wy;
                                let _ = new bd(B.roughness ? ? .3),
                                    O = new bd(B.metalness ? ? 0),
                                    N = new bd(B.reflectivity ? ? .5),
                                    F = new bN(B.occlusion ? ? !0);
                                Y = {
                                    roughness: _,
                                    metalness: O,
                                    reflectivity: N,
                                    occlusion: F
                                }, k.roughness = _, k.metalness = O, k.reflectivity = N, k.occlusion = F
                            } else {
                                k = new wv;
                                let _ = new bd(B.shininess ? ? 30),
                                    O = new bB(void 0 !== B.specular ? N.color(B.specular) ? ? 1118481 : 1118481),
                                    F = new bN(B.occlusion ? ? !0);
                                Y = {
                                    shininess: _,
                                    specular: O,
                                    occlusion: F
                                }, k.shininess = _, k.specular = O, k.occlusion = F
                            }
                        } else k = new wf, Y = {};
                        return k.alpha = new bd(1), k.shadingAlpha = F, k.shadingBlend = U, k.bumpMapIntensity = j, k.alphaOverride = G, Y.alpha = k.shadingAlpha, Y.mode = k.shadingBlend, Y.bumpMapIntensity = k.bumpMapIntensity, Y.alphaOverride = k.alphaOverride, new wX(_, O, B, k, Y, N)
                    }
                    get category() {
                        return this.node.category
                    }
                };

            function es(_) {
                return {
                    alpha: new bd(_.alpha ? ? 1),
                    mode: new bz(_.mode ? ? 0),
                    isMask: new bN(_.isMask ? ? !1)
                }
            }

            function NA(_, O, B, N) {
                if ("displace" === B.type && ("intensity" === _ || "visible" === _)) {
                    let _ = O.uniforms[`f${O.id}_intensity`];
                    return _ ? (_.value = B.intensity * (B.visible ? 1 : 0), _) : void 0
                }
                if ("displace" !== B.type && ("alpha" === _ || "visible" === _)) {
                    let k = O.uniforms[`f${O.id}_alpha`];
                    if (!k) return;
                    if (k.value = ml(B.alpha, N) * (B.visible ? 1 : 0), "outline" === B.type && "visible" === _) {
                        let _ = O.uniforms[`f${O.id}_compensation`];
                        _ && (_.value = B.compensation && B.visible)
                    }
                    return k
                }
            }

            function _c(_, O) {
                let B = 0,
                    N = _.layers.find(_ => "light" === _.data.type);
                if (N) {
                    let _ = N.data,
                        B = Number(O.getVariable(_.alphaOverride));
                    if (("string" == typeof _.alphaOverride ? B / 100 : _.alphaOverride) < 1) return !0
                }
                for (let N of _.layers) {
                    if ("displace" !== N.data.type && N.data.isMask) return !0;
                    if ("displace" !== N.data.type && "alpha" in N.data && "light" !== N.data.type && "fresnel" !== N.data.type && "texture" !== N.data.type && "matcap" !== N.data.type && "rainbow" !== N.data.type && "outline" !== N.data.type && "pattern" !== N.data.type) {
                        let _ = N.data.visible ? N.data.alpha : 0;
                        if ("string" == typeof _ && (_ = Math.max(0, Math.min(1, Number(O.getVariable(_) ? ? 100) / 100))), 1 === _ && "depth" === N.data.type || "gradient" === N.data.type) {
                            for (let O of N.data.colors)
                                if (O[3] < 1) {
                                    _ = O[3];
                                    break
                                }
                        } else if (1 === _ && "noise" === N.data.type) {
                            let B = Math.min(O.color(N.data.colorA).a, Math.min(O.color(N.data.colorB).a, Math.min(O.color(N.data.colorC).a, O.color(N.data.colorD).a)));
                            B < 1 && (_ = B)
                        }
                        B += (1 - B) * _
                    }
                }
                return B < 1
            }
            var wQ = class extends an {
                    constructor() {
                        super(void 0), this.flatShading = !1, this.needsJitter = !0, this.cacheKey = "", this.fog = !0, this.dithering = !0, this.vertexColors = !0, this.transparent = !0
                    }
                    customProgramCacheKey() {
                        return this.cacheKey
                    }
                },
                wZ = class extends wQ {
                    constructor(_, O, B, N) {
                        super(), this.flatShading = _, this.side = O, this.wireframe = B, this.root = N
                    }
                    updateAfterBuild() {
                        let _ = this.root;
                        this.lights = _.lights, this.vertexShader = _.vertexShader, this.fragmentShader = _.fragmentShader, this.defines = _.defines, this.uniforms = _.uniforms, this.extensions = _.extensions, this.transparent = _.transparent, this.cacheKey = _.customProgramCacheKey() + "flat" + this.flatShading + this.side
                    }
                    onBeforeCompile(_, O) {
                        this.root.onBeforeCompile(_)
                    }
                    get data() {
                        return this.root.data
                    }
                    get category() {
                        return this.root.category
                    }
                    get hasAO() {
                        return this.root.hasAO
                    }
                    getFlavor(_, O, B) {
                        return this.root.getFlavor(_, O, B)
                    }
                    get layers() {
                        return this.root.layers
                    }
                    get fragment() {
                        return this.root.fragment
                    }
                    getLayersOfType(_) {
                        return this.root.getLayersOfType(_)
                    }
                    getLayerByUuid(_) {
                        return this.root.getLayerByUuid(_)
                    }
                    updateByOp(_, O, B) {
                        this.root.updateByOp(_, O, B)
                    }
                    nodeMaterialDispose() {
                        this.root.nodeMaterialDispose()
                    }
                },
                wK = class extends wQ {
                    constructor(_, O, B = !0) {
                        super(), this.data = _, this.allowVariableSaves = B, this.layerIdGen = 0, this.flavors = [], this.masks = {}, this.type = "NodeMaterial", this.updaters = [], this.reset0(_, O)
                    }
                    get nodeMaterial() {
                        return this
                    }
                    getFlavor(_, O, B) {
                        let N = B ? 6 : (_ ? 3 : 0) + O;
                        if (0 === N) return this;
                        void 0 === this.flavors && (this.flavors = []), N -= 1;
                        let k = this.flavors[N];
                        return void 0 === k && (k = new wZ(_, O, B, this), this.flavors[N] = k, k.flatShading = _, k.side = O, k.updateAfterBuild()), k
                    }
                    get fragment() {
                        return this.lightLayer.node
                    }
                    get category() {
                        return this.lightLayer.category
                    }
                    get hasAO() {
                        return this.lightLayer.getNode("occlusion") ? .value ? ? !1
                    }
                    reset(_, O) {
                        this.data !== _ && this.reset0(_, O)
                    }
                    reset0(_, O) {
                        this.data = _;
                        let B = _.layers ? ? m0.defaultTwoLayerData("phong").layers;
                        try {
                            this.layers = B.map(_ => wW.create(this.layerIdGen++, _.id, _.data, O.shared))
                        } catch {
                            this.layers = []
                        }
                        this.layers.reverse(), this.name = _.name ? ? "Untitled Material", this.onUpdate(O.shared), this.transparent = _c(_, O.shared), this.saveVariableLocations(O)
                    }
                    onVariableUpdate(_, O, B) {
                        if ("alphaOverride" === _[0]) this.transparent = _c(this.data, B.shared), this.lightLayer.setValue("alphaOverride", Math.max(0, Math.min(Number(O) / 100, 1)));
                        else if ("layer" === _[0]) {
                            let N = _[1],
                                k = _[2];
                            if (N && k) {
                                let _ = this.layers.find(_ => _.uuid === N);
                                _ ? .hasValue(k) && ("alpha" === k ? (this.transparent = _c(this.data, B.shared), _.setValue(k, Math.max(0, Math.min(Number(O) / 100, 1)))) : _.setValue(k, O))
                            }
                        }
                    }
                    saveVariableLocations(_) {
                        if (!this.allowVariableSaves) return;
                        let O = this.data.layers.find(_ => "light" === _.data.type);
                        O && _.shared.getVariable(O.data.alphaOverride, ["material", this.uuid, "alphaOverride"]), this.data.layers.forEach(O => {
                            "alpha" in O.data && "string" == typeof O.data.alpha && _.shared.getVariable(O.data.alpha, ["material", this.uuid, "layer", O.id, "alpha"])
                        })
                    }
                    getLayersOfType(_) {
                        return this.layers.filter(O => O.type === _)
                    }
                    getLayerByUuid(_) {
                        return this.layers.find(O => O.uuid === _)
                    }
                    onUpdate(_) {
                        for (let O of (this.cacheKey = this.computeCacheKey(), this.lightLayer = this.layers.find(_ => _ instanceof wX), void 0 === this.lightLayer && (this.lightLayer = new wX(0, "", { ...f9.defaultData("light", "phong"),
                                visible: !1
                            }, new wf, {}, _)), this.dispose(), this.flavors)) O && O.dispose();
                        this.applyTextureMaps(), this.applyMasks(), this.blendColors(), this.blendAfterColors(), this.blendPositions()
                    }
                    applyTextureMaps() {
                        let _ = this.layers.find(_ => _ instanceof wX);
                        if (!_) return;
                        let O = _.data,
                            B = O.bumpMap,
                            N = O.roughnessMap;
                        _.node.bumpMap = void 0, _.node.roughnessMap = void 0;
                        for (let O = 0; O < this.layers.length; ++O) {
                            let k = this.layers[O];
                            k instanceof wq && k.color instanceof bK && (k.uuid === B && (_.node.bumpMap = k.color), k.uuid === N && (_.node.roughnessMap = k.color))
                        }
                    }
                    updateByOp(_, O, B) {
                        if (void 0 !== O ? this.data = O : O = this.data, this.transparent = _c(O, B.shared), "layers" === _.path[0]) {
                            this.data = O;
                            let N = B.shared,
                                k = _.path[1];
                            if (void 0 === k) {
                                if (this.layers.reverse(), 4 === _.type) {
                                    let O = wW.create(this.layerIdGen++, _.id, _.data, B.shared);
                                    this.layers.splice(_.localIndex, 0, O), B.scene.markNeedsUpdateRendererDirty()
                                } else if (5 === _.type) this.layers.splice(_.localIndex, 1)[0].dispose(), B.scene.markNeedsUpdateRendererDirty();
                                else if (6 === _.type) {
                                    let O = this.layers.findIndex(O => O.uuid === _.id),
                                        N = this.layers[O];
                                    this.layers.splice(O, 1), this.layers.splice(_.localIndex, 0, N), B.scene.markNeedsUpdateRendererDirty()
                                }
                                this.layers.reverse(), this.onUpdate(B.shared)
                            } else {
                                0 === _.type && void 0 !== _.props.occlusion && B.scene.markNeedsUpdateRendererDirty();
                                let F = this.layers.find(_ => _.uuid === k);
                                if (F) {
                                    let U = O.layers.data(k),
                                        j;
                                    if (0 === _.type && ("alpha" in _.props || "alphaOverride" in _.props) && (j = "alpha" in _.props ? { ..._.props,
                                            alpha: ml(_.props.alpha, N, ["material", this.uuid, "layer", k, "alpha"])
                                        } : { ..._.props,
                                            alphaOverride: ml(_.props.alphaOverride, N, ["material", this.uuid, "alphaOverride"])
                                        }), F.updateByOp({ ..._,
                                            ...j ? {
                                                props: j
                                            } : {},
                                            path: _.path.slice(2)
                                        }, U, B)) {
                                        let _ = wW.create(this.layerIdGen++, k, U, N);
                                        this.layers.splice(this.layers.findIndex(_ => _.uuid === k), 1, _), this.onUpdate(B.shared)
                                    }
                                }
                            }
                        } else this.reset(O, B)
                    }
                    applyMasks() {
                        for (let _ = 0; _ < this.layers.length; ++_) {
                            let O = this.layers[_];
                            O instanceof wq ? O.color.mask = void 0 : O instanceof wX && (O.node.mask = void 0)
                        }
                        for (let _ = 0; _ < this.layers.length; ++_) {
                            let O = this.layers[_];
                            if (O instanceof wq && O.isMask.value && O.data.visible && _ > 0) {
                                let B = _ - 1,
                                    N = this.layers[B];
                                N instanceof wX ? N.node.mask = new bp(O.color, O.alpha, bp.MUL) : N instanceof wq && (N.isMask.value || (N.color.mask = new bp(O.color, O.alpha, bp.MUL)))
                            }
                        }
                    }
                    blendColors() {
                        let _ = this.layers.findIndex(_ => _ instanceof wq),
                            O = this.layers.findIndex(_ => _ instanceof wX);
                        if (-1 !== _ && _ < O) {
                            let B = this.layers[_].color;
                            for (let N = _ + 1; N < O; ++N) {
                                let _ = this.layers[N];
                                if (_ instanceof wq) {
                                    if (_.isMask.value) continue;
                                    B = new bX(B, _.color, _.alpha, _.mode)
                                }
                            }
                            this.fragment.color = B
                        } else this.fragment.color = void 0
                    }
                    blendAfterColors() {
                        let _ = new bh("outgoingLight", "f"),
                            O = this.layers.findIndex(_ => _ instanceof wX);
                        if (this.layers.length > O + 1) {
                            for (let B = O + 1; B < this.layers.length; ++B) {
                                let O = this.layers[B];
                                if (O instanceof wq) {
                                    if (O.isMask.value) continue;
                                    _ = new bX(_, O.color, O.alpha, O.mode)
                                }
                            }
                            this.fragment.afterColor = _
                        } else this.fragment.afterColor = void 0
                    }
                    blendPositions() {
                        let _ = this.layers.filter(_ => _ instanceof wY);
                        if (_.length > 0) {
                            let O = _[0].position;
                            for (let B = 1; B < _.length; ++B) _[B] && (O = new bp(O, _[B].position, bp.ADD), O = new bp(O, new bd(.5).setReadonly(!0), bp.MUL));
                            this.fragment.position = O
                        } else this.fragment.position = void 0
                    }
                    getDefines() {
                        return this.defines
                    }
                    getUniforms() {
                        return this.uniforms
                    }
                    getVertexShader() {
                        return this.vertexShader
                    }
                    getFragmentShader() {
                        return this.fragmentShader
                    }
                    onBeforeCompile(_) {
                        this.build(), _.defines = this.defines, _.uniforms = this.uniforms, _.vertexShader = this.vertexShader, _.fragmentShader = this.fragmentShader, _.extensionDerivatives = !0 === this.extensions.derivatives, _.extensionFragDepth = !0 === this.extensions.fragDepth, _.extensionDrawBuffers = !0 === this.extensions.drawBuffers, _.extensionShaderTextureLOD = !0 === this.extensions.shaderTextureLOD
                    }
                    clampUniformsForPreview(_, O) {
                        let n = (_, O, B) => Math.min(Math.max(_, O), B);
                        for (let B of this.layers)
                            if ("displace" === B.type) {
                                let N = n(B.uniforms[`f${B.id}_intensity`].value, _, O);
                                B.uniforms[`f${B.id}_intensity`].value = N
                            }
                    }
                    computeCacheKey() {
                        let _ = "[";
                        for (let {
                                data: O
                            } of this.data.layers)
                            if ("light" === O.type) _ += `"${O.visible?O.category.toUpperCase():"Basic"}"`;
                            else {
                                let B = [...(wG[O.type] ? ? []).map(_ => O[_]), ...(wH[O.type] ? ? []).map(_ => O[_] ? .length ? ? 0)],
                                    N = "isMask" in O && O.isMask,
                                    k = `"${O.type}-${O.visible}-${N}"`;
                                B.length ? _ += `[${k}, "${B.join('","')}"],` : _ += k
                            }
                        return _.slice(0, -1) + "]"
                    }
                    updateFrame(_) {
                        for (let O = 0; O < this.updaters.length; ++O) _.updateNode(this.updaters[O])
                    }
                    build() {
                        let _ = new bL;
                        for (let O of (_.needsJitter = this.needsJitter, this.lights = this.lightLayer.data.visible, _.build(this.fragment, this.fragment), this.vertexShader = _.getCode("vertex"), this.fragmentShader = _.getCode("fragment"), this.defines = _.defines, this.uniforms = _.uniforms, this.extensions = _.extensions, this.updaters = _.updaters, this.flavors)) O && O.updateAfterBuild();
                        return this
                    }
                    nodeMaterialDispose() {
                        for (let _ of (this.layers.forEach(_ => _.dispose()), super.dispose(), this.flavors)) _ && _.dispose()
                    }
                    assetsLoaded() {
                        for (let _ of this.layers)
                            if (_ instanceof wq) {
                                let O = _.params.texture;
                                if (O instanceof bj && !O.image.loaded) return !1
                            }
                        return !0
                    }
                    getHash() {
                        return '{"fragment":' + this.fragment.getHash() + "}"
                    }
                };
            Object.defineProperties(wQ.prototype, {
                properties: {
                    get: function() {
                        return this.fragment.properties
                    }
                }
            });
            var wJ, w$ = class extends wK {
                    constructor(_, O, B) {
                        super(_, O, !1), this.uuid = B, this.allowVariableSaves = !0, this.saveVariableLocations(O)
                    }
                },
                w0 = pn(iM()),
                w2 = new Map,
                w3 = class {
                    constructor({
                        src: _,
                        volume: O,
                        delay: B,
                        loop: N
                    }) {
                        let k;
                        this._volume = 1, this.delay = 0, this._loop = 1, this.loopsRemaining = 0, this._status = "stopped", this.onEnd = () => {
                            this.loopsRemaining === 1 / 0 ? this.replay() : this.loopsRemaining > 1 ? (this.replay(), this.loopsRemaining--) : (this._status = "stopped", this.loopsRemaining = this._loop)
                        }, k = "string" == typeof _ ? {
                            src: _
                        } : {
                            src: function(_) {
                                if ("string" == typeof _) return _;
                                let O = w2.get(_);
                                return O || (O = {
                                    url: URL.createObjectURL(new Blob([_]))
                                }, w2.set(_, O)), O.url
                            }(_),
                            format: "wav"
                        }, this.sound = new w0.Howl(k), this.sound.on("end", this.onEnd), this.src = _, void 0 !== O && (this.volume = O), void 0 !== B && (this.delay = B), void 0 !== N && (this.loop = N)
                    }
                    get status() {
                        return this._status
                    }
                    get volume() {
                        return this._volume
                    }
                    set volume(_) {
                        this._volume = _, this.sound.volume(_)
                    }
                    get loop() {
                        return this._loop
                    }
                    set loop(_) {
                        this._loop = _, this.loopsRemaining = _
                    }
                    replay() {
                        this.clearDelay(), this.delayTimerId = window.setTimeout(() => {
                            this.sound.play(), this.clearDelay()
                        }, this.delay)
                    }
                    fade(_, O = 1e3) {
                        _ ? (this.sound.volume(this._volume), this.clearFade(), this.fadeTimerId = window.setTimeout(() => {
                            this.sound.fade(this._volume, 0, O), this.clearFade()
                        }, _)) : this.sound.fade(this._volume, 0, O)
                    }
                    on(_, O, B) {
                        this.sound.on(_, O, B)
                    }
                    off(_, O, B) {
                        this.sound.off(_, O, B)
                    }
                    play() {
                        "playing" === this._status || this.sound.playing() || ("paused" === this._status ? (0 === this.sound.seek() ? this.replay() : this.sound.play(), this._status = "playing") : "stopped" === this._status && (this.replay(), this._status = "playing"))
                    }
                    pause() {
                        "playing" === this._status && (this.sound.pause(), this.clearFade(), this.clearDelay(), this._status = "paused")
                    }
                    stop() {
                        this.sound.stop(), this.loopsRemaining = this._loop, this.clearFade(), this.clearDelay(), this._status = "stopped"
                    }
                    clearFade() {
                        this.fadeTimerId && (clearTimeout(this.fadeTimerId), delete this.fadeTimerId)
                    }
                    clearDelay() {
                        this.delayTimerId && (clearTimeout(this.delayTimerId), delete this.delayTimerId)
                    }
                    dispose(_ = !1) {
                        this.off(), this.stop(), this.clearFade(), this.clearDelay()
                    }
                },
                w4 = class {
                    constructor() {
                        this.type = "ShapePath", this.color = new re, this.subPaths = [], this.currentPath = null
                    }
                    moveTo(_, O) {
                        return this.currentPath = new os, this.subPaths.push(this.currentPath), this.currentPath.moveTo(_, O), this
                    }
                    lineTo(_, O) {
                        return this.currentPath ? .lineTo(_, O), this
                    }
                    quadraticCurveTo(_, O, B, N) {
                        return this.currentPath ? .quadraticCurveTo(_, O, B, N), this
                    }
                    bezierCurveTo(_, O, B, N, k, F) {
                        return this.currentPath ? .bezierCurveTo(_, O, B, N, k, F), this
                    }
                    splineThru(_) {
                        return this.currentPath ? .splineThru(_), this
                    }
                    toShapes() {
                        let _ = {
                                ORIGIN: 0,
                                DESTINATION: 1,
                                BETWEEN: 2,
                                LEFT: 3,
                                RIGHT: 4,
                                BEHIND: 5,
                                BEYOND: 6
                            },
                            O = {
                                loc: _.ORIGIN,
                                t: 0
                            };

                        function s(B, N, k) {
                            let F = k.x - N.x,
                                U = k.y - N.y,
                                j = B.x - N.x,
                                G = B.y - N.y,
                                Y = F * G - j * U;
                            if (B.x === N.x && B.y === N.y) {
                                O.loc = _.ORIGIN, O.t = 0;
                                return
                            }
                            if (B.x === k.x && B.y === k.y) {
                                O.loc = _.DESTINATION, O.t = 1;
                                return
                            }
                            if (Y < -Number.EPSILON) {
                                O.loc = _.LEFT;
                                return
                            }
                            if (Y > Number.EPSILON) {
                                O.loc = _.RIGHT;
                                return
                            }
                            if (F * j < 0 || U * G < 0) {
                                O.loc = _.BEHIND;
                                return
                            }
                            if (Math.sqrt(F * F + U * U) < Math.sqrt(j * j + G * G)) {
                                O.loc = _.BEYOND;
                                return
                            }
                            O.loc = _.BETWEEN, O.t = 0 !== F ? j / F : G / U
                        }
                        let B = 0,
                            N = 999999999,
                            k = -999999999,
                            F = [];
                        this.subPaths.forEach(_ => {
                            let O = _.getPoints(),
                                U = -999999999,
                                j = 999999999,
                                G = -999999999,
                                Y = 999999999;
                            for (let _ = 0; _ < O.length; _++) {
                                let B = O[_];
                                B.y > U && (U = B.y), B.y < j && (j = B.y), B.x > G && (G = B.x), B.x < Y && (Y = B.x)
                            }
                            k <= G && (k = G + 1), N >= Y && (N = Y - 1), O.length && F.push({
                                curves: _.curves,
                                points: O,
                                isCW: ow.isClockWise(O),
                                identifier: B++,
                                boundingBox: new lC(new iJ(Y, j), new iJ(G, U))
                            })
                        });
                        let U = F.map(B => (function(B, N, k, F, U) {
                                (null == U || "" === U) && (U = "nonzero");
                                let j = new iJ;
                                B.boundingBox.getCenter(j);
                                let G = function(B, N, k) {
                                    let F = new iJ;
                                    N.getCenter(F);
                                    let U = [];
                                    return k.forEach(N => {
                                        N.boundingBox.containsPoint(F) && (function(B, N) {
                                            let k = [],
                                                F = [];
                                            for (let U = 1; U < B.length; U++) {
                                                let j = B[U - 1],
                                                    G = B[U];
                                                for (let B = 1; B < N.length; B++) {
                                                    let U = function(B, N, k, F) {
                                                        let U = B.x,
                                                            j = N.x,
                                                            G = k.x,
                                                            Y = F.x,
                                                            Q = B.y,
                                                            K = N.y,
                                                            $ = k.y,
                                                            ee = F.y,
                                                            et = (Y - G) * (Q - $) - (ee - $) * (U - G),
                                                            ei = (ee - $) * (j - U) - (Y - G) * (K - Q),
                                                            er = et / ei,
                                                            ea = ((j - U) * (Q - $) - (K - Q) * (U - G)) / ei;
                                                        if (0 === ei && 0 !== et || er <= 0 || er >= 1 || ea < 0 || ea > 1) return null;
                                                        if (0 === et && 0 === ei) {
                                                            for (let G = 0; G < 2; G++)
                                                                if (s(0 === G ? k : F, B, N), O.loc === _.ORIGIN) {
                                                                    let _ = 0 === G ? k : F;
                                                                    return {
                                                                        x: _.x,
                                                                        y: _.y,
                                                                        t: O.t
                                                                    }
                                                                } else if (O.loc === _.BETWEEN) return {
                                                                x: +(U + O.t * (j - U)).toPrecision(10),
                                                                y: +(Q + O.t * (K - Q)).toPrecision(10),
                                                                t: O.t
                                                            };
                                                            return null
                                                        }
                                                        for (let U = 0; U < 2; U++)
                                                            if (s(0 === U ? k : F, B, N), O.loc === _.ORIGIN) {
                                                                let _ = 0 === U ? k : F;
                                                                return {
                                                                    x: _.x,
                                                                    y: _.y,
                                                                    t: O.t
                                                                }
                                                            }
                                                        return {
                                                            x: +(U + er * (j - U)).toPrecision(10),
                                                            y: +(Q + er * (K - Q)).toPrecision(10),
                                                            t: er
                                                        }
                                                    }(j, G, N[B - 1], N[B]);
                                                    null !== U && void 0 === k.find(_ => _.t <= U.t + Number.EPSILON && _.t >= U.t - Number.EPSILON) && (k.push(U), F.push(new iJ(U.x, U.y)))
                                                }
                                            }
                                            return F
                                        })(B, N.points).forEach(_ => {
                                            U.push({
                                                identifier: N.identifier,
                                                isCW: N.isCW,
                                                point: _
                                            })
                                        })
                                    }), U.sort((_, O) => _.point.x - O.point.x), U
                                }([new iJ(k, j.y), new iJ(F, j.y)], B.boundingBox, N);
                                G.sort((_, O) => _.point.x - O.point.x);
                                let Y = [],
                                    Q = [];
                                G.forEach(_ => {
                                    _.identifier === B.identifier ? Y.push(_) : Q.push(_)
                                });
                                let K = Y[0].point.x,
                                    $ = [],
                                    ee = 0;
                                for (; ee < Q.length && Q[ee].point.x < K;) $.length > 0 && $[$.length - 1] === Q[ee].identifier ? $.pop() : $.push(Q[ee].identifier), ee++;
                                if ($.push(B.identifier), "evenodd" === U) {
                                    let _ = $.length % 2 == 0,
                                        O = $[$.length - 2];
                                    return {
                                        identifier: B.identifier,
                                        isHole: _,
                                        for: O
                                    }
                                }
                                if ("nonzero" === U) {
                                    let _ = !0,
                                        O = null,
                                        k = null;
                                    for (let B = 0; B < $.length; B++) {
                                        let F = $[B];
                                        N[F] && (_ ? (k = N[F].isCW, _ = !1, O = F) : k !== N[F].isCW && (k = N[F].isCW, _ = !0))
                                    }
                                    return {
                                        identifier: B.identifier,
                                        isHole: _,
                                        for: O
                                    }
                                }
                                console.warn('fill-rule: "' + U + '" is currently not implemented.')
                            })(B, F, N, k, this.userData ? .style.fillRule)),
                            j = [];
                        return F.forEach(_ => {
                            let O = U[_.identifier];
                            if (O && !O.isHole) {
                                let O = new ox;
                                O.curves = _.curves, U.filter(O => O ? .isHole && O.for === _.identifier).forEach(_ => {
                                    if (_) {
                                        let B = F[_.identifier],
                                            N = new os;
                                        N.curves = B.curves, O.holes.push(N)
                                    }
                                }), j.push(O)
                            }
                        }), j
                    }
                },
                w5 = new Promise(_ => {
                    wJ = _
                }),
                w6 = !1;
            async function d9(_) {
                return await (await fetch(_)).arrayBuffer()
            }
            var w8 = new class {
                async load(_, O, B = () => {}) {
                    let {
                        load: N
                    } = await w5;
                    N(_, (_, N) => {
                        _ || !N ? B(_ ? ? "Something went wrong") : O(N)
                    })
                }
                async parse(_) {
                    let {
                        parse: O,
                        Bidi: B
                    } = await w5;
                    try {
                        let N = O(_),
                            k = new B;
                        return k.registerModifier("glyphIndex", null, _ => N.charToGlyphIndex(_.char)), k.applyFeatures(N, N.defaultRenderOptions.features), {
                            font: N,
                            bidi: k
                        }
                    } catch (_) {
                        console.error(_)
                    }
                }
            };
            async function FA(_) {
                let O, B, N = !1;
                if (_.url ? (O = await d9(_.url), B = _.url, N = _.url.startsWith("/")) : _.data && (O = _.data.buffer.slice(_.data.byteOffset, _.data.byteOffset + _.data.byteLength)), O) {
                    let _ = await w8.parse(O);
                    if (_) return {
                        font: _.font,
                        url: B,
                        intercepted: N,
                        arr: O,
                        bidi: _.bidi
                    }
                }
            }
            var w9 = class {
                    constructor(_) {
                        this._arrayBuffer = new ArrayBuffer(1), this._isLoaded = !1, this._intercepted = !1, this._isUserFont = _.isUserFont ? ? !1, this._loadingPromise = FA(_).then(_ => {
                            _ && (this._arrayBuffer = _.arr, this._url = _.url, this.font = _.font, this._intercepted = _.intercepted, this._isLoaded = !0, this._bidi = _.bidi)
                        })
                    }
                    update(_) {
                        this._isLoaded = !1, this._isUserFont = _.isUserFont ? ? !1, this._loadingPromise = FA(_).then(_ => {
                            _ && (this._arrayBuffer = _.arr, this._url = _.url, this.font = _.font, this._intercepted = _.intercepted, this._isLoaded = !0, this._bidi = _.bidi)
                        })
                    }
                    get url() {
                        return this._url
                    }
                    get intercepted() {
                        return this._intercepted
                    }
                    get isLoaded() {
                        return this._isLoaded
                    }
                    get loadingPromise() {
                        return this._loadingPromise
                    }
                    reverseLigaturesTable(_, O, B) {
                        if (!this._bidi) return [];
                        let N = this._bidi;
                        N.getTextGlyphs(O);
                        let k = N.tokenizer.tokens,
                            F = [],
                            U = 0,
                            j = B.length === k.length;
                        for (let N = 0; N < B.length; N++) {
                            let G = B[N].index,
                                Y = String.fromCharCode(B[N].unicode),
                                Q = k[U];
                            if (Q.state.glyphIndex === G || Q.state.fina === G || Q.state.medi === G || Q.state.init === G || j) F.push({
                                char: Y,
                                index: G,
                                replacements: [Q.state.glyphIndex],
                                replacementChars: [Q.char]
                            }), U++;
                            else {
                                let B = Q.char,
                                    N = "",
                                    k = [Q.state.glyphIndex],
                                    j = [],
                                    K = !1;
                                for (; !K;) U++, B += N = O.charAt(U), k.push(_.charToGlyphIndex(N)), 1 === (j = _.stringToGlyphs(B)).length && j[0].index === G && (K = !0), U > O.length && (K = !0);
                                F.push({
                                    char: Y,
                                    index: G,
                                    replacements: k,
                                    replacementChars: Array.from(B)
                                }), U++
                            }
                        }
                        return F
                    }
                    generateShapes(_, O) {
                        if (!this._isLoaded) return;
                        let B = this.font,
                            N = O.fontSize / this.unitsPerEm,
                            k = O.fontSize * O.lineHeight,
                            F = _.map(_ => this.getTextWidth(_, O)),
                            U = O.width,
                            j = this.getCharWidth(`
`, O),
                            G = 1 === O.horizontalAlign ? j : 0,
                            Y = this.computeSpaceWidthForLine(_, 0, O),
                            Q = this.getLineInitialOffsetX(F[0], U, O.horizontalAlign, _[0], j),
                            K = this.getLineInitialOffsetY(k, _.length, O.height, N, O.verticalAlign),
                            $ = [],
                            ee = _.map(_ => []),
                            et = _.map(_ => []),
                            ei;
                        for (let er = 0; er < _.length; er++) {
                            let ea = _[er],
                                en = {
                                    features: {
                                        liga: !0
                                    }
                                },
                                eo = [];
                            try {
                                eo = B.stringToGlyphs(ea, en)
                            } catch (_) {
                                console.warn(_)
                            }
                            Q = this.getLineInitialOffsetX(F[er], U, O.horizontalAlign, ea, j);
                            let el = [];
                            try {
                                el = this.reverseLigaturesTable(B, ea, eo)
                            } catch (_) {
                                console.warn(_)
                            }
                            Y = this.computeSpaceWidthForLine(_, er, O);
                            for (let _ = 0; _ < eo.length; _++) {
                                let k = eo[_],
                                    F = 0 === k.index ? `
` : k.unicode ? String.fromCharCode(k.unicode) : void 0,
                                    U = el[_],
                                    j = 0,
                                    ea = 0;
                                0 === _ && 2 === O.horizontalAlign && void 0 !== k.leftSideBearing && (ea = -k.leftSideBearing * N), ei && (j = B.getKerningValue(k, ei) * N), Q += ea + j;
                                let en = 0;
                                if (F === `
`) en = G;
                                else if (" " === F) en = Y;
                                else {
                                    let _ = this.createPath(k, N, Q, K, O);
                                    _ && (en = _.offsetX - (j + ea), $.push(_.path))
                                }
                                if (1 === U.replacements.length) et[er].push([Q, K]), ee[er].push(en);
                                else {
                                    let _ = U.replacements.map(_ => (B.glyphs.get(_).advanceWidth ? ? 0) * N),
                                        O = _.reduce((_, O) => _ += O, 0),
                                        k = _.map(_ => _ / O),
                                        F = Q;
                                    for (let _ = 0; _ < k.length; _++) {
                                        let O = en * k[_];
                                        et[er].push([F, K]), ee[er].push(O), F += O
                                    }
                                }
                                Q += en, ei = k
                            }
                            K -= k
                        }
                        let er = [];
                        for (let _ = 0, O = $.length; _ < O; _++) er.push(...$[_].toShapes());
                        return {
                            shapes: er,
                            charWidths: ee,
                            lineWidths: F,
                            charCoords: et
                        }
                    }
                    get isUserFont() {
                        return this._isUserFont
                    }
                    get arrayBuffer() {
                        return this._arrayBuffer
                    }
                    get ascender() {
                        return this.font ? .ascender ? ? 0
                    }
                    get descender() {
                        return this.font ? .descender ? ? 0
                    }
                    get familyName() {
                        return this.font ? .names.fontFamily ? ? ""
                    }
                    get subfamilyName() {
                        return this.font ? .names.fontSubfamily ? ? ""
                    }
                    get unitsPerEm() {
                        return this.font ? .unitsPerEm ? ? 1
                    }
                    getLineInitialOffsetX(_, O, B, N, k) {
                        return (3 === B || 2 === B) && N.indexOf(`
`) >= 0 && (_ -= k), 3 === B ? .5 * O - .5 * _ : 2 === B ? O - _ : 0
                    }
                    getLineInitialOffsetY(_, O, B, N, k) {
                        let F = O * _,
                            U = Math.abs(this.ascender - this.descender) * N,
                            j = -this.ascender * N - (_ - U) / 2;
                        return 3 === k ? -(B - F - j) : 2 === k ? -(.5 * B - .5 * F - j) : j
                    }
                    createPath(_, O, B, N, k) {
                        let F = _.getPath(B, -N, k.fontSize, {
                            kerning: !1,
                            letterSpacing: k.letterSpacing
                        });
                        if (!F) {
                            console.error('THREE.Font: character "' + _ + '" does not exists in font family ' + this.familyName + ".");
                            return
                        }
                        let U = new w4,
                            j = (_.advanceWidth ? ? 1) * O;
                        if (_)
                            for (let _ of F.commands) {
                                let O = U.currentPath ? .currentPoint;
                                if (!(O && "Z" !== _.type && O.x === _.x && -O.y === _.y)) switch (_.type) {
                                    case "M":
                                        U.moveTo(_.x, -_.y);
                                        break;
                                    case "L":
                                        U.lineTo(_.x, -_.y);
                                        break;
                                    case "Q":
                                        U.quadraticCurveTo(_.x1, -_.y1, _.x, -_.y);
                                        break;
                                    case "C":
                                        U.bezierCurveTo(_.x1, -_.y1, _.x2, -_.y2, _.x, -_.y)
                                }
                            }
                        return U.subPaths.forEach(_ => {
                            let O = function(_) {
                                if (_.length) {
                                    let O = _[0];
                                    if (O instanceof n6) return O.v1;
                                    if (O instanceof n4 || O instanceof n9) return O.v0
                                }
                            }(_.curves);
                            void 0 !== O && _.currentPoint.distanceTo(O) > 0 && _.lineTo(O.x, O.y)
                        }), {
                            offsetX: j + k.fontSize * k.letterSpacing,
                            path: U
                        }
                    }
                    getCharWidth(_, O) {
                        return this.font ? .getAdvanceWidth(_, O.fontSize, {
                            kerning: !0,
                            letterSpacing: O.letterSpacing
                        }) ? ? 0
                    }
                    getTextWidth(_, O) {
                        return this.font ? .getAdvanceWidth(_, O.fontSize, {
                            kerning: !0,
                            letterSpacing: O.letterSpacing
                        }) ? ? 0
                    }
                    computeSpaceWidthForLine(_, O, B) {
                        let N = this.getCharWidth(" ", B),
                            k = _[O];
                        if (k) {
                            let F = this.countSpaces(k.trimEnd());
                            if (4 === B.horizontalAlign && O < _.length - 1 && F) return (B.width - (this.getTextWidth(k, B) - F * N)) / F
                        }
                        return N
                    }
                    countSpaces(_) {
                        return (_.match(/ /g) || []).length
                    }
                },
                _i = class {
                    constructor() {
                        this.objects = new Map, this.unreachable = new Set
                    }
                    getCached(_) {
                        return this.objects.get(_)
                    }
                    get size() {
                        return this.objects.size
                    }
                    get(_, O, B) {
                        let N = this.objects.get(_);
                        return void 0 === N ? (N = this.createObject(_, O, B), this.objects.set(_, N)) : N.isShared = !0, N
                    }
                    forceDelete(_) {
                        let O = this.objects.get(_);
                        O && (this.disposeObject(O), this.objects.delete(_))
                    }
                    mutateIfUnique(_, O) {
                        let B = this.objects.get(_);
                        if (B && !0 !== B.isShared) return this.objects.delete(_), this.objects.set(O, B), B
                    }
                    startGc() {
                        this.unreachable = new Set(this.objects.keys())
                    }
                    markAsReachable(_, O) {
                        O === this.objects.get(_) && this.unreachable.delete(_)
                    }
                    endGc() {
                        this.unreachable.forEach(_ => {
                            this.disposeObject(this.objects.get(_)), this.objects.delete(_)
                        }), this.unreachable.clear()
                    }
                    dispose() {
                        this.objects.forEach(_ => {
                            this.disposeObject(_)
                        }), this.objects.clear()
                    }
                },
                _r = class extends _i {
                    constructor(_) {
                        super(), this.flatShading = _
                    }
                    disposeObject(_) {
                        _.dispose()
                    }
                    createObject(_, O, B) {
                        let N = gc(_, O, this.flatShading, B);
                        return N.computeBoundingSphere(), N
                    }
                },
                _s = {
                    markNeedsUpdateRendererDirty: () => {}
                },
                _a = class extends wA {
                    constructor(_) {
                        super(), this.shared = _
                    }
                    create(_) {
                        return new wM(_, this.shared)
                    }
                },
                _n = class {
                    constructor(_, O = {}) {
                        if (this.data = _, this.geometryCache = new _r(!0), this.geometryCache2 = new _r(!1), this.imageHolderCache = new _a(this), this.thisContext = {
                                scene: _s,
                                shared: this
                            }, this.deletedMaterial = new w$(m0.defaultTwoLayerData("phong"), this.thisContext, ""), this.deletedImage = new wC(gO.emptyImage, this), this.deletedVideo = new wC(f5.defaultVideo, this), this.materials = {}, this.images = {}, this.videos = {}, this.colors = {}, this.audios = {}, this.fonts = {}, this.variables = {}, this.mouseProperty = null, this.raycastProperty = null, this.requestRender = () => {
                                this._requestRender && this._requestRender()
                            }, O.images)
                            for (let [_, B] of Object.entries(O.images)) this.addImage(_, B);
                        if (O.videos)
                            for (let [_, B] of Object.entries(O.videos)) this.addVideo(_, B);
                        if (O.audios)
                            for (let [_, B] of Object.entries(O.audios)) this.addAudio(_, B);
                        this.reset(_)
                    }
                    setRequestRender(_) {
                        this._requestRender = _
                    }
                    setEntityOpContext(_) {
                        this.entityOpContext = _
                    }
                    reset(_, O = !1) {
                        for (let {
                                id: B,
                                data: N
                            } of (this.resetLib(_.lib), _.variables)) this.addVariableHolder(B, N), O && this.updateVariableHolder(B, N);
                        for (let [O, B] of Object.entries(_.images)) this.addImage(O, B);
                        for (let [O, B] of Object.entries(_.videos)) this.addVideo(O, B);
                        for (let [O, B] of Object.entries(_.colors)) this.addColor(O, B);
                        for (let [O, B] of Object.entries(_.materials)) this.addMaterial(O, B);
                        for (let [O, B] of Object.entries(_.audios)) this.addAudio(O, B);
                        for (let [O, B] of Object.entries(_.fonts)) this.addFont(O, B)
                    }
                    addMaterial(_, O) {
                        if (this.materials[_]) {
                            let B = this.materials[_];
                            B.reset(O, this.thisContext), B.dispose()
                        } else {
                            let B = new w$(O, this.thisContext, _);
                            this.materials[_] = B
                        }
                    }
                    deleteMaterial(_) {
                        this.materials[_] && (this.materials[_].nodeMaterialDispose(), delete this.materials[_])
                    }
                    getMaterial(_) {
                        return this.materials[_]
                    }
                    getMaterialOrDeletedPlaceholder(_) {
                        return this.materials[_] ? ? this.deletedMaterial
                    }
                    material(_) {
                        return "string" == typeof _ ? this.getMaterialOrDeletedPlaceholder(_) : null == _ ? (console.error("material is undefined or null"), this.deletedMaterial) : new wK(_, this.thisContext)
                    }
                    getMaterials() {
                        return this.materials
                    }
                    addImage(_, O) {
                        return this.images[_] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), this.images[_].updateSrc(O.data), !0) : (this.images[_] = new wC(O, this), !1)
                    }
                    deleteImage(_) {
                        let O = this.images[_];
                        O && (O.dispose(), delete this.images[_])
                    }
                    getDefaultImage() {
                        return this.images.image_0
                    }
                    getImage(_) {
                        return this.images[_] ? ? this.deletedImage
                    }
                    image(_) {
                        return "string" == typeof _ ? this.getImage(_) : this.imageHolderCache.load(_)
                    }
                    addVideo(_, O) {
                        return this.videos[_] ? (this.videos[_].updateSrc(O.data), !0) : (this.videos[_] = new wC(O, this), !1)
                    }
                    deleteVideo(_) {
                        let O = this.videos[_];
                        O && (O.dispose(), delete this.videos[_])
                    }
                    getVideo(_) {
                        return this.videos[_] ? ? this.deletedVideo
                    }
                    video(_) {
                        return "string" == typeof _ ? this.getVideo(_) : this.imageHolderCache.load(_)
                    }
                    addColor(_, O) {
                        return this.colors[_] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), "a" in O ? this.colors[_].setRGBA(O.r, O.g, O.b, O.a) : this.colors[_].setRGBA(O.r, O.g, O.b, 1), !0) : ("a" in O ? this.colors[_] = new wj(O.r, O.g, O.b, O.a) : this.colors[_] = new wj(O.r, O.g, O.b, 1), !1)
                    }
                    updateColor(_, O) {
                        if (this.colors[_]) {
                            this.onColorOrImageUpdate && this.onColorOrImageUpdate();
                            let B = this.colors[_];
                            return this.colors[_].r = O.r ? ? B.r, this.colors[_].g = O.g ? ? B.g, this.colors[_].b = O.b ? ? B.b, this.colors[_].a = O.a ? ? B.a, !0
                        }
                        return !1
                    }
                    deleteColor(_) {
                        this.colors[_] && delete this.colors[_]
                    }
                    getColor(_) {
                        return this.colors[_]
                    }
                    color(_) {
                        let O;
                        if ("string" != typeof _) return "a" in _ ? new x8(_.r, _.g, _.b, _.a) : new x8(_.r, _.g, _.b, 1); {
                            let B = this.getColor(_);
                            B ? O = B : (console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"), O = new x8(0, 0, 0, 0))
                        }
                        return O
                    }
                    addAudio(_, O) {
                        this.audios[_] = O
                    }
                    getAudio(_) {
                        let O = this.audios[_];
                        if (O instanceof w3) return O; {
                            let B = new w3({
                                src: O.data
                            });
                            return this.audios[_] = B, B
                        }
                    }
                    deleteAudio(_) {
                        let O = this.audios[_];
                        O && (O instanceof w3 && O.dispose(), delete this.audios[_])
                    }
                    addFont(_, O) {
                        this.fonts[_] = new w9(O), this.fonts[_].loadingPromise.then(() => this.requestRender())
                    }
                    getFont(_) {
                        return this.fonts[_]
                    }
                    deleteFont(_) {
                        this.fonts[_] && delete this.fonts[_]
                    }
                    dispose() {
                        Object.keys(this.materials).forEach(_ => this.deleteMaterial(_)), this._requestRender = void 0, Object.values(this.audios).forEach(_ => {
                            _ instanceof w3 && _.dispose()
                        }), this.audios = {}, this.geometryCache.dispose(), this.geometryCache2.dispose()
                    }
                    addVariableHolder(_, O) {
                        return void 0 === this.variables[_] ? (this.variables[_] = {
                            value: O.value,
                            locations: []
                        }, "dynamicVariableType" in O && (this.variables[_].dynamicVariablePlayState = "Playing", this.variables[_].dynamicVariableToggleIsForward = void 0), !0) : (this.variables[_].value = O.value, !1)
                    }
                    resetDynamicVariablePlayState() {
                        for (let _ in this.variables) void 0 !== this.variables[_].dynamicVariablePlayState && (this.variables[_].dynamicVariablePlayState = "Playing", this.variables[_].dynamicVariableToggleIsForward = void 0)
                    }
                    updateVariableHolder(_, O) {
                        this.updateVariable(_, O.value)
                    }
                    updateVariable(_, O) {
                        if (void 0 === this.variables[_]) return !1;
                        this.variables[_].value = O;
                        let B = O;
                        for (;
                            "string" == typeof B;) B = this.variables[B].value;
                        let N = this.entityOpContext.scene;
                        for (let O = this.variables[_].locations.length - 1; O >= 0; O--) {
                            let k = this.variables[_].locations[O];
                            if ("material" === k[0]) {
                                let _ = k[1],
                                    O = B,
                                    F = {
                                        scene: N,
                                        shared: this
                                    },
                                    U = k.slice(2);
                                N.traverseMaterial(B => {
                                    let N = B.root ? ? B;
                                    N.uuid === _ && N.onVariableUpdate(U, O, F)
                                });
                                let j = this.materials[_];
                                j && j.onVariableUpdate(U, O, F)
                            } else {
                                let F = N.find(k[0]);
                                if (void 0 === F) {
                                    this.variables[_].locations.splice(O, 1);
                                    continue
                                }
                                if ("geometry" !== k[1]) {
                                    for (let _ = 1; _ < k.length - 1; _++) F = F[k[_]];
                                    "rotation" === k[1] ? F[k[k.length - 1]] = B * iK.DEG2RAD : F[k[k.length - 1]] = B
                                }
                                if (F = N.find(k[0]), xu.is(F)) {
                                    if ("position" === k[1] || "rotation" === k[1] || "scale" === k[1]) F.onVariableUpdate();
                                    else if ("geometry" === k[1]) {
                                        let _ = F;
                                        F.component && (_ = F.component);
                                        let O = _.dataPatched;
                                        _.chooseGeoemtryCache(this).forceDelete(O.geometry), _.createGeometryDelayed(this.entityOpContext), _.onVariableUpdate(!0), _.instances.forEach(_ => {
                                            let O = _.dataPatched;
                                            _.chooseGeoemtryCache(this).forceDelete(O.geometry), _.createGeometryDelayed(this.entityOpContext), _.onVariableUpdate(!0)
                                        })
                                    }
                                }
                            }
                        }
                        return !0
                    }
                    deleteVariable(_) {
                        this.variables[_] && delete this.variables[_]
                    }
                    getVariable(_, O) {
                        if (Array.isArray(_)) {
                            if ("mouse" === _[0]) return this.mouseProperty ? .[_[1]] ? ? 0;
                            if ("raycast" === _[0]) return this.raycastProperty ? .[_[1]] ? ? 0;
                            let O = this.entityOpContext.scene.find(_[0]);
                            if ("width" === _[1] || "height" === _[1] || "depth" === _[1]) return O.geometry.userData.parameters[_[1]];
                            for (let B = 1; B < _.length; B++) O = O[_[B]];
                            return "rotation" === _[1] && (O *= iK.RAD2DEG), O
                        }
                        for (let _ in this.variables) {
                            if (void 0 === O) break;
                            let B = this.variables[_],
                                N = B.locations ? .findIndex(_ => uz.equal(_, O));
                            void 0 !== N && -1 !== N && B.locations.splice(N, 1)
                        }
                        if ("string" != typeof _) return _; {
                            let B = _,
                                N = _;
                            do {
                                if (N = B, void 0 === this.variables[B]) break;
                                B = this.variables[B].value
                            } while ("string" == typeof B);
                            return O && void 0 !== this.variables[N] && this.variables[N].locations.push(O), B
                        }
                    }
                    getVariables() {
                        return this.variables
                    }
                    getDynamicVariablePlayState(_) {
                        return this.variables[_] ? .dynamicVariablePlayState
                    }
                    setDynamicVariablePlayState(_, O) {
                        void 0 !== this.variables[_] && (this.variables[_].dynamicVariablePlayState = O)
                    }
                    getDynamicVariableToggleIsForward(_) {
                        return this.variables[_] ? .dynamicVariableToggleIsForward
                    }
                    setDynamicVariableToggleIsForward(_, O) {
                        void 0 !== this.variables[_] && (this.variables[_].dynamicVariableToggleIsForward = O)
                    }
                    resetLib(_) {
                        for (let [O, B] of Object.entries(_.images)) this.addImage(O, B.asset);
                        for (let [O, B] of Object.entries(_.audios)) this.addAudio(O, B.asset);
                        for (let [O, B] of Object.entries(_.colors)) this.addColor(O, B.asset);
                        for (let [O, B] of Object.entries(_.fonts)) this.addFont(O, B.asset);
                        for (let [O, B] of Object.entries(_.materials)) this.addMaterial(O, B.asset);
                        for (let [O, B] of Object.entries(_.videos)) this.addVideo(O, B.asset);
                        for (let [O, B] of Object.entries(_.variables)) this.addVariableHolder(O, B.asset)
                    }
                    updateLibByOp(_, O) {
                        "images" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addImage(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteImage(_.id) : "videos" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addVideo(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteVideo(_.id) : "audios" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addAudio(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteAudio(_.id) : "colors" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addColor(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteColor(_.id) : "materials" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addMaterial(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteMaterial(_.id) : "fonts" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addFont(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteFont(_.id) : "variables" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addVariableHolder(_.id, _.data.asset) : 1 === _.path.length && 2 === _.type && this.deleteVariable(_.id) : "components" === _.path[0] && O.updateByLibOp(_, this)
                    }
                    updateByOp(_, O, B) {
                        this.data = O, "images" === _.path[0] ? 2 === _.path.length && 0 === _.type ? _.props.data && this.getImage(_.path[1]).updateSrc(_.props.data) : 1 === _.path.length && 1 === _.type ? this.addImage(_.id, _.data) : 1 === _.path.length && 2 === _.type && this.deleteImage(_.id) : "videos" === _.path[0] ? 2 === _.path.length && 0 === _.type ? _.props.data && this.getVideo(_.path[1]).updateSrc(_.props.data) : 1 === _.path.length && 1 === _.type ? this.addVideo(_.id, _.data) : 1 === _.path.length && 2 === _.type && this.deleteVideo(_.id) : "audios" === _.path[0] ? 2 === _.path.length && 0 === _.type ? _.props.data && this.addAudio(_.path[1], O.audios[_.path[1]]) : 1 === _.path.length && 1 === _.type ? this.addAudio(_.id, _.data) : 1 === _.path.length && 2 === _.type && this.deleteAudio(_.id) : "colors" === _.path[0] ? 2 === _.path.length && 0 === _.type ? this.updateColor(_.path[1], _.props) : 1 === _.path.length && 1 === _.type ? this.addColor(_.id, _.data) : 1 === _.path.length && 2 === _.type && this.deleteColor(_.id) : "materials" === _.path[0] ? 1 === _.path.length && 1 === _.type ? this.addMaterial(_.id, _.data) : 1 === _.path.length && 2 === _.type ? this.deleteMaterial(_.id) : _.path.length > 1 && this.getMaterial(_.path[1]).updateByOp(uR.drop(_, 2), O.materials[_.path[1]], {
                            shared: this,
                            scene: B
                        }) : "fonts" === _.path[0] ? 2 === _.path.length && 0 === _.type ? this.updateFont(_.path[1], _, B) : 1 === _.path.length && 1 === _.type ? this.addFont(_.id, _.data) : 1 === _.path.length && 2 === _.type && this.deleteFont(_.id) : "variables" === _.path[0] ? 2 === _.path.length && 0 === _.type && "value" in _.props ? this.updateVariable(_.path[1], _.props.value) : 1 === _.path.length && 4 === _.type ? this.addVariableHolder(_.id, _.data) : 1 === _.path.length && 5 === _.type && this.deleteVariable(_.id) : "lib" === _.path[0] && this.updateLibByOp(uR.drop(_, 1), B)
                    }
                    updateFont(_, O, B) {
                        if (O.props.url) {
                            let N = this.getFont(_),
                                k = { ...this.data.fonts[_],
                                    url: O.props.url
                                };
                            N.update(k), N.loadingPromise.then(() => this.requestRender()), B.updateFont(_, this)
                        }
                    }
                };
            new _n(gk.emptyData());
            var _l = class extends xK {
                    updateByPatchedOp(_, O, B) {
                        if (super.updateByPatchedOp(_, O, B), null !== function(_, O) {
                                let B = [];
                                if (O.length !== _.length) return null;
                                for (var N = 0; N < _.length;) {
                                    if ("*" === O[N]) B.push(_[N]);
                                    else if (_[N] !== O[N]) return null;
                                    N += 1
                                }
                                return B
                            }(_.path, ["materials"]) && 0 === _.type && Array.isArray(this.material))
                            for (let [O, N] of Object.entries(_.props)) {
                                let _ = B.shared.material(N);
                                this.material[Number(O)] = _
                            } else if (qn(_.path, ["material"]) && this.material instanceof wQ) "material" in O && "string" != typeof O.material && this.material.updateByOp(uR.drop(_, 1), O.material, B);
                            else if (qn(_.path, ["materials", "*"]) && Array.isArray(this.material)) {
                            let N = _.path[1];
                            if ("materials" in O && N < this.material.length) {
                                let k = O.materials[N];
                                "string" != typeof k && this.material[N].updateByOp(uR.drop(_, 2), k, B)
                            }
                        }
                    }
                    get needsAO() {
                        return void 0 !== this.material && (Array.isArray(this.material) ? this.material[0] : this.material).hasAO
                    }
                    updateState(_, O) {
                        super.updateState(_, O), void 0 !== _.castShadow && (this.castShadow = _.castShadow), void 0 !== _.receiveShadow && (this.receiveShadow = _.receiveShadow);
                        let B = this.dataPatched;
                        if (_.geometry ? .type !== "NonParametricGeometry" && "material" in _ && void 0 !== _.material && (this.disposeMaterial(), this.material = O.shared.material(_.material).getFlavor(B.flatShading, B.side, B.wireframe), O.scene.markNeedsUpdateRendererDirty()), _.geometry ? .type === "NonParametricGeometry" && ("materials" in _ && void 0 !== _.materials ? (this.disposeMaterial(), this.material = _.materials.map(_ => O.shared.material(_).getFlavor(B.flatShading, B.side, B.wireframe)), O.scene.markNeedsUpdateRendererDirty()) : "material" in _ && void 0 !== _.material && (this.disposeMaterial(), this.material = [O.shared.material(_.material).getFlavor(B.flatShading, B.side, B.wireframe)], O.scene.markNeedsUpdateRendererDirty())), void 0 !== _.flatShading || void 0 !== _.wireframe || void 0 !== _.side) {
                            if (Array.isArray(this.material))
                                for (let _ = 0; _ < this.material.length; _++) this.material[_] = this.material[_].getFlavor(B.flatShading, B.side, B.wireframe);
                            else this.material = this.material.getFlavor(B.flatShading, B.side, B.wireframe)
                        }
                    }
                    disposeMaterial() {
                        this.material && hy(this.material).forEach(_ => {
                            _ instanceof wQ && (_ instanceof w$ || _.nodeMaterialDispose())
                        })
                    }
                    dispose() {
                        this.disposeMaterial(), super.dispose()
                    }
                },
                _h = new rv,
                _d = new rl,
                _u = new rl,
                _p = new rv,
                _f = new rJ,
                _m = class extends _l {
                    constructor(_, O, B) {
                        super(_, O), this.data = O, this.isSkinnedMesh = !1, this.localGeometry = void 0, O.bindMode && O.bindMatrix && (this.bindMode = O.bindMode, this.bindMatrix = new rJ().fromArray(O.bindMatrix), this.bindMatrixInverse = new rJ)
                    }
                    chooseGeoemtryCache(_) {
                        return _.geometryCache
                    }
                    markGeometryAsReachable(_) {
                        this.geometryCreateDeleyed instanceof sK && this.chooseGeoemtryCache(_).markAsReachable(this.dataPatched.geometry, this.geometryCreateDeleyed)
                    }
                    get geometry() {
                        if (void 0 !== this.localGeometry) return this.localGeometry;
                        if (this.geometryCreateDeleyed instanceof _n) {
                            let _ = this.geometryCreateDeleyed,
                                O = this.chooseGeoemtryCache(_);
                            this.geometryCreateDeleyed = O.get(this.dataPatched.geometry, _, this)
                        }
                        return this.geometryCreateDeleyed
                    }
                    set geometry(_) {
                        this.localGeometry = _
                    }
                    get is2DAndNoDepth() {
                        let _ = this.dataPatched.geometry;
                        return m5.is2DParametricMesh(_.type) && 0 === _.depth
                    }
                    get is2DType() {
                        return m5.is2DParametricMesh(this.geometry.userData.type)
                    }
                    get isNonParametric() {
                        return "NonParametricGeometry" === this.geometry.userData.type
                    }
                    updateByPatchedOp(_, O, B) {
                        super.updateByPatchedOp(_, O, B), qn(_.path, ["geometry"]) && this.updateByPatchedOpGeometry(uR.drop(_, 1), O.geometry, B)
                    }
                    removeInteractionGeometry() {
                        this.localGeometry ? .dispose(), this.localGeometry = void 0
                    }
                    updateGeometryInteractions(_, O) {
                        this.invalidateDownstreamBooleanData();
                        let B = this.data.geometry.type;
                        if ("NonParametricGeometry" === B || "SubdivGeometry" === B) {
                            let B, N, k;
                            if (void 0 === this.localGeometry) {
                                let B = { ...this.data.geometry,
                                    ..._
                                };
                                this.localGeometry = gc(B, O, this.data.flatShading, this)
                            }
                            _.scaleBaked ? [B, N, k] = _.scaleBaked : {
                                width: B,
                                height: N,
                                depth: k
                            } = _;
                            let F = this.localGeometry.userData;
                            void 0 !== F.sxPrev && Lp(this.localGeometry.attributes, B / F.sxPrev, N / F.syPrev, k / F.szPrev), F.sxPrev = B, F.syPrev = N, F.szPrev = k
                        } else {
                            let B = { ...this.data.geometry,
                                ..._
                            };
                            this.localGeometry ? .dispose(), this.localGeometry = gc(B, O, this.data.flatShading, this)
                        }
                    }
                    refreshAttachedCloners(_) {
                        for (let O of this.attachedSurfaceCloners) _.scene.addPendingUpdateCloner(O.object)
                    }
                    refreshAttachedPaths(_) {
                        for (let O of this.attachedPaths) _.scene.addPendingCommand(() => O.updateShape())
                    }
                    createGeometryDelayed(_) {
                        this.geometryCreateDeleyed = _.shared, this.refreshAttachedCloners(_), this.refreshAttachedPaths(_)
                    }
                    updateByPatchedOpGeometry(_, O, B) {
                        let N = !1;
                        0 === _.type && 0 === _.path.length && Object.keys(_.props).includes("scaleBaked") && this.geometryCreateDeleyed instanceof xN && this.chooseGeoemtryCache(B.shared).mutateIfUnique(this.geometryCreateDeleyed.data, O) === this.geometryCreateDeleyed && (N = !0, this.geometryCreateDeleyed.mutateDirectlyScaleBaked(O, _.props.scaleBaked), this.refreshAttachedCloners(B), this.refreshAttachedPaths(B)), N || (B.scene ? .markGeometryCacheDirty(), this.createGeometryDelayed(B)), this.resetBBoxNeedsUpdate(), this.invalidateDownstreamBooleanData()
                    }
                    updateGeometryOnStateUpdate(_, O) {
                        this.createGeometryDelayed(O)
                    }
                    updateState(_, O) {
                        void 0 !== _.geometry && this.updateGeometryOnStateUpdate(_.geometry, O), super.updateState(_, O)
                    }
                    updateGeometryGroupsIfNeeded() {
                        Array.isArray(this.material) && 0 === this.geometry.groups.length && this.geometry.addGroup(0, Math.max(this.geometry.getIndex() ? .count ? ? 0, this.geometry.getAttribute("position").count), 0)
                    }
                    updateEntityBoxSize(_, O) {
                        let B = this.geometry.userData.parameters;
                        this.is2DType ? _.set(0, 0, .5 * B.depth) : this.isNonParametric ? (_.setScalar(0), this.geometry.boundingSphere && _.copy(this.geometry.boundingSphere.center), O.set(B.width, B.height, B.depth ? ? 0).multiplyScalar(.5)) : _.setScalar(0), O.set(B.width, B.height, B.depth ? ? 0).multiplyScalar(.5)
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
                    }
                    bind(_, O) {
                        this.skeleton = _, this.isSkinnedMesh = !0, void 0 === O && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), O = this.matrixWorld), this.bindMatrix.copy(O), this.bindMatrixInverse.copy(O).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights(_) {
                        let O = new rl,
                            B = this.geometry.attributes.skinWeight;
                        for (let _ = 0, N = B.count; _ < N; _++) {
                            O.fromBufferAttribute(B, _);
                            let N = 1 / O.manhattanLength();
                            N !== 1 / 0 ? O.multiplyScalar(N) : O.set(1, 0, 0, 0), B.setXYZW(_, O.x, O.y, O.z, O.w)
                        }
                    }
                    boneTransform(_, O) {
                        let B = this.skeleton;
                        if (void 0 === B) return;
                        let N = this.geometry;
                        _d.fromBufferAttribute(N.attributes.skinIndex, _), _u.fromBufferAttribute(N.attributes.skinWeight, _), _h.copy(O).applyMatrix4(this.bindMatrix), O.set(0, 0, 0);
                        for (let _ = 0; _ < 4; _++) {
                            let N = _u.getComponent(_);
                            if (0 !== N) {
                                let k = _d.getComponent(_);
                                _f.multiplyMatrices(B.bones[k].matrixWorld, B.boneInverses[k]), O.addScaledVector(_p.copy(_h).applyMatrix4(_f), N)
                            }
                        }
                        return O.applyMatrix4(this.bindMatrixInverse)
                    }
                };

            function Td(_) {
                if (Array.isArray(_.material)) {
                    for (let O of _.material)
                        if (0 === O.getLayersOfType("outline").length) return
                } else if (!(_.material instanceof wQ) || 0 === _.material.getLayersOfType("outline").length) return;
                _ instanceof _m && _.is2DAndNoDepth ? function(_) {
                    if (_.geometry.attributes.extrudeNormals || !_.geometry.attributes.position) return;
                    let O = _.geometry.attributes.position.array,
                        B = new Float32Array(O.length),
                        N = new rv;
                    for (let _ = 0; _ < O.length; _ += 3) N.set(O[_], O[_ + 1], O[_ + 2]).normalize(), B[_] = N.x, B[_ + 1] = N.y, B[_ + 2] = N.z;
                    _.geometry.setAttribute("extrudeNormal", new sG(B, 3))
                }(_) : function(_) {
                    if (_.geometry.attributes.extrudeNormal || !_.geometry.attributes.position || !_.geometry.attributes.normal) return;
                    let O = new Map,
                        B = _.geometry.attributes,
                        N = B.position.array,
                        k = B.normal.array,
                        F = new Float32Array(N.length);
                    for (let _ = 0; _ < N.length; _ += 3) {
                        let B = `${N[_]}_${N[_+1]}_${N[_+2]}`,
                            F = new rv(k[_], k[_ + 1], k[_ + 2]);
                        O.has(B) ? O.get(B) ? .normals.push(F) : O.set(B, {
                            normals: [F],
                            result: new rv
                        })
                    }
                    O.forEach((_, O) => {
                        for (let O of _.normals) _.result.add(O);
                        _.result.divideScalar(_.normals.length)
                    });
                    for (let _ = 0; _ < N.length; _ += 3) {
                        let B = `${N[_]}_${N[_+1]}_${N[_+2]}`,
                            k = O.get(B) ? .result;
                        k && (F[_] = k.x, F[_ + 1] = k.y, F[_ + 2] = k.z)
                    }
                    _.geometry.setAttribute("extrudeNormal", new sG(F, 3))
                }(_)
            }

            function Cd(_) {
                if (!_.geometry.attributes.position) return;
                let O = _.geometry.attributes.position.array,
                    B = new Float32Array(O.length),
                    N = parseInt(_.uuid.replace(/\D/g, "")),
                    k = [iK.seededRandom(N), iK.seededRandom(N + 1e4), iK.seededRandom(N + 2e4)];
                for (let _ = 0; _ < O.length; _++) B[_] = k[_ % 3];
                _.geometry.setAttribute("randomColor", new sF(B, 3))
            }
            xx.then(_ => {});
            var _g = new rb,
                _v = new rv,
                _x = class extends _m {
                    constructor(_, O, B) {
                        super(_, O, B), this.data = O, this.hiddenMatrixOld = new rJ, this.smoothShading = !0, this.skipReactionUpdate = !1
                    }
                    chooseGeoemtryCache(_) {
                        return this.dataPatched.flatShading ? _.geometryCache : _.geometryCache2
                    }
                    get subdivPointerNew() {
                        return void 0 !== this.localGeometry ? this.subdivPointer : this.geometry.ensureSubdivPointer()
                    }
                    get originalGeometryNew() {
                        return void 0 !== this.localGeometry ? this.originalGeometry : this.geometry.originalGeometry
                    }
                    get phongAngle() {
                        return this.data.geometry.phongAngle ? ? 45
                    }
                    updateEntityBoxSize(_, O) {
                        let B = this.geometry.userData.parameters;
                        _.copy(this.originalGeometryNew.boundingSphere.center), O.set(B.width, B.height, B.depth ? ? 0).multiplyScalar(.5)
                    }
                    createGeometryByControls(_) {
                        if (!0 === this.skipReactionUpdate) return;
                        let O = this.localGeometry ? .uuid,
                            {
                                originalGeometry: B,
                                subdividedGeometry: N,
                                subdivPointer: k
                            } = xN.build(_, this.subdivPointer, this.smoothShading, this.hasNonUniformScale ? this.shearScale : void 0);
                        this.subdivPointer = k, void 0 !== B && (this.originalGeometry ? .dispose(), this.originalGeometry = B), void 0 !== N && (this.subdividedGeometry ? .dispose(), this.subdividedGeometry = N ? ? void 0), this.localGeometry = this.subdividedGeometry ? ? this.originalGeometry, Td(this), Cd(this), this.calcBoundingBox(), O && (this.localGeometry.uuid = O)
                    }
                    updateState(_, O) {
                        if (super.updateState(_, O), void 0 !== _.flatShading) {
                            let B = this.material;
                            this.material = B.getFlavor(!1, B.side, B.wireframe), this.smoothShading = !_.flatShading, this.createGeometryDelayed(O)
                        }
                    }
                    updateMesh(_ = !1) {
                        xN.buildLevel(this.subdivPointer, !0, this.smoothShading ? this.phongAngle : -1, this.originalGeometry, _ && this.hasNonUniformScale ? this.shearScaleInv : void 0), this.subdividedGeometry && xN.buildLevel(this.subdivPointer, !1, this.smoothShading ? this.phongAngle : -1, this.subdividedGeometry, _ && this.hasNonUniformScale ? this.shearScaleInv : void 0)
                    }
                    updateTopology() {
                        this.originalGeometry.dispose(), this.originalGeometry = xN.buildLevel(this.subdivPointer, !0, this.smoothShading ? this.phongAngle : -1), this.subdividedGeometry && (this.subdividedGeometry.dispose(), this.subdividedGeometry = xN.buildLevel(this.subdivPointer, !1, this.smoothShading ? this.phongAngle : -1)), this.localGeometry = this.subdividedGeometry ? ? this.originalGeometry
                    }
                    raycast(_, O) {
                        let B = this.localGeometry;
                        this.localGeometry = this.originalGeometryNew, xK.prototype.raycast.call(this, _, O), this.localGeometry = B
                    }
                    activateSVDCompensation() {
                        this.hasNonUniformScale && (this.matrix.copy(this.matrixWorldRigid), this.hiddenMatrixOld.copy(this.hiddenMatrix), this.hiddenMatrix.copy(this.parent.matrixWorld).invert())
                    }
                    deactivateSVDCompensation() {
                        this.hasNonUniformScale && (this.updateMatrix(), this.hasNonUniformScale = void 0, this.hiddenMatrix.copy(this.hiddenMatrixOld))
                    }
                    calcBoundingBox() {
                        let _ = this.originalGeometry;
                        null === _.boundingSphere && (_.boundingSphere = new rG, this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = _.boundingSphere));
                        let O = _.attributes.position,
                            B = _.boundingSphere.center;
                        _g.setFromBufferAttribute(O), _g.getCenter(B), _.boundingSphere.radius = B.distanceTo(_g.max), isNaN(_.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), _g.getSize(_v), this.hasNonUniformScale && _v.divide(this.scale);
                        let N = {
                            width: _v.x,
                            height: _v.y,
                            depth: _v.z
                        };
                        return this.geometry.userData.parameters = N, N
                    }
                    updateBoundingSphere(_) {
                        let O = this.originalGeometry;
                        _g.min.set(_[0], _[2], _[4]), _g.max.set(_[1], _[3], _[5]), this.hasNonUniformScale && (_g.min.applyMatrix4(this.shearScaleInv), _g.max.applyMatrix4(this.shearScaleInv)), null === O.boundingSphere && (O.boundingSphere = new rG);
                        let B = O.boundingSphere.center;
                        _g.getCenter(B), O.boundingSphere.radius = B.distanceTo(_g.max)
                    }
                    freeSubdivPointer() {
                        this.subdivPointer && (xN.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0), this.localGeometry = void 0, this.originalGeometry ? .dispose(), this.subdividedGeometry ? .dispose()
                    }
                    dispose() {
                        super.dispose(), this.freeSubdivPointer()
                    }
                    updateByPatchedOpGeometry(_, O, B) {
                        super.updateByPatchedOpGeometry(_, O, B), this.localGeometry && this.createGeometryByControls(O)
                    }
                },
                _b = {
                    x: [1, 0, 0],
                    "-x": [-1, 0, 0],
                    y: [0, 1, 0],
                    "-y": [0, -1, 0],
                    z: [0, 0, 1],
                    "-z": [0, 0, -1]
                },
                __ = {
                    polygon_center: 0,
                    edge: 1,
                    vertex: 2
                },
                Qp = (_, O) => (B, N) => O && 0 !== B && 0 !== _ ? _ * N / 100 : 0,
                ct = (_, O) => {
                    let B = Math.abs(O),
                        N = -1 * B;
                    return (_ - -1) * (B - N) / 2 + N
                },
                _A = new rv,
                _M = new rv,
                _T = new rv,
                _D = new rv;

            function Pd(_, O) {
                let B = _T.fromArray(_),
                    N = _D.fromArray(O);
                _M.copy(N).sub(B);
                let k = _M.length();
                return _M.normalize().multiplyScalar(.5 * k), _A.copy(B).add(_M).toArray()
            }
            var _P = new sO,
                _I = new rv,
                _O = new rv,
                _L = new rv,
                zA = _ => .5 * (1 - Math.cos(_ * Math.PI)),
                _R = class {
                    constructor() {
                        this.perlin = Array(4096)
                    }
                    noise(_, O = 0, B = 0) {
                        if (null == this.perlin) {
                            this.perlin = Array(4096);
                            for (let _ = 0; _ < 4096; _++) this.perlin[_] = Math.random()
                        }
                        _ < 0 && (_ = -_), O < 0 && (O = -O), B < 0 && (B = -B);
                        let N = Math.floor(_),
                            k = Math.floor(O),
                            F = Math.floor(B),
                            U = _ - N,
                            j = O - k,
                            G = B - F,
                            Y, Q, K = 0,
                            $ = .5,
                            ee, et, ei;
                        for (let _ = 0; _ < 4; _++) {
                            let _ = N + (k << 4) + (F << 8);
                            Y = zA(U), Q = zA(j), ee = this.perlin[4095 & _], ee += Y * (this.perlin[_ + 1 & 4095] - ee), et = this.perlin[_ + 16 & 4095], et += Y * (this.perlin[_ + 16 + 1 & 4095] - et), ee += Q * (et - ee), _ += 256, et = this.perlin[4095 & _], et += Y * (this.perlin[_ + 1 & 4095] - et), ei = this.perlin[_ + 16 & 4095], ei += Y * (this.perlin[_ + 16 + 1 & 4095] - ei), et += Q * (ei - et), ee += zA(G) * (et - ee), K += ee * $, $ *= .5, N <<= 1, k <<= 1, j *= 2, F <<= 1, G *= 2, (U *= 2) >= 1 && (N++, U--), j >= 1 && (k++, j--), G >= 1 && (F++, G--)
                        }
                        return K
                    }
                    noiseSeed(_) {
                        let O, B;
                        let N = {
                            setSeed(_) {
                                B = O = (_ ? ? 4294967296 * Math.random()) >>> 0
                            },
                            getSeed: () => O,
                            rand: () => (B = (1664525 * B + 1013904223) % 4294967296) / 4294967296
                        };
                        N.setSeed(_), this.perlin = Array(4096);
                        for (let _ = 0; _ < 4096; _++) this.perlin[_] = N.rand()
                    }
                },
                _B = new rv,
                _z = new rJ,
                _N = new rK;

            function GA(_) {
                let O = !1;
                return _.scene.objects.traverse((_, B) => {
                    "Mesh" === B.type && "TextGeometry" === B.geometry.type && (O = !0)
                }), O
            }
            var _k, _F, _U, _j, _G, _H = class extends _m {
                    constructor(_, O, B) {
                        super(_, O, B), this.data = O
                    }
                    get textGeometry() {
                        return this.geometry
                    }
                    get charWidths() {
                        return this.textGeometry.charWidths
                    }
                    get charCoords() {
                        return this.textGeometry.charCoords
                    }
                    get wrappedText() {
                        return this.textGeometry.wrappedText
                    }
                    get font() {
                        return this.textGeometry.font
                    }
                    get initialOffsetY() {
                        let _ = this.dataPatched;
                        return this.font ? .getLineInitialOffsetY(this.lineHeight, this.wrappedText.length, _.geometry.height, this.fontScale, _.geometry.verticalAlign) ? ? 0
                    }
                    get fontScale() {
                        let _ = this.dataPatched;
                        return this.font ? _.geometry.fontSize / this.font.unitsPerEm : 1
                    }
                    get AD() {
                        return Math.abs(this.ascender - this.descender)
                    }
                    get ascender() {
                        return (this.font ? .ascender ? ? 1) * this.fontScale
                    }
                    get descender() {
                        return (this.font ? .descender ? ? 1) * this.fontScale
                    }
                    get lineHeight() {
                        let _ = this.dataPatched;
                        return _.geometry.fontSize * _.geometry.lineHeight
                    }
                    raycast(_, O) {
                        let {
                            matrixWorld: B
                        } = this;
                        if (!(isNaN(_.ray.origin.x) || 0 === this.scale.x || 0 === this.scale.y || 0 === this.scale.z) && (_z.copy(B).invert(), _N.copy(_.ray).applyMatrix4(_z), _N.intersectBox(this.singleBBox, _B))) {
                            let N = _B.applyMatrix4(B),
                                k = _.ray.origin.distanceTo(N);
                            O.push({
                                distance: k,
                                point: N.clone(),
                                object: this
                            })
                        }
                    }
                },
                _W = new rv,
                _q = new rv;
            xx.then(_ => {
                _U = [(_F = _).get_face_center, _F.get_edge_midpoint, _F.get_vertex_position], _j = [_F.get_face_normal, _F.get_edge_normal, _F.get_vertex_normal], _G = [_F.face_count, _F.edge_count, _F.vertex_count]
            });
            var _Y = new rJ,
                _X = new rJ,
                _Q = new rv,
                _Z = new rv,
                _K = new rv,
                _J = new rv,
                _$ = new rv,
                _0 = new rv,
                _2 = new _R,
                _3 = class extends Gh(sv) {
                    constructor(_, O) {
                        super(), this.parameters = O, this.objectForSample = void 0, this._pendingMediaLoad = !1, this.object = _
                    }
                    resetOnMove() {
                        this.removeFromParent(), this.parent = null
                    }
                    expandClones(_) {
                        if (null === this.parent) this.updateState(this.parameters, _);
                        else
                            for (let _ of this.children) _ instanceof vb && _.expand()
                    }
                    invalidateTransform(_) {
                        this.matrixWorldNeedsUpdate = !0, this.traverse(O => {
                            O instanceof vb && O.object === _ && (O.matrixWorldNeedsUpdate = !0)
                        })
                    }
                    onObjUpdateMatrix() {
                        "toObject" !== this.parameters.type && (this.matrixWorldNeedsUpdate = !0)
                    }
                    update() {
                        switch (this._updateCount(), this.parameters.type) {
                            case "radial":
                                this._updateRadial(this.parameters);
                                break;
                            case "linear":
                                this._updateLinear(this.parameters);
                                break;
                            case "grid":
                                this._updateGrid(this.parameters);
                                break;
                            case "toObject":
                                this._updateToObject(this.parameters)
                        }
                        for (let _ of this.children) _.updateMatrix(), _.hasNonUniformScale && (_.updateMatrixWorld(), _.updateMatrixWorldSVD())
                    }
                    _updateCount(_) {
                        let O;
                        if (O = void 0 !== _ ? _ : "grid" === this.parameters.type ? Math.round(this.parameters.grid.count[0]) * Math.round(this.parameters.grid.count[1]) * Math.round(this.parameters.grid.count[2]) : this.parameters.count, "toObject" !== this.parameters.type || this.parameters.toObject.object || (O = 0), "toObject" === this.parameters.type && this.objectForSample) {
                            for (let _ = 0, O = this.children.length; _ < O; ++_) this.remove(this.children[0]);
                            let _ = this.children;
                            if (_.length === O) return;
                            if (_.length < O)
                                for (let B = 0, N = O - _.length; B < N; ++B) {
                                    let _ = new vb(this.object);
                                    _.expand(), this.add(_)
                                } else
                                    for (let B = 0, N = _.length - O; B < N; ++B) this.remove(_[B])
                        } else {
                            if (this.children.length === O) return;
                            if (this.children.length < O)
                                for (let _ = 0, B = O - this.children.length; _ < B; ++_) {
                                    let _ = new vb(this.object);
                                    _.expand(), this.add(_)
                                } else
                                    for (let _ = 0, B = this.children.length - O; _ < B; ++_) this.remove(this.children[0])
                        }
                    }
                    _updateRadial(_) {
                        let O = _.radial,
                            B = O.start * iK.DEG2RAD,
                            N = B - O.end * iK.DEG2RAD,
                            k = new r9(O.rotation[0], O.rotation[1], O.rotation[2]),
                            F;
                        switch (O.axis) {
                            case "z":
                                F = new rv(0, 0, 1);
                                break;
                            case "y":
                                F = new rv(0, 1, 0);
                                break;
                            default:
                                F = new rv(1, 0, 0)
                        }
                        let U = _.randomnessObject ? ? fQ.defaultData([1, 1, 1]).randomnessObject,
                            j = "perlin" === U.noiseType;
                        _2.noiseSeed(U.seed);
                        let G = pv((0, vi.default)(U.seed)),
                            Y = Qp(U.strength, this.parameters.randomness);
                        for (let [Q, K] of this.children.entries()) {
                            let $ = Q * (U.freqScale / 10) + U.movement,
                                ee = j ? _2.noise($) : G($, $),
                                et = Q + 1;
                            K.scale.x = O.scale[0] + Y(et, ct(ee, U.scale[0])) || 1e-4, K.scale.y = O.scale[1] + Y(et, ct(ee, U.scale[1])) || 1e-4, K.scale.z = O.scale[2] + Y(et, ct(ee, U.scale[2])) || 1e-4, K.position.setScalar(0);
                            let ei = N / _.count * Q - B;
                            switch (O.axis) {
                                case "x":
                                    K.rotation.set(0, ei, 0);
                                    break;
                                case "y":
                                    K.rotation.set(0, 0, ei);
                                    break;
                                case "z":
                                    K.rotation.set(ei, 0, 0)
                            }
                            K.translateOnAxis(F, O.radius), K.position.x += O.position[0] + Y(et, ct(ee, U.position[0])), K.position.y += O.position[1] + Y(et, ct(ee, U.position[1])), K.position.z += O.position[2] + Y(et, ct(ee, U.position[2]));
                            let er = Y(et, ct(ee, U.rotation[0])),
                                ea = Y(et, ct(ee, U.rotation[1])),
                                en = Y(et, ct(ee, U.rotation[2]));
                            !0 === O.alignment ? (K.rotation.x += k.x + er, K.rotation.y += k.y + ea, K.rotation.z += k.z + en) : K.rotation.set(k.x + er, k.y + ea, k.z + en)
                        }
                    }
                    _updateLinear(_) {
                        if ("linear" !== _.type) throw Error();
                        let O = _.linear,
                            B = new r9(O.rotation[0], O.rotation[1], O.rotation[2]),
                            N = _.randomnessObject ? ? fQ.defaultData([1, 1, 1]).randomnessObject,
                            k = "perlin" === N.noiseType;
                        _2.noiseSeed(N.seed);
                        let F = pv((0, vi.default)(N.seed)),
                            U = Qp(N.strength, this.parameters.randomness);
                        for (let [_, j] of this.children.entries()) {
                            let G = _ * (N.freqScale / 10) + N.movement,
                                Y = k ? _2.noise(G) : F(G, G),
                                Q = _ + 1,
                                K = U(Q, ct(Y, N.rotation[0])),
                                $ = U(Q, ct(Y, N.rotation[1])),
                                ee = U(Q, ct(Y, N.rotation[2]));
                            j.scale.x = 1 + (O.scale[0] - 1) * _ + U(Q, ct(Y, N.scale[0])) || 1e-4, j.scale.y = 1 + (O.scale[1] - 1) * _ + U(Q, ct(Y, N.scale[1])) || 1e-4, j.scale.z = 1 + (O.scale[2] - 1) * _ + U(Q, ct(Y, N.scale[2])) || 1e-4, j.rotation.x = B.x * _ + K, j.rotation.y = B.y * _ + $, j.rotation.z = B.z * _ + ee, j.position.x = O.position[0] * _ + U(Q, ct(Y, N.position[0])), j.position.y = O.position[1] * _ + U(Q, ct(Y, N.position[1])), j.position.z = O.position[2] * _ + U(Q, ct(Y, N.position[2]))
                        }
                    }
                    _updateGrid(_) {
                        let O = 0,
                            B = _.grid,
                            N = _.randomnessObject ? ? fQ.defaultData([1, 1, 1]).randomnessObject,
                            k = Qp(N.strength, this.parameters.randomness),
                            F = "perlin" === N.noiseType;
                        _2.noiseSeed(N.seed);
                        let U = function(_ = Math.random) {
                            let O = V2(_),
                                B = new Float64Array(O).map(_ => vh[_ % 12 * 3]),
                                N = new Float64Array(O).map(_ => vh[_ % 12 * 3 + 1]),
                                k = new Float64Array(O).map(_ => vh[_ % 12 * 3 + 2]);
                            return function(_, F, U) {
                                let j, G, Y, Q, K = (_ + F + U) * vn,
                                    $ = Sp(_ + K),
                                    ee = Sp(F + K),
                                    et = Sp(U + K),
                                    ei = ($ + ee + et) * vo,
                                    er = _ - ($ - ei),
                                    ea = F - (ee - ei),
                                    en = U - (et - ei),
                                    eo, el, eh, ec, eu, ep;
                                er >= ea ? ea >= en ? (eo = 1, el = 0, eh = 0, ec = 1, eu = 1, ep = 0) : (er >= en ? (eo = 1, el = 0, eh = 0) : (eo = 0, el = 0, eh = 1), ec = 1, eu = 0, ep = 1) : ea < en ? (eo = 0, el = 0, eh = 1, ec = 0, eu = 1, ep = 1) : er < en ? (eo = 0, el = 1, eh = 0, ec = 0, eu = 1, ep = 1) : (eo = 0, el = 1, eh = 0, ec = 1, eu = 1, ep = 0);
                                let ef = er - eo + vo,
                                    em = ea - el + vo,
                                    eg = en - eh + vo,
                                    ev = er - ec + 2 * vo,
                                    ex = ea - eu + 2 * vo,
                                    eb = en - ep + 2 * vo,
                                    e_ = er - 1 + 3 * vo,
                                    eS = ea - 1 + 3 * vo,
                                    eA = en - 1 + 3 * vo,
                                    eM = 255 & $,
                                    eE = 255 & ee,
                                    eC = 255 & et,
                                    eT = .6 - er * er - ea * ea - en * en;
                                if (eT < 0) j = 0;
                                else {
                                    let _ = eM + O[eE + O[eC]];
                                    eT *= eT, j = eT * eT * (B[_] * er + N[_] * ea + k[_] * en)
                                }
                                let eD = .6 - ef * ef - em * em - eg * eg;
                                if (eD < 0) G = 0;
                                else {
                                    let _ = eM + eo + O[eE + el + O[eC + eh]];
                                    eD *= eD, G = eD * eD * (B[_] * ef + N[_] * em + k[_] * eg)
                                }
                                let eP = .6 - ev * ev - ex * ex - eb * eb;
                                if (eP < 0) Y = 0;
                                else {
                                    let _ = eM + ec + O[eE + eu + O[eC + ep]];
                                    eP *= eP, Y = eP * eP * (B[_] * ev + N[_] * ex + k[_] * eb)
                                }
                                let eI = .6 - e_ * e_ - eS * eS - eA * eA;
                                if (eI < 0) Q = 0;
                                else {
                                    let _ = eM + 1 + O[eE + 1 + O[eC + 1]];
                                    eI *= eI, Q = eI * eI * (B[_] * e_ + N[_] * eS + k[_] * eA)
                                }
                                return 32 * (j + G + Y + Q)
                            }
                        }((0, vi.default)(N.seed));
                        if (!0 === B.useCenter) {
                            let _ = {
                                    x: B.count[0] % 2 == 0 ? 2 : 1,
                                    y: B.count[1] % 2 == 0 ? 2 : 1,
                                    z: B.count[2] % 2 == 0 ? 2 : 1
                                },
                                j = new rv(B.size[0] * (B.count[0] - _.x) * .5, B.size[1] * (B.count[1] - _.y) * .5, B.size[2] * (B.count[2] - _.z) * .5);
                            for (let _ = 0; _ < B.count[0]; _++)
                                for (let G = 0; G < B.count[1]; G++)
                                    for (let Y = 0; Y < B.count[2]; Y++) {
                                        let Q = [(_ + 1) * (N.freqScale / 10) + N.movement, (G + 1) * (N.freqScale / 10) + N.movement, (Y + 1) * (N.freqScale / 10) + N.movement],
                                            K = F ? _2.noise(...Q) : U(...Q),
                                            $ = this.children[O++];
                                        $.scale.x = 1 + k(O, ct(K, N.scale[0])) || 1e-4, $.scale.y = 1 + k(O, ct(K, N.scale[1])) || 1e-4, $.scale.z = 1 + k(O, ct(K, N.scale[2])) || 1e-4;
                                        let ee = k(O, ct(K, N.rotation[0])),
                                            et = k(O, ct(K, N.rotation[1])),
                                            ei = k(O, ct(K, N.rotation[2]));
                                        $.rotation.set(ee, et, ei), $.position.x = B.size[0] * _ - j.x + k(O, ct(K, N.position[0])), $.position.y = B.size[1] * G - j.y + k(O, ct(K, N.position[1])), $.position.z = B.size[2] * Y - j.z + k(O, ct(K, N.position[2]))
                                    }
                        } else
                            for (let _ = 0; _ < B.count[0]; _++)
                                for (let j = 0; j < B.count[1]; j++)
                                    for (let G = 0; G < B.count[2]; G++) {
                                        let Y = [(_ + 1) * (N.freqScale / 10) + N.movement, (j + 1) * (N.freqScale / 10) + N.movement, (G + 1) * (N.freqScale / 10) + N.movement],
                                            Q = F ? _2.noise(...Y) : U(...Y),
                                            K = this.children[O++];
                                        K.scale.x = 1 + k(O, ct(Q, N.scale[0])) || 1e-4, K.scale.y = 1 + k(O, ct(Q, N.scale[1])) || 1e-4, K.scale.z = 1 + k(O, ct(Q, N.scale[2])) || 1e-4;
                                        let $ = k(O, ct(Q, N.rotation[0])),
                                            ee = k(O, ct(Q, N.rotation[1])),
                                            et = k(O, ct(Q, N.rotation[2]));
                                        K.rotation.set($, ee, et), K.position.x = B.size[0] * _ + k(O, ct(Q, N.position[0])), K.position.y = -B.size[1] * j + k(O, ct(Q, N.position[1])), K.position.z = -B.size[2] * G + k(O, ct(Q, N.position[2]))
                                    }
                    }
                    _updateToObject(_) {
                        if ("toObject" !== _.type) throw Error();
                        let {
                            toObject: O
                        } = _, B = new r9(O.rotation[0], O.rotation[1], O.rotation[2]), N = _.randomnessObject ? ? fQ.defaultData([1, 1, 1]).randomnessObject, k = "perlin" === N.noiseType;
                        _2.noiseSeed(N.seed);
                        let F = pv((0, vi.default)(N.seed)),
                            U = Qp(N.strength, this.parameters.randomness);
                        if (!O.object) {
                            for (let [, _] of this.children.entries()) _.position.set(0, 0, 0), _.scale.setScalar(1), _.rotation.set(0, 0, 0);
                            this.objectForSample = void 0;
                            return
                        }
                        if (!this.objectForSample) return;
                        if (this.objectForSample instanceof _H) {
                            if (this.objectForSample.font ? .isLoaded && void 0 !== this.objectForSample.geometry.attributes.position) this._pendingMediaLoad = !1;
                            else {
                                this._pendingMediaLoad = !0;
                                return
                            }
                        }
                        if (void 0 === this.objectForSample.geometry && this.objectForSample.isAncestorOf(this.object.uuid)) {
                            console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`);
                            return
                        }
                        let j = this.getSubdivData(),
                            G = [],
                            h = _ => {
                                let O = _.length;
                                return [_.map(_ => _[0]).reduce((_, O) => _ + O, 0) / O, _.map(_ => _[1]).reduce((_, O) => _ + O, 0) / O, _.map(_ => _[2]).reduce((_, O) => _ + O, 0) / O]
                            },
                            d = _ => Math.round(1e6 * _) / 1e6;
                        j.forEach(_ => {
                            let O = j.filter(O => d(_.pos[0]) === d(O.pos[0]) && d(_.pos[1]) === d(O.pos[1]) && d(_.pos[2]) === d(O.pos[2]));
                            O.length > 1 ? G.push({
                                pos: _.pos,
                                norm: h(O.map(_ => _.norm))
                            }) : G.push(_)
                        });
                        let Y = function(_) {
                            let O = [],
                                B = {};
                            for (var N = 0, k = _.length; N < k; N++) {
                                var F = JSON.stringify(_[N].pos.map(_ => Math.round(1e4 * _) / 1e4));
                                B[F] || (O.push(_[N]), B[F] = !0)
                            }
                            return O
                        }(G);
                        if (Y.length > 0) {
                            let _ = Math.round(Y.length * O.count / 100);
                            this._updateCount(_)
                        } else {
                            let _ = this.objectForSample.geometry.getAttribute("position");
                            if (!_ || isNaN(_.count) || 0 === _.count) {
                                console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) cannot be cloned on the surface of "${this.objectForSample.name}" (${this.objectForSample.uuid}) because the latter does not have a valid geometry.`);
                                return
                            }
                        }
                        this.objectForSample.updateMatrixWorld();
                        let Q = new vu(this.objectForSample).build(),
                            K = _b[O.axis],
                            $ = this.children;
                        for (let [_, j] of (Q.setRandomGenerator((0, vi.default)(this.object.uuid + O.seed)), $.entries())) {
                            let G = _ * (N.freqScale / 10) + N.movement,
                                $ = k ? _2.noise(G) : F(G, G),
                                ee = _ + 1,
                                et = U(ee, ct($, N.rotation[0])),
                                ei = U(ee, ct($, N.rotation[1])),
                                er = U(ee, ct($, N.rotation[2]));
                            "random" === O.spreadType ? Q.sample(_K, _J) : (Y.length && (_K.fromArray(Y[_].pos), _J.fromArray(Y[_].norm)), this.objectForSample instanceof _x && _K.applyMatrix4(_Y.copy(this.objectForSample.matrixWorld).invert())), _K.applyMatrix4(this.object.hiddenMatrix.clone().invert()), j.position.copy(_K), _Q.fromArray(K);
                            let ea = "normal" === O.align ? _J : this.object.getWorldDirection(_0),
                                en = _Z.fromArray(O.position);
                            _Z.x += _Z.x + U(ee, ct($, N.position[0])), _Z.y += _Z.y + U(ee, ct($, N.position[1])), _Z.z += _Z.z + U(ee, ct($, N.position[2]));
                            let eo = Math.acos(ea.dot(_Q)),
                                el = _$.crossVectors(_Q, ea).normalize(),
                                eh = _X.makeRotationAxis(el, eo),
                                ec = ea.clone().cross(this.object.up).normalize(),
                                eu = ec.clone().cross(ea).normalize(),
                                ep = new rJ().makeBasis(ec, ea, eu),
                                ef = new rv(_Q.y, _Q.z, _Q.x).normalize(),
                                em = ef.clone().cross(_Q).normalize(),
                                eg = new rJ().makeBasis(ef, _Q, em).invert(),
                                ev = new rJ().multiplyMatrices(ep, eg);
                            j.rotation.setFromRotationMatrix(ev), en.applyMatrix4(eh), j.position.add(en), j.rotation.x = j.rotation.x + B.x + et, j.rotation.y = j.rotation.y + B.y + ei, j.rotation.z = j.rotation.z + B.z + er, j.scale.setScalar(1), j.scale.x = j.scale.x + O.scale[0] + U(ee, ct($, N.scale[0])) || 1e-4, j.scale.y = j.scale.y + O.scale[1] + U(ee, ct($, N.scale[1])) || 1e-4, j.scale.z = j.scale.z + O.scale[2] + U(ee, ct($, N.scale[2])) || 1e-4, j.scale.multiply(this.object.scale), j.hiddenMatrix = this.object.hiddenMatrix
                        }
                    }
                    getSubdivData() {
                        if (!this.objectForSample) return [];
                        let _ = this.parameters.toObject.spreadType;
                        if ("random" === _) return [];
                        if (!(this.objectForSample instanceof _x)) return (this.objectForSample.geometry.index ? function(_) {
                            let O = [];
                            for (let B = 0; B <= _.index.count; B++)
                                if (_I.fromArray(_.index.array, 3 * B), _P.setFromAttributeAndIndices(_.attributes.position, _I.x, _I.y, _I.z), _P.getNormal(_O), _P.getMidpoint(_L), !(isNaN(_L.x) || isNaN(_L.y) || isNaN(_L.z))) {
                                    let {
                                        a: _,
                                        b: B,
                                        c: N
                                    } = _P, k = _.toArray(), F = B.toArray(), U = N.toArray(), j = _.distanceTo(B), G = B.distanceTo(N), Y = N.distanceTo(_), Q = Pd(k, F), K = Pd(F, U), $ = Pd(U, k), ee = [j, G, Y], et = Math.max(...ee), ei = ee.filter(_ => Math.round(_) === Math.round(et)).length > 1, er = [], ea = _P.getMidpoint(_L).toArray();
                                    et !== j || ei || (er = [K, $, $], ea = Q), et !== G || ei || (er = [Q, $, $], ea = K), et !== Y || ei || (er = [Q, K, K], ea = $), ei && (er = [Q, K, $]), O.push({
                                        vertices: [k, F, U],
                                        faceCenters: er,
                                        midpoint: ea,
                                        norm: _P.getNormal(_O).toArray()
                                    })
                                }
                            return O
                        }(this.objectForSample.geometry) : function(_) {
                            let O = [],
                                {
                                    position: B
                                } = _.attributes;
                            for (let _ = 0; _ < B.count; _++) {
                                _P.setFromAttributeAndIndices(B, 3 * _, 3 * _ + 1, 3 * _ + 2), _P.getNormal(_O), _P.getMidpoint(_L);
                                let N = _P.a.toArray(),
                                    k = _P.b.toArray(),
                                    F = _P.c.toArray();
                                O.push({
                                    vertices: [N, k, F],
                                    faceCenters: [Pd(N, k), Pd(k, F), Pd(F, N)],
                                    midpoint: _L.toArray(),
                                    norm: _O.toArray()
                                })
                            }
                            return O
                        }(this.objectForSample.geometry)).map((O, B) => "polygon_center" === _ ? {
                            pos: O.midpoint,
                            norm: O.norm
                        } : "vertex" === _ ? [{
                            pos: O.vertices[0],
                            norm: O.norm
                        }, {
                            pos: O.vertices[1],
                            norm: O.norm
                        }, {
                            pos: O.vertices[2],
                            norm: O.norm
                        }] : "edge" === _ ? [{
                            pos: O.faceCenters[0],
                            norm: O.norm
                        }, {
                            pos: O.faceCenters[1],
                            norm: O.norm
                        }, {
                            pos: O.faceCenters[2],
                            norm: O.norm
                        }] : []).flat(); {
                            let O = this.objectForSample,
                                B = __[_],
                                N = _G[B],
                                k = _U[B],
                                F = _j[B],
                                U = [],
                                j = N(O.subdivPointerNew);
                            for (let _ = 0; _ <= j - 1; _++) {
                                let B = k(O.subdivPointerNew, _),
                                    N = F(O.subdivPointerNew, _);
                                _W.fromArray(B).applyMatrix4(O.matrixWorld), _q.fromArray(N), U.push({
                                    pos: _W.toArray(),
                                    norm: _q.toArray()
                                })
                            }
                            return U
                        }
                    }
                    updateState(_, O) {
                        if (this.parameters = Zo(_), "toObject" !== this.parameters.type)(null === this.parent || this.parent !== this.object) && (this.removeFromParent(), this.object.parent ? .add(this), this.matrix = this.object.matrix, this.hiddenMatrix = this.object.hiddenMatrix, this.matrixWorldNeedsUpdate = !0, this.matrixAutoUpdate = !1);
                        else if (null === this.parent || this.parent.uuid !== this.parameters.toObject.object) {
                            this.removeFromParent();
                            let _ = O.find(this.parameters.toObject.object);
                            _ instanceof xK ? this.objectForSample = _ : this.objectForSample = void 0, this.matrix = new rJ, this.hiddenMatrix = new rJ, this.matrixWorldNeedsUpdate = !0, this.matrixAutoUpdate = !1, _ && _.add(this)
                        }
                        this.update()
                    }
                    get pendingMediaLoad() {
                        return this._pendingMediaLoad
                    }
                },
                mo = _ => {
                    var O;
                    return (O = class extends _ {}).geometryHelper = new ai(30, 30, 30), O
                },
                _4 = new rK,
                _5 = new rG,
                _6 = new rJ,
                go = (_, O, B, N, k = !1) => {
                    let F = _.matrixWorld;
                    if (null === O.boundingSphere && O.computeBoundingSphere(), _5.copy(O.boundingSphere), _5.applyMatrix4(F), !1 === B.ray.intersectsSphere(_5) || (_6.copy(F).invert(), _4.copy(B.ray).applyMatrix4(_6), null !== O.boundingBox && !1 === _4.intersectsBox(O.boundingBox))) return;
                    let U, j = O.index,
                        G = O.attributes.position,
                        Y = O.drawRange,
                        Q;
                    if (!1 === k) {
                        let O = Math.max(0, Y.start),
                            k = Math.min(j.count, Y.start + Y.count);
                        for (Q = O; Q < k; Q += 3)
                            if (U = function(_, O, B, N, k, F, U) {
                                    let j = new rv,
                                        G = new rv,
                                        Y = new rv,
                                        Q = new rv,
                                        K = new rv;
                                    if (j.fromBufferAttribute(N, k), G.fromBufferAttribute(N, F), Y.fromBufferAttribute(N, U), null === B.intersectTriangle(j, G, Y, !1, Q)) return null;
                                    K.copy(Q), K.applyMatrix4(_.matrixWorld);
                                    let $ = O.ray.origin.distanceTo(K);
                                    return $ < O.near || $ > O.far ? null : {
                                        faceIndex: 1,
                                        distance: $,
                                        point: K.clone(),
                                        object: _
                                    }
                                }(_, B, _4, G, j.getX(Q), j.getX(Q + 1), j.getX(Q + 2))) {
                                U.faceIndex = Math.floor(Q / 3), N.push(U);
                                return
                            }
                    } else {
                        let k = O.attributes.position,
                            F = new rv,
                            U = new rv,
                            j = new rv,
                            G = new rv,
                            Q = 1 / ((_.scale.x + _.scale.y + _.scale.z) / 3),
                            K = Q * Q,
                            $ = Math.max(0, Y.start),
                            ee = Math.min(k.count, Y.start + Y.count);
                        for (let O = $, Y = ee - 1; O < Y; O += 2) {
                            if (F.fromBufferAttribute(k, O), U.fromBufferAttribute(k, O + 1), _4.distanceSqToSegment(F, U, G, j) > K) continue;
                            G.applyMatrix4(_.matrixWorld);
                            let Y = B.ray.origin.distanceTo(G);
                            Y < B.near || Y > B.far || N.push({
                                distance: Y,
                                point: j.clone().applyMatrix4(_.matrixWorld),
                                object: _
                            })
                        }
                    }
                },
                _8 = new rv,
                _9 = new ao,
                _7 = class extends nX {
                    constructor(_) {
                        let O = new sK,
                            B = new nk({
                                color: 16777215,
                                vertexColors: !0,
                                toneMapped: !1
                            }),
                            N = [],
                            k = [],
                            F = {},
                            U = new re(15711266),
                            j = new re(15711266),
                            G = new re(2857471);

                        function h(_, O, B) {
                            d(_, B), d(O, B)
                        }

                        function d(_, O) {
                            N.push(0, 0, 0), k.push(O.r, O.g, O.b), void 0 === F[_] && (F[_] = []), F[_].push(N.length / 3 - 1)
                        }
                        h("n1", "n2", U), h("n2", "n4", U), h("n4", "n3", U), h("n3", "n1", U), h("f1", "f2", U), h("f2", "f4", U), h("f4", "f3", U), h("f3", "f1", U), h("n1", "f1", U), h("n2", "f2", U), h("n3", "f3", U), h("n4", "f4", U), h("p", "n1", j), h("p", "n2", j), h("p", "n3", j), h("p", "n4", j), h("u1", "u2", G), h("u2", "u3", G), h("u3", "u1", G), O.setAttribute("position", new sG(N, 3)), O.setAttribute("color", new sG(k, 3)), super(O, B), this.type = "CameraHelper", this.camera = _, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = _.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = F, this.update()
                    }
                    update() {
                        let _ = this.geometry,
                            O = this.pointMap;
                        _9.projectionMatrixInverse.elements = [.5112609807824982, -0, -0, -0, -0, .41421356237309503, -0, -0, -0, -0, -0, -.099999, -0, -0, -1.0000000000000002, .100001], Is("n1", O, _, _9, -1, -1, .8), Is("n2", O, _, _9, 1, -1, .8), Is("n3", O, _, _9, -1, 1, .8), Is("n4", O, _, _9, 1, 1, .8), Is("f1", O, _, _9, -1, -1, .8), Is("f2", O, _, _9, 1, -1, .8), Is("f3", O, _, _9, -1, 1, .8), Is("f4", O, _, _9, 1, 1, .8), Is("u1", O, _, _9, .35, 1.1, .8), Is("u2", O, _, _9, -.35, 1.1, .8), Is("u3", O, _, _9, 0, 1.55, .8), _.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                };

            function Is(_, O, B, N, k, F, U) {
                _8.set(k, F, U).unproject(N);
                let j = O[_];
                if (void 0 !== j) {
                    let _ = B.getAttribute("position");
                    for (let O = 0, B = j.length; O < B; O++) _.setXYZ(j[O], _8.x, _8.y, _8.z)
                }
            }
            var Se = class extends mo(_7) {
                constructor(_) {
                    super(_), this.object = _, this.object = _, this.name = `CombinedCameraHelper: ${_.uuid}`
                }
                updateMatrixWorld(_) {
                    super.updateMatrixWorld(_), this.updateTarget()
                }
                updateTarget() {
                    let _ = this.object.getTarget();
                    this.updateWorldMatrix(!0, !1), this.worldToLocal(_)
                }
                raycast(_, O) {
                    go(this.object, this.geometry, _, O, !0)
                }
            };
            (Eg || (Eg = {})).is = _ => "objectHelper" in _;
            var yo = (_, O) => class extends jh(_) {
                    constructor() {
                        super(...arguments), this.objectHelper = new O(this), this.gizmos = {}
                    }
                    get geometryHelper() {
                        return O.geometryHelper
                    }
                    raycast(_, O) {
                        this.objectHelper.raycast(_, O)
                    }
                    showGizmos() {
                        for (let _ in this.gizmos) {
                            let O = this.gizmos[_];
                            O instanceof lH && (O.visible = !0)
                        }
                    }
                    updateEntityBoxSize(_, O) {
                        this.objectHelper.visible && this.geometryHelper instanceof ai ? (_.setScalar(0), O.set(this.geometryHelper.parameters.width, this.geometryHelper.parameters.height, this.geometryHelper.parameters.height).multiplyScalar(.5)) : super.updateEntityBoxSize(_, O)
                    }
                    hideGizmos() {
                        for (let _ in this.gizmos) {
                            let O = this.gizmos[_];
                            O instanceof lH && (O.visible = !1)
                        }
                    }
                },
                St = new rv,
                Si = new rv,
                Ss = new rm,
                Sa = new rv,
                Sn = new rv,
                So = new rv,
                Sh = class extends yo(ao, Se) {
                    constructor(_ = "", O = { ...gm.defaultData,
                        name: ""
                    }) {
                        super(), this._cameraType = "OrthographicCamera", this.targetOffset = fX.DefaultTargetOffset, this.isUpVectorFlipped = !1, this.angleOffsetFromUp = 0, this.wasMovedByUser = !1, this.wasMovedBySwitchCameraAction = !1, this.super_Entity(_, O), this.previousProjectionMatrix = new rJ, this.matrixAutoUpdate = !0, this.width = window.innerWidth, this.height = window.innerHeight;
                        let B = this.width,
                            N = this.height;
                        this.orthoCamera = new aI(-.5 * B, .5 * B, .5 * N, -.5 * N, -5e4, 1e4), this.perspCamera = new al(45, B / N, 50, 1e4), this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.objectHelper.update()
                    }
                    get isPerspectiveCamera() {
                        return "PerspectiveCamera" === this.cameraType
                    }
                    get isOrthographicCamera() {
                        return !this.isPerspectiveCamera
                    }
                    get cameraType() {
                        return this._cameraType
                    }
                    set fov(_) {
                        this.perspCamera.fov = _
                    }
                    get fov() {
                        return this.perspCamera.fov
                    }
                    setNear(_, O) {
                        "PerspectiveCamera" === _ ? this.perspCamera.near = O : this.orthoCamera.near = O
                    }
                    setZoom(_, O) {
                        O >= 0 && ("PerspectiveCamera" === _ ? this.perspCamera.zoom = O : this.orthoCamera.zoom = O)
                    }
                    set cameraType(_) {
                        "PerspectiveCamera" === _ ? this.toPerspective() : "OrthographicCamera" === _ && this.toOrthographic()
                    }
                    get near() {
                        return "PerspectiveCamera" === this._cameraType ? this.perspCamera.near : this.orthoCamera.near
                    }
                    set near(_) {
                        "PerspectiveCamera" === this._cameraType ? this.perspCamera.near = _ : this.orthoCamera.near = _
                    }
                    get zoom() {
                        return "PerspectiveCamera" === this._cameraType ? this.perspCamera.zoom : this.orthoCamera.zoom
                    }
                    set zoom(_) {
                        _ >= 0 && ("PerspectiveCamera" === this._cameraType ? this.perspCamera.zoom = _ : this.orthoCamera.zoom = _)
                    }
                    lookAt(_, O, B) {
                        "number" == typeof _ && (_ = new rv(_, O, B)), super.lookAt(_), this.getWorldPosition(St), this.targetOffset = St.distanceTo(_)
                    }
                    getTarget(_ = new rv) {
                        return this.getWorldDirection(Si), this.getWorldPosition(St), Si.multiplyScalar(this.targetOffset), _.copy(St).add(Si), _
                    }
                    getDistanceToTarget() {
                        let _ = this.getTarget();
                        return this.getWorldPosition(St), St.distanceTo(_)
                    }
                    updateUp() {
                        this.getWorldQuaternion(Ss), Sa.set(0, 0, 1).applyQuaternion(Ss), Sn.copy(sv.DEFAULT_UP), this.isUpVectorFlipped && Sn.negate(), Sn.applyQuaternion(Ss), So.copy(sv.DEFAULT_UP).projectOnPlane(Sa), this.angleOffsetFromUp = So.angleTo(Sn), this.angleOffsetFromUp *= So.cross(Sn).dot(Sa) >= 0 ? 1 : -1
                    }
                    updateTransformState(_, O) {
                        let B = super.updateTransformState(_, O);
                        return void 0 !== _.isUpVectorFlipped && (this.isUpVectorFlipped = _.isUpVectorFlipped), this.updateUp(), B
                    }
                    getViewFrontToObject(_) {
                        let O = _.getWorldPosition(new rv),
                            B = _.getWorldDirection(new rv).multiplyScalar(this.targetOffset);
                        return {
                            position: O.clone().add(B),
                            target: O
                        }
                    }
                    getViewToTarget(_) {
                        let O = this.getWorldDirection(new rv).multiplyScalar(this.targetOffset);
                        return {
                            position: _.clone().sub(O),
                            target: _
                        }
                    }
                    getViewToObject(_) {
                        let O = new rv;
                        return _.getWorldPosition(O), this.getViewToTarget(O)
                    }
                    setViewplaneSize(_, O, B = !1) {
                        if (this.aspect = _ / O, B) {
                            let B = _ > O ? this.aspect : 1,
                                N = _ > O ? 1 : this.aspect;
                            this.left = -395 * B, this.right = 395 * B, this.top = 395 * (1 / N), this.bottom = -395 * (1 / N)
                        } else this.left = -(.5 * _), this.right = .5 * _, this.top = .5 * O, this.bottom = -(.5 * O);
                        this.updateProjectionMatrix()
                    }
                    copyViewPlaneSize(_) {
                        this.aspect = _.aspect, this.left = _.left, this.right = _.right, this.top = _.top, this.bottom = _.bottom, this.updateProjectionMatrix()
                    }
                    toOrthographic() {
                        this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", this.objectHelper && this.objectHelper.update()
                    }
                    toPerspective() {
                        this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", this.objectHelper && this.objectHelper.update()
                    }
                    setFocalLength(_) {
                        this.perspCamera.setFocalLength(_), this.toPerspective()
                    }
                    getFocalLength() {
                        return this.perspCamera.getFocalLength()
                    }
                    getEffectiveFOV() {
                        return this.perspCamera.getEffectiveFOV()
                    }
                    getFilmWidth() {
                        return this.perspCamera.getFilmWidth()
                    }
                    getFilmHeight() {
                        return this.perspCamera.getFilmHeight()
                    }
                    setViewOffset(_, O, B, N, k, F) {
                        "PerspectiveCamera" === this._cameraType ? this.perspCamera.setViewOffset(_, O, B, N, k, F) : this.orthoCamera.setViewOffset(_, O, B, N, k, F)
                    }
                    clearViewOffset() {
                        "PerspectiveCamera" === this._cameraType ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic())
                    }
                    copyHistory() {
                        this.previousProjectionMatrix && this.previousProjectionMatrix.copy(this.projectionMatrix)
                    }
                    updateProjectionMatrix() {
                        "PerspectiveCamera" === this._cameraType ? this.toPerspective() : "OrthographicCamera" === this._cameraType && this.toOrthographic()
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(_, O) {
                        super.updateWorldMatrix(_, O), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    copy(_, O) {
                        return super.copy(_, O), this.parent = _.parent, this.orthoCamera.copy(_.orthoCamera), this.perspCamera.copy(_.perspCamera), this.left = _.left, this.right = _.right, this.top = _.top, this.bottom = _.bottom, this.far = _.far, this.view = null === _.view ? null : Object.assign({}, _.view), this._cameraType = _._cameraType, this.aspect = _.aspect, this.fov = _.fov, this.focus = _.focus, this.filmGauge = _.filmGauge, this.filmOffset = _.filmOffset, this.targetOffset = _.targetOffset, this.updateProjectionMatrix(), this
                    }
                    toCameraState(_ = []) {
                        return dN({
                            type: this.cameraType,
                            far: this.far,
                            orthographic: {
                                near: this.orthoCamera.near,
                                zoom: this.orthoCamera.zoom
                            },
                            perspective: {
                                near: this.perspCamera.near,
                                fov: this.perspCamera.fov,
                                zoom: this.perspCamera.zoom
                            },
                            up: this.up.toArray(),
                            targetOffset: this.targetOffset,
                            isUpVectorFlipped: this.isUpVectorFlipped
                        }, _)
                    }
                    updateCameraSubtype(_, O) {
                        let B = "perspective" === _ ? "PerspectiveCamera" : "OrthographicCamera";
                        void 0 !== O.zoom && this.setZoom(B, O.zoom), void 0 !== O.near && this.setNear(B, O.near), void 0 !== O.fov && "PerspectiveCamera" === B && (this.fov = O.fov)
                    }
                    updateState(_, O) {
                        this.updateCameraState(_, O)
                    }
                    updateCameraState(_, O) {
                        this.updateState_Entity(_, O), void 0 !== _.far && (this.far = _.far), void 0 !== _.orthographic && this.updateCameraSubtype("orthographic", _.orthographic), void 0 !== _.perspective && this.updateCameraSubtype("perspective", _.perspective), void 0 !== _.type && (this.cameraType = _.type), void 0 !== _.up && this.up.fromArray(_.up), void 0 !== _.targetOffset && (this.targetOffset = _.targetOffset), void 0 !== _.isUpVectorFlipped && (this.isUpVectorFlipped = _.isUpVectorFlipped), this.updateProjectionMatrix()
                    }
                    updateByPatchedOp(_, O, B) {
                        super.updateByPatchedOp(_, O, B), 1 === _.path.length && 0 === _.type && this.updateCameraSubtype(_.path[0], _.props)
                    }
                    toState(_) {
                        return { ...super.toState(_),
                            ...this.toCameraState(_),
                            type: this.cameraType
                        }
                    }
                },
                Sc = new rJ,
                Sd = new rJ,
                Su = new rJ,
                Sf = new rv,
                Sm = new rv;

            function KA(_) {
                let O = !1;
                return _.scene.objects.traverse((_, B) => {
                    B.geometry ? .type === "BooleanGeometry" && (O = !0)
                }), O
            }
            var Sg = class extends _l {
                constructor(_, O, B) {
                    super(_, O), this.data = O, this.meshSetAddresses = [], this.needsTransformForDownstream = !1, this.geometry = new sK, this.onAfterRender = (_, O, B, N, k, F) => {
                        super.onAfterRender(_, O, B, N, k, F), this.recomputeBoolean()
                    }, this.geometry.userData.parameters = {
                        width: 0,
                        height: 0,
                        depth: 0
                    }
                }
                get booleanOp() {
                    return this.data.geometry.operation
                }
                get phongAngle() {
                    return this.data.geometry.phongAngle ? ? 45
                }
                get isLOD() {
                    return this.recomputeBoolean(), !1
                }
                updateByPatchedOp(_, O, B) {
                    super.updateByPatchedOp(_, O, B), 1 === _.path.length && "geometry" === _.path[0] && 0 === _.type && void 0 !== _.props.operation && (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate())
                }
                freeBooleanPointer() {
                    super.freeBooleanPointer(), this.geometry.dispose()
                }
                recomputeBoolean(_, O = !0) {
                    if (-1 !== this.booleanMeshSetAddress && !_) return;
                    for (let B = 0; B < this.children.length; B++) {
                        let N = this.children[B];
                        N instanceof Sg && !0 === N.dataPatched.visible && N.recomputeBoolean(!0 === _, O)
                    }
                    this.meshSetAddresses = [];
                    for (let B = 0; B < this.children.length; B++) {
                        let N = this.children[B];
                        if (N instanceof xK && !0 === N.dataPatched.visible && N.geometry.attributes.position ? .count > 0 && N.geometry.drawRange.count > 0 && 0 !== N.booleanMeshSetAddress) {
                            Sc.multiplyMatrices(N.hiddenMatrix, N.matrix);
                            try {
                                if (-1 === N.booleanMeshSetAddress) {
                                    if ((N.geometry.index ? ? N.geometry.getAttribute("position")).count / 3 < 15e5 && (N.booleanMeshSetAddress = xH.getMeshSet(N.geometry, !0 === _, O)), -1 === N.booleanMeshSetAddress) return;
                                    xH.transformMeshSet(N.booleanMeshSetAddress, Sc), N.booleanMatrixInvOld.copy(Sc).invert(), N.booleanWasTransformed = !1
                                } else N instanceof Sg && !0 === N.needsTransformForDownstream ? (xH.transformMeshSet(N.booleanMeshSetAddress, Sc), N.needsTransformForDownstream = !1) : !0 === N.booleanWasTransformed && (xH.transformMeshSet(N.booleanMeshSetAddress, Sd.multiplyMatrices(Sc, N.booleanMatrixInvOld)), N.booleanMatrixInvOld.copy(Sc).invert(), N.booleanWasTransformed = !1)
                            } catch (_) {
                                console.error(_), N.booleanMeshSetAddress = 0, N.geometry.userData.booleanOperationDidFail = !0;
                                continue
                            }!1 === xH.hasOpenEdges(N.booleanMeshSetAddress) || B === this.children.length - 1 && 2 === this.booleanOp ? (this.meshSetAddresses.push(N.booleanMeshSetAddress), N.geometry.userData.booleanOperationDidFail = !1) : N.geometry.userData.booleanOperationDidFail = "openEdges"
                        }
                    }
                    if (0 === this.meshSetAddresses.length) {
                        this.geometry.setAttribute("position", new sG([], 0)), this.geometry.setDrawRange(0, 0);
                        return
                    }
                    if (!0 === _) return xH.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
                    let B = this.geometry;
                    B.dispose(), this.geometry = new sK, this.geometry.userData = B.userData, this.geometry.boundingSphere = B.boundingSphere;
                    try {
                        this.booleanMeshSetAddress = xH.calcBoolean(this.meshSetAddresses, this.booleanOp, this.geometry, this.phongAngle)
                    } catch (_) {
                        this.booleanMeshSetAddress = 0, this.geometry.userData.booleanOperationDidFail = !0, console.error(_)
                    }
                    this.booleanMatrixInvOld.copy(this.matrix).invert(), this.needsTransformForDownstream = !0, Td(this), Cd(this)
                }
                dispose() {
                    super.dispose(), this.geometry.dispose()
                }
                get recursiveBBox() {
                    let _ = super.recursiveBBox;
                    return this.geometry.boundingSphere ? .radius === -1 && (_.getCenter(this.geometry.boundingSphere.center), Su.copy(this.matrixWorld).invert(), this.geometry.boundingSphere.center.applyMatrix4(Su), Sf.copy(_.max).applyMatrix4(Su), Sm.copy(_.min).applyMatrix4(Su), this.geometry.boundingSphere.radius = Sf.distanceTo(Sm) / 2), _
                }
            };
            (Ey || (Ey = {})).is = function(_) {
                return xu.is(_) && _ instanceof oZ
            };
            var Ld = (_, O) => class extends yo(_, O) {
                    updateState_Light(_, O) {
                        this.updateState_Entity(_, O), void 0 !== _.color && (this.color = O.shared.color(_.color)), void 0 !== _.intensity && (this.intensity = _.intensity), void 0 !== _.depth && (this.shadow.camera.far = _.depth, this.shadow.needsUpdate = !0), void 0 !== _.shadows && (this.castShadow = _.shadows)
                    }
                },
                Yn = _ => _ instanceof xK,
                Xn = _ => null !== _ && _ instanceof Sg,
                tO = _ => _ instanceof Sh,
                rO = _ => Ey.is(_),
                Jp = _ => Eg.is(_),
                Sv = class extends mo(lW) {
                    constructor(_, O = 15) {
                        super(O), this.object = _, this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${_.uuid}`, this.matrix = _.matrixWorld, this.matrixAutoUpdate = !1, this.object.isBone && (this.visible = !1)
                    }
                    raycast(_, O) {
                        go(this.object, Sv.geometryHelper, _, O)
                    }
                    update() {}
                },
                Sy = class extends yo(nv, Sv) {
                    constructor(_, O) {
                        super(), this.super_Entity(_, O), this.objectHelper.update()
                    }
                    updateState(_, O) {
                        this.updateState_Entity(_, O), "buffer" in _ && 1 === Object.keys(_).length && O.scene.reloadSplats()
                    }
                },
                Sx = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
                Sb = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,
                Sw = class extends an {
                    constructor(_ = !1, O = !1) {
                        super({
                            name: "BokehMaterial",
                            defines: {
                                PASS: _ ? "2" : "1"
                            },
                            uniforms: {
                                kernel64: new l_(null),
                                kernel16: new l_(null),
                                inputBuffer: new l_(null),
                                cocBuffer: new l_(null),
                                texelSize: new l_(new iJ),
                                scale: new l_(1)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: Sb,
                            vertexShader: Sx
                        }), this.toneMapped = !1, O && (this.defines.FOREGROUND = "1"), this.generateKernel()
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    set cocBuffer(_) {
                        this.uniforms.cocBuffer.value = _
                    }
                    setCoCBuffer(_) {
                        this.uniforms.cocBuffer.value = _
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(_) {
                        this.uniforms.scale.value = _
                    }
                    getScale(_) {
                        return this.uniforms.scale.value = _
                    }
                    setScale(_) {
                        this.uniforms.scale.value = _
                    }
                    generateKernel() {
                        let _ = new Float32Array(128),
                            O = new Float32Array(32),
                            B = 0,
                            N = 0;
                        for (let k = 0; k < 80; ++k) {
                            let F = 2.39996323 * k,
                                U = Math.sqrt(k) / Math.sqrt(80),
                                j = U * Math.cos(F),
                                G = U * Math.sin(F);
                            k % 5 == 0 ? (O[N++] = j, O[N++] = G) : (_[B++] = j, _[B++] = G)
                        }
                        let k = [],
                            F = [];
                        for (let O = 0; O < 128;) k.push(new rl(_[O++], _[O++], _[O++], _[O++]));
                        for (let _ = 0; _ < 32;) F.push(new rl(O[_++], O[_++], O[_++], O[_++]));
                        this.uniforms.kernel64.value = k, this.uniforms.kernel16.value = F
                    }
                    setTexelSize(_, O) {
                        this.uniforms.texelSize.value.set(_, O)
                    }
                    setSize(_, O) {
                        this.uniforms.texelSize.value.set(1 / _, 1 / O)
                    }
                };

            function t1(_, O, B) {
                return Math.min(Math.max((_ + O) / (O - B), 0), 1)
            }
            var S_ = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,
                SS = class extends an {
                    constructor(_) {
                        super({
                            name: "CircleOfConfusionMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new l_(null),
                                focusDistance: new l_(0),
                                focusRange: new l_(0),
                                cameraNear: new l_(.3),
                                cameraFar: new l_(1e3)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: S_,
                            vertexShader: Sx
                        }), this.toneMapped = !1, this.uniforms.focalLength = this.uniforms.focusRange, this.adoptCameraSettings(_)
                    }
                    get near() {
                        return this.uniforms.cameraNear.value
                    }
                    get far() {
                        return this.uniforms.cameraFar.value
                    }
                    set depthBuffer(_) {
                        this.uniforms.depthBuffer.value = _
                    }
                    set depthPacking(_) {
                        this.defines.DEPTH_PACKING = _.toFixed(0), this.needsUpdate = !0
                    }
                    setDepthBuffer(_, O = 3200) {
                        this.depthBuffer = _, this.depthPacking = O
                    }
                    get focusDistance() {
                        return this.uniforms.focusDistance.value
                    }
                    set focusDistance(_) {
                        this.uniforms.focusDistance.value = _
                    }
                    get worldFocusDistance() {
                        var _;
                        return -(this.focusDistance * ((_ = this.near) - this.far) - _)
                    }
                    set worldFocusDistance(_) {
                        this.focusDistance = t1(-_, this.near, this.far)
                    }
                    getFocusDistance(_) {
                        this.uniforms.focusDistance.value = _
                    }
                    setFocusDistance(_) {
                        this.uniforms.focusDistance.value = _
                    }
                    get focalLength() {
                        return this.focusRange
                    }
                    set focalLength(_) {
                        this.focusRange = _
                    }
                    get focusRange() {
                        return this.uniforms.focusRange.value
                    }
                    set focusRange(_) {
                        this.uniforms.focusRange.value = _
                    }
                    get worldFocusRange() {
                        var _;
                        return -(this.focusRange * ((_ = this.near) - this.far) - _)
                    }
                    set worldFocusRange(_) {
                        this.focusRange = t1(-_, this.near, this.far)
                    }
                    getFocalLength(_) {
                        return this.focusRange
                    }
                    setFocalLength(_) {
                        this.focusRange = _
                    }
                    adoptCameraSettings(_) {
                        _ && (this.uniforms.cameraNear.value = _.near, this.uniforms.cameraFar.value = _.far, _ instanceof al ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                    }
                },
                SA = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`,
                SC = class extends an {
                    constructor(_ = new iJ) {
                        super({
                            name: "KawaseBlurMaterial",
                            uniforms: {
                                inputBuffer: new l_(null),
                                texelSize: new l_(new iJ),
                                halfTexelSize: new l_(new iJ),
                                kernel: new l_(0),
                                scale: new l_(1)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: SA,
                            vertexShader: "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                        }), this.toneMapped = !1, this.setTexelSize(_.x, _.y)
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.inputBuffer = _
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(_) {
                        this.uniforms.scale.value = _
                    }
                    getScale() {
                        return this.uniforms.scale.value
                    }
                    setScale(_) {
                        this.uniforms.scale.value = _
                    }
                    getKernel() {
                        return null
                    }
                    get kernel() {
                        return this.uniforms.kernel.value
                    }
                    set kernel(_) {
                        this.uniforms.kernel.value = _
                    }
                    setKernel(_) {
                        this.kernel = _
                    }
                    setTexelSize(_, O) {
                        this.uniforms.texelSize.value.set(_, O), this.uniforms.halfTexelSize.value.set(_, O).multiplyScalar(.5)
                    }
                    setSize(_, O) {
                        let B = this.uniforms;
                        B.texelSize.value.set(1 / _, 1 / O), B.halfTexelSize.value.copy(B.texelSize.value).multiplyScalar(.5)
                    }
                },
                ST = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`,
                SD = class extends an {
                    constructor() {
                        super({
                            name: "CopyMaterial",
                            uniforms: {
                                inputBuffer: new l_(null),
                                opacity: new l_(1)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: ST,
                            vertexShader: Sx
                        }), this.toneMapped = !1
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    getOpacity(_) {
                        return this.uniforms.opacity.value
                    }
                    setOpacity(_) {
                        this.uniforms.opacity.value = _
                    }
                },
                SP = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,
                SI = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`,
                SO = {
                    COLOR: 2
                },
                SB = class extends an {
                    constructor(_ = new iJ, O = SO.COLOR) {
                        super({
                            name: "EdgeDetectionMaterial",
                            defines: {
                                THREE_REVISION: "149".replace(/\D+/g, ""),
                                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                                EDGE_THRESHOLD: "0.1",
                                DEPTH_THRESHOLD: "0.01",
                                PREDICATION_MODE: "0",
                                PREDICATION_THRESHOLD: "0.01",
                                PREDICATION_SCALE: "2.0",
                                PREDICATION_STRENGTH: "1.0",
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                inputBuffer: new l_(null),
                                depthBuffer: new l_(null),
                                predicationBuffer: new l_(null),
                                texelSize: new l_(_)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: SP,
                            vertexShader: SI
                        }), this.toneMapped = !1, this.edgeDetectionMode = O
                    }
                    set depthBuffer(_) {
                        this.uniforms.depthBuffer.value = _
                    }
                    set depthPacking(_) {
                        this.defines.DEPTH_PACKING = _.toFixed(0), this.needsUpdate = !0
                    }
                    setDepthBuffer(_, O = 3200) {
                        this.depthBuffer = _, this.depthPacking = O
                    }
                    get edgeDetectionMode() {
                        return Number(this.defines.EDGE_DETECTION_MODE)
                    }
                    set edgeDetectionMode(_) {
                        this.defines.EDGE_DETECTION_MODE = _.toFixed(0), this.needsUpdate = !0
                    }
                    getEdgeDetectionMode() {
                        return this.edgeDetectionMode
                    }
                    setEdgeDetectionMode(_) {
                        this.edgeDetectionMode = _
                    }
                    get localContrastAdaptationFactor() {
                        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
                    }
                    set localContrastAdaptationFactor(_) {
                        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = _.toFixed("6"), this.needsUpdate = !0
                    }
                    getLocalContrastAdaptationFactor() {
                        return this.localContrastAdaptationFactor
                    }
                    setLocalContrastAdaptationFactor(_) {
                        this.localContrastAdaptationFactor = _
                    }
                    get edgeDetectionThreshold() {
                        return Number(this.defines.EDGE_THRESHOLD)
                    }
                    set edgeDetectionThreshold(_) {
                        this.defines.EDGE_THRESHOLD = _.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * _).toFixed("6"), this.needsUpdate = !0
                    }
                    getEdgeDetectionThreshold() {
                        return this.edgeDetectionThreshold
                    }
                    setEdgeDetectionThreshold(_) {
                        this.edgeDetectionThreshold = _
                    }
                    get predicationMode() {
                        return Number(this.defines.PREDICATION_MODE)
                    }
                    set predicationMode(_) {
                        this.defines.PREDICATION_MODE = _.toFixed(0), this.needsUpdate = !0
                    }
                    getPredicationMode() {
                        return this.predicationMode
                    }
                    setPredicationMode(_) {
                        this.predicationMode = _
                    }
                    set predicationBuffer(_) {
                        this.uniforms.predicationBuffer.value = _
                    }
                    setPredicationBuffer(_) {
                        this.uniforms.predicationBuffer.value = _
                    }
                    get predicationThreshold() {
                        return Number(this.defines.PREDICATION_THRESHOLD)
                    }
                    set predicationThreshold(_) {
                        this.defines.PREDICATION_THRESHOLD = _.toFixed("6"), this.needsUpdate = !0
                    }
                    getPredicationThreshold() {
                        return this.predicationThreshold
                    }
                    setPredicationThreshold(_) {
                        this.predicationThreshold = _
                    }
                    get predicationScale() {
                        return Number(this.defines.PREDICATION_SCALE)
                    }
                    set predicationScale(_) {
                        this.defines.PREDICATION_SCALE = _.toFixed("6"), this.needsUpdate = !0
                    }
                    getPredicationScale() {
                        return this.predicationScale
                    }
                    setPredicationScale(_) {
                        this.predicationScale = _
                    }
                    get predicationStrength() {
                        return Number(this.defines.PREDICATION_STRENGTH)
                    }
                    set predicationStrength(_) {
                        this.defines.PREDICATION_STRENGTH = _.toFixed("6"), this.needsUpdate = !0
                    }
                    getPredicationStrength() {
                        return this.predicationStrength
                    }
                    setPredicationStrength(_) {
                        this.predicationStrength = _
                    }
                    setSize(_, O) {
                        this.uniforms.texelSize.value.set(1 / _, 1 / O)
                    }
                },
                Sz = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,
                SN = {
                    FRAGMENT_HEAD: "FRAGMENT_HEAD",
                    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                    VERTEX_HEAD: "VERTEX_HEAD",
                    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
                },
                Sk = class extends an {
                    constructor(_, O, B, N, k = !1) {
                        super({
                            name: "EffectMaterial",
                            defines: {
                                THREE_REVISION: "149".replace(/\D+/g, ""),
                                DEPTH_PACKING: "0",
                                ENCODE_OUTPUT: "1"
                            },
                            uniforms: {
                                inputBuffer: new l_(null),
                                depthBuffer: new l_(null),
                                resolution: new l_(new iJ),
                                texelSize: new l_(new iJ),
                                cameraNear: new l_(.3),
                                cameraFar: new l_(1e3),
                                aspect: new l_(1),
                                time: new l_(0)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            dithering: k
                        }), this.toneMapped = !1, _ && this.setShaderParts(_), O && this.setDefines(O), B && this.setUniforms(B), this.adoptCameraSettings(N)
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    get depthBuffer() {
                        return this.uniforms.depthBuffer.value
                    }
                    set depthBuffer(_) {
                        this.uniforms.depthBuffer.value = _
                    }
                    get depthPacking() {
                        return Number(this.defines.DEPTH_PACKING)
                    }
                    set depthPacking(_) {
                        this.defines.DEPTH_PACKING = _.toFixed(0), this.needsUpdate = !0
                    }
                    setDepthBuffer(_, O = 3200) {
                        this.depthBuffer = _, this.depthPacking = O
                    }
                    setShaderParts(_) {
                        return this.fragmentShader = Sz.replace(SN.FRAGMENT_HEAD, _.get(SN.FRAGMENT_HEAD)).replace(SN.FRAGMENT_MAIN_UV, _.get(SN.FRAGMENT_MAIN_UV)).replace(SN.FRAGMENT_MAIN_IMAGE, _.get(SN.FRAGMENT_MAIN_IMAGE)), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}".replace(SN.VERTEX_HEAD, _.get(SN.VERTEX_HEAD)).replace(SN.VERTEX_MAIN_SUPPORT, _.get(SN.VERTEX_MAIN_SUPPORT)), this.needsUpdate = !0, this
                    }
                    setDefines(_) {
                        for (let O of _.entries()) this.defines[O[0]] = O[1];
                        return this.needsUpdate = !0, this
                    }
                    setUniforms(_) {
                        for (let O of _.entries()) this.uniforms[O[0]] = O[1];
                        return this
                    }
                    setExtensions(_) {
                        for (let O of (this.extensions = {}, _)) this.extensions[O] = !0;
                        return this
                    }
                    get encodeOutput() {
                        return void 0 !== this.defines.ENCODE_OUTPUT
                    }
                    set encodeOutput(_) {
                        this.encodeOutput !== _ && (_ ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
                    }
                    isOutputEncodingEnabled(_) {
                        return this.encodeOutput
                    }
                    setOutputEncodingEnabled(_) {
                        this.encodeOutput = _
                    }
                    get time() {
                        return this.uniforms.time.value
                    }
                    set time(_) {
                        this.uniforms.time.value = _
                    }
                    setDeltaTime(_) {
                        this.uniforms.time.value += _
                    }
                    adoptCameraSettings(_) {
                        _ && (this.uniforms.cameraNear.value = _.near, this.uniforms.cameraFar.value = _.far, _ instanceof al ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                    }
                    setSize(_, O) {
                        let B = this.uniforms;
                        B.resolution.value.set(_, O), B.texelSize.value.set(1 / _, 1 / O), B.aspect.value = _ / O
                    }
                    static get Section() {
                        return SN
                    }
                },
                SF = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,
                SU = class extends an {
                    constructor(_ = !1, O = null) {
                        super({
                            name: "LuminanceMaterial",
                            defines: {
                                THREE_REVISION: "149".replace(/\D+/g, "")
                            },
                            uniforms: {
                                inputBuffer: new l_(null),
                                threshold: new l_(0),
                                smoothing: new l_(1),
                                range: new l_(null)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: SF,
                            vertexShader: Sx
                        }), this.toneMapped = !1, this.colorOutput = _, this.luminanceRange = O
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    get threshold() {
                        return this.uniforms.threshold.value
                    }
                    set threshold(_) {
                        this.smoothing > 0 || _ > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = _
                    }
                    getThreshold() {
                        return this.threshold
                    }
                    setThreshold(_) {
                        this.threshold = _
                    }
                    get smoothing() {
                        return this.uniforms.smoothing.value
                    }
                    set smoothing(_) {
                        this.threshold > 0 || _ > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = _
                    }
                    getSmoothingFactor() {
                        return this.smoothing
                    }
                    setSmoothingFactor(_) {
                        this.smoothing = _
                    }
                    get useThreshold() {
                        return this.threshold > 0 || this.smoothing > 0
                    }
                    set useThreshold(_) {}
                    get colorOutput() {
                        return void 0 !== this.defines.COLOR
                    }
                    set colorOutput(_) {
                        _ ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
                    }
                    isColorOutputEnabled(_) {
                        return this.colorOutput
                    }
                    setColorOutputEnabled(_) {
                        this.colorOutput = _
                    }
                    get useRange() {
                        return null !== this.luminanceRange
                    }
                    set useRange(_) {
                        this.luminanceRange = null
                    }
                    get luminanceRange() {
                        return this.uniforms.range.value
                    }
                    set luminanceRange(_) {
                        null !== _ ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = _, this.needsUpdate = !0
                    }
                    getLuminanceRange() {
                        return this.luminanceRange
                    }
                    setLuminanceRange(_) {
                        this.luminanceRange = _
                    }
                },
                Sj = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,
                SG = class extends an {
                    constructor(_ = null) {
                        super({
                            name: "MaskMaterial",
                            uniforms: {
                                maskTexture: new l_(_),
                                inputBuffer: new l_(null),
                                strength: new l_(1)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: Sj,
                            vertexShader: Sx
                        }), this.toneMapped = !1, this.setColorChannel(0), this.setMaskFunction(0)
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    set maskTexture(_) {
                        this.uniforms.maskTexture.value = _, delete this.defines.MASK_PRECISION_HIGH, 1009 !== _.type && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0
                    }
                    setMaskTexture(_) {
                        this.maskTexture = _
                    }
                    set colorChannel(_) {
                        this.defines.COLOR_CHANNEL = _.toFixed(0), this.needsUpdate = !0
                    }
                    setColorChannel(_) {
                        this.colorChannel = _
                    }
                    set maskFunction(_) {
                        this.defines.MASK_FUNCTION = _.toFixed(0), this.needsUpdate = !0
                    }
                    setMaskFunction(_) {
                        this.maskFunction = _
                    }
                    get inverted() {
                        return void 0 !== this.defines.INVERTED
                    }
                    set inverted(_) {
                        this.inverted && !_ ? delete this.defines.INVERTED : _ && (this.defines.INVERTED = "1"), this.needsUpdate = !0
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(_) {
                        this.inverted = _
                    }
                    get strength() {
                        return this.uniforms.strength.value
                    }
                    set strength(_) {
                        this.uniforms.strength.value = _
                    }
                    getStrength() {
                        return this.strength
                    }
                    setStrength(_) {
                        this.strength = _
                    }
                },
                SH = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,
                SW = class extends an {
                    constructor(_ = new iJ, O = new iJ) {
                        super({
                            name: "SMAAWeightsMaterial",
                            defines: {
                                MAX_SEARCH_STEPS_INT: "16",
                                MAX_SEARCH_STEPS_FLOAT: "16.0",
                                MAX_SEARCH_STEPS_DIAG_INT: "8",
                                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                                CORNER_ROUNDING: "25",
                                CORNER_ROUNDING_NORM: "0.25",
                                AREATEX_MAX_DISTANCE: "16.0",
                                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                            },
                            uniforms: {
                                inputBuffer: new l_(null),
                                searchTexture: new l_(null),
                                areaTexture: new l_(null),
                                resolution: new l_(O),
                                texelSize: new l_(_)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: SH,
                            vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                        }), this.toneMapped = !1
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    setInputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                    get searchTexture() {
                        return this.uniforms.searchTexture.value
                    }
                    set searchTexture(_) {
                        this.uniforms.searchTexture.value = _
                    }
                    get areaTexture() {
                        return this.uniforms.areaTexture.value
                    }
                    set areaTexture(_) {
                        this.uniforms.areaTexture.value = _
                    }
                    setLookupTextures(_, O) {
                        this.searchTexture = _, this.areaTexture = O
                    }
                    get orthogonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_INT)
                    }
                    set orthogonalSearchSteps(_) {
                        let O = Math.min(Math.max(_, 0), 112);
                        this.defines.MAX_SEARCH_STEPS_INT = O.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = O.toFixed("1"), this.needsUpdate = !0
                    }
                    setOrthogonalSearchSteps(_) {
                        this.orthogonalSearchSteps = _
                    }
                    get diagonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
                    }
                    set diagonalSearchSteps(_) {
                        let O = Math.min(Math.max(_, 0), 20);
                        this.defines.MAX_SEARCH_STEPS_DIAG_INT = O.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = O.toFixed("1"), this.needsUpdate = !0
                    }
                    setDiagonalSearchSteps(_) {
                        this.diagonalSearchSteps = _
                    }
                    get diagonalDetection() {
                        return void 0 === this.defines.DISABLE_DIAG_DETECTION
                    }
                    set diagonalDetection(_) {
                        _ ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0
                    }
                    isDiagonalDetectionEnabled() {
                        return this.diagonalDetection
                    }
                    setDiagonalDetectionEnabled(_) {
                        this.diagonalDetection = _
                    }
                    get cornerRounding() {
                        return Number(this.defines.CORNER_ROUNDING)
                    }
                    set cornerRounding(_) {
                        let O = Math.min(Math.max(_, 0), 100);
                        this.defines.CORNER_ROUNDING = O.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (O / 100).toFixed("4"), this.needsUpdate = !0
                    }
                    setCornerRounding(_) {
                        this.cornerRounding = _
                    }
                    get cornerDetection() {
                        return void 0 === this.defines.DISABLE_CORNER_DETECTION
                    }
                    set cornerDetection(_) {
                        _ ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0
                    }
                    isCornerRoundingEnabled() {
                        return this.cornerDetection
                    }
                    setCornerRoundingEnabled(_) {
                        this.cornerDetection = _
                    }
                    setSize(_, O) {
                        let B = this.uniforms;
                        B.texelSize.value.set(1 / _, 1 / O), B.resolution.value.set(_, O)
                    }
                },
                Sq = new ao,
                SY = null,
                SX = class {
                    constructor(_ = "Pass", O = new nS, B = Sq) {
                        this.name = _, this.renderer = null, this.scene = O, this.camera = B, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
                    }
                    get renderToScreen() {
                        return !this.rtt
                    }
                    set renderToScreen(_) {
                        if (this.rtt === _) {
                            let O = this.getFullscreenMaterial();
                            null !== O && (O.needsUpdate = !0), this.rtt = !_
                        }
                    }
                    setRenderer(_) {
                        this.renderer = _
                    }
                    isEnabled() {
                        return this.enabled
                    }
                    setEnabled(_) {
                        this.enabled = _
                    }
                    get fullscreenMaterial() {
                        return null !== this.screen ? this.screen.material : null
                    }
                    set fullscreenMaterial(_) {
                        let O = this.screen;
                        null !== O ? O.material = _ : ((O = new at(function() {
                            if (null === SY) {
                                let _ = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                                    O = new Float32Array([0, 0, 2, 0, 0, 2]);
                                void 0 !== (SY = new sK).setAttribute ? (SY.setAttribute("position", new sF(_, 3)), SY.setAttribute("uv", new sF(O, 2))) : (SY.addAttribute("position", new sF(_, 3)), SY.addAttribute("uv", new sF(O, 2)))
                            }
                            return SY
                        }(), _)).frustumCulled = !1, null === this.scene && (this.scene = new nS), this.scene.add(O), this.screen = O)
                    }
                    getFullscreenMaterial() {
                        return this.fullscreenMaterial
                    }
                    setFullscreenMaterial(_) {
                        this.fullscreenMaterial = _
                    }
                    getDepthTexture() {
                        return null
                    }
                    setDepthTexture(_, O = 3200) {}
                    render(_, O, B, N, k) {
                        throw Error("Render method not implemented!")
                    }
                    setSize(_, O) {}
                    initialize(_, O, B) {}
                    dispose() {
                        for (let _ of Object.keys(this)) {
                            let O = this[_];
                            if (null !== O && "function" == typeof O.dispose) {
                                if (O instanceof nS || O === this.renderer) continue;
                                this[_].dispose()
                            }
                        }
                    }
                },
                SQ = class extends SX {
                    constructor(_, O = !0) {
                        super("CopyPass"), this.fullscreenMaterial = new SD, this.needsSwap = !1, this.renderTarget = _, void 0 === _ && (this.renderTarget = new rh(1, 1, {
                            minFilter: 1006,
                            magFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = O
                    }
                    get resize() {
                        return this.autoResize
                    }
                    set resize(_) {
                        this.autoResize = _
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    setAutoResizeEnabled(_) {
                        this.autoResize = _
                    }
                    render(_, O, B, N, k) {
                        this.fullscreenMaterial.inputBuffer = O.texture, _.setRenderTarget(this.renderToScreen ? null : this.renderTarget), _.render(this.scene, this.camera)
                    }
                    setSize(_, O) {
                        this.autoResize && this.renderTarget.setSize(_, O)
                    }
                    initialize(_, O, B) {
                        void 0 !== B && (this.renderTarget.texture.type = B, 1009 !== B ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : 3001 === _.outputEncoding && (this.renderTarget.texture.encoding = 3001))
                    }
                },
                SZ = class extends SX {
                    constructor() {
                        super("ClearMaskPass", null, null), this.needsSwap = !1
                    }
                    render(_, O, B, N, k) {
                        let F = _.state.buffers.stencil;
                        F.setLocked(!1), F.setTest(!1)
                    }
                },
                SK = new re,
                SJ = class extends SX {
                    constructor(_ = !0, O = !0, B = !1) {
                        super("ClearPass", null, null), this.needsSwap = !1, this.color = _, this.depth = O, this.stencil = B, this.overrideClearColor = null, this.overrideClearAlpha = -1
                    }
                    setClearFlags(_, O, B) {
                        this.color = _, this.depth = O, this.stencil = B
                    }
                    getOverrideClearColor() {
                        return this.overrideClearColor
                    }
                    setOverrideClearColor(_) {
                        this.overrideClearColor = _
                    }
                    getOverrideClearAlpha() {
                        return this.overrideClearAlpha
                    }
                    setOverrideClearAlpha(_) {
                        this.overrideClearAlpha = _
                    }
                    render(_, O, B, N, k) {
                        let F = this.overrideClearColor,
                            U = this.overrideClearAlpha,
                            j = _.getClearAlpha(),
                            G = null !== F,
                            Y = U >= 0;
                        G ? (SK.copy(_.getClearColor(SK)), _.setClearColor(F, Y ? U : j)) : Y && _.setClearAlpha(U), _.setRenderTarget(this.renderToScreen ? null : O), _.clear(this.color, this.depth, this.stencil), G ? _.setClearColor(SK, j) : Y && _.setClearAlpha(j)
                    }
                },
                S$ = class extends iq {
                    constructor(_, O = -1, B = -1, N = 1) {
                        super(), this.resizable = _, this.base = new iJ(1, 1), this.preferred = new iJ(O, B), this.target = this.preferred, this.s = N
                    }
                    get width() {
                        let {
                            base: _,
                            preferred: O,
                            scale: B
                        } = this;
                        return -1 !== O.width ? O.width : -1 !== O.height ? Math.round(O.height * (_.width / Math.max(_.height, 1))) : Math.round(_.width * B)
                    }
                    set width(_) {
                        this.preferredWidth = _
                    }
                    get height() {
                        let {
                            base: _,
                            preferred: O,
                            scale: B
                        } = this;
                        return -1 !== O.height ? O.height : -1 !== O.width ? Math.round(O.width / Math.max(_.width / Math.max(_.height, 1), 1)) : Math.round(_.height * B)
                    }
                    set height(_) {
                        this.preferredHeight = _
                    }
                    getWidth() {
                        return this.width
                    }
                    getHeight() {
                        return this.height
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(_) {
                        this.s !== _ && (this.s = _, this.preferred.setScalar(-1), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(_) {
                        this.scale = _
                    }
                    get baseWidth() {
                        return this.base.width
                    }
                    set baseWidth(_) {
                        this.base.width !== _ && (this.base.width = _, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    getBaseWidth() {
                        return this.base.width
                    }
                    setBaseWidth(_) {
                        this.base.width !== _ && (this.base.width = _, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    get baseHeight() {
                        return this.base.height
                    }
                    set baseHeight(_) {
                        this.base.height !== _ && (this.base.height = _, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    getBaseHeight() {
                        return this.baseHeight
                    }
                    setBaseHeight(_) {
                        this.baseHeight = _
                    }
                    setBaseSize(_, O) {
                        (this.base.width !== _ || this.base.height !== O) && (this.base.set(_, O), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    get preferredWidth() {
                        return this.preferred.width
                    }
                    set preferredWidth(_) {
                        this.preferred.width !== _ && (this.preferred.width = _, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    getPreferredWidth() {
                        return this.preferredWidth
                    }
                    setPreferredWidth(_) {
                        this.preferredWidth = _
                    }
                    get preferredHeight() {
                        return this.preferred.height
                    }
                    set preferredHeight(_) {
                        this.preferred.height !== _ && (this.preferred.height = _, this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    getPreferredHeight() {
                        return this.preferredHeight
                    }
                    setPreferredHeight(_) {
                        this.preferredHeight = _
                    }
                    setPreferredSize(_, O) {
                        (this.preferred.width !== _ || this.preferred.height !== O) && (this.preferred.set(_, O), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height))
                    }
                    copy(_) {
                        this.base.set(_.getBaseWidth(), _.getBaseHeight()), this.preferred.set(_.getPreferredWidth(), _.getPreferredHeight()), this.dispatchEvent({
                            type: "change"
                        }), this.resizable.setSize(this.base.width, this.base.height)
                    }
                    static get AUTO_SIZE() {
                        return -1
                    }
                },
                S0 = !1,
                S1 = class {
                    constructor(_ = null) {
                        this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(_), this.meshCount = 0, this.replaceMaterial = _ => {
                            if (_.isMesh) {
                                let O;
                                if (_.material.flatShading) switch (_.material.side) {
                                    case 2:
                                        O = this.materialsFlatShadedDoubleSide;
                                        break;
                                    case 1:
                                        O = this.materialsFlatShadedBackSide;
                                        break;
                                    default:
                                        O = this.materialsFlatShaded
                                } else switch (_.material.side) {
                                    case 2:
                                        O = this.materialsDoubleSide;
                                        break;
                                    case 1:
                                        O = this.materialsBackSide;
                                        break;
                                    default:
                                        O = this.materials
                                }
                                this.originalMaterials.set(_, _.material), _.isSkinnedMesh ? _.material = O[2] : _.isInstancedMesh ? _.material = O[1] : _.material = O[0], ++this.meshCount
                            }
                        }
                    }
                    setMaterial(_) {
                        if (this.disposeMaterials(), this.material = _, null !== _) {
                            let O = this.materials = [_.clone(), _.clone(), _.clone()];
                            for (let B of O) B.uniforms = Object.assign({}, _.uniforms), B.side = 0;
                            O[2].skinning = !0, this.materialsBackSide = O.map(O => {
                                let B = O.clone();
                                return B.uniforms = Object.assign({}, _.uniforms), B.side = 1, B
                            }), this.materialsDoubleSide = O.map(O => {
                                let B = O.clone();
                                return B.uniforms = Object.assign({}, _.uniforms), B.side = 2, B
                            }), this.materialsFlatShaded = O.map(O => {
                                let B = O.clone();
                                return B.uniforms = Object.assign({}, _.uniforms), B.flatShading = !0, B
                            }), this.materialsFlatShadedBackSide = O.map(O => {
                                let B = O.clone();
                                return B.uniforms = Object.assign({}, _.uniforms), B.flatShading = !0, B.side = 1, B
                            }), this.materialsFlatShadedDoubleSide = O.map(O => {
                                let B = O.clone();
                                return B.uniforms = Object.assign({}, _.uniforms), B.flatShading = !0, B.side = 2, B
                            })
                        }
                    }
                    render(_, O, B) {
                        let N = _.shadowMap.enabled;
                        if (_.shadowMap.enabled = !1, S0) {
                            let N = this.originalMaterials;
                            for (let k of (this.meshCount = 0, O.traverse(this.replaceMaterial), _.render(O, B), N)) k[0].material = k[1];
                            this.meshCount !== N.size && N.clear()
                        } else {
                            let N = O.overrideMaterial;
                            O.overrideMaterial = this.material, _.render(O, B), O.overrideMaterial = N
                        }
                        _.shadowMap.enabled = N
                    }
                    disposeMaterials() {
                        if (null !== this.material)
                            for (let _ of this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide)) _.dispose()
                    }
                    dispose() {
                        this.originalMaterials.clear(), this.disposeMaterials()
                    }
                    static get workaroundEnabled() {
                        return S0
                    }
                    static set workaroundEnabled(_) {
                        S0 = _
                    }
                },
                S2 = class extends SX {
                    constructor(_, O, B = null) {
                        super("RenderPass", _, O), this.needsSwap = !1, this.clearPass = new SJ, this.overrideMaterialManager = null === B ? null : new S1(B), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
                    }
                    get renderToScreen() {
                        return super.renderToScreen
                    }
                    set renderToScreen(_) {
                        super.renderToScreen = _, this.clearPass.renderToScreen = _
                    }
                    get overrideMaterial() {
                        let _ = this.overrideMaterialManager;
                        return null !== _ ? _.material : null
                    }
                    set overrideMaterial(_) {
                        let O = this.overrideMaterialManager;
                        null !== _ ? null !== O ? O.setMaterial(_) : this.overrideMaterialManager = new S1(_) : null !== O && (O.dispose(), this.overrideMaterialManager = null)
                    }
                    getOverrideMaterial() {
                        return this.overrideMaterial
                    }
                    setOverrideMaterial(_) {
                        this.overrideMaterial = _
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(_) {
                        this.clearPass.enabled = _
                    }
                    getSelection() {
                        return this.selection
                    }
                    setSelection(_) {
                        this.selection = _
                    }
                    isBackgroundDisabled() {
                        return this.ignoreBackground
                    }
                    setBackgroundDisabled(_) {
                        this.ignoreBackground = _
                    }
                    isShadowMapDisabled() {
                        return this.skipShadowMapUpdate
                    }
                    setShadowMapDisabled(_) {
                        this.skipShadowMapUpdate = _
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    render(_, O, B, N, k) {
                        let F = this.scene,
                            U = this.camera,
                            j = this.selection,
                            G = U.layers.mask,
                            Y = F.background,
                            Q = _.shadowMap.autoUpdate,
                            K = this.renderToScreen ? null : O;
                        null !== j && U.layers.set(j.getLayer()), this.skipShadowMapUpdate && (_.shadowMap.autoUpdate = !1), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (F.background = null), this.clearPass.enabled && this.clearPass.render(_, O), _.setRenderTarget(K), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(_, F, U) : _.render(F, U), U.layers.mask = G, F.background = Y, _.shadowMap.autoUpdate = Q
                    }
                },
                S3 = class extends SX {
                    constructor(_, O, {
                        resolutionScale: B = 1,
                        width: N = S$.AUTO_SIZE,
                        height: k = S$.AUTO_SIZE,
                        renderTarget: F
                    } = {}) {
                        super("DepthPass"), this.needsSwap = !1, this.renderPass = new S2(_, O, new no({
                            depthPacking: 3201
                        }));
                        let U = this.renderPass;
                        U.skipShadowMapUpdate = !0, U.ignoreBackground = !0;
                        let j = U.getClearPass();
                        j.overrideClearColor = new re(16777215), j.overrideClearAlpha = 1, this.renderTarget = F, void 0 === this.renderTarget && (this.renderTarget = new rh(1, 1, {
                            minFilter: 1003,
                            magFilter: 1003,
                            stencilBuffer: !1
                        }), this.renderTarget.texture.name = "DepthPass.Target");
                        let G = this.resolution = new S$(this, N, k, B);
                        G.addEventListener("change", _ => this.setSize(G.baseWidth, G.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(_) {
                        this.resolution.scale = _
                    }
                    render(_, O, B, N, k) {
                        let F = this.renderToScreen ? null : this.renderTarget;
                        this.renderPass.render(_, F)
                    }
                    setSize(_, O) {
                        let B = this.resolution;
                        B.setBaseSize(_, O), this.renderTarget.setSize(B.width, B.height)
                    }
                };
            new Float32Array([255 / 256 / 16777216, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]);
            var S4 = {
                    SKIP: 0,
                    ADD: 1,
                    ALPHA: 2,
                    AVERAGE: 3,
                    COLOR_BURN: 4,
                    COLOR_DODGE: 5,
                    DARKEN: 6,
                    DIFFERENCE: 7,
                    EXCLUSION: 8,
                    LIGHTEN: 9,
                    MULTIPLY: 10,
                    DIVIDE: 11,
                    NEGATION: 12,
                    NORMAL: 13,
                    OVERLAY: 14,
                    REFLECT: 15,
                    SCREEN: 16,
                    SOFT_LIGHT: 17,
                    SUBTRACT: 18
                },
                S5 = new Map([
                    [S4.SKIP, null],
                    [S4.ADD, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}"],
                    [S4.ALPHA, "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}"],
                    [S4.AVERAGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}"],
                    [S4.COLOR_BURN, "float blend(const in float x,const in float y){return(y==0.0)?y:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
                    [S4.COLOR_DODGE, "float blend(const in float x,const in float y){return(y==1.0)?y:min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
                    [S4.DARKEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}"],
                    [S4.DIFFERENCE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}"],
                    [S4.EXCLUSION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}"],
                    [S4.LIGHTEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}"],
                    [S4.MULTIPLY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}"],
                    [S4.DIVIDE, "float blend(const in float x,const in float y){return(y>0.0)?min(x/y,1.0):1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
                    [S4.NEGATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}"],
                    [S4.NORMAL, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}"],
                    [S4.OVERLAY, "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
                    [S4.REFLECT, "float blend(const in float x,const in float y){return(y==1.0)?y:min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
                    [S4.SCREEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}"],
                    [S4.SOFT_LIGHT, "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
                    [S4.SUBTRACT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}"]
                ]),
                S6 = class extends iq {
                    constructor(_, O = 1) {
                        super(), this.f = _, this.opacity = new l_(O)
                    }
                    getOpacity() {
                        return this.opacity.value
                    }
                    setOpacity(_) {
                        this.opacity.value = _
                    }
                    get blendFunction() {
                        return this.f
                    }
                    set blendFunction(_) {
                        this.f = _, this.dispatchEvent({
                            type: "change"
                        })
                    }
                    getBlendFunction() {
                        return this.blendFunction
                    }
                    setBlendFunction(_) {
                        this.blendFunction = _
                    }
                    getShaderCode() {
                        return S5.get(this.blendFunction)
                    }
                },
                S8 = {
                    NONE: 0,
                    DEPTH: 1,
                    CONVOLUTION: 2
                },
                S9 = class extends iq {
                    constructor(_, O, {
                        attributes: B = S8.NONE,
                        blendFunction: N = S4.SCREEN,
                        defines: k = new Map,
                        uniforms: F = new Map,
                        extensions: U = null,
                        vertexShader: j = null
                    } = {}) {
                        super(), this.name = _, this.renderer = null, this.attributes = B, this.fragmentShader = O, this.vertexShader = j, this.defines = k, this.uniforms = F, this.extensions = U, this.blendMode = new S6(N), this.blendMode.addEventListener("change", _ => this.setChanged())
                    }
                    getName() {
                        return this.name
                    }
                    setRenderer(_) {
                        this.renderer = _
                    }
                    getDefines() {
                        return this.defines
                    }
                    getUniforms() {
                        return this.uniforms
                    }
                    getExtensions() {
                        return this.extensions
                    }
                    getBlendMode() {
                        return this.blendMode
                    }
                    getAttributes() {
                        return this.attributes
                    }
                    setAttributes(_) {
                        this.attributes = _, this.setChanged()
                    }
                    getFragmentShader() {
                        return this.fragmentShader
                    }
                    setFragmentShader(_) {
                        this.fragmentShader = _, this.setChanged()
                    }
                    getVertexShader() {
                        return this.vertexShader
                    }
                    setVertexShader(_) {
                        this.vertexShader = _, this.setChanged()
                    }
                    setChanged() {
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    setDepthTexture(_, O = 3200) {}
                    update(_, O, B) {}
                    setSize(_, O) {}
                    initialize(_, O, B) {}
                    dispose() {
                        for (let _ of Object.keys(this)) {
                            let O = this[_];
                            if (null !== O && "function" == typeof O.dispose) {
                                if (O instanceof nS || O === this.renderer) continue;
                                this[_].dispose()
                            }
                        }
                    }
                };

            function oO(_, O, B) {
                for (let N of O) {
                    let O = "$1" + _ + N.charAt(0).toUpperCase() + N.slice(1),
                        k = RegExp("([^\\.])(\\b" + N + "\\b)", "g");
                    for (let _ of B.entries()) null !== _[1] && B.set(_[0], _[1].replace(k, O))
                }
            }
            var Ae = class extends SX {
                    constructor(_, ...O) {
                        super("EffectPass"), this.fullscreenMaterial = new Sk(null, null, null, _), this.effects = O.sort((_, O) => O.attributes - _.attributes), this.skipRendering = !1, this.uniformCount = 0, this.varyingCount = 0, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY
                    }
                    get encodeOutput() {
                        return this.fullscreenMaterial.encodeOutput
                    }
                    set encodeOutput(_) {
                        this.fullscreenMaterial.encodeOutput = _
                    }
                    get dithering() {
                        return this.fullscreenMaterial.dithering
                    }
                    set dithering(_) {
                        let O = this.fullscreenMaterial;
                        O.dithering = _, O.needsUpdate = !0
                    }
                    verifyResources() {
                        let _ = this.renderer.capabilities,
                            O = Math.min(_.maxFragmentUniforms, _.maxVertexUniforms);
                        this.uniformCount > O && console.warn("The current rendering context doesn't support more than " + O + " uniforms, but " + this.uniformCount + " were defined"), O = _.maxVaryings, this.varyingCount > O && console.warn("The current rendering context doesn't support more than " + O + " varyings, but " + this.varyingCount + " were defined")
                    }
                    updateMaterial() {
                        let _ = Sk.Section,
                            O = new Map([
                                [_.FRAGMENT_HEAD, ""],
                                [_.FRAGMENT_MAIN_UV, ""],
                                [_.FRAGMENT_MAIN_IMAGE, ""],
                                [_.VERTEX_HEAD, ""],
                                [_.VERTEX_MAIN_SUPPORT, ""]
                            ]),
                            B = new Map,
                            N = new Map,
                            k = new Map,
                            F = new Set,
                            U = 0,
                            j = 0,
                            G = 0,
                            Y = !1,
                            Q = !1;
                        for (let _ of this.effects)
                            if (_.blendMode.blendFunction === S4.SKIP) G |= _.getAttributes() & S8.DEPTH;
                            else if ((G & _.getAttributes() & S8.CONVOLUTION) != 0) console.error("Convolution effects cannot be merged", _);
                        else {
                            G |= _.getAttributes();
                            let K = function(_, O, B, N, k, F, U) {
                                let j = new Map([
                                        ["fragment", O.getFragmentShader()],
                                        ["vertex", O.getVertexShader()]
                                    ]),
                                    G = void 0 !== j.get("fragment") && /mainImage/.test(j.get("fragment")),
                                    Y = void 0 !== j.get("fragment") && /mainUv/.test(j.get("fragment")),
                                    Q = [],
                                    K = [],
                                    $ = !1,
                                    ee = !1;
                                if (void 0 === j.get("fragment")) console.error("Missing fragment shader", O);
                                else if (Y && (U & S8.CONVOLUTION) != 0) console.error("Effects that transform UV coordinates are incompatible with convolution effects", O);
                                else if (G || Y) {
                                    let et = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,
                                        ei = Sk.Section;
                                    if (Y) {
                                        let O = `	${_}MainUv(UV);
`;
                                        B.set(ei.FRAGMENT_MAIN_UV, B.get(ei.FRAGMENT_MAIN_UV) + O), $ = !0
                                    }
                                    if (null !== j.get("vertex") && /mainSupport/.test(j.get("vertex"))) {
                                        let O = `	${_}MainSupport(`;
                                        O += /mainSupport *\([\w\s]*?uv\s*?\)/.test(j.get("vertex")) ? `vUv);
` : `);
`, B.set(ei.VERTEX_MAIN_SUPPORT, B.get(ei.VERTEX_MAIN_SUPPORT) + O), Q = Q.concat([...j.get("vertex").matchAll(/(?:varying\s+\w+\s+(\w*))/g)].map(_ => _[1])), K = K.concat(Q).concat([...j.get("vertex").matchAll(et)].map(_ => _[1]))
                                    }
                                    K = (K = (K = K.concat([...j.get("fragment").matchAll(et)].map(_ => _[1]))).concat([...O.defines.keys()].map(_ => _.replace(/\([\w\s,]*\)/g, "")))).concat([...O.uniforms.keys()]), O.uniforms.forEach((O, B) => F.set(_ + B.charAt(0).toUpperCase() + B.slice(1), O)), O.defines.forEach((O, B) => k.set(_ + B.charAt(0).toUpperCase() + B.slice(1), O)), oO(_, K, k), oO(_, K, j);
                                    let er = O.blendMode;
                                    if (N.set(er.blendFunction, er), G) {
                                        let O = `${_}MainImage(color0, UV, `;
                                        (U & S8.DEPTH) != 0 && /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/.test(j.get("fragment")) && (O += "depth, ", ee = !0), O += `color1);
	`;
                                        let N = _ + "BlendOpacity";
                                        F.set(N, er.opacity), O += `color0 = blend${er.blendFunction}(color0, color1, ${N});

	`, B.set(ei.FRAGMENT_MAIN_IMAGE, B.get(ei.FRAGMENT_MAIN_IMAGE) + O), O = `uniform float ${N};

`, B.set(ei.FRAGMENT_HEAD, B.get(ei.FRAGMENT_HEAD) + O)
                                    }
                                    B.set(ei.FRAGMENT_HEAD, B.get(ei.FRAGMENT_HEAD) + j.get("fragment") + `
`), null !== j.get("vertex") && B.set(ei.VERTEX_HEAD, B.get(ei.VERTEX_HEAD) + j.get("vertex") + `
`)
                                } else console.error("The fragment shader contains neither a mainImage nor a mainUv function", O);
                                return {
                                    varyings: Q,
                                    transformedUv: $,
                                    readDepth: ee
                                }
                            }("e" + U++, _, O, B, N, k, G);
                            if (j += K.varyings.length, Y = Y || K.transformedUv, Q = Q || K.readDepth, null !== _.extensions)
                                for (let O of _.extensions) F.add(O)
                        }
                        let K = /\bblend\b/g;
                        for (let N of B.values()) {
                            let B = N.getShaderCode().replace(K, `blend${N.blendFunction}`);
                            O.set(_.FRAGMENT_HEAD, O.get(_.FRAGMENT_HEAD) + B + `
`)
                        }
                        if ((G & S8.DEPTH) != 0) {
                            if (Q) {
                                let B = `float depth = readDepth(UV);

	`;
                                O.set(_.FRAGMENT_MAIN_IMAGE, B + O.get(_.FRAGMENT_MAIN_IMAGE))
                            }
                            this.needsDepthTexture = null === this.getDepthTexture()
                        } else this.needsDepthTexture = !1;
                        if (Y) {
                            let B = `vec2 transformedUv = vUv;
`;
                            O.set(_.FRAGMENT_MAIN_UV, B + O.get(_.FRAGMENT_MAIN_UV)), N.set("UV", "transformedUv")
                        } else N.set("UV", "vUv");
                        O.forEach((_, O, B) => B.set(O, _.trim().replace(/^#/, `
#`))), this.uniformCount = k.size, this.varyingCount = j, this.skipRendering = 0 === U, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderParts(O).setExtensions(F).setUniforms(k).setDefines(N)
                    }
                    recompile() {
                        this.updateMaterial(), this.verifyResources()
                    }
                    getDepthTexture() {
                        return this.fullscreenMaterial.depthBuffer
                    }
                    setDepthTexture(_, O = 3200) {
                        for (let B of (this.fullscreenMaterial.depthBuffer = _, this.fullscreenMaterial.depthPacking = O, this.effects)) B.setDepthTexture(_, O)
                    }
                    render(_, O, B, N, k) {
                        for (let B of this.effects) B.update(_, O, N);
                        if (!this.skipRendering || this.renderToScreen) {
                            let k = this.fullscreenMaterial;
                            k.inputBuffer = O.texture, k.time += N, _.setRenderTarget(this.renderToScreen ? null : B), _.render(this.scene, this.camera)
                        }
                    }
                    setSize(_, O) {
                        for (let B of (this.fullscreenMaterial.setSize(_, O), this.effects)) B.setSize(_, O)
                    }
                    initialize(_, O, B) {
                        for (let N of (this.renderer = _, this.effects)) N.initialize(_, O, B), N.addEventListener("change", _ => this.handleEvent(_));
                        this.updateMaterial(), this.verifyResources(), void 0 !== B && 1009 !== B && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                    dispose() {
                        for (let _ of (super.dispose(), this.effects)) _.dispose()
                    }
                    handleEvent(_) {
                        "change" === _.type && this.recompile()
                    }
                },
                At = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
                Ai = class extends SX {
                    constructor({
                        resolutionScale: _ = .5,
                        width: O = S$.AUTO_SIZE,
                        height: B = S$.AUTO_SIZE,
                        kernelSize: N = Al.LARGE
                    } = {}) {
                        super("KawaseBlurPass"), this.renderTargetA = new rh(1, 1, {
                            minFilter: 1006,
                            magFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
                        let k = this.resolution = new S$(this, O, B, _);
                        k.addEventListener("change", _ => this.setSize(k.baseWidth, k.baseHeight)), this.blurMaterial = new SC, this.ditheredBlurMaterial = new SC, this.ditheredBlurMaterial.uniforms.scale = this.blurMaterial.uniforms.scale, this.ditheredBlurMaterial.dithering = !0, this.dithering = !1, this.kernelSize = N
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(_) {
                        this.resolution.preferredWidth = _
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(_) {
                        this.resolution.preferredHeight = _
                    }
                    get scale() {
                        return this.blurMaterial.scale
                    }
                    set scale(_) {
                        this.blurMaterial.scale = _
                    }
                    getScale() {
                        return this.blurMaterial.scale
                    }
                    setScale(_) {
                        this.blurMaterial.scale = _
                    }
                    getKernelSize() {
                        return this.kernelSize
                    }
                    setKernelSize(_) {
                        this.kernelSize = _
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(_) {
                        this.resolution.scale = _
                    }
                    render(_, O, B, N, k) {
                        let F = this.scene,
                            U = this.camera,
                            j = this.renderTargetA,
                            G = this.renderTargetB,
                            Y = At[this.kernelSize],
                            Q = this.blurMaterial,
                            K = O,
                            $, ee;
                        for (this.fullscreenMaterial = Q, $ = 0, ee = Y.length - 1; $ < ee; ++$) {
                            let O = (1 & $) == 0 ? j : G;
                            Q.kernel = Y[$], Q.inputBuffer = K.texture, _.setRenderTarget(O), _.render(F, U), K = O
                        }
                        this.dithering && (Q = this.ditheredBlurMaterial, this.fullscreenMaterial = Q), Q.kernel = Y[$], Q.inputBuffer = K.texture, _.setRenderTarget(this.renderToScreen ? null : B), _.render(F, U)
                    }
                    setSize(_, O) {
                        let B = this.resolution;
                        B.setBaseSize(_, O);
                        let N = B.width,
                            k = B.height;
                        this.renderTargetA.setSize(N, k), this.renderTargetB.setSize(N, k), this.blurMaterial.setSize(N, k), this.ditheredBlurMaterial.setSize(N, k)
                    }
                    initialize(_, O, B) {
                        void 0 !== B && (this.renderTargetA.texture.type = B, this.renderTargetB.texture.type = B, 1009 !== B ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : 3001 === _.outputEncoding && (this.renderTargetA.texture.encoding = 3001, this.renderTargetB.texture.encoding = 3001))
                    }
                    static get AUTO_SIZE() {
                        return S$.AUTO_SIZE
                    }
                },
                Ar = class extends SX {
                    constructor({
                        width: _ = S$.AUTO_SIZE,
                        height: O = S$.AUTO_SIZE,
                        renderTarget: B,
                        luminanceRange: N,
                        colorOutput: k
                    } = {}) {
                        super("LuminancePass"), this.fullscreenMaterial = new SU(k, N), this.needsSwap = !1, this.renderTarget = B, void 0 === this.renderTarget && (this.renderTarget = new rh(1, 1, {
                            minFilter: 1006,
                            magFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "LuminancePass.Target", this.renderTarget.texture.generateMipmaps = !1);
                        let F = this.resolution = new S$(this, _, O);
                        F.addEventListener("change", _ => this.setSize(F.baseWidth, F.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    render(_, O, B, N, k) {
                        this.fullscreenMaterial.inputBuffer = O.texture, _.setRenderTarget(this.renderToScreen ? null : this.renderTarget), _.render(this.scene, this.camera)
                    }
                    setSize(_, O) {
                        let B = this.resolution;
                        B.setBaseSize(_, O), this.renderTarget.setSize(B.width, B.height)
                    }
                    initialize(_, O, B) {
                        void 0 !== B && 1009 !== B && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                },
                As = class extends SX {
                    constructor(_, O) {
                        super("MaskPass", _, O), this.needsSwap = !1, this.clearPass = new SJ(!1, !1, !0), this.inverse = !1
                    }
                    get inverted() {
                        return this.inverse
                    }
                    set inverted(_) {
                        this.inverse = _
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(_) {
                        this.clearPass.enabled = _
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(_) {
                        this.inverted = _
                    }
                    render(_, O, B, N, k) {
                        let F = _.getContext(),
                            U = _.state.buffers,
                            j = this.scene,
                            G = this.camera,
                            Y = this.clearPass,
                            Q = this.inverted ? 0 : 1,
                            K = 1 - Q;
                        U.color.setMask(!1), U.depth.setMask(!1), U.color.setLocked(!0), U.depth.setLocked(!0), U.stencil.setTest(!0), U.stencil.setOp(F.REPLACE, F.REPLACE, F.REPLACE), U.stencil.setFunc(F.ALWAYS, Q, 4294967295), U.stencil.setClear(K), U.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? Y.render(_, null) : (Y.render(_, O), Y.render(_, B))), this.renderToScreen ? _.setRenderTarget(null) : (_.setRenderTarget(O), _.render(j, G), _.setRenderTarget(B)), _.render(j, G), U.color.setLocked(!1), U.depth.setLocked(!1), U.stencil.setLocked(!1), U.stencil.setFunc(F.EQUAL, 1, 4294967295), U.stencil.setOp(F.KEEP, F.KEEP, F.KEEP), U.stencil.setLocked(!0)
                    }
                },
                An = class extends SX {
                    constructor(_, O = "inputBuffer") {
                        super("ShaderPass"), this.fullscreenMaterial = _, this.inputBufferUniform = null, this.setInput(O)
                    }
                    setInput(_) {
                        if (this.inputBufferUniform = null, null !== this.fullscreenMaterial) {
                            let O = this.fullscreenMaterial.uniforms;
                            void 0 !== O && void 0 !== O[_] && (this.inputBufferUniform = O[_])
                        }
                    }
                    render(_, O, B, N, k) {
                        null !== this.inputBufferUniform && null !== O && (this.inputBufferUniform.value = O.texture), _.setRenderTarget(this.renderToScreen ? null : B), _.render(this.scene, this.camera)
                    }
                    initialize(_, O, B) {
                        void 0 !== B && 1009 !== B && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                },
                Ao = class {
                    constructor() {
                        this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1, this.autoReset = !1
                    }
                    setFixedDeltaEnabled(_) {
                        return this.fixedDeltaEnabled = _, this
                    }
                    isAutoResetEnabled(_) {
                        return this.autoReset
                    }
                    setAutoResetEnabled(_) {
                        return "u" > typeof document && void 0 !== document.hidden && (_ ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this.autoReset = _), this
                    }
                    getDelta() {
                        return .001 * this.delta
                    }
                    getFixedDelta() {
                        return .001 * this.fixedDelta
                    }
                    setFixedDelta(_) {
                        return this.fixedDelta = 1e3 * _, this
                    }
                    getElapsed() {
                        return .001 * this.elapsed
                    }
                    getTimescale() {
                        return this.timescale
                    }
                    setTimescale(_) {
                        return this.timescale = _, this
                    }
                    update(_) {
                        return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = void 0 !== _ ? _ : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.delta, this
                    }
                    reset() {
                        return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this
                    }
                    handleEvent(_) {
                        document.hidden || (this.currentTime = performance.now())
                    }
                    dispose() {
                        this.setAutoResetEnabled(!1)
                    }
                },
                Al = {
                    MEDIUM: 2,
                    LARGE: 3
                },
                Ah = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`,
                Ac = class extends S9 {
                    constructor({
                        blendFunction: _ = S4.SCREEN,
                        luminanceThreshold: O = .9,
                        luminanceSmoothing: B = .025,
                        resolutionScale: N = .5,
                        intensity: k = 1,
                        width: F = S$.AUTO_SIZE,
                        height: U = S$.AUTO_SIZE,
                        kernelSize: j = Al.LARGE
                    } = {}) {
                        super("BloomEffect", Ah, {
                            blendFunction: _,
                            uniforms: new Map([
                                ["map", new l_(null)],
                                ["intensity", new l_(k)]
                            ])
                        }), this.renderTarget = new rh(1, 1, {
                            minFilter: 1006,
                            magFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "Bloom.Target", this.renderTarget.texture.generateMipmaps = !1, this.uniforms.get("map").value = this.renderTarget.texture, this.luminancePass = new Ar({
                            renderTarget: this.renderTarget,
                            colorOutput: !0
                        }), this.luminanceMaterial.threshold = O, this.luminanceMaterial.smoothingFactor = B, this.blurPass = new Ai({
                            resolutionScale: N,
                            width: F,
                            height: U,
                            kernelSize: j
                        });
                        let G = this.blurPass.getResolution();
                        G.addEventListener("change", _ => this.setSize(G.baseWidth, G.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    get resolution() {
                        return this.blurPass.resolution
                    }
                    getResolution() {
                        return this.blurPass.resolution
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getLuminancePass() {
                        return this.luminancePass
                    }
                    get luminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    getLuminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(_) {
                        this.resolution.preferredWidth = _
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(_) {
                        this.resolution.preferredHeight = _
                    }
                    get dithering() {
                        return this.blurPass.dithering
                    }
                    set dithering(_) {
                        this.blurPass.dithering = _
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(_) {
                        this.blurPass.kernelSize = _
                    }
                    get distinction() {
                        return console.warn(this.name, "distinction was removed"), 1
                    }
                    set distinction(_) {
                        console.warn(this.name, "distinction was removed")
                    }
                    get intensity() {
                        return this.uniforms.get("intensity").value
                    }
                    set intensity(_) {
                        this.uniforms.get("intensity").value = _
                    }
                    getIntensity() {
                        return this.intensity
                    }
                    setIntensity(_) {
                        this.intensity = _
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(_) {
                        this.resolution.scale = _
                    }
                    update(_, O, B) {
                        let N = this.renderTarget;
                        this.luminancePass.enabled ? (this.luminancePass.render(_, O, N), this.blurPass.render(_, N, N)) : this.blurPass.render(_, O, N)
                    }
                    setSize(_, O) {
                        let B = this.resolution;
                        B.setBaseSize(_, O), this.renderTarget.setSize(B.width, B.height), this.luminancePass.resolution.copy(B)
                    }
                    initialize(_, O, B) {
                        this.blurPass.initialize(_, O, B), void 0 !== B && (this.renderTarget.texture.type = B, 3001 === _.outputEncoding && (this.renderTarget.texture.encoding = 3001))
                    }
                },
                Ad = class extends S9 {
                    constructor({
                        blendFunction: _ = S4.NORMAL,
                        brightness: O = 0,
                        contrast: B = 0
                    } = {}) {
                        super("BrightnessContrastEffect", "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}", {
                            blendFunction: _,
                            uniforms: new Map([
                                ["brightness", new l_(O)],
                                ["contrast", new l_(B)]
                            ])
                        })
                    }
                    get brightness() {
                        return this.uniforms.get("brightness").value
                    }
                    set brightness(_) {
                        this.uniforms.get("brightness").value = _
                    }
                    getBrightness(_) {
                        return this.brightness
                    }
                    setBrightness(_) {
                        this.brightness = _
                    }
                    get contrast() {
                        return this.uniforms.get("contrast").value
                    }
                    set contrast(_) {
                        this.uniforms.get("contrast").value = _
                    }
                    getContrast(_) {
                        return this.contrast
                    }
                    setContrast(_) {
                        this.contrast = _
                    }
                },
                Au = class extends S9 {
                    constructor(_ = S4.NORMAL) {
                        super("ColorAverageEffect", "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}", {
                            blendFunction: _
                        })
                    }
                },
                Ap = class extends S9 {
                    constructor({
                        blendFunction: _ = S4.NORMAL,
                        offset: O = new iJ(.001, 5e-4)
                    } = {}) {
                        super("ChromaticAberrationEffect", "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}", {
                            vertexShader: "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}",
                            blendFunction: _,
                            attributes: S8.CONVOLUTION,
                            uniforms: new Map([
                                ["offset", new l_(O)]
                            ])
                        })
                    }
                    get offset() {
                        return this.uniforms.get("offset").value
                    }
                    set offset(_) {
                        this.uniforms.get("offset").value = _
                    }
                    getOffset() {
                        return this.offset
                    }
                    setOffset(_) {
                        this.offset = _
                    }
                },
                Af = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`,
                Am = class extends S9 {
                    constructor(_, {
                        blendFunction: O = S4.NORMAL,
                        worldFocusDistance: B,
                        worldFocusRange: N,
                        focusDistance: k = 0,
                        focalLength: F = .1,
                        focusRange: U = F,
                        bokehScale: j = 1,
                        width: G = S$.AUTO_SIZE,
                        height: Y = S$.AUTO_SIZE
                    } = {}) {
                        super("DepthOfFieldEffect", Af, {
                            blendFunction: O,
                            attributes: S8.DEPTH,
                            uniforms: new Map([
                                ["nearColorBuffer", new l_(null)],
                                ["farColorBuffer", new l_(null)],
                                ["nearCoCBuffer", new l_(null)],
                                ["scale", new l_(1)]
                            ])
                        }), this.camera = _, this.renderTarget = new rh(1, 1, {
                            minFilter: 1006,
                            magFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTarget.texture.generateMipmaps = !1, this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new An(new SS(_));
                        let Q = this.cocMaterial;
                        Q.focusDistance = k, Q.focusRange = U, void 0 !== B && (Q.worldFocusDistance = B), void 0 !== N && (Q.worldFocusRange = N), this.blurPass = new Ai({
                            kernelSize: Al.MEDIUM,
                            width: G,
                            height: Y
                        });
                        let K = this.blurPass.getResolution();
                        K.addEventListener("change", _ => this.setSize(K.getBaseWidth(), K.getBaseHeight())), this.maskPass = new An(new SG(this.renderTargetCoC.texture));
                        let $ = this.maskPass.fullscreenMaterial;
                        $.maskFunction = 1, $.colorChannel = 1, this.bokehNearBasePass = new An(new Sw(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new An(new Sw(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new An(new Sw(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new An(new Sw(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null, this.bokehScale = j
                    }
                    get cocTexture() {
                        return this.renderTargetCoC.texture
                    }
                    get cocMaterial() {
                        return this.cocPass.fullscreenMaterial
                    }
                    get circleOfConfusionMaterial() {
                        return this.cocMaterial
                    }
                    getCircleOfConfusionMaterial() {
                        return this.circleOfConfusionMaterial
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    get resolution() {
                        return this.blurPass.getResolution()
                    }
                    getResolution() {
                        return this.blurPass.getResolution()
                    }
                    get bokehScale() {
                        return this.uniforms.get("scale").value
                    }
                    set bokehScale(_) {
                        for (let O of [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass]) O.fullscreenMaterial.setScale(_);
                        this.maskPass.fullscreenMaterial.setStrength(_), this.uniforms.get("scale").value = _
                    }
                    getBokehScale() {
                        return this.bokehScale
                    }
                    setBokehScale(_) {
                        this.bokehScale = _
                    }
                    getTarget() {
                        return this.target
                    }
                    setTarget(_) {
                        this.target = _
                    }
                    calculateFocusDistance(_) {
                        let O = this.camera;
                        return t1(-O.position.distanceTo(_), O.near, O.far)
                    }
                    setDepthTexture(_, O = 3200) {
                        this.circleOfConfusionMaterial.depthBuffer = _, this.circleOfConfusionMaterial.depthPacking = O
                    }
                    update(_, O, B) {
                        let N = this.renderTarget,
                            k = this.renderTargetCoC,
                            F = this.renderTargetCoCBlurred,
                            U = this.renderTargetMasked;
                        if (null !== this.target) {
                            let _ = this.calculateFocusDistance(this.target);
                            this.circleOfConfusionMaterial.focusDistance = _
                        }
                        this.cocPass.render(_, null, k), this.blurPass.render(_, k, F), this.maskPass.render(_, O, U), this.bokehFarBasePass.render(_, U, N), this.bokehFarFillPass.render(_, N, this.renderTargetFar), this.bokehNearBasePass.render(_, O, N), this.bokehNearFillPass.render(_, N, this.renderTargetNear)
                    }
                    setSize(_, O) {
                        let B = this.resolution;
                        B.setBaseSize(_, O);
                        let N = B.width,
                            k = B.height,
                            F = [this.cocPass, this.blurPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass];
                        F.push(this.renderTargetCoC, this.renderTargetMasked), F.forEach(B => B.setSize(_, O)), (F = [this.renderTarget, this.renderTargetNear, this.renderTargetFar, this.renderTargetCoCBlurred]).forEach(_ => _.setSize(N, k)), [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach(_ => _.fullscreenMaterial.setSize(N, k))
                    }
                    initialize(_, O, B) {
                        [this.cocPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach(N => N.initialize(_, O, B)), this.blurPass.initialize(_, O, 1009), void 0 !== B && (this.renderTarget.texture.type = B, this.renderTargetNear.texture.type = B, this.renderTargetFar.texture.type = B, this.renderTargetMasked.texture.type = B, 3001 === _.outputEncoding && (this.renderTarget.texture.encoding = 3001, this.renderTargetNear.texture.encoding = 3001, this.renderTargetFar.texture.encoding = 3001, this.renderTargetMasked.texture.encoding = 3001))
                    }
                };
            new rv, new rJ;
            var Ag = class extends S9 {
                constructor({
                    blendFunction: _ = S4.NORMAL,
                    hue: O = 0,
                    saturation: B = 0
                } = {}) {
                    super("HueSaturationEffect", "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", {
                        blendFunction: _,
                        uniforms: new Map([
                            ["hue", new l_(new rv)],
                            ["saturation", new l_(B)]
                        ])
                    }), this.hue = O
                }
                get saturation() {
                    return this.uniforms.get("saturation").value
                }
                set saturation(_) {
                    this.uniforms.get("saturation").value = _
                }
                getSaturation() {
                    return this.saturation
                }
                setSaturation(_) {
                    this.saturation = _
                }
                get hue() {
                    return Math.acos((3 * this.uniforms.get("hue").value.x - 1) / 2)
                }
                set hue(_) {
                    let O = Math.sin(_),
                        B = Math.cos(_);
                    this.uniforms.get("hue").value.set((2 * B + 1) / 3, (-Math.sqrt(3) * O - B + 1) / 3, (Math.sqrt(3) * O - B + 1) / 3)
                }
                getHue() {
                    return this.hue
                }
                setHue(_) {
                    this.hue = _
                }
            };
            new re;
            var Ay = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,
                Ax = class extends S9 {
                    constructor({
                        blendFunction: _ = S4.SCREEN,
                        premultiply: O = !1
                    } = {}) {
                        super("NoiseEffect", Ay, {
                            blendFunction: _
                        }), this.premultiply = O
                    }
                    get premultiply() {
                        return this.defines.has("PREMULTIPLY")
                    }
                    set premultiply(_) {
                        this.premultiply !== _ && (_ ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged())
                    }
                    isPremultiplied() {
                        return this.premultiply
                    }
                    setPremultiplied(_) {
                        this.premultiply = _
                    }
                },
                Ab = class extends S9 {
                    constructor(_ = 30) {
                        super("PixelationEffect", "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}", {
                            uniforms: new Map([
                                ["active", new l_(!1)],
                                ["d", new l_(new iJ)]
                            ])
                        }), this.resolution = new iJ, this.d = 0, this.granularity = _
                    }
                    get granularity() {
                        return this.d
                    }
                    set granularity(_) {
                        let O = Math.floor(_);
                        O % 2 > 0 && (O += 1), this.d = O, this.uniforms.get("active").value = O > 0, this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getGranularity() {
                        return this.granularity
                    }
                    setGranularity(_) {
                        this.granularity = _
                    }
                    setSize(_, O) {
                        this.resolution.set(_, O), this.uniforms.get("d").value.setScalar(this.d).divide(this.resolution)
                    }
                };
            new rv, new rv;
            var Aw = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
                A_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
                AS = {
                    LOW: 0,
                    MEDIUM: 1,
                    HIGH: 2,
                    ULTRA: 3
                },
                AA = class extends S9 {
                    constructor({
                        preset: _ = AS.MEDIUM,
                        edgeDetectionMode: O = SO.COLOR,
                        predicationMode: B = 0
                    } = {}) {
                        let N, k;
                        super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", {
                            vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                            blendFunction: S4.NORMAL,
                            attributes: S8.CONVOLUTION | S8.DEPTH,
                            uniforms: new Map([
                                ["weightMap", new l_(null)]
                            ])
                        }), arguments.length > 1 && (N = arguments[0], k = arguments[1], arguments.length > 2 && (_ = arguments[2]), arguments.length > 3 && (O = arguments[3])), this.renderTargetEdges = new rh(1, 1, {
                            minFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new SJ(!0, !1, !1), this.clearPass.overrideClearColor = new re(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new An(new SB), this.edgeDetectionMaterial.edgeDetectionMode = O, this.edgeDetectionMaterial.predicationMode = B, this.weightsPass = new An(new SW);
                        let F = new oH;
                        F.onLoad = () => {
                            let _ = new ro(N);
                            _.name = "SMAA.Search", _.magFilter = 1003, _.minFilter = 1003, _.generateMipmaps = !1, _.needsUpdate = !0, _.flipY = !0, this.weightsMaterial.searchTexture = _;
                            let O = new ro(k);
                            O.name = "SMAA.Area", O.magFilter = 1006, O.minFilter = 1006, O.generateMipmaps = !1, O.needsUpdate = !0, O.flipY = !1, this.weightsMaterial.areaTexture = O, this.dispatchEvent({
                                type: "load"
                            })
                        }, F.itemStart("search"), F.itemStart("area"), void 0 !== N && void 0 !== k ? (F.itemEnd("search"), F.itemEnd("area")) : "u" > typeof Image && (N = new Image, k = new Image, N.addEventListener("load", () => F.itemEnd("search")), k.addEventListener("load", () => F.itemEnd("area")), N.src = Aw, k.src = A_), this.applyPreset(_)
                    }
                    get edgesTexture() {
                        return this.renderTargetEdges.texture
                    }
                    getEdgesTexture() {
                        return this.edgesTexture
                    }
                    get weightsTexture() {
                        return this.renderTargetWeights.texture
                    }
                    getWeightsTexture() {
                        return this.weightsTexture
                    }
                    get edgeDetectionMaterial() {
                        return this.edgeDetectionPass.fullscreenMaterial
                    }
                    get colorEdgesMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    getEdgeDetectionMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    get weightsMaterial() {
                        return this.weightsPass.fullscreenMaterial
                    }
                    getWeightsMaterial() {
                        return this.weightsMaterial
                    }
                    setEdgeDetectionThreshold(_) {
                        this.edgeDetectionMaterial.edgeDetectionThreshold = _
                    }
                    setOrthogonalSearchSteps(_) {
                        this.weightsMaterial.orthogonalSearchSteps = _
                    }
                    applyPreset(_) {
                        let O = this.edgeDetectionMaterial,
                            B = this.weightsMaterial;
                        switch (_) {
                            case AS.LOW:
                                O.edgeDetectionThreshold = .15, B.orthogonalSearchSteps = 4, B.diagonalDetection = !1, B.cornerDetection = !1;
                                break;
                            case AS.MEDIUM:
                                O.edgeDetectionThreshold = .1, B.orthogonalSearchSteps = 8, B.diagonalDetection = !1, B.cornerDetection = !1;
                                break;
                            case AS.HIGH:
                                O.edgeDetectionThreshold = .1, B.orthogonalSearchSteps = 16, B.diagonalSearchSteps = 8, B.cornerRounding = 25, B.diagonalDetection = !0, B.cornerDetection = !0;
                                break;
                            case AS.ULTRA:
                                O.edgeDetectionThreshold = .05, B.orthogonalSearchSteps = 32, B.diagonalSearchSteps = 16, B.cornerRounding = 25, B.diagonalDetection = !0, B.cornerDetection = !0
                        }
                    }
                    setDepthTexture(_, O = 3200) {
                        this.edgeDetectionMaterial.depthBuffer = _, this.edgeDetectionMaterial.depthPacking = O
                    }
                    update(_, O, B) {
                        this.clearPass.render(_, this.renderTargetEdges), this.edgeDetectionPass.render(_, O, this.renderTargetEdges), this.weightsPass.render(_, this.renderTargetEdges, this.renderTargetWeights)
                    }
                    setSize(_, O) {
                        this.edgeDetectionMaterial.setSize(_, O), this.weightsMaterial.setSize(_, O), this.renderTargetEdges.setSize(_, O), this.renderTargetWeights.setSize(_, O)
                    }
                    dispose() {
                        let {
                            searchTexture: _,
                            areaTexture: O
                        } = this.weightsMaterial;
                        null !== _ && null !== O && (_.dispose(), O.dispose()), super.dispose()
                    }
                    static get searchImageDataURL() {
                        return Aw
                    }
                    static get areaImageDataURL() {
                        return A_
                    }
                },
                AM = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,
                AC = {
                    DEFAULT: 0,
                    ESKIL: 1
                },
                AT = class extends S9 {
                    constructor({
                        blendFunction: _ = S4.NORMAL,
                        technique: O = AC.DEFAULT,
                        eskil: B = !1,
                        offset: N = .5,
                        darkness: k = .5
                    } = {}) {
                        super("VignetteEffect", AM, {
                            blendFunction: _,
                            defines: new Map([
                                ["VIGNETTE_TECHNIQUE", O.toFixed(0)]
                            ]),
                            uniforms: new Map([
                                ["offset", new l_(N)],
                                ["darkness", new l_(k)]
                            ])
                        })
                    }
                    get technique() {
                        return Number(this.defines.get("VIGNETTE_TECHNIQUE"))
                    }
                    set technique(_) {
                        this.technique !== _ && (this.defines.set("VIGNETTE_TECHNIQUE", _.toFixed(0)), this.setChanged())
                    }
                    get eskil() {
                        return this.technique === AC.ESKIL
                    }
                    set eskil(_) {
                        this.technique = _ ? AC.ESKIL : AC.DEFAULT
                    }
                    getTechnique() {
                        return this.technique
                    }
                    setTechnique(_) {
                        this.technique = _
                    }
                    get offset() {
                        return this.uniforms.get("offset").value
                    }
                    set offset(_) {
                        this.uniforms.get("offset").value = _
                    }
                    getOffset() {
                        return this.offset
                    }
                    setOffset(_) {
                        this.offset = _
                    }
                    get darkness() {
                        return this.uniforms.get("darkness").value
                    }
                    set darkness(_) {
                        this.uniforms.get("darkness").value = _
                    }
                    getDarkness() {
                        return this.darkness
                    }
                    setDarkness(_) {
                        this.darkness = _
                    }
                };

            function Qn(_, O, B, N) {
                var k;
                return (k = _ + (O - _) * .75) + (B + (N - B) * .75 - k) * .875
            }
            new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array(2), new Float32Array(2), new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]), Qn(0, 0, 0, 0), new Float32Array([0, 0, 0, 0]), Qn(0, 0, 0, 1), new Float32Array([0, 0, 0, 1]), Qn(0, 0, 1, 0), new Float32Array([0, 0, 1, 0]), Qn(0, 0, 1, 1), new Float32Array([0, 0, 1, 1]), Qn(0, 1, 0, 0), new Float32Array([0, 1, 0, 0]), Qn(0, 1, 0, 1), new Float32Array([0, 1, 0, 1]), Qn(0, 1, 1, 0), new Float32Array([0, 1, 1, 0]), Qn(0, 1, 1, 1), new Float32Array([0, 1, 1, 1]), Qn(1, 0, 0, 0), new Float32Array([1, 0, 0, 0]), Qn(1, 0, 0, 1), new Float32Array([1, 0, 0, 1]), Qn(1, 0, 1, 0), new Float32Array([1, 0, 1, 0]), Qn(1, 0, 1, 1), new Float32Array([1, 0, 1, 1]), Qn(1, 1, 0, 0), new Float32Array([1, 1, 0, 0]), Qn(1, 1, 0, 1), new Float32Array([1, 1, 0, 1]), Qn(1, 1, 1, 0), new Float32Array([1, 1, 1, 0]), Qn(1, 1, 1, 1), new Float32Array([1, 1, 1, 1]);
            var AD = class {
                    constructor(_, O) {
                        this.enabled = !1, this.effect = new _(O), Object.defineProperty(this, "opacity", {
                            enumerable: !0,
                            set(_) {
                                this.effect.blendMode.opacity.value = _
                            },
                            get() {
                                return this.effect.blendMode.opacity.value
                            }
                        }), Object.defineProperty(this, "blendFunction", {
                            enumerable: !0,
                            set(_) {
                                this.effect.blendMode.setBlendFunction(Number(_))
                            },
                            get() {
                                return this.effect.blendMode.blendFunction
                            }
                        }), this.blendFunction = S4.NORMAL
                    }
                },
                AI = class extends AD {
                    constructor() {
                        super(Ac), this.blendFunction = S4.SCREEN
                    }
                    set intensity(_) {
                        this.effect.intensity = _
                    }
                    get intensity() {
                        return this.effect.intensity
                    }
                    set luminanceThreshold(_) {
                        this.effect.luminanceMaterial.threshold = _
                    }
                    get luminanceThreshold() {
                        return this.effect.luminanceMaterial.threshold
                    }
                    set luminanceSmoothing(_) {
                        this.effect.luminanceMaterial.smoothing = _
                    }
                    get luminanceSmoothing() {
                        return this.effect.luminanceMaterial.smoothing
                    }
                    set blurScale(_) {
                        this.effect.blurPass.scale = _
                    }
                    get blurScale() {
                        return this.effect.blurPass.scale
                    }
                    set kernelSize(_) {
                        this.effect.blurPass.kernelSize = _
                    }
                    get kernelSize() {
                        return this.effect.blurPass.kernelSize
                    }
                },
                AO = class extends AD {
                    constructor() {
                        super(Ad)
                    }
                    set contrast(_) {
                        this.effect.uniforms.get("contrast").value = _
                    }
                    get contrast() {
                        return this.effect.uniforms.get("contrast").value
                    }
                    set brightness(_) {
                        this.effect.uniforms.get("brightness").value = _
                    }
                    get brightness() {
                        return this.effect.uniforms.get("brightness").value
                    }
                },
                AL = class extends AD {
                    constructor() {
                        super(Ap), this.effect.offset = new iJ(.01, .01)
                    }
                    set offset(_) {
                        this.effect.offset.set(_[0] / 1e3, _[1] / 1e3)
                    }
                    get offset() {
                        return [1e3 * this.effect.offset.x, 1e3 * this.effect.offset.y]
                    }
                },
                AR = class extends AD {
                    constructor() {
                        super(Au)
                    }
                },
                AB = class extends AD {
                    constructor() {
                        super(Ag), this._hue = 0
                    }
                    set hue(_) {
                        this._hue = _, this.effect.setHue(_)
                    }
                    get hue() {
                        return this._hue
                    }
                    set saturation(_) {
                        this.effect.uniforms.get("saturation").value = _
                    }
                    get saturation() {
                        return this.effect.uniforms.get("saturation").value
                    }
                },
                Az = class extends AD {
                    constructor() {
                        super(Ax), this.blendFunction = S4.OVERLAY
                    }
                },
                AN = class extends AD {
                    constructor() {
                        super(AT)
                    }
                    get eskil() {
                        return this.effect.eskil
                    }
                    set eskil(_) {
                        this.effect.eskil = _
                    }
                    get darkness() {
                        return this.effect.uniforms.get("darkness").value
                    }
                    set darkness(_) {
                        this.effect.uniforms.get("darkness").value = _
                    }
                    get offset() {
                        return this.effect.uniforms.get("offset").value
                    }
                    set offset(_) {
                        this.effect.uniforms.get("offset").value = _
                    }
                },
                Ak = class extends AD {
                    constructor(_) {
                        super(Am, _)
                    }
                    set focalLength(_) {
                        this.effect.circleOfConfusionMaterial.uniforms.focalLength.value = _
                    }
                    get focalLength() {
                        return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value
                    }
                    set focusDistance(_) {
                        this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value = _
                    }
                    get focusDistance() {
                        return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value
                    }
                    get bokehScale() {
                        return this.effect.bokehScale
                    }
                    set bokehScale(_) {
                        this.effect.bokehScale = _
                    }
                },
                AF = class extends AD {
                    constructor() {
                        super(Ab)
                    }
                    get granularity() {
                        return this.effect.getGranularity()
                    }
                    set granularity(_) {
                        this.effect.setGranularity(_)
                    }
                },
                AU = `#define GLSLIFY 1
varying vec2 vUv;varying vec2 vTexCoords[9];uniform vec2 resolution;void main(){vUv=position.xy*0.5+0.5;vec2 texelSize=vec2(1.0)/resolution;vTexCoords[0]=vUv+vec2(-texelSize.x,-texelSize.y);vTexCoords[1]=vUv+vec2(0.0,-texelSize.y);vTexCoords[2]=vUv+vec2(texelSize.x,-texelSize.y);vTexCoords[3]=vUv+vec2(-texelSize.x,0.0);vTexCoords[4]=vUv+vec2(0.0,0.0);vTexCoords[5]=vUv+vec2(texelSize.x,0.0);vTexCoords[6]=vUv+vec2(-texelSize.x,texelSize.y);vTexCoords[7]=vUv+vec2(0.0,texelSize.y);vTexCoords[8]=vUv+vec2(texelSize.x,texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}`,
                Aj = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;varying vec2 vTexCoords[9];uniform sampler2D inputBuffer;uniform sampler2D historyBuffer;uniform sampler2D velocityBuffer;uniform sampler2D depthBuffer;uniform vec2 resolution;
#define USE_YCOCG
#define USE_CATMULL_ROM
const float feedback_min=0.5;const float feedback_max=0.95;vec3 RGB_YCoCg(vec3 c){return vec3(c.x/4.0+c.y/2.0+c.z/4.0,c.x/2.0-c.z/2.0,-c.x/4.0+c.y/2.0-c.z/4.0);}vec3 YCoCg_RGB(vec3 c){return clamp(vec3(c.x+c.y-c.z,c.x+c.z,c.x-c.y-c.z),vec3(0.0),vec3(1.0));}vec4 sample_color(sampler2D tex,vec2 uv){
#ifdef USE_YCOCG
vec4 c=texture(tex,uv);return vec4(RGB_YCoCg(c.rgb),c.a);
#else
return texture(tex,uv);
#endif
}vec4 sample_catmull_rom(sampler2D tex,vec2 uv,vec2 texSize){vec2 samplePos=uv*texSize;vec2 texPos1=floor(samplePos-0.5)+0.5;vec2 f=samplePos-texPos1;vec2 w0=f*(-0.5+f*(1.0-0.5*f));vec2 w1=1.0+f*f*(-2.5+1.5*f);vec2 w2=f*(0.5+f*(2.0-1.5*f));vec2 w3=f*f*(-0.5+0.5*f);vec2 w12=w1+w2;vec2 offset12=w2/(w1+w2);vec2 texPos0=texPos1-1.0;vec2 texPos3=texPos1+2.0;vec2 texPos12=texPos1+offset12;texPos0/=texSize;texPos3/=texSize;texPos12/=texSize;vec4 result=vec4(0.0);result+=texture2D(tex,vec2(texPos12.x,texPos0.y))*w12.x*w0.y;result+=texture2D(tex,vec2(texPos0.x,texPos12.y))*w0.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos12.y))*w12.x*w12.y;result+=texture2D(tex,vec2(texPos3.x,texPos12.y))*w3.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos3.y))*w12.x*w3.y;return result;}vec3 choose_motion_vector(){
#ifdef CHOOSE_LONGEST_MOTION_VECTOR
float longest=-1.0;vec3 v_choose=vec3(-1.0);for(int i=0;i<9;i++){vec3 v=texture2D(velocityBuffer,vTexCoords[i]).rgb;float l=length(v.xy);if(l>longest){longest=l;v_choose=v;}}return v_choose;
#else
float closest_depth=1000.0;vec2 closest_uv_offset=vec2(0.0);for(int i=0;i<9;i++){float neighbor_depth=texture2D(depthBuffer,vTexCoords[i]).r;if(neighbor_depth<closest_depth){closest_uv_offset=vTexCoords[i];closest_depth=neighbor_depth;}}return texture2D(velocityBuffer,closest_uv_offset).rgb;
#endif
}vec4 clipAabb(vec3 aabb_min,vec3 aabb_max,vec4 avg,vec4 input_texel){const float FLT_EPS=0.00000001;vec3 p_clip=0.5*(aabb_max+aabb_min);vec3 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=input_texel-vec4(p_clip,avg.w);vec3 v_unit=v_clip.xyz/e_clip;vec3 a_unit=abs(v_unit);float ma_unit=max(a_unit.x,max(a_unit.y,a_unit.z));if(ma_unit>1.0){return vec4(p_clip,avg.w)+v_clip/ma_unit;}else{return input_texel;}}vec3 clip_aabb_variance(in vec3 cOld,in vec3 cNew,in vec3 centre,in vec3 halfSize){if(all(lessThanEqual(abs(cOld-centre),halfSize))){return cOld;}vec3 dir=(cNew-cOld);vec3 near=centre-sign(dir)*halfSize;vec3 tAll=(near-cOld)/dir;float t=0.0001;for(int i=0;i<3;i++){if(tAll[i]>=0.0&&tAll[i]<t){t=tAll[i];}}if(t>=0.0001){return cOld;}return cOld+dir*t;}void main(){vec3 v=choose_motion_vector();vec2 velocity=v.rg;vec2 previousPixelPos=vUv-velocity;vec4 currentColor=sample_color(inputBuffer,vUv);
#ifdef USE_CATMULL_ROM
vec4 previousColor=sample_catmull_rom(historyBuffer,previousPixelPos,resolution);
#else
vec4 previousColor=sample_color(historyBuffer,previousPixelPos);
#endif
#ifdef USE_YCOCG
previousColor=vec4(RGB_YCoCg(previousColor.rgb),previousColor.a);
#endif
vec4 ctl=sample_color(inputBuffer,vTexCoords[0]);vec4 ctc=sample_color(inputBuffer,vTexCoords[1]);vec4 ctr=sample_color(inputBuffer,vTexCoords[2]);vec4 cml=sample_color(inputBuffer,vTexCoords[3]);vec4 cmc=sample_color(inputBuffer,vTexCoords[4]);vec4 cmr=sample_color(inputBuffer,vTexCoords[5]);vec4 cbl=sample_color(inputBuffer,vTexCoords[6]);vec4 cbc=sample_color(inputBuffer,vTexCoords[7]);vec4 cbr=sample_color(inputBuffer,vTexCoords[8]);vec4 cmin=min(ctl,min(ctc,min(ctr,min(cml,min(cmc,min(cmr,min(cbl,min(cbc,cbr))))))));vec4 cmax=max(ctl,max(ctc,max(ctr,max(cml,max(cmc,max(cmr,max(cbl,max(cbc,cbr))))))));vec4 cavg=(ctl+ctc+ctr+cml+cmc+cmr+cbl+cbc+cbr)/9.0;vec4 cmin5=min(ctc,min(cml,min(cmc,min(cmr,cbc))));vec4 cmax5=max(ctc,max(cml,max(cmc,max(cmr,cbc))));vec4 cavg5=(ctc+cml+cmc+cmr+cbc)/5.0;cmin=0.5*(cmin+cmin5);cmax=0.5*(cmax+cmax5);cavg=0.5*(cavg+cavg5);
#ifdef USE_YCOCG
vec2 chroma_extent=vec2(0.25*0.5*(cmax.r-cmin.r));vec2 chroma_center=currentColor.gb;cmin.yz=chroma_center-chroma_extent;cmax.yz=chroma_center+chroma_extent;cavg.yz=chroma_center;
#endif
vec4 previousColorClipped=clamp(previousColor,cmin,cmax);
#ifdef LUMINANCE_DIFFERENCES
#ifdef USE_YCOCG
float lum0=currentColor.r;float lum1=previousColorClipped.r;
#else
float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColorClipped.rgb);
#endif
float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.0-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedback_min,feedback_max,unbiased_weight_sqr);vec4 result=mix(currentColor,previousColorClipped,vec4(k_feedback));
#else
const float alpha=0.1;vec4 result=mix(currentColor,previousColorClipped,1.0-alpha);
#endif
#ifdef USE_YCOCG
gl_FragColor=vec4(YCoCg_RGB(result.rgb).rgb,result.a);
#else
gl_FragColor=result;
#endif
}`,
                AG = `#define GLSLIFY 1
varying vec2 vUv;void main(){gl_Position=vec4(position.xy,1.0,1.0);vUv=position.xy*0.5+0.5;}`,
                AH = `#define GLSLIFY 1
layout(location=1)out vec4 gVelocity;varying vec2 vUv;uniform sampler2D inputBuffer;void main(){gl_FragColor=texture2D(inputBuffer,vUv);gVelocity=vec4(0.0);}`,
                AW = class extends an {
                    constructor() {
                        super({
                            name: "PassthroughMaterial",
                            uniforms: {
                                inputBuffer: new l_(null)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            vertexShader: AG,
                            fragmentShader: AH
                        })
                    }
                    set inputBuffer(_) {
                        this.uniforms.inputBuffer.value = _
                    }
                },
                Aq = class extends SX {
                    constructor() {
                        super("TAAResolvePass"), this.MRTCompatible = !0, this.needsSwap = !1, this.passThroughMaterial = new AW, this.resolutionVector = new iJ, this.resolveMaterial = new an({
                            name: "TAAResolveMaterial",
                            uniforms: {
                                inputBuffer: new l_(null),
                                historyBuffer: new l_(null),
                                velocityBuffer: new l_(null),
                                depthBuffer: new l_(null),
                                resolution: new l_(new iJ)
                            },
                            blending: 0,
                            depthWrite: !1,
                            depthTest: !1,
                            vertexShader: AU,
                            fragmentShader: Aj
                        }), this.historyRenderTarget = new rh(1024, 1024, {
                            minFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.historyRenderTarget.texture.name = "TAA.History", this.resultRenderTarget = new rh(1024, 1024, {
                            minFilter: 1006,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }), this.resultRenderTarget.texture.name = "TAA.Output"
                    }
                    setSize(_, O) {
                        this.historyRenderTarget.setSize(_, O), this.resultRenderTarget.setSize(_, O)
                    }
                    render(_, O) {
                        this.fullscreenMaterial = this.resolveMaterial, this.resolveMaterial.uniforms.inputBuffer.value = O.texture[0], this.resolveMaterial.uniforms.velocityBuffer.value = O.texture[1], this.resolveMaterial.uniforms.depthBuffer.value = O.depthTexture, this.resolveMaterial.uniforms.historyBuffer.value = this.historyRenderTarget.texture, this.resolveMaterial.uniforms.resolution.value.set(O.width, O.height), _.setRenderTarget(this.resultRenderTarget), _.render(this.scene, this.camera), this.fullscreenMaterial = this.passThroughMaterial, this.passThroughMaterial.inputBuffer = this.resultRenderTarget.texture, _.setRenderTarget(this.historyRenderTarget), _.render(this.scene, this.camera);
                        let B = this.renderToScreen ? null : O;
                        this.fullscreenMaterial = this.passThroughMaterial, this.passThroughMaterial.inputBuffer = this.resultRenderTarget.texture, _.setRenderTarget(B), _.render(this.scene, this.camera)
                    }
                    dispose() {
                        this.resultRenderTarget.dispose(), this.historyRenderTarget.dispose(), this.resolveMaterial.dispose(), this.passThroughMaterial.dispose()
                    }
                },
                AY = class extends SX {
                    constructor(_, O, B) {
                        super("TransmissionPass", void 0, O), this.MRTCompatible = !0, this.depthPass = new S3(_, O, {
                            renderTarget: B.transmissionDepthTarget
                        }), this.passThroughMaterial = new AW, this.splineScene = _, this.needsSwap = !1
                    }
                    updatePasses(_) {
                        this.passThroughMaterial = new AW, this.depthPass = new S3(this.splineScene, this.camera, {
                            renderTarget: _.transmissionDepthTarget
                        })
                    }
                    setCamera(_) {
                        this.camera = _
                    }
                    setScene(_) {
                        this.splineScene = _
                    }
                    render(_, O, B) {
                        let N = this.camera.layers.mask;
                        _.setRenderTarget(_.transmissionRenderTarget), this.fullscreenMaterial = this.passThroughMaterial, this.passThroughMaterial.inputBuffer = O.texture[0], _.clear(), _.render(this.scene, this.camera), this.camera.layers.disable(3), this.depthPass.render(_, O, B), _.shadowMap.needsUpdate = !1, _.shadowMap.autoUpdate = !1;
                        let k = this.renderToScreen ? null : O;
                        this.camera.layers.set(3), _.setRenderTarget(k), _.render(this.splineScene, this.camera), this.camera.layers.mask = N
                    }
                },
                AX = new nS,
                AQ = new an({
                    transparent: !0,
                    vertexShader: `
        void main() {
            gl_Position = vec4(0.0);
        }
    `,
                    fragmentShader: `
        layout(location = 1) out vec4 gVelocity;

        void main() {
            gl_FragColor = vec4(0.0);
			gVelocity = vec4(0.0);
        }
    `
                }),
                AZ = class extends SX {
                    constructor(_, O, B) {
                        super("OpaquePass", O ? ? AX, B), this.MRTCompatible = !0, this.hasTransmissionPass = !1, this.clear = !0, this.clearColorOnly = !1, this.clearDepth = !1, this.needsSwap = !1, this.originalMaterials = new Map, this.MRTCompatible = _
                    }
                    set splatViewer(_) {
                        this._splatViewer = _
                    }
                    get splatViewer() {
                        return this._splatViewer
                    }
                    setCamera(_) {
                        this.camera = _
                    }
                    setScene(_) {
                        this.scene = _ ? ? AX
                    }
                    getScene() {
                        return this.scene
                    }
                    render(_, O) {
                        this.camera.layers.enable(3), this.hasTransmissionPass && (this.originalMaterials.clear(), this.scene.traverse(_ => {
                            _.layers.isEnabled(3) && _ instanceof xK && (this.originalMaterials.set(_.id, _.material), _.material = AQ)
                        }), _.shadowMap.needsUpdate = !0, _.shadowMap.autoUpdate = !0), this.camera.layers.enable(8);
                        let B = this.renderToScreen ? null : O;
                        if (_.setRenderTarget(B), this.clearColorOnly && _.clear(!0, !1, !0), this.clear && _.clear(), this._splatViewer ? .splatRenderingInitialized === !0) {
                            let O = _.autoClear;
                            _.autoClear = !1, _.render(this.scene, this.camera), this._splatViewer.update(), _.render(this._splatViewer.splatMesh, this.camera), _.autoClear = O
                        } else _.render(this.scene, this.camera);
                        this.clearDepth && _.clear(!1, !0, !1), this.hasTransmissionPass && this.originalMaterials.forEach((_, O) => {
                            let B = this.scene.getObjectById(O);
                            B && (B.material = _)
                        })
                    }
                },
                AK = class {
                    constructor(_, {
                        depthBuffer: O = !0,
                        stencilBuffer: B = !1,
                        multisampling: N = 0,
                        frameBufferType: k = 0
                    } = {}) {
                        this.renderer = _, this.helperStartIndex = 0, this.copyPass = new SQ, this.depthTexture = null, this.timer = new Ao, this._width = 1, this._height = 1, this.passes = [], this.helperPasses = [], this.autoRenderToScreen = !0, this.inputBuffer = this.createBuffer(O, B, k, N, !0, "input buffer mrt"), this.inputBufferSingle = this.createBuffer(O, B, k, N, !1, " input buffer single"), this.inputBufferSingle.texture.dispose(), this.inputBufferSingle.depthTexture.dispose(), this.inputBufferSingle.texture = this.inputBuffer.texture[0], this.inputBufferSingle.depthTexture = this.inputBuffer.depthTexture, this.outputBuffer = this.inputBuffer.clone(), this.outputBuffer.name = "output buffer mrt", this.outputBufferSingle = this.createBuffer(O, B, k, N, !1, "output buffer single"), this.outputBufferSingle.texture.dispose(), this.outputBufferSingle.depthTexture.dispose(), this.outputBufferSingle.texture = this.outputBuffer.texture[0], this.outputBufferSingle.depthTexture = this.outputBuffer.depthTexture, this.setRenderer(_)
                    }
                    get multisampling() {
                        return this.inputBuffer.samples || 0
                    }
                    set multisampling(_) {
                        let O = this.inputBuffer,
                            B = this.multisampling;
                        B > 0 && _ > 0 ? (this.inputBuffer.samples = _, this.outputBuffer.samples = _, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : B !== _ && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), console.log("creating new input buffer"), this.inputBuffer = this.createBuffer(O.depthBuffer, O.stencilBuffer, O.texture.type, _, !0, "new input buffer"), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
                    }
                    getTimer() {
                        return this.timer
                    }
                    getRenderer() {
                        return this.renderer
                    }
                    setRenderer(_) {
                        if (this.renderer = _, null !== _) {
                            let O = _.getSize(new iJ),
                                B = _.getContext().getContextAttributes() ? .alpha ? ? !1,
                                N = this.inputBuffer.texture[0].type;
                            for (let k of (1009 === N && 3001 === _.outputEncoding && (this.inputBuffer.texture[0].encoding = 3001, this.outputBuffer.texture[0].encoding = 3001, this.inputBuffer.dispose(), this.outputBuffer.dispose(), console.log("doing some kinda dispose??")), _.autoClear = !1, this.setSize(O.width, O.height, !1), this.passes)) k.initialize(_, B, N)
                        }
                    }
                    replaceRenderer(_, O = !0) {
                        let B = this.renderer,
                            N = B.domElement.parentNode;
                        return this.setRenderer(_), O && null !== N && (N.removeChild(B.domElement), N.appendChild(_.domElement)), B
                    }
                    createDepthTexture() {
                        let _ = this.depthTexture = new nb(this._width, this._height);
                        return this.inputBuffer.depthTexture = _, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (_.format = 1027, _.type = 1020) : _.type = 1014, _
                    }
                    deleteDepthTexture() {
                        if (null !== this.depthTexture)
                            for (let _ of (this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(), this.passes)) _.setDepthTexture(null)
                    }
                    createBuffer(_, O, B, N, k, F) {
                        let U = this.renderer,
                            j = null === U ? new iJ : U.getDrawingBufferSize(new iJ),
                            G = {
                                minFilter: 1006,
                                magFilter: 1006,
                                wrapS: 1001,
                                wrapT: 1001,
                                stencilBuffer: O,
                                depthBuffer: _
                            },
                            Y;
                        return N > 0 ? (Y = new rh(j.width, j.height, G)).samples = N : (k ? (Y = new rf(j.width, j.height, 2, G)).texture[1].type = 1016 : Y = new rh(j.width, j.height, G), Y.depthTexture = new nb(2048, 2048), Y.depthTexture.type = 1015), 1009 === B && null !== U && 3001 === U.outputEncoding && (Array.isArray(Y.texture) ? Y.texture.forEach(_ => _.encoding = 3001) : Y.texture.encoding = 3001), Array.isArray(Y.texture) ? Y.texture.forEach((_, O) => {
                            _.name = `EffectComposer.Buffer ${k} ${O}`, _.generateMipmaps = !1
                        }) : (Y.texture.name = `EffectComposer.Buffer ${k}`, Y.texture.generateMipmaps = !1), Y.name = F, Y
                    }
                    addPass(_, O) {
                        let B = this.passes,
                            N = this.renderer,
                            k = N.getDrawingBufferSize(new iJ),
                            F = N.getContext().getContextAttributes() ? .alpha ? ? !1,
                            U;
                        if (_.MRTCompatible && (U = this.inputBuffer.texture[0].type), _.MRTCompatible || (U = this.inputBuffer.texture.type), _.setRenderer(N), _.setSize(k.width, k.height), _.initialize(N, F, U), this.autoRenderToScreen && (B.length > 0 && (B[B.length - 1].renderToScreen = !1), _.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== O ? B.splice(O, 0, _) : B.push(_), this.autoRenderToScreen && (B[B.length - 1].renderToScreen = !0), _.needsDepthTexture || null !== this.depthTexture) {
                            if (null === this.depthTexture) {
                                let O = this.createDepthTexture();
                                for (_ of B) _.setDepthTexture(O)
                            } else _.setDepthTexture(this.depthTexture)
                        }
                    }
                    setHelperStartIndex(_) {
                        this.helperStartIndex = _
                    }
                    removePass(_) {
                        let O = this.passes,
                            B = O.indexOf(_); - 1 !== B && O.splice(B, 1).length > 0 && (null !== this.depthTexture && (O.reduce((_, O) => _ || O.needsDepthTexture, !1) || (_.getDepthTexture() === this.depthTexture && _.setDepthTexture(null), this.deleteDepthTexture())), this.autoRenderToScreen && B === O.length && (_.renderToScreen = !1, O.length > 0 && (O[O.length - 1].renderToScreen = !0)))
                    }
                    removeAllPasses() {
                        let _ = this.passes;
                        this.deleteDepthTexture(), _.length > 0 && (this.autoRenderToScreen && (_[_.length - 1].renderToScreen = !1), this.passes = [])
                    }
                    render(_) {
                        let O = this.renderer,
                            B = this.copyPass,
                            N = this.inputBuffer,
                            k = this.outputBuffer,
                            F = this.inputBufferSingle,
                            U = this.outputBufferSingle,
                            j = !1,
                            G, Y, Q, K;
                        for (let $ of (void 0 === _ && (_ = this.timer.update().getDelta()), this.passes)) $.enabled && ($.MRTCompatible ? $.render(O, N, k, _, j) : $.render(O, F, U, _, j), $.needsSwap && (j && (B.renderToScreen = $.renderToScreen, G = O.getContext(), (Y = O.state.buffers.stencil).setFunc(G.NOTEQUAL, 1, 4294967295), B.render(O, N, k, _, j), Y.setFunc(G.EQUAL, 1, 4294967295)), Q = N, K = F, N = k, F = U, k = Q, U = K), $ instanceof As ? j = !0 : $ instanceof SZ && (j = !1))
                    }
                    setSize(_, O, B) {
                        let N = this.renderer;
                        if (this._width = _, this._height = O, void 0 === _ || void 0 === O) {
                            let B = N.getSize(new iJ);
                            _ = B.width, O = B.height
                        }
                        N.setSize(_, O, B);
                        let k = N.getDrawingBufferSize(new iJ);
                        for (let _ of (this.inputBuffer.setSize(k.width, k.height), this.outputBuffer.setSize(k.width, k.height), this.inputBufferSingle.setSize(k.width, k.height), this.outputBufferSingle.setSize(k.width, k.height), this.passes)) _.setSize(k.width, k.height)
                    }
                    reset() {
                        let _ = this.timer.isAutoResetEnabled();
                        this.dispose(), this.autoRenderToScreen = !0, this.timer.setAutoResetEnabled(_)
                    }
                    dispose() {
                        for (let _ of this.passes) _.dispose();
                        this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), null !== this.inputBufferSingle && this.inputBufferSingle.dispose(), null !== this.outputBufferSingle && this.outputBufferSingle.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose()
                    }
                },
                AJ = new an({
                    name: "CombineMaterial",
                    uniforms: {
                        inputBufferA: new l_(null),
                        inputBufferB: new l_(null)
                    },
                    blending: 0,
                    depthWrite: !1,
                    depthTest: !1,
                    vertexShader: `
varying vec2 vUv;
void main() {
    gl_Position = vec4(position.xy, 1.0, 1.0);
    vUv = position.xy * 0.5 + 0.5;
}
`,
                    fragmentShader: `
    varying vec2 vUv;
    uniform sampler2D inputBufferA;
    uniform sampler2D inputBufferB;

    // TODO: Why do we need these when postpro of framemode is enabled???
    layout(location = 1) out vec4 gVelocity;

    void main() {
	vec4 resA = texture2D(inputBufferA, vUv);
	vec4 resB = texture2D(inputBufferB, vUv);
    float a = resA.a + resB.a * ( 1.0 - resA.a );

	vec4 res;
	res.rgb =  resA.rgb + (resB.rgb * (1.0 - resA.a));
	res.a = resA.a + resB.a * (1.0 - resA.a);
	gl_FragColor = res;
    gVelocity = vec4(0.0);
    }
`
                }),
                A$ = class extends SX {
                    constructor(_) {
                        super("HelperPass", void 0, _), this.MRTCompatible = !1, this.fullscreenMaterial = AJ, this.helperPass = new AZ(!1, void 0, this.camera), this.helperPass.hasTransmissionPass = !1, this.helperPass.clear = !1, this.helperPass.renderToScreen = !1, this.helperPassOnTop = new AZ(!1, void 0, this.camera), this.helperPassOnTop.hasTransmissionPass = !1, this.helperPassOnTop.clear = !1, this.helperPassOnTop.renderToScreen = !1;
                        let O = new AA({
                            preset: AS.LOW,
                            edgeDetectionMode: SO.COLOR
                        });
                        this.effectPass = new Ae(this.camera, O), this.rt = new rh(10, 10, {
                            minFilter: 1006,
                            magFilter: 1006,
                            wrapS: 1001,
                            wrapT: 1001,
                            depthBuffer: !0
                        })
                    }
                    setSize(_, O) {
                        this.rt.setSize(_, O), this.effectPass.setSize(_, O)
                    }
                    set sceneHelpers(_) {
                        this.helperPass.setScene(_)
                    }
                    get sceneHelpers() {
                        return this.helperPass.getScene()
                    }
                    set sceneHelpersOnTop(_) {
                        this.helperPassOnTop.setScene(_)
                    }
                    get sceneHelpersOnTop() {
                        return this.helperPassOnTop.getScene()
                    }
                    setCamera(_) {
                        this.helperPass.setCamera(_), this.helperPassOnTop.setCamera(_)
                    }
                    initialize(_, O, B) {
                        super.initialize(_, O, B), this.effectPass.initialize(_, O, B)
                    }
                    dispose() {
                        super.dispose(), this.rt.dispose(), this.effectPass.dispose()
                    }
                    render(_, O, B) {
                        this.rt.depthTexture = O.depthTexture;
                        let N = _.getClearAlpha();
                        _.setClearAlpha(0), this.helperPass.clearDepth = !0, this.helperPass.clearColorOnly = !0, this.helperPass.render(_, this.rt), this.helperPassOnTop.render(_, this.rt), this.effectPass.renderToScreen = !1, this.effectPass.render(_, this.rt, B), this.fullscreenMaterial.uniforms.inputBufferA.value = B.texture, this.fullscreenMaterial.uniforms.inputBufferB.value = O.texture, _.setClearAlpha(N), _.setRenderTarget(null), _.clear(), _.render(this.scene, this.camera)
                    }
                },
                A0 = `#define GLSLIFY 1
#include <skinning_pars_vertex>
out vec3 n;void main(){
#include <beginnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <skinning_vertex>
vec4 view_space=viewMatrix*modelMatrix*vec4(transformed,1.0);gl_Position=projectionMatrix*view_space;n=normalize(transformedNormal);}`,
                A2 = `#define GLSLIFY 1
in vec3 n;void main(){gl_FragColor=vec4(n,1.0);}`,
                A3 = `#define GLSLIFY 1
out vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy,1.0,1.0);}`,
                A4 = `#define GLSLIFY 1
in vec2 v_uv;const float pi=3.14159265;const float num_steps=4.0;const float num_directions=4.0;uniform float near;uniform float far;uniform float fov;uniform vec4 proj_info;uniform bool is_ortho;uniform vec2 resolution;uniform float radius_of_influence;uniform float radius_in_screen_space;uniform float exponent;uniform vec3 ao_color;uniform float bias;uniform sampler2D texture_depth;uniform sampler2D texture_normals;uniform sampler2D texture_blue_noise;uniform sampler2D texture_blue_noise_in_disk;uniform sampler2D texture_color_pass;uniform int frame_index;uniform bool fog_enabled;uniform float fog_near;uniform float fog_far;vec3 uv_to_view_space(vec2 uv,float eye_z){return vec3((uv*proj_info.xy+proj_info.zw)*(is_ortho ? 1.0 : eye_z),eye_z);}float linearize_depth(float depth_sampled){float z=is_ortho ? depth_sampled : depth_sampled*2.0-1.0;return mix((2.0*near*far)/(far+near-z*(far-near)),near+z*(far-near),float(is_ortho));}vec3 get_view_position(vec2 uv_coords){float linear_depth=linearize_depth(texture(texture_depth,uv_coords).x);return uv_to_view_space(uv_coords,linear_depth);}vec3 min_difference(vec3 p,vec3 right,vec3 left){vec3 v1=right-p;vec3 v2=p-left;return(dot(v1,v1)<dot(v2,v2))? v1 : v2;}vec3 rebuild_normal(in vec2 uv,in vec3 p){vec2 one_over_resolution=1.0/resolution;vec3 r=get_view_position(uv+vec2(one_over_resolution.x,0));vec3 l=get_view_position(uv+vec2(-one_over_resolution.x,0));vec3 t=get_view_position(uv+vec2(0,one_over_resolution.y));vec3 b=get_view_position(uv+vec2(0,-one_over_resolution.y));return normalize(cross(min_difference(p,r,l),min_difference(p,t,b)));}float falloff(float distance_squared){float neg_inv_r2=-1.0/(radius_of_influence*radius_of_influence);return distance_squared*neg_inv_r2+1.0;}float ao_contribution(vec3 P,vec3 N,vec3 S){vec3 to_sample=S-P;float norm_squared=dot(to_sample,to_sample);float norm=sqrt(norm_squared);float cos_theta=dot(N,to_sample)/norm;return clamp(cos_theta-bias,0.0,1.0)*clamp(falloff(norm_squared),0.0,1.0);}float compute_ambient_occlusion(vec2 uv,float radius_in_screen_space,vec3 pc,vec3 view_space_n){vec2 one_over_resolution=1.0/resolution;ivec2 noise_uv=ivec2(int(mod(gl_FragCoord.x,128.0)),int(mod(gl_FragCoord.y,128.0)));float noise=texelFetch(texture_blue_noise,noise_uv,0).r;noise=fract(noise+0.61803398875*float(frame_index));float theta=noise*2.0*3.1415;float ct=cos(theta);float st=sin(theta);float step_size=radius_in_screen_space/(num_steps+1.0);const float angle_step=2.0*pi/num_directions;float contribution=0.0;for(int i=0;i<int(num_directions);++i){float current_pixel=step_size+1.0;for(int j=0;j<int(num_steps);++j){int index=i*int(num_steps)+j;vec2 blue_noise_sample=texelFetch(texture_blue_noise_in_disk,ivec2(index,0),0).rg;vec2 disk_point;disk_point.x=blue_noise_sample.x*ct-blue_noise_sample.y*st;disk_point.y=blue_noise_sample.x*st+blue_noise_sample.y*ct;vec2 sample_direction=disk_point;vec2 snapped_uv=round(current_pixel*sample_direction)*one_over_resolution+uv;vec3 ps=get_view_position(snapped_uv);current_pixel+=step_size;contribution+=ao_contribution(pc,view_space_n,ps);}}float mult=1.0/(1.0-bias);contribution*=mult/(num_directions*num_steps);return clamp(1.0-contribution*2.0,0.0,1.0);}
#define USE_GBUFFER_NORMALS
void main(){vec3 view_space_p=get_view_position(v_uv);
#ifdef USE_GBUFFER_NORMALS
vec3 view_space_n=texture(texture_normals,v_uv).rgb;view_space_n.z*=-1.0;
#else
vec3 view_space_n=-rebuild_normal(v_uv,view_space_p);
#endif
float radius_ss=radius_in_screen_space/(is_ortho ? 1.0 : view_space_p.z);float ao=compute_ambient_occlusion(v_uv,radius_ss,view_space_p,view_space_n);float final=pow(ao,exponent);if(view_space_p.z>=far){final=1.0;}vec3 color=mix(ao_color,vec3(1.0),final);if(fog_enabled){float fog_factor=smoothstep(fog_near,fog_far,view_space_p.z);color=mix(color,vec3(1.0),fog_factor);}gl_FragColor=vec4(color,1.0);}`,
                A5 = `#define GLSLIFY 1
out vec2 v_uv;void main(){gl_Position=vec4(position.xy,1.0,1.0);v_uv=uv;}`,
                A6 = `#define GLSLIFY 1
in vec2 v_uv;uniform sampler2D texture_ao_lrez;uniform sampler2D texture_depth_lrez;uniform sampler2D texture_depth_hrez;uniform float near;uniform float far;float linearize_depth(float depth_sampled){float z=depth_sampled*2.0-1.0;return(2.0*near*far)/(far+near-z*(far-near));}vec2 nearest_depth_filter(in vec2 uv){vec2 resolution=vec2(textureSize(texture_depth_lrez,0));vec2 texel_size=1.0/resolution;vec2 offset=uv-0.5*texel_size;float d_hrez=texture(texture_depth_hrez,uv).r;float a=abs(d_hrez-texture(texture_depth_lrez,offset).r);float b=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,0.0)).r);float c=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(0.0,texel_size.y)).r);float d=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,texel_size.y)).r);float min_diff=min(a,min(b,min(c,d)));if(min_diff==a)return offset;if(min_diff==b)return offset+vec2(texel_size.x,0.0);if(min_diff==c)return offset+vec2(0.0,texel_size.y);if(min_diff==d)return offset+vec2(texel_size.x,texel_size.y);}void main(){
#ifdef DEBUG
float d_lrez=texture(texture_depth_lrez,v_uv).r;float d_hrez=texture(texture_depth_hrez,v_uv).r;float output_d=mix(linearize_depth(d_lrez)/far,linearize_depth(d_hrez)/far,step(0.5,v_uv.x));gl_FragColor=vec4(vec3(output_d),1.0);
#else
vec2 filtered_uv=nearest_depth_filter(v_uv);vec4 ao=texture(texture_ao_lrez,filtered_uv);gl_FragColor=vec4(ao.rgb,1.0);gl_FragColor=ao;
#endif
}`,
                A8 = [
                    [.478712, .875764],
                    [-.337956, -.793959],
                    [-.955259, -.028164],
                    [.864527, .325689],
                    [.209342, -.395657],
                    [-.106779, .672585],
                    [.156213, .235113],
                    [-.413644, -.082856],
                    [-.415667, .323909],
                    [.141896, -.93998],
                    [.954932, -.182516],
                    [-.766184, .410799],
                    [-.434912, -.458845],
                    [.415242, -.078724],
                    [.728335, -.491777],
                    [-.058086, -.066401],
                    [.20299, .686837],
                    [-.808362, -.556402],
                    [.507386, -.640839],
                    [-.723494, -.22924],
                    [.48974, .317826],
                    [-.622663, .765301],
                    [-.01064, .929347],
                    [.663146, .647618],
                    [-.096674, -.413835],
                    [.525945, -.321063],
                    [-.122533, .366019],
                    [.195235, -.687983],
                    [-.563203, .098748],
                    [.418563, .561335],
                    [-.378595, .800367],
                    [.826922, .001024],
                    [-.085372, -.766651],
                    [-.92192, .183673],
                    [-.590008, -.721799],
                    [.167751, -.164393],
                    [.032961, -.56253],
                    [.6329, -.107059],
                    [-.46408, .569669],
                    [-.173676, -.958758],
                    [-.242648, -.234303],
                    [-.275362, .157163],
                    [.382295, -.795131],
                    [.562955, .115562],
                    [.190586, .470121],
                    [.770764, -.297576],
                    [.237281, .93105],
                    [-.666642, -.455871],
                    [-.905649, -.298379],
                    [.33952, .157829],
                    [.701438, -.7041],
                    [-.062758, .160346],
                    [-.220674, .957141],
                    [.642692, .432706],
                    [-.77339, -.015272],
                    [-.671467, .24688],
                    [.158051, .062859],
                    [.806009, .527232],
                    [-.05762, -.247071],
                    [.333436, -.51671],
                    [-.550658, -.315773],
                    [-.652078, .589846],
                    [.008818, .530556],
                    [-.210004, .519896]
                ],
                A9 = new an({
                    vertexShader: A0,
                    fragmentShader: A2
                }),
                A7 = new an({
                    vertexShader: A5,
                    fragmentShader: A6,
                    uniforms: {
                        texture_ao_lrez: new l_(null),
                        texture_depth_lrez: new l_(null),
                        texture_depth_hrez: new l_(null),
                        near: new l_(null),
                        far: new l_(null)
                    }
                }),
                Mt = class extends SX {
                    constructor(_, O) {
                        super("AmbientOcclusionPass", void 0, O), this.fogEnabled = !1, this.fogNear = 1, this.fogFar = 1e3, this.frameIndex = 0, this._runHalfRes = !0, this._width = 1, this._height = 1, this.gBuffer = new rh(1024, 1024, {
                            type: 1015,
                            depthTexture: new nb(1024, 1024),
                            minFilter: 1006,
                            magFilter: 1006
                        }), this.depthBufferHighRes = new rh(1024, 1024, {
                            depthTexture: new nb(1024, 1024)
                        }), this.aoBuffer = new rh(1024, 1024, {
                            minFilter: 1006,
                            magFilter: 1006
                        }), this.splineScene = _, this.splineCamera = O;
                        let B = new Float32Array(2 * A8.length);
                        for (let _ = 0; _ < A8.length; _++) {
                            let O = 2 * _;
                            B[O + 0] = A8[_][0], B[O + 1] = A8[_][1]
                        }
                        this.blueNoiseInDiskTexture = new nI(B, A8.length, 1, 1030, 1015), this.blueNoiseInDiskTexture.wrapS = 1e3, this.blueNoiseInDiskTexture.wrapT = 1e3, this.blueNoiseInDiskTexture.needsUpdate = !0, this.hbaoMaterial = new an({
                            vertexShader: A3,
                            fragmentShader: A4,
                            uniforms: {
                                near: new l_(null),
                                far: new l_(null),
                                fov: new l_(null),
                                proj_info: new l_(new rl),
                                is_ortho: new l_(!1),
                                resolution: new l_(new iJ),
                                radius_of_influence: new l_(8),
                                radius_in_screen_space: new l_(1),
                                exponent: new l_(1),
                                ao_color: new l_(new rv),
                                bias: new l_(.5),
                                texture_depth: new l_(null),
                                texture_normals: new l_(null),
                                texture_blue_noise: new l_(null),
                                texture_blue_noise_in_disk: new l_(this.blueNoiseInDiskTexture),
                                frame_index: new l_(0),
                                fog_enabled: new l_(!1),
                                fog_near: new l_(1),
                                fog_far: new l_(1e3)
                            }
                        }), this.radius = 128, this.aoColor = {
                            r: 0,
                            g: 0,
                            b: 0
                        }, this.bias = .5, this.hbaoMaterial.uniforms.texture_depth.value = this.gBuffer.depthTexture, this.hbaoMaterial.uniforms.texture_normals.value = this.gBuffer.texture, this.needsSwap = !0, this.aaBuffer = new rh(1024, 1024, {
                            minFilter: 1006,
                            magFilter: 1006,
                            wrapS: 1001,
                            wrapT: 1001,
                            depthBuffer: !1,
                            type: 1015
                        });
                        let N = new AA({
                            preset: AS.ULTRA,
                            edgeDetectionMode: SO.COLOR
                        });
                        this.effectPass = new Ae(this.camera, N)
                    }
                    initialize(_, O, B) {
                        super.initialize(_, O, B), this.effectPass.initialize(_, O, B)
                    }
                    setBlueNoiseTexture(_) {
                        this.hbaoMaterial.uniforms.texture_blue_noise.value = _
                    }
                    setSize(_, O) {
                        this._width = _, this._height = O, this.depthBufferHighRes.setSize(_, O);
                        let B = this._runHalfRes ? .5 : 1,
                            N = _ * B,
                            k = O * B;
                        this.gBuffer.setSize(N, k), this.aoBuffer.setSize(N, k), this.hbaoMaterial.uniforms.resolution.value.set(N, k), this.aaBuffer.setSize(N, k), this.effectPass.setSize(N, k)
                    }
                    get runHalfRes() {
                        return this._runHalfRes
                    }
                    set runHalfRes(_) {
                        this._runHalfRes = _, this.setSize(this._width, this._height)
                    }
                    setCamera(_) {
                        this.splineCamera = _
                    }
                    setScene(_) {
                        this.splineScene = _
                    }
                    render(_, O, B) {
                        this.splineScene.overrideMaterial = A9;
                        let N = this.splineCamera.layers.mask;
                        if (this.splineCamera.layers.set(5), _.setRenderTarget(this.gBuffer), _.clear(), _.render(this.splineScene, this.splineCamera), _.setRenderTarget(this.depthBufferHighRes), _.clear(), _.render(this.splineScene, this.splineCamera), this.splineScene.overrideMaterial = null, this.splineCamera.layers.mask = N, this.hbaoMaterial.uniforms.radius_of_influence.value = this.radius, this.hbaoMaterial.uniforms.ao_color.value.set(this.aoColor.r, this.aoColor.g, this.aoColor.b), this.hbaoMaterial.uniforms.bias.value = this.bias, this.hbaoMaterial.uniforms.fog_enabled.value = this.fogEnabled, this.hbaoMaterial.uniforms.fog_near.value = this.fogNear, this.hbaoMaterial.uniforms.fog_far.value = this.fogFar, this.hbaoMaterial.uniforms.frame_index.value = this.frameIndex, this.frameIndex++, this.splineCamera.isPerspectiveCamera) {
                            this.hbaoMaterial.uniforms.near.value = this.splineCamera.perspCamera.near, this.hbaoMaterial.uniforms.far.value = this.splineCamera.perspCamera.far;
                            let _ = this.splineCamera.perspCamera.projectionMatrix.elements,
                                O = 2 / _[0],
                                B = 2 / _[5],
                                N = -(1 - _[8]) / _[0],
                                k = -(1 + _[9]) / _[5];
                            this.hbaoMaterial.uniforms.proj_info.value.set(O, B, N, k);
                            let F = this.splineCamera.perspCamera.fov * (Math.PI / 180),
                                U = this.hbaoMaterial.uniforms.resolution.value.y / (2 * Math.tan(.5 * F)),
                                j = .5 * this.hbaoMaterial.uniforms.radius_of_influence.value * U;
                            this.hbaoMaterial.uniforms.radius_in_screen_space.value = j, this.hbaoMaterial.uniforms.is_ortho.value = !1
                        } else {
                            this.hbaoMaterial.uniforms.near.value = this.splineCamera.orthoCamera.near, this.hbaoMaterial.uniforms.far.value = this.splineCamera.orthoCamera.far;
                            let _ = this.splineCamera.orthoCamera.projectionMatrix.elements,
                                O = 2 / _[0],
                                B = 2 / _[5],
                                N = -(1 + _[12]) / _[0],
                                k = -(1 - _[13]) / _[5];
                            this.hbaoMaterial.uniforms.proj_info.value.set(O, B, N, k);
                            let F = .5 * (this.hbaoMaterial.uniforms.resolution.value.y / B),
                                U = this.hbaoMaterial.uniforms.radius_of_influence.value * F;
                            this.hbaoMaterial.uniforms.radius_in_screen_space.value = U, this.hbaoMaterial.uniforms.is_ortho.value = !0
                        }
                        this.runHalfRes ? (this.fullscreenMaterial = this.hbaoMaterial, _.setRenderTarget(this.aoBuffer), _.clear(), _.render(this.scene, this.camera), this.fullscreenMaterial = A7, A7.uniforms.texture_ao_lrez.value = this.aoBuffer.texture, A7.uniforms.texture_depth_lrez.value = this.gBuffer.depthTexture, A7.uniforms.texture_depth_hrez.value = this.depthBufferHighRes.depthTexture, _.setRenderTarget(_.aoRenderTarget), _.clear(), _.render(this.scene, this.camera)) : (this.fullscreenMaterial = this.hbaoMaterial, _.setRenderTarget(this.aaBuffer), _.clear(), _.render(this.scene, this.camera), this.effectPass.renderToScreen = !1, this.effectPass.render(_, this.aaBuffer, _.aoRenderTarget))
                    }
                    dispose() {
                        this.gBuffer.dispose(), this.depthBufferHighRes.dispose(), this.aoBuffer.dispose()
                    }
                },
                Mi = `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
                Ms = `
uniform sampler2D tInput;
uniform sampler2D tMap;
uniform vec2 resolution;
varying vec2 vUv;

uniform vec2 uResolution;
uniform vec2 uCoords;

// Draws a rectangle at center <st> with size <size>
float rectangle(vec2 st, vec2 size) {
    size = vec2(0.5) - size * 0.5;
    vec2 uv = vec2(step(size.x, st.x), step(size.y, st.y));
    uv *= vec2(step(size.x, 1.0 - st.x), step(size.y, 1.0 - st.y));

    return uv.x * uv.y;
}

uniform vec2 uSize;
uniform float uScale;
uniform float uDPR;
uniform float uCurrent;
uniform vec3 uSceneColor;

void main() {
    vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
    screenUv *= 1.0 / uDPR;

    vec2 center = vec2(0.5, -0.5);
    vec2 outsideUv = screenUv;
    outsideUv += center;
    outsideUv -= uCoords.xy / uResolution.xy;
    outsideUv = (outsideUv - 0.5) + 0.5;
    outsideUv -= center;
    vec2 s = (uSize / uResolution) * uScale;
    float isOutside = 1.0 - rectangle(outsideUv, s);
    
    vec2 mid = vec2(0.5);
    vec2 insideUv = (screenUv - mid + s * mid) / s;
    vec4 background = texture2D(tInput, screenUv);
    vec4 image = texture2D(tMap, insideUv);
    gl_FragColor = mix(image, background, isOutside);
}
`,
                Ma = class extends An {
                    constructor() {
                        super(new an({
                            vertexShader: Mi,
                            fragmentShader: Ms,
                            uniforms: {
                                tInput: new l_(null),
                                tMap: new l_(null),
                                uResolution: new l_(new iJ),
                                uSize: new l_(new iJ),
                                uCoords: new l_(new iJ),
                                uScale: new l_(1),
                                uSceneColor: new l_(new re(16711680)),
                                uDPR: new l_(1),
                                uCurrent: new l_(0)
                            }
                        }), "tInput"), this.needsSwap = !0
                    }
                    get uniforms() {
                        return this.fullscreenMaterial.uniforms
                    }
                    get texture() {
                        return this.uniforms.tMap.value
                    }
                    set texture(_) {
                        this.uniforms.tMap.value = _
                    }
                },
                Mn = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
                Mo = `
uniform sampler2D toScene;
uniform sampler2D fromScene;
uniform vec2 resolution;

uniform vec2 uResolution;
uniform float uDPR;

uniform float mixRatio;
uniform sampler2D tMixTexture;
uniform int useTexture;
uniform float threshold;

void main() {
	vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
	screenUv *= 1.0 / uDPR;

	vec4 texel1 = texture2D( fromScene, screenUv );
	vec4 texel2 = texture2D( toScene, screenUv );

	if (useTexture==1) {
		
		vec4 transitionTexel = texture2D( tMixTexture, screenUv );
		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;
		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);
		
		gl_FragColor = mix( texel1, texel2, mixf );
	} else {
		
		gl_FragColor = mix( texel1, texel2, mixRatio );
		
	}
}
`,
                Ml = class extends An {
                    constructor() {
                        super(new an({
                            vertexShader: Mn,
                            fragmentShader: Mo,
                            uniforms: {
                                toScene: new l_(null),
                                fromScene: new l_(null),
                                uResolution: new l_(new iJ),
                                uDPR: new l_(1),
                                mixRatio: new l_(0),
                                threshold: new l_(.1),
                                useTexture: new l_(0),
                                tMixTexture: {
                                    value: [][0]
                                }
                            }
                        }), "toScene"), this.needsSwap = !0
                    }
                    get uniforms() {
                        return this.fullscreenMaterial.uniforms
                    }
                    get texture() {
                        return this.uniforms.fromScene.value
                    }
                    set texture(_) {
                        this.uniforms.fromScene.value = _
                    }
                };

            function BO(_, O) {
                return O && O.enabled && _.push(O.effect), _
            }
            var n7 = _ => Object.values(S4).includes(_) ? _ : S4.NORMAL,
                Mh = class extends iq {
                    constructor(_) {
                        super(), this.postprocessingState = m7.defaultData, this._scene = new nS, this._camera = new Sh, this.effects = new Map, this.blueNoiseTexture = new nI, this._renderToScreen = !0, this.clock = new ls, this.renderer = _, this.debug = !1, this.effects.set("bloom", new AI), this.effects.set("chromaticAberration", new AL), this.effects.set("vignette", new AN), this.effects.set("noise", new Az), this.effects.set("colorAverage", new AR), this.effects.set("hueSaturation", new AB), this.effects.set("brightnessContrast", new AO), this.effects.set("depthOfField", new Ak), this.effects.set("pixelation", new AF), this.effectComposer = new AK(this.renderer), this.effectComposer.autoRenderToScreen = !1, this.opaquePass = new AZ(!0, this.scene, this.camera), this.opaquePass.clear = !0, this.transmissionPass = new AY(this.scene, this.camera, this.renderer), this.aoPass = new Mt(this.scene, this.camera), this.taaPass = new Aq, this.taaPass.renderToScreen = !1, this.helperPass = new A$(this.camera), this.helperPass.renderToScreen = !1, this.overlayPass = new Ma, this.overlayPass.enabled = !1, this.sceneTransitionPass = new Ml, this.sceneTransitionPass.enabled = !1, this._initCopyPass(), this._initPasses()
                    }
                    set overlayTexture(_) {
                        void 0 !== _ ? (this.overlayPass.texture = _, this.overlayPass.enabled = !0) : this.overlayPass.enabled = !1
                    }
                    get overlayTexture() {
                        return this.overlayPass.texture
                    }
                    set sceneHelpers(_) {
                        this.helperPass.sceneHelpers = _
                    }
                    get sceneHelpers() {
                        return this.helperPass.sceneHelpers
                    }
                    set sceneHelpersOnTop(_) {
                        this.helperPass.sceneHelpersOnTop = _
                    }
                    get sceneHelpersOnTop() {
                        return this.helperPass.sceneHelpersOnTop
                    }
                    get scene() {
                        return this._scene
                    }
                    set scene(_) {
                        this._scene = _, this.opaquePass.setScene(_), this.transmissionPass.setScene(_), this.aoPass.setScene(_)
                    }
                    get camera() {
                        return this._camera
                    }
                    set camera(_) {
                        this._camera = _, this.opaquePass.setCamera(_), this.transmissionPass.setCamera(_), this.aoPass.setCamera(_), this.helperPass.setCamera(_)
                    }
                    updateRenderToScreen() {
                        let _ = !1;
                        for (let O = this.effectComposer.passes.length - 1; O >= 0; O--) {
                            let B = this.effectComposer.passes[O];
                            if (!0 === B.enabled && !_ && this._renderToScreen) {
                                B.renderToScreen = !0, _ = !0;
                                continue
                            }
                            B.renderToScreen = !1
                        }
                    }
                    disableHelpers() {
                        this.helperPass.enabled = !1, this.updateRenderToScreen()
                    }
                    enableHelpers() {
                        this.helperPass.enabled = !0, this.updateRenderToScreen()
                    }
                    updateBlueNoiseTexture(_) {
                        this.blueNoiseTexture = new nI(_, 128, 128), this.blueNoiseTexture.wrapS = 1e3, this.blueNoiseTexture.wrapT = 1e3, this.blueNoiseTexture.minFilter = 1003, this.blueNoiseTexture.magFilter = 1003, this.blueNoiseTexture.needsUpdate = !0
                    }
                    setAmbientOcclusionParams(_, O, B, N, k, F, U, j) {
                        this.aoPass.enabled = _, this.aoPass.radius = O, this.aoPass.bias = B, this.aoPass.aoColor = N, this.aoPass.fogEnabled = k, this.aoPass.fogNear = F, this.aoPass.fogFar = U, !j !== this.aoPass.runHalfRes && (this.aoPass.runHalfRes = !j)
                    }
                    setTransmissionPassEnabled(_) {
                        this.transmissionPass.enabled = _, this.opaquePass.hasTransmissionPass = _
                    }
                    _initPasses() {
                        if (this.uvEffectPass ? .dispose(), this.effectPass ? .dispose(), this.effectComposer.removeAllPasses(), this.transmissionPass.updatePasses(this.renderer), this.effectComposer.addPass(this.aoPass), this.effectComposer.addPass(this.opaquePass), this.effectComposer.addPass(this.transmissionPass), this.effectComposer.addPass(this.taaPass), this.postprocessingState.enabled) {
                            let _ = [this.effects.get("pixelation")].reduce(BO, []);
                            _.length > 0 && (this.uvEffectPass = new Ae(this.camera, ..._), this.uvEffectPass.renderToScreen = !1, this.effectComposer.addPass(this.uvEffectPass));
                            let O = [this.effects.get("chromaticAberration"), this.effects.get("bloom"), this.effects.get("colorAverage"), this.effects.get("hueSaturation"), this.effects.get("brightnessContrast"), this.effects.get("vignette"), this.effects.get("noise")].reduce(BO, []);
                            O.length > 0 && (this.effectPass = new Ae(this.camera, ...O), this.effectPass.renderToScreen = !1, this.effectComposer.addPass(this.effectPass))
                        }
                        this.effectComposer.addPass(this.overlayPass), this.effectComposer.addPass(this.sceneTransitionPass), this.effectComposer.addPass(this.helperPass)
                    }
                    _initCopyPass() {
                        if (this._savePass) return;
                        let _ = new iJ;
                        this.renderer.getDrawingBufferSize(_), this._rt = new rh(_.x, _.y, {
                            depthBuffer: !1,
                            stencilBuffer: !1,
                            wrapS: 1e3,
                            wrapT: 1e3
                        }), this._rt.samples = 0, this._savePass = new SQ(this._rt, !1), this._savePass.renderToScreen = !1
                    }
                    setCopyPass(_) {
                        this._rt = _, this._savePass = new SQ(this._rt, !1), this.renderToScreen = !1
                    }
                    get renderToScreen() {
                        return this._renderToScreen
                    }
                    set renderToScreen(_) {
                        if (this._renderToScreen === _) return;
                        let O = this.effectComposer;
                        O && (!0 === _ ? O.removePass(this._savePass) : O.addPass(this._savePass), this._renderToScreen = _, this.updateRenderToScreen())
                    }
                    set sceneTransitionFromTexture(_) {
                        _ !== this.sceneTransitionPass.texture && (null !== _ ? this.sceneTransitionPass.enabled = !0 : (this.sceneTransitionPass.enabled = !1, this.updateRenderToScreen()), this.sceneTransitionPass.texture = _)
                    }
                    get texture() {
                        return this._rt && this._rt.texture
                    }
                    get renderTarget() {
                        return this._rt
                    }
                    updatePostprocessing(_) {
                        let {
                            enabled: O,
                            ...B
                        } = _, N = !1;
                        for (let _ of (O !== this.postprocessingState.enabled && (N = !0), Object.entries(B))) {
                            let O = _[1],
                                B = this.effects.get(_[0]);
                            if (B)
                                for (let [_, k] of (B.enabled !== O.enabled && (N = !0), B.enabled = O.enabled, Object.entries(O))) "blendFunction" === _ ? B.blendFunction = n7(k) : B[_] = k
                        }
                        this.postprocessingState = _, N && this._initPasses()
                    }
                    render() {
                        this.effectComposer.render(this.clock.getDelta())
                    }
                    setScissor(_, O, B, N) {
                        _ instanceof rl ? (this.effectComposer.inputBuffer.scissor.set(_.x, _.y, _.z, _.w), this.effectComposer.outputBuffer.scissor.set(_.x, _.y, _.z, _.w)) : (this.effectComposer.inputBuffer.scissor.set(_, O, B, N), this.effectComposer.outputBuffer.scissor.set(_, O, B, N));
                        let k = this.renderer.getPixelRatio();
                        this.effectComposer.inputBuffer.scissor.multiplyScalar(k), this.effectComposer.outputBuffer.scissor.multiplyScalar(k), this.renderer.setScissor(_, O, B, N)
                    }
                    setScissorTest(_) {
                        this.effectComposer.inputBuffer.scissorTest = _, this.effectComposer.outputBuffer.scissorTest = _, this.renderer.setScissorTest(_)
                    }
                    setViewport(_, O, B, N) {
                        _ instanceof rl ? (this.effectComposer.inputBuffer.viewport.copy(_), this.effectComposer.outputBuffer.viewport.copy(_)) : (this.effectComposer.inputBuffer.viewport.set(_, O, B, N), this.effectComposer.outputBuffer.viewport.set(_, O, B, N))
                    }
                    resize(_, O, B) {
                        if (this.effectComposer.setSize(_, O, B), this._rt) {
                            let B = this.renderer.getPixelRatio();
                            this._rt.setSize(_ * B, O * B)
                        }
                    }
                    dispose() {
                        this.uvEffectPass ? .dispose(), this.effectPass ? .dispose(), this.effectComposer.dispose()
                    }
                },
                i7 = _ => `

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${_};
const int gShadowSamples = ${_};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        vec2 halton = haltonSequence[frameIndex];
        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
        float temporalAngle  = temporalOffset * PI2;

        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`,
                Mc = aM.lights_fragment_begin,
                Md = aM.shadowmask_pars_fragment,
                Mu = null,
                a7 = _ => {
                    switch (_) {
                        case "low":
                            return 8;
                        case "medium":
                        default:
                            return 16;
                        case "high":
                            return 32
                    }
                },
                kO = (_ = "medium") => {
                    if (Mu === _) return !1;
                    Mu = _;
                    let O = a7(_);
                    aM.shadowmap_pars_fragment = i7(O);
                    let B = Mc.slice();
                    B = (B = B.replace("getShadow( spotShadowMap[ i ]", "getShadow( UNROLLED_LOOP_INDEX + 3, spotShadowMap[ i ]")).replace("getShadow( directionalShadowMap[ i ]", "getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"), aM.lights_fragment_begin = B;
                    let N = Md.slice();
                    return N = N.replaceAll("getShadow(", "getShadow( UNROLLED_LOOP_INDEX, "), aM.shadowmask_pars_fragment = N, !0
                },
                Mp = `
attribute vec3 randomColor;
varying vec3 vNormal;
flat out vec3 vColor;

void main()
{
vNormal = normal;
vColor = randomColor;
gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
}
`,
                Mm = `
uniform float depthContrast;
varying vec3 vNormal;
flat in vec3 vColor;
void main()
{
vec3 normal = (normalize(vNormal)).rgb;

float contrastDepth = (gl_FragCoord.z - 0.5) * depthContrast + 0.5;

vec3 resultColor = mix(mix(vColor, normal, 0.2), vec3(contrastDepth), 0.4);
gl_FragColor = vec4(resultColor, vColor.r);
}
`,
                Mg = new an({
                    vertexShader: Mp,
                    fragmentShader: Mm,
                    uniforms: {
                        depthContrast: {
                            value: 1
                        }
                    }
                }),
                Mx = new ro,
                Mb = class extends tw {
                    constructor(_) {
                        super(_), this._pixelRatio = this.getPixelRatio(), this.viewportWidth = 1, this.viewportHeight = 1, this.resolution = new iJ, this.pipeline = new Mh(this), this.dummyCamera = new Sh, this.sceneTransitionDuration = 0, this.sceneTransitionTimeRemaining = -1, this.isXRCopyPassSet = !1, this.clear = (_ = !0, O = !0, B = !0) => {
                            let N = this.getContext(),
                                k = 0;
                            _ && (k |= N.COLOR_BUFFER_BIT), O && (k |= N.DEPTH_BUFFER_BIT), B && (k |= N.STENCIL_BUFFER_BIT), N.clear(k), N.clearBufferfv(N.COLOR, 1, [0, 0, 0, 1])
                        }, this.autoClear = !1;
                        let O = this.setPixelRatio.bind(this),
                            B = this.setSize.bind(this);
                        this.shadowMap.enabled = !0, this.shadowMap.type = 1, this.dummyCamera.matrixAutoUpdate = !1;
                        let N = this.getContext();
                        if (N && "drawingBufferColorSpace" in N) try {
                            N.drawingBufferColorSpace = "display-p3"
                        } catch (_) {
                            console.warn(_)
                        }
                        this.setPixelRatio = _ => {
                            this._pixelRatio !== _ && (this._pixelRatio = _, O(_))
                        }, this.setSize = (_, O, N = !0) => {
                            (this.viewportWidth !== _ || this.viewportHeight !== O) && (this.viewportWidth = _, this.viewportHeight = O, B(_, O, N), this.normalRenderTarget ? .setSize(_ * this._pixelRatio, O * this._pixelRatio), this._resizeTransmission(_, O), this.transmissionDepthTarget ? .setSize(_ * this._pixelRatio / 2, O * this._pixelRatio / 2), this.pipeline.resize(_, O, N))
                        }, this._superDispose = this.dispose, this.dispose = this._currentDispose
                    }
                    createAORenderTarget() {
                        void 0 === this.aoRenderTarget && (this.aoRenderTarget = new rh(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio, {
                            generateMipmaps: !1,
                            minFilter: 1006,
                            magFilter: 1006,
                            wrapS: 1001,
                            wrapT: 1001,
                            depthBuffer: !1
                        }))
                    }
                    _resizeTransmission(_, O) {
                        this.transmissionRenderTarget ? .setSize(_ * this._pixelRatio / (this.hdTransmission ? 1 : 2), O * this._pixelRatio / (this.hdTransmission ? 1 : 2)), this.aoRenderTarget ? .setSize(_ * this._pixelRatio / 1, O * this._pixelRatio / 1)
                    }
                    get hdTransmission() {
                        return 1 === wn.transmissionLod.value
                    }
                    set hdTransmission(_) {
                        wn.transmissionLod.value = !0 === _ ? 1 : 2, this._resizeTransmission(this.viewportWidth, this.viewportHeight)
                    }
                    createTransmissionRenderTarget() {
                        void 0 === this.transmissionRenderTarget && (this.transmissionRenderTarget = new rh(this.viewportWidth * this._pixelRatio / (this.hdTransmission ? 1 : 2), this.viewportHeight * this._pixelRatio / (this.hdTransmission ? 1 : 2), {
                            generateMipmaps: !0,
                            minFilter: 1008,
                            magFilter: 1006,
                            wrapS: 1001,
                            wrapT: 1001,
                            depthBuffer: !1
                        }), this.transmissionDepthTarget = new rh(this.viewportWidth * this._pixelRatio / 2, this.viewportHeight * this._pixelRatio / 2, {
                            minFilter: 1003,
                            magFilter: 1003,
                            depthBuffer: !1
                        }))
                    }
                    createNormalRenderTarget() {
                        void 0 === this.normalRenderTarget && (this.normalRenderTarget = new rh(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio, {
                            generateMipmaps: !1,
                            minFilter: 1003,
                            magFilter: 1003,
                            type: 1015,
                            depthTexture: new nb(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio)
                        }))
                    }
                    renderNormal(_, O, B) {
                        this.normalRenderTarget && (this.setClearColor(0), B.layers.enable(8), B.layers.disable(0), B.layers.disable(3), O.traverseEntity(_ => {
                            _.layers.isEnabled(8) && (_.copyPreviousMatrix = !1)
                        }), this.setRenderTarget(this.normalRenderTarget), this.clear(), B instanceof Sh ? Mg.uniforms.depthContrast.value = (B.far - B.near) / 1e4 : Mg.uniforms.depthContrast.value = 1, O.overrideMaterial = Mg, this.render(O, B), this.setClearColor(O.bgColor, O.bgColor.a), this.setRenderTarget(null), O.overrideMaterial = _.wireframeState ? Ed : null, B.layers.enable(0), B.layers.enable(3), O.traverseEntity(_ => {
                            _.layers.isEnabled(8) && (_.copyPreviousMatrix = !0)
                        }))
                    }
                    renderSplineSceneWithDummyCamera(_, O, B = 1) {
                        this.dummyCamera.updateCameraState(O.dataPatched), this.dummyCamera.matrix.copy(O.matrixWorld);
                        let N = O.height,
                            k = O.width,
                            F = this.viewportWidth / this.viewportHeight;
                        k < N ? k = N * F : N = k / F, this.dummyCamera.setViewplaneSize(k, N);
                        for (let O = 0; O < B; O++) this.renderSplineScene(_, this.dummyCamera)
                    }
                    renderSplineScene(_, O, {
                        sceneHelpers: B,
                        sceneHelpersOnTop: N,
                        overrideTransmission: k,
                        overrideNormal: F
                    } = {}) {
                        let U = _ instanceof Ep ? _.activePage : _,
                            j = U.visible;
                        U.visible = !0;
                        let G = U.scene;
                        this.xr.enabled && (!1 === this.isXRCopyPassSet && null !== this.getRenderTarget() && (this.pipeline.setCopyPass(this.getRenderTarget()), this.isXRCopyPassSet = !0), this.xr.updateCamera(O)), this.setClearColor(U.bgColor, U.bgColor.a), U.penumbraSizeArray.forEach((_, O) => {
                            wn.penumbraSize.value[O] = _
                        }), wn.pixelRatioNode.value = this.getPixelRatio(), 0 !== this.resolution.x && 0 !== this.resolution.y ? wn.resolution.value.set(this.resolution.x, this.resolution.y) : wn.resolution.value.set(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio), void 0 !== F ? (wn.normalRenderTarget.value = F, wn.normalRenderTargetDepth.value = Mx) : G.needsNormal() && (this.createNormalRenderTarget(), wn.normalRenderTarget.value = this.normalRenderTarget.texture, wn.normalRenderTargetDepth.value = this.normalRenderTarget.depthTexture, this.renderNormal(G, U, O));
                        let Y = U.data.ao,
                            Q = Y.occlusion;
                        Q && (this.createAORenderTarget(), wn.aoRenderTarget.value = this.aoRenderTarget.texture), wn.aoEnabled.value = Q, this.pipeline.setAmbientOcclusionParams(Y.occlusion, Y.radius, Y.bias, U.aoColor, null !== U.fog, U.backupFog.near, U.backupFog.far, Y.aoFullRes), this.pipeline.aoPass.setBlueNoiseTexture(this.pipeline.blueNoiseTexture);
                        let K = !1;
                        if (void 0 !== k) wn.transmissionRenderTarget.value = k, wn.transmissionRenderTargetDepth.value = Mx, this.pipeline.setTransmissionPassEnabled(!1);
                        else {
                            var $, ee;
                            let _ = G.needsTransmission();
                            _ && (void 0 === this.transmissionRenderTarget && (K = !0), this.createTransmissionRenderTarget(), wn.transmissionRenderTarget.value = this.transmissionRenderTarget.texture, wn.aspectRatio.value = ($ = this.viewportWidth) >= (ee = this.viewportHeight) ? new iJ(ee / $, 1) : new iJ(1, $ / ee), wn.transmissionRenderTargetDepth.value = this.transmissionDepthTarget.texture), this.pipeline.setTransmissionPassEnabled(_)
                        }
                        O.layers.enable(3), O.layers.enable(8), this.pipeline.sceneHelpers = B, this.pipeline.sceneHelpersOnTop = N, this.pipeline.scene = U, this.pipeline.camera = O, K && this.pipeline.transmissionPass.updatePasses(this), this.pipeline.postprocessingState === U.postprocessing || (this.pipeline.updatePostprocessing(U.postprocessing), B || N || this.pipeline.disableHelpers()), void 0 !== this.clearAlphaOverride && this.setClearAlpha(this.clearAlphaOverride), U.overrideMaterial = G.wireframeState ? Ed : null, this.pipeline.render(), wn.frameIndex.value = (wn.frameIndex.value + 1) % 16, O instanceof Sh && O.copyHistory(), U.visible = j
                    }
                    renderFromSceneForSceneTransitionPass(_, O, B) {
                        this.pipeline.renderToScreen = !1, this.pipeline.renderTarget, this.renderSplineScene(_, O), this.pipeline.sceneTransitionFromTexture = this.pipeline.renderTarget.texture, this.sceneTransitionDuration = B, this.sceneTransitionTimeRemaining = B, this.pipeline.renderToScreen = !0;
                        let N = this.pipeline.sceneTransitionPass.uniforms;
                        N.uDPR.value = window.devicePixelRatio, N.uResolution.value.set(this.domElement.width, this.domElement.height).divideScalar(window.devicePixelRatio)
                    }
                    _currentDispose() {
                        this._superDispose(), this.pipeline.dispose(), this.aoRenderTarget ? .dispose(), this.transmissionRenderTarget ? .dispose(), this.transmissionDepthTarget ? .dispose(), this.normalRenderTarget ? .dispose(), this.normalRenderTarget ? .depthTexture ? .dispose()
                    }
                },
                M_ = class extends mo(lF) {
                    constructor(_, O = 15, B = 10066329) {
                        super(_, O, B), this.object = _, this.added = !1, this.name = `DirectionalLightHelper: ${_.uuid}`
                    }
                    raycast(_, O) {
                        go(this.object, M_.geometryHelper, _, O)
                    }
                },
                MS = class extends mo(lR) {
                    constructor(_, O = 15, B = 6710886) {
                        super(_, O, B), this.object = _, this.name = `PointLightHelper: ${_.uuid}`
                    }
                    raycast(_, O) {
                        go(this.object, MS.geometryHelper, _, O)
                    }
                },
                MM = class extends mo(lO) {
                    constructor(_, O = 6710886) {
                        super(_, O), this.object = _, this.name = `SpotLightHelper: ${_.uuid}`
                    }
                    raycast(_, O) {
                        go(this.object, MM.geometryHelper, _, O)
                    }
                    update() {
                        if (void 0 !== this.object) {
                            let _ = MM._vector,
                                O = this.object.distance ? this.object.distance : 1e3,
                                B = O * Math.tan(this.object.angle);
                            this.cone.scale.set(B, B, O), _.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(_);
                            let N = void 0 !== this.color ? this.color : this.light.color;
                            if (this.cone.material instanceof Array)
                                for (let _ = 0, O = this.cone.material.length; _ < O; _++) this.cone.material[_].color.set(N);
                            else this.cone.material.color.set(N)
                        }
                    }
                },
                MT = MM;
            MT._vector = new rv;
            var MI = class extends Ld(lt, M_) {
                    constructor(_, O, B) {
                        super(), this.super_Entity(_, O), this.castShadow = !0, this.shadow.mapSize.width = 2048, this.shadow.mapSize.height = 2048, this.shadow.normalBias = 1, this.layers.enable(3);
                        let N = this.shadow.camera;
                        N.top = 1250, N.bottom = -1250, N.right = 1250, N.left = -1250, N.near = -1e4, N.far = 2500;
                        let k = new lG(this.shadow.camera);
                        k.visible = !1, this.gizmos.shadowmap = k
                    }
                    update() {
                        for (let _ in this.shadow.camera.updateProjectionMatrix(), this.gizmos) {
                            let O = this.gizmos[_];
                            O instanceof lG && O.update()
                        }
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), this.objectHelper && this.objectHelper.update()
                    }
                    updateState(_, O) {
                        var B;
                        this.updateState_Light(_, O);
                        let N = void 0 !== _.depth && _.depth !== this.shadow.camera.far || void 0 !== _.size && _.size / 2 !== this.shadow.camera.right;
                        void 0 !== _.size && (B = _.size, this.shadow.camera.right = B / 2, this.shadow.camera.left = -B / 2, this.shadow.camera.top = B / 2, this.shadow.camera.bottom = -B / 2, this.shadow.needsUpdate = !0), void 0 !== _.shadowRadius && (this.shadow.radius = _.shadowRadius), void 0 !== _.shadowResolution && (this.shadow.mapSize.set(_.shadowResolution, _.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), void 0 !== _.penumbraSize && O.scene.markPenumbraSizeDirty(), N && this.update()
                    }
                },
                MO = new rv,
                ML = new rv,
                MR = new rm,
                MB = class extends Ld(o4, MT) {
                    constructor(_, O, B) {
                        super(), this.super_Entity(_, O), this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3);
                        let N = this.shadow.camera;
                        N.fov = 2 * iK.RAD2DEG * this.angle, N.aspect = 1, N.near = 100, N.far = 2500;
                        let k = new lG(this.shadow.camera);
                        k.visible = !1, this.gizmos.shadowmap = k, this.update()
                    }
                    update() {
                        for (let _ in this.shadow.camera.updateProjectionMatrix(), this.gizmos) {
                            let O = this.gizmos[_];
                            O instanceof lG && O.update()
                        }
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), ML.setFromMatrixPosition(this.matrixWorld), MR.setFromRotationMatrix(this.matrixWorld), MO.copy(this.up).applyQuaternion(MR).negate().multiplyScalar(this.distance), this.target.position.copy(ML).add(MO), this.target.updateMatrixWorld(), this.objectHelper && this.objectHelper.update()
                    }
                    updateState(_, O) {
                        this.updateState_Light(_, O), void 0 !== _.distance && (this.distance = _.distance), void 0 !== _.decay && (this.decay = _.decay), void 0 !== _.angle && (this.angle = _.angle), void 0 !== _.penumbra && (this.penumbra = _.penumbra), void 0 !== _.shadowRadius && (this.shadow.radius = _.shadowRadius), void 0 !== _.penumbraSize && O.scene.markPenumbraSizeDirty(), void 0 !== _.shadowResolution && (this.shadow.mapSize.set(_.shadowResolution, _.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null))
                    }
                },
                Mz = class extends jh(nS) {
                    constructor(_, O) {
                        super(), this.data = O, this.bgColor = new x8(1, 1, 1, 1), this.fog = null, this.backupFog = new n_(16777215, .1, 2e3), this.fogUseBGColor = !1, this.isActive = !1, this.aoColor = new re, this.penumbraSizeArrayCache = null, this.super_Entity(_, O), this.personalCamera = new Sh(pq, { ...gm.defaultData,
                            ...O.camera,
                            name: "Personal Camera"
                        }), this.personalCamera.objectHelper.visible = !1, this.add(this.personalCamera), this.activeCamera = this.personalCamera, this.ambientLight = new oK(13882323, 8553090, .75), this.ambientLight.name = "Default Ambient Light", this.ambientLight.layers.enable(3), this.ambientLight.removeFromParent(), this.add(this.ambientLight)
                    }
                    get scene() {
                        return this.parent
                    }
                    get postprocessing() {
                        return this.data.postprocessing
                    }
                    updateVisible() {}
                    setBackgroundColor(_) {
                        this.bgColor = _, !0 === this.fogUseBGColor && (this.backupFog.color = _)
                    }
                    updateAmbientLight(_, O) {
                        void 0 !== _.color && (this.ambientLight.color = zn(_.color, O)), void 0 !== _.intensity && (this.ambientLight.intensity = _.intensity), void 0 !== _.enabled && (_.enabled ? this.add(this.ambientLight) : this.remove(this.ambientLight))
                    }
                    onDeactive() {
                        this.isActive = !1
                    }
                    onActive(_) {
                        this.isActive = !0, _.fog = this.fog, this.updateShadow(this.data.shadow)
                    }
                    forceMaterialsUpdate() {
                        this.traverseEntity(_ => {
                            if (_ instanceof _l) {
                                if (Array.isArray(_.material))
                                    for (let O of _.material) O.needsUpdate = !0;
                                else _.material.needsUpdate = !0, _.material.dispose()
                            }
                        })
                    }
                    updateShadow(_) {
                        void 0 !== _.softShadowQuality && this.isActive && kO(_.softShadowQuality) && this.forceMaterialsUpdate()
                    }
                    updateFog(_, O) {
                        _.enabled ? this.fog = this.backupFog : this.fog = null, this.isActive && (this.scene.fog = this.fog), this.fogUseBGColor = _.useBackgroundColor, _.useBackgroundColor ? this.backupFog.color.set(this.bgColor) : this.backupFog.color = zn(_.color, O), this.backupFog.near = _.near, this.backupFog.far = _.far
                    }
                    updateAo(_, O) {
                        void 0 !== _.aoColor && (this.aoColor = zn(_.aoColor, O))
                    }
                    updateByOp(_, O, B, N) {
                        super.updateByOp(_, O, B, N), qn(_.path, ["fog"]) ? this.updateFog(O.fog, B.shared) : qn(_.path, ["ao"]) ? this.updateAo(O.ao, B.shared) : qn(_.path, ["ambient"]) ? this.updateAmbientLight(O.ambient, B.shared) : qn(_.path, ["shadow"]) && this.updateShadow(O.shadow)
                    }
                    updateState(_, O) {
                        this.updateState_Entity(_, O), void 0 !== _.backgroundColor && this.setBackgroundColor(zn(_.backgroundColor, O.shared)), void 0 !== _.fog && this.updateFog(_.fog, O.shared), void 0 !== _.ambient && this.updateAmbientLight(_.ambient, O.shared), void 0 !== _.ao && this.updateAo(_.ao, O.shared), void 0 !== _.shadow && this.updateShadow(_.shadow)
                    }
                    raycast(_, O) {
                        super.raycast(_, O)
                    }
                    switchActiveCamera(_) {
                        _ && _.isDescendantOf(this) && (this.activeCamera !== this.personalCamera && (this.activeCamera.objectHelper.visible = !0), this.activeCamera = _, _.objectHelper.visible = !1)
                    }
                    get playCamera() {
                        return this.scene ? .find(this.data.publish.playCamera) ? ? this.personalCamera
                    }
                    switchToPlayCamera() {
                        this.switchActiveCamera(this.playCamera)
                    }
                    get penumbraSizeArray() {
                        return null === this.penumbraSizeArrayCache && this.updatePenumbraSizeArray(), this.penumbraSizeArrayCache
                    }
                    updatePenumbraSizeArray() {
                        this.penumbraSizeArrayCache = [, , , , , ].fill(.5);
                        let _ = 0,
                            O = 0;
                        this.traverseEntity(B => {
                            if (!B.visible) return !0;
                            B instanceof MI && B.visible && _ < 3 && (this.penumbraSizeArrayCache[_] = B.data.penumbraSize, _ += 1), B instanceof MB && B.visible && _ < 2 && (this.penumbraSizeArrayCache[3 + O] = B.data.penumbraSize, O += 1)
                        })
                    }
                    raycastWithClones(_) {
                        let O = [],
                            n = B => {
                                for (let N of B.children) {
                                    let B = N.cloner;
                                    xu.is(N) && (N.visible || B ? .object.data.visible) && ((Yn(N) || Jp(N) && this.scene.enableHelpers && N.objectHelper.visible) && (_.intersectObject(N, !1, O), nm(N, _, O, !0)), n(N))
                                }
                            };
                        return n(this), O
                    }
                },
                MN = class extends Ld(o7, MS) {
                    constructor(_, O, B) {
                        super(), this.super_Entity(_, O), this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3);
                        let N = this.shadow.camera;
                        N.fov = 90, N.aspect = 1, N.near = 100, N.far = 2500;
                        let k = new rv(-N.far + this.position.x, -N.far + this.position.y, -N.far + this.position.z),
                            F = new rv(N.far + this.position.x, N.far + this.position.y, N.far + this.position.z),
                            U = new rb(k, F),
                            j = new lH(U, new re(16755200));
                        j.visible = !1, this.gizmos.shadowmap = j, this.update()
                    }
                    update() {
                        if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this.gizmos))
                            for (let _ in this.gizmos) {
                                let O = this.gizmos[_];
                                if (O instanceof lH) {
                                    let _ = this.shadow.camera,
                                        B = new rv(-_.far + this.position.x, -_.far + this.position.y, -_.far + this.position.z),
                                        N = new rv(_.far + this.position.x, _.far + this.position.y, _.far + this.position.z);
                                    O.box.set(B, N), O.updateMatrixWorld(!0)
                                }
                            }
                    }
                    updateMatrixWorld(_) {
                        super.updateMatrixWorld(_), this.objectHelper && this.objectHelper.update()
                    }
                    updateState(_, O) {
                        this.updateState_Light(_, O), void 0 !== _.distance && (this.distance = _.distance), void 0 !== _.decay && (this.decay = _.decay), void 0 !== _.shadowRadius && (this.shadow.radius = _.shadowRadius), void 0 !== _.shadowResolution && (this.shadow.mapSize.set(_.shadowResolution, _.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null))
                    }
                },
                Mk = class extends _m {
                    get forceComputeSize() {
                        return !0
                    }
                    get shape() {
                        return this.geometry.userData.shape
                    }
                    updateEntityBoxSize(_, O) {
                        let B = this.geometry.getAttribute("position");
                        void 0 !== B ? Np(B, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : B.count, _, O) : super.updateEntityBoxSize(_, O)
                    }
                },
                MF = class extends _m {
                    constructor(_, O, B) {
                        super(_, O, B), this._shapeId = null, this._context = B
                    }
                    updateState(_, O) {
                        super.updateState(_, O), this.updateShape()
                    }
                    updateShape() {
                        let _, O = { ...this.data.geometry.extrusion.shape
                        };
                        for (let _ in O) "string" == typeof O[_] && (O[_] = this._context.shared.getVariable(O[_], [this.uuid, "geometry", "extrusion", "shape", _]));
                        if ("Custom" === O.type) {
                            let B = O.shapeId;
                            if (B !== this._shapeId && this.detachShape(), B) {
                                this._shapeId = B;
                                let O = this._context.scene.find(B);
                                O ? .data && (O.attachedPaths.add(this), _ = O.geometry.userData ? .shape), _ || this._context.scene.addPendingCommand(() => this.updateShape())
                            }
                        } else {
                            let B;
                            switch (O.type) {
                                case "Rectangle":
                                    B = yK;
                                    break;
                                case "Ellipse":
                                    B = yE;
                                    break;
                                case "Polygon":
                                    B = yX;
                                    break;
                                case "Star":
                                    B = y4;
                                    break;
                                default:
                                    throw Error(`Unknown shape type: ${O.type}`)
                            }
                            _ = B.create({
                                parameters: O
                            }).userData.shape
                        }
                        let B = this.geometry;
                        _ && B.inputs && (B.inputs.shapeData = _, B.build(), this.attachedSurfaceCloners.forEach(_ => _.update()))
                    }
                    detachShape() {
                        null !== this._shapeId && this._context.scene.find(this._shapeId) ? .attachedPaths.delete(this)
                    }
                    createGeometryDelayed(_) {
                        this.geometryCreateDeleyed = _.shared, this.updateShape(), this.refreshAttachedPaths(_)
                    }
                    updateTransformState(_, O) {
                        return super.updateTransformState(_, O)
                    }
                    updateGeometryInteractions(_, O) {
                        super.updateGeometryInteractions(_, O), this.updateShape()
                    }
                    updateEntityBoxSize(_, O) {
                        let B = this.geometry.getAttribute("position");
                        void 0 !== B ? Np(B, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : B.count, _, O) : super.updateEntityBoxSize(_, O)
                    }
                },
                MU = class extends yo(nv, Sv) {
                    constructor(_, O, B) {
                        super(), "Instance" === O.type && "string" == typeof _ && (O = this.transformAssignData(O, B)), this.super_Entity(_, O), this.objectHelper.update()
                    }
                    get isComponentRoot() {
                        return "Component" === this.data.type && "string" == typeof this.identity
                    }
                    get isInstanceRoot() {
                        return "Instance" === this.data.type && "string" == typeof this.identity
                    }
                    transformAssignData(_, O) {
                        let B = gj.getComponentData({
                            scene: O.scene.data,
                            shared: O.shared.data
                        }, _.component);
                        if (!B) return { ...gh.defaultData,
                            ..._,
                            ...dk(gh.defaultData, gy.rootOverrideProps)
                        }; {
                            let O, N;
                            for (let k of gy.rootOverrideProps) void 0 === _[k] ? (void 0 === O && (O = { ..._
                            }), O[k] = B.data[k]) : (void 0 === N && (N = {}), N[k] = _[k], void 0 === O && (O = { ..._
                            }), O[k] = uo.apply(B.data[k], _[k]));
                            return this.overrideData = N, O
                        }
                    }
                    updateByOp(_, O, B, N) {
                        let k;
                        if (this.isInstanceRoot && !N) {
                            if (O = this.transformAssignData(O, B), 0 === _.type && 0 === _.path.length && this.component)
                                for (let O of gy.rootOverrideProps) O in _.props && void 0 === _.props[O] && (void 0 === k && (k = { ..._,
                                    props: { ..._.props
                                    }
                                }), k.props[O] = this.component.data[O]);
                            else if (0 === _.type && _.path.length > 0 && gy.rootOverrideProps.includes(_.path[0])) {
                                let B = _.path[0];
                                void 0 === k && (k = { ..._,
                                    path: [],
                                    props: {
                                        [B]: O[B]
                                    }
                                })
                            }
                        }
                        super.updateByOp(k ? ? _, O, B, N)
                    }
                    updateState(_, O) {
                        this.updateState_Entity(_, O)
                    }
                    expandInstanceChildren(_) {
                        let O = this.data;
                        if (void 0 === this.component) {
                            let B = _.scene.find(O.component) ? ? null,
                                N = !1;
                            if (B !== this.oldComponent) {
                                if (this.oldComponent) {
                                    let O = 0;
                                    for (let B of this.children)
                                        if (xu.is(B)) _.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(B), C0(B), O += 1;
                                        else break;
                                    this.children.splice(0, O)
                                }
                                N = !0
                            }
                            if (B) {
                                let k = {};
                                for (let F of (function jO(_, O, B, N, k, F, U, j, G) {
                                        if (U > 50) return !1;
                                        if (N.component !== k) {
                                            if (N.component) {
                                                let _ = N.component.instances.indexOf(N);
                                                _ >= 0 && N.component.instances.splice(_, 1)
                                            }
                                            k.instances.push(N), N.component = k
                                        }
                                        k instanceof MU && k.isInstanceRoot && k.expandInstanceChildren(_);
                                        let Y = 0;
                                        for (let Q of k.children)
                                            if (xu.is(Q)) {
                                                let k = [...O, ..."string" == typeof Q.identity ? [Q.identity] : Q.identity],
                                                    K = gv.resolve(B, k, 1);
                                                null == K || K instanceof ul || (Object.setPrototypeOf(K, ul.prototype), console.error("wrong prototype"));
                                                let $ = null,
                                                    ee;
                                                if (!j) {
                                                    let O = N.children[Y];
                                                    if (null !== ($ = xu.is(O) ? O : null)) {
                                                        let _ = HO($, Q, K, k);
                                                        ee = _ >= 1 ? $.stateSelection : void 0, 2 !== _ && ($ = null)
                                                    }
                                                    if (null === $ && null !== ($ = _.scene.findInstance(k) ? ? null)) {
                                                        let O = HO($, Q, K, k);
                                                        if (ee = O >= 1 ? $.stateSelection : void 0, 2 !== O) $ = null;
                                                        else {
                                                            let O = $.parent.children.indexOf($);
                                                            $.parent.children.splice(O, 1), N.children.splice(Y, 0, $), $.parent === N ? O <= Y && console.error("not possible") : ($.parent = N, $.matrixWorldNeedsUpdate = !0, $.resetBBoxNeedsUpdate(), $.updateVisible(), _.pendingDeletes.delete($))
                                                        }
                                                    }
                                                }
                                                if (null === $) {
                                                    let O = K ? uo.apply(Q.data, K) : Q.data;
                                                    fY.is(O.type) && (O = { ...O,
                                                        type: "Empty"
                                                    }), ($ = vD.createEntity(k, O, _)).overrideData = K, N.add($), N.children.splice(N.children.length - 1, 1), N.children.splice(Y, 0, $), $.updateState($.data, _), ee && $.changeSelectedState(ee, _), _.scene.registerInstanceAndSetUuid($)
                                                }
                                                $.isBone && (G[$.identity[$.identity.length - 1]] = $.uuid), Y += 1, jO(_, O, B, $, Q, F, U + 1, j, G)
                                            }
                                        if (!j) {
                                            let O = Y;
                                            for (;;) {
                                                let O = N.children[Y];
                                                if (xu.is(O)) _.pendingDeletes.add(O);
                                                else break;
                                                Y += 1
                                            }
                                            N.children.splice(O, Y - O)
                                        }
                                        return !0
                                    }(_, [this.uuid], O.overrides, this, B, B, 0, N, k), this.children))
                                    if (xu.is(F)) {
                                        let O = F.data;
                                        "Empty" === O.type && O.animations && F.traverseEntity(O => {
                                            if (O instanceof _m && O.isSkinnedMesh) {
                                                let B = O.dataPatched;
                                                if (B.bones && B.boneInverses) {
                                                    let N = B.bones.map(O => _.scene.find(k[O])),
                                                        F = B.boneInverses.map(_ => new rJ().fromArray(_)),
                                                        U = new nB(N, F);
                                                    O.bind(U, O.bindMatrix)
                                                }
                                            } else O.matrixAutoUpdate = !0
                                        })
                                    }
                            }
                            this.oldComponent = this.component
                        }
                    }
                };

            function C0(_) {
                if (_.component) {
                    let O = _.component.instances.indexOf(_);
                    for (let B of (O >= 0 && _.component.instances.splice(O, 1), _.children)) xu.is(B) && C0(B)
                }
            }

            function HO(_, O, B, N) {
                return _.component === O && np(_.identity, N) ? _.overrideData === B ? 2 : 1 : 0
            }
            var Mj = class extends yo(nP, Sv) {
                constructor(_, O) {
                    super(), this.super_Entity(_, O), this.objectHelper.update(), this.matrixAutoUpdate = !0
                }
                updateState(_, O) {
                    this.updateState_Entity(_, O)
                }
            };

            function D0(_, O, B) {
                return "Mesh" === O.type ? "TextGeometry" === O.geometry.type ? new _H(_, O, B) : "SubdivGeometry" === O.geometry.type ? new _x(_, O, B) : "PathGeometry" === O.geometry.type ? new MF(_, O, B) : "VectorGeometry" === O.geometry.type ? new Mk(_, O, B) : "BooleanGeometry" === O.geometry.type ? new Sg(_, O, B) : new _m(_, O, B) : "Empty" === O.type ? new Sy(_, O) : "Splat" === O.type ? new Sy(_, O) : "Bone" === O.type ? new Mj(_, O) : "Page" === O.type ? new Mz(_, O) : "PointLight" === O.type ? new MN(_, O, B) : "SpotLight" === O.type ? new MB(_, O, B) : "DirectionalLight" === O.type ? new MI(_, O, B) : "Component" === O.type || "Instance" === O.type ? new MU(_, O, B) : fY.is(O.type) ? new Sh(_, O) : (console.error(O), new Sy(_, O))
            }

            function qO(_, O) {
                let B = !1,
                    N = O.getLayersOfType("transmission"),
                    k = O.getLayersOfType("outline");
                return k.length > 0 && (_.layers.set(8), N.length > 0 && _.layers.enable(3), B = !0, Cd(_), Td(_)), 0 === N.length && 0 === k.length && _.layers.set(0), _ instanceof _l && _.needsAO && _.layers.enable(5), B
            }

            function YO(_, O) {
                if (!O.layers) return !1;
                let B = !1,
                    N = O.getLayersOfType("transmission").filter(_ => _.data.visible),
                    k = O.getLayersOfType("outline").filter(_ => _.data.visible);
                return N.length > 0 && (_.layers.set(3), k.length > 0 && _.layers.enable(8), B = !0), 0 === N.length && 0 === k.length && _.layers.set(0), _.needsAO && _.layers.enable(5), B
            }
            vD.createEntity = D0, vD.changeEntityProptotype = function(_, O, B) {
                let N = D0(_.identity, O, B),
                    k = _.children,
                    F = _.attachedPaths,
                    U = _.parent,
                    j = _.component,
                    G = _.instances,
                    Y = _.overrideData,
                    Q = _.uuid,
                    K = _.stateSelection;
                for (let O of (_.dispose(), Object.keys(_))) delete _[O];
                for (let O of (Object.setPrototypeOf(_, Object.getPrototypeOf(N)), Object.keys(N))) _[O] = N[O];
                _.children = [..._.children, ...k], _.attachedPaths = F, _.parent = U, _.component = j, _.instances = G, _.uuid = Q, _.overrideData = Y, _.updateState(_.data, B), K && _.changeSelectedState(K, B), _.resetBBoxNeedsUpdate()
            }, vD.Cloner = _3;
            var MG = new lA,
                MH = new rJ,
                MW = new rK;

            function nm(_, O, B, N = !1) {
                let k = _.cloner;
                if (k)
                    for (let F of k.children) {
                        let k = MH.copy(F.matrixWorld).invert(),
                            U = MW.copy(O.ray).applyMatrix4(k),
                            j = _.matrixWorld;
                        U.applyMatrix4(j), MG.set(U.origin, U.direction), MG.near = O.near, MG.far = O.far;
                        let G = MG.intersectObject(_, !1);
                        G.length > 0 && B.push({ ...G[0],
                            object: N ? F : _
                        })
                    }
            }
            var Mq = class {
                    constructor() {
                        this._constraints = new Map
                    }
                    setConstraint(_, O) {
                        null === O ? this._constraints.delete(_) : this._constraints.set(_, O)
                    }
                    removeDependencies(_) {
                        this._constraints.delete(_)
                    }
                    applyConstraints(_) {
                        let O = new Set;
                        this._constraints.forEach((B, N) => {
                            let k = [N, B],
                                F = B;
                            for (; this._constraints.has(F);) F = this._constraints.get(F), O.has(F) || k.push(F);
                            for (let B = k.length - 2; B >= 0; B--)
                                if (!O.has(k[B])) {
                                    let N = _.find(k[B]);
                                    N ? N.applyPathSnapping(_) : console.warn(`missing entity ${k[B]}`), O.add(k[B])
                                }
                        })
                    }
                    findDependency(_, O) {
                        let B = _;
                        for (; this._constraints.has(B);)
                            if ((B = this._constraints.get(B)) === O) return !0;
                        return !1
                    }
                },
                MY = pn(iP()),
                MX = pn(iF()),
                MQ = pn(iP()),
                MZ = pn(iF()),
                MK = class {
                    constructor(_, O, B) {
                        this._dataNormalized = _, this._minD = O, this._maxD = B
                    }
                    static createFromUnnormalized(_) {
                        let O = MZ.sup(_),
                            B = MZ.inf(_),
                            N = (0, MQ.default)(new Float32Array(_.size), _.shape),
                            k = O - B;
                        return k < 1e-4 ? MZ.assigns(N, 0) : (MZ.subs(N, _, B), MZ.divs(N, N, k)), new MK(N, B, O)
                    }
                    get data() {
                        return this._dataNormalized
                    }
                    get minD() {
                        return this._minD
                    }
                    get maxD() {
                        return this._maxD
                    }
                    denormalize() {
                        let _ = (0, MQ.default)(new Float32Array(this._dataNormalized.size), this._dataNormalized.shape);
                        return MZ.muls(_, this._dataNormalized, this._maxD - this._minD), MZ.adds(_, _, this._minD), _
                    }
                },
                MJ = class {
                    constructor(_, O) {
                        this._quantized = _, this._method = O
                    }
                    get quantized() {
                        return this._quantized
                    }
                    static maxIntBits(_) {
                        return 2 ** _ - 1
                    }
                    static fromNormalized(_, O) {
                        let B = _.data,
                            N;
                        if ("norm8x" === O) {
                            let _ = MJ.maxIntBits(8),
                                O = (0, MQ.default)(new Float32Array(B.size), B.shape);
                            MZ.muls(O, B, _), MZ.roundeq(O), N = (0, MQ.default)(new Uint8Array(O.data), B.shape)
                        } else if ("norm565" === O) {
                            let _ = (0, MQ.default)(new Float32Array(B.size), B.shape);
                            MZ.assign(_, B), MZ.mulseq(_.pick(null, 0), MJ.maxIntBits(5)), MZ.mulseq(_.pick(null, 1), MJ.maxIntBits(6)), MZ.mulseq(_.pick(null, 2), MJ.maxIntBits(5)), MZ.roundeq(_);
                            let O = (0, MQ.default)(new Uint16Array(_.data), B.shape),
                                k = (0, MQ.default)(new Uint16Array(B.shape[0]), [B.shape[0]]),
                                F = (0, MQ.default)(new Uint16Array(B.shape[0]), [B.shape[0]]);
                            MZ.lshifts(k, O.pick(null, 0), 11), MZ.lshifts(F, O.pick(null, 1), 5), MZ.boreq(k, F), MZ.boreq(k, O.pick(null, 2)), N = k
                        } else {
                            let _ = (0, MQ.default)(new Float32Array(B.size), B.shape);
                            MZ.assign(_, B), MZ.mulseq(_.pick(null, 0), MJ.maxIntBits(11)), MZ.mulseq(_.pick(null, 1), MJ.maxIntBits(10)), MZ.mulseq(_.pick(null, 2), MJ.maxIntBits(11)), MZ.roundeq(_);
                            let O = (0, MQ.default)(new Uint32Array(_.data), B.shape),
                                k = (0, MQ.default)(new Uint32Array(B.shape[0]), [B.shape[0]]),
                                F = (0, MQ.default)(new Uint32Array(B.shape[0]), [B.shape[0]]);
                            MZ.lshifts(k, O.pick(null, 0), 21), MZ.lshifts(F, O.pick(null, 1), 11), MZ.boreq(k, F), MZ.boreq(k, O.pick(null, 2)), N = k
                        }
                        return new MJ(N, O)
                    }
                    dequantize(_, O) {
                        let B = this._method,
                            N, k = this._quantized;
                        if ("norm8x" === B) {
                            let _ = MJ.maxIntBits(8);
                            N = (0, MQ.default)(new Float32Array(k.size), k.shape), MZ.muls(N, k, 1 / _)
                        } else if ("norm565" === B) {
                            let _ = (0, MQ.default)(new Uint8Array(k.shape[0]), [k.shape[0]]),
                                O = (0, MQ.default)(new Uint8Array(k.shape[0]), [k.shape[0]]),
                                B = (0, MQ.default)(new Uint8Array(k.shape[0]), [k.shape[0]]);
                            MZ.rrshifts(_, k, 11), MZ.rrshifts(O, k, 5), MZ.bandseq(O, MJ.maxIntBits(6)), MZ.bands(B, k, MJ.maxIntBits(5)), N = (0, MQ.default)(new Float32Array(3 * k.shape[0]), [k.shape[0], 3]), MZ.muls(N.pick(null, 0), _, 1 / MJ.maxIntBits(5)), MZ.muls(N.pick(null, 1), O, 1 / MJ.maxIntBits(6)), MZ.muls(N.pick(null, 2), B, 1 / MJ.maxIntBits(5))
                        } else {
                            let _ = (0, MQ.default)(new Uint16Array(k.shape[0]), [k.shape[0]]),
                                O = (0, MQ.default)(new Uint16Array(k.shape[0]), [k.shape[0]]),
                                B = (0, MQ.default)(new Uint16Array(k.shape[0]), [k.shape[0]]);
                            MZ.rrshifts(_, k, 21), MZ.rrshifts(O, k, 11), MZ.bandseq(O, MJ.maxIntBits(10)), MZ.bands(B, k, MJ.maxIntBits(11)), N = (0, MQ.default)(new Float32Array(3 * k.shape[0]), [k.shape[0], 3]), MZ.muls(N.pick(null, 0), _, 1 / MJ.maxIntBits(11)), MZ.muls(N.pick(null, 1), O, 1 / MJ.maxIntBits(10)), MZ.muls(N.pick(null, 2), B, 1 / MJ.maxIntBits(11))
                        }
                        return new MK(N, _, O)
                    }
                },
                M$ = class {
                    constructor(_, O, B, N, k, F = !1) {
                        this._quantized = _, this._minMaxMatrix = O, this._chunkSize = B, this._quantizationMethod = N, this._variableChunkSize = k, this._isDynamicChunks = F
                    }
                    get length() {
                        return this._quantized.shape[0]
                    }
                    get nchunks() {
                        return this._minMaxMatrix.shape[0]
                    }
                    get quantized() {
                        return this._quantized
                    }
                    get method() {
                        return this._quantizationMethod
                    }
                    get minmaxMatrix() {
                        return this._minMaxMatrix
                    }
                    _createPrunedMinMax(_) {
                        let O = _.length,
                            B = this.minmaxMatrix.shape[0] - O,
                            N = (0, MY.default)(new Float32Array(2 * B), [B, 2]),
                            k = 0,
                            F = B,
                            U = 0,
                            j = this.minmaxMatrix.shape[0];
                        for (let O = 0; O < _.length; O++)(F = (j = _[O]) - U + k) > k && MX.assign(N.hi(F, 2).lo(k, 0), this.minmaxMatrix.hi(j, 2).lo(U, 0)), k = F, U = j + 1;
                        return k < B && MX.assign(N.lo(k, 0), this.minmaxMatrix.lo(U, 0)), N
                    }
                    _createPrunedQuantized(_) {
                        let O = _.length,
                            B = this.quantized.shape[0] - O,
                            N = this._quantizationMethod,
                            k, F;
                        if ("norm8x" === N) {
                            let _ = (F = this._quantized.shape[1]) ? B * F : B;
                            k = (0, MY.default)(new Uint8Array(_), F ? [B, F] : [B, 1])
                        } else k = "norm565" === N ? (0, MY.default)(new Uint16Array(B), [B]) : (0, MY.default)(new Uint32Array(B), [B]);
                        let U = 0,
                            j = B,
                            G = 0,
                            Y = k.shape[0];
                        for (let O = 0; O < _.length; O++)(j = (Y = _[O]) - G + U) > U && (F ? MX.assign(k.hi(j, F).lo(U, 0), this._quantized.hi(Y, F).lo(G, 0)) : MX.assign(k.hi(j).lo(U), this._quantized.hi(Y).lo(G))), U = j, G = Y + 1;
                        return U < B && (F ? MX.assign(k.lo(U, 0), this._quantized.lo(G, 0)) : MX.assign(k.lo(U), this._quantized.lo(G))), k
                    }
                    pruneFeature(_, O, B) {
                        let N = this._createPrunedQuantized(_),
                            k = this._createPrunedMinMax(O);
                        return new M$(N, k, this._chunkSize, this._quantizationMethod, B, !0)
                    }
                    static getRequiredNChunks(_, O) {
                        return Math.floor(_ / O)
                    }
                    static fromArray(_, O, B) {
                        let N = _.shape[0],
                            k = Math.floor(N / B),
                            F = (0, MY.default)(new Float32Array(2 * k), [k, 2], [2, 1]),
                            U;
                        U = "norm8x" === O ? (0, MY.default)(new Uint8Array(_.size), _.shape) : "norm565" === O ? (0, MY.default)(new Uint16Array(_.shape[0]), [_.shape[0]]) : (0, MY.default)(new Uint32Array(_.shape[0]), [_.shape[0]]);
                        for (let j = 0; j < k; j++) {
                            let G = j * B,
                                Y = j + 1 < k ? (j + 1) * B : N,
                                Q;
                            Q = _.shape.length > 1 ? MK.createFromUnnormalized(_.hi(Y, _.shape[1]).lo(G, 0)) : MK.createFromUnnormalized(_.hi(Y).lo(G)), F.set(j, 0, Q.minD), F.set(j, 1, Q.maxD), U.shape.length > 1 ? MX.assign(U.hi(Y, U.shape[1]).lo(G, 0), MJ.fromNormalized(Q, O).quantized) : MX.assign(U.hi(Y).lo(G), MJ.fromNormalized(Q, O).quantized)
                        }
                        return new M$(U, F, B, O)
                    }
                    denormDequant() {
                        let _, O = this._minMaxMatrix.shape[0],
                            B = this._quantized,
                            N = B.shape[0],
                            k = this._quantizationMethod,
                            F = this._chunkSize,
                            U;
                        if (this._isDynamicChunks) {
                            if (!this._variableChunkSize) throw Error("variable chunk must exists if chunkSize isDynamic");
                            U = this._variableChunkSize
                        }
                        _ = "norm8x" === k ? (0, MY.default)(new Float32Array(B.size), B.shape) : (0, MY.default)(new Float32Array(3 * N), [N, 3]);
                        let j = 0,
                            G = F;
                        for (let F = 0; F < O; F++) {
                            let [Y, Q] = [this._minMaxMatrix.get(F, 0), this._minMaxMatrix.get(F, 1)];
                            this._isDynamicChunks && (G = U[F]);
                            let K = F + 1 < O ? j + G : N,
                                $;
                            $ = B.shape.length > 1 ? new MJ(B.hi(K, B.shape[1]).lo(j, 0), k) : new MJ(B.hi(K).lo(j), k), MX.assign(_.hi(K, _.shape[1]).lo(j, 0), $.dequantize(Y, Q).denormalize()), j = K
                        }
                        return _
                    }
                    static async fetchArrayBuffer(_) {
                        return await (await fetch(_, {
                            mode: "cors"
                        })).arrayBuffer()
                    }
                },
                M0 = pn(iP()),
                M2 = pn(iF()),
                M4 = pn(iP()),
                M5 = pn(iF()),
                M6 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

            function xR(_) {
                return _ < 1e5 ? _ < 100 ? _ < 10 ? 0 : 1 : _ < 1e4 ? _ < 1e3 ? 2 : 3 : 4 : _ < 1e7 ? _ < 1e6 ? 5 : 6 : _ < 1e9 ? _ < 1e8 ? 7 : 8 : 9
            }

            function bR(_, O) {
                if (_ === O) return 0;
                if (~~_ === _ && ~~O === O) {
                    if (0 === _ || 0 === O) return _ < O ? -1 : 1;
                    if (_ < 0 || O < 0) {
                        if (O >= 0) return -1;
                        if (_ >= 0) return 1;
                        _ = -_, O = -O
                    }
                    let B = xR(_),
                        N = xR(O),
                        k = 0;
                    return B < N ? (_ *= M6[N - B - 1], O /= 10, k = -1) : B > N && (O *= M6[B - N - 1], _ /= 10, k = 1), _ === O ? k : _ < O ? -1 : 1
                }
                let B = String(_),
                    N = String(O);
                return B === N ? 0 : B < N ? -1 : 1
            }

            function wR(_, O, B, N) {
                let k = O + 1;
                if (k === B) return 1;
                if (0 > N(_[k++], _[O])) {
                    for (; k < B && 0 > N(_[k], _[k - 1]);) k++;
                    ! function(_, O, B) {
                        for (B--; O < B;) {
                            let N = _[O];
                            _[O++] = _[B], _[B--] = N
                        }
                    }(_, O, k)
                } else
                    for (; k < B && N(_[k], _[k - 1]) >= 0;) k++;
                return k - O
            }

            function SR(_, O, B, N, k) {
                for (N === O && N++; N < B; N++) {
                    let B = _[N],
                        F = O,
                        U = N;
                    for (; F < U;) {
                        let O = F + U >>> 1;
                        0 > k(B, _[O]) ? U = O : F = O + 1
                    }
                    let j = N - F;
                    switch (j) {
                        case 3:
                            _[F + 3] = _[F + 2];
                        case 2:
                            _[F + 2] = _[F + 1];
                        case 1:
                            _[F + 1] = _[F];
                            break;
                        default:
                            for (; j > 0;) _[F + j] = _[F + j - 1], j--
                    }
                    _[F] = B
                }
            }

            function c1(_, O, B, N, k, F) {
                let U = 0,
                    j = 0,
                    G = 1;
                if (F(_, O[B + k]) > 0) {
                    for (j = N - k; G < j && F(_, O[B + k + G]) > 0;) U = G, (G = (G << 1) + 1) <= 0 && (G = j);
                    G > j && (G = j), U += k, G += k
                } else {
                    for (j = k + 1; G < j && 0 >= F(_, O[B + k - G]);) U = G, (G = (G << 1) + 1) <= 0 && (G = j);
                    G > j && (G = j);
                    let N = U;
                    U = k - G, G = k - N
                }
                for (U++; U < G;) {
                    let N = U + (G - U >>> 1);
                    F(_, O[B + N]) > 0 ? U = N + 1 : G = N
                }
                return G
            }

            function u1(_, O, B, N, k, F) {
                let U = 0,
                    j = 0,
                    G = 1;
                if (0 > F(_, O[B + k])) {
                    for (j = k + 1; G < j && 0 > F(_, O[B + k - G]);) U = G, (G = (G << 1) + 1) <= 0 && (G = j);
                    G > j && (G = j);
                    let N = U;
                    U = k - G, G = k - N
                } else {
                    for (j = N - k; G < j && F(_, O[B + k + G]) >= 0;) U = G, (G = (G << 1) + 1) <= 0 && (G = j);
                    G > j && (G = j), U += k, G += k
                }
                for (U++; U < G;) {
                    let N = U + (G - U >>> 1);
                    0 > F(_, O[B + N]) ? G = N : U = N + 1
                }
                return G
            }
            var M8 = class {
                constructor(_, O) {
                    mn(this, "array", null), mn(this, "compare", null), mn(this, "minGallop", 7), mn(this, "length", 0), mn(this, "tmpStorageLength", 256), mn(this, "stackLength", 0), mn(this, "runStart", null), mn(this, "runLength", null), mn(this, "stackSize", 0), this.array = _, this.compare = O, this.length = _.length, this.length < 512 && (this.tmpStorageLength = this.length >>> 1), this.tmp = Array(this.tmpStorageLength), this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40, this.runStart = Array(this.stackLength), this.runLength = Array(this.stackLength)
                }
                pushRun(_, O) {
                    this.runStart[this.stackSize] = _, this.runLength[this.stackSize] = O, this.stackSize += 1
                }
                mergeRuns() {
                    for (; this.stackSize > 1;) {
                        let _ = this.stackSize - 2;
                        if (_ >= 1 && this.runLength[_ - 1] <= this.runLength[_] + this.runLength[_ + 1] || _ >= 2 && this.runLength[_ - 2] <= this.runLength[_] + this.runLength[_ - 1]) this.runLength[_ - 1] < this.runLength[_ + 1] && _--;
                        else if (this.runLength[_] > this.runLength[_ + 1]) break;
                        this.mergeAt(_)
                    }
                }
                forceMergeRuns() {
                    for (; this.stackSize > 1;) {
                        let _ = this.stackSize - 2;
                        _ > 0 && this.runLength[_ - 1] < this.runLength[_ + 1] && _--, this.mergeAt(_)
                    }
                }
                mergeAt(_) {
                    let O = this.compare,
                        B = this.array,
                        N = this.runStart[_],
                        k = this.runLength[_],
                        F = this.runStart[_ + 1],
                        U = this.runLength[_ + 1];
                    this.runLength[_] = k + U, _ === this.stackSize - 3 && (this.runStart[_ + 1] = this.runStart[_ + 2], this.runLength[_ + 1] = this.runLength[_ + 2]), this.stackSize--;
                    let j = u1(B[F], B, N, k, 0, O);
                    N += j, 0 != (k -= j) && 0 !== (U = c1(B[N + k - 1], B, F, U, U - 1, O)) && (k <= U ? this.mergeLow(N, k, F, U) : this.mergeHigh(N, k, F, U))
                }
                mergeLow(_, O, B, N) {
                    let k = this.compare,
                        F = this.array,
                        U = this.tmp,
                        j = 0;
                    for (j = 0; j < O; j++) U[j] = F[_ + j];
                    let G = 0,
                        Y = B,
                        Q = _;
                    if (F[Q++] = F[Y++], 0 == --N) {
                        for (j = 0; j < O; j++) F[Q + j] = U[G + j];
                        return
                    }
                    if (1 === O) {
                        for (j = 0; j < N; j++) F[Q + j] = F[Y + j];
                        F[Q + N] = U[G];
                        return
                    }
                    let K = this.minGallop;
                    for (;;) {
                        let _ = 0,
                            B = 0,
                            $ = !1;
                        do
                            if (0 > k(F[Y], U[G])) {
                                if (F[Q++] = F[Y++], B++, _ = 0, 0 == --N) {
                                    $ = !0;
                                    break
                                }
                            } else if (F[Q++] = U[G++], _++, B = 0, 1 == --O) {
                            $ = !0;
                            break
                        } while ((_ | B) < K);
                        if ($) break;
                        do {
                            if (0 !== (_ = u1(F[Y], U, G, O, 0, k))) {
                                for (j = 0; j < _; j++) F[Q + j] = U[G + j];
                                if (Q += _, G += _, (O -= _) <= 1) {
                                    $ = !0;
                                    break
                                }
                            }
                            if (F[Q++] = F[Y++], 0 == --N) {
                                $ = !0;
                                break
                            }
                            if (0 !== (B = c1(U[G], F, Y, N, 0, k))) {
                                for (j = 0; j < B; j++) F[Q + j] = F[Y + j];
                                if (Q += B, Y += B, 0 == (N -= B)) {
                                    $ = !0;
                                    break
                                }
                            }
                            if (F[Q++] = U[G++], 1 == --O) {
                                $ = !0;
                                break
                            }
                            K--
                        } while (_ >= 7 || B >= 7);
                        if ($) break;
                        K < 0 && (K = 0), K += 2
                    }
                    if (this.minGallop = K, K < 1 && (this.minGallop = 1), 1 === O) {
                        for (j = 0; j < N; j++) F[Q + j] = F[Y + j];
                        F[Q + N] = U[G]
                    } else {
                        if (0 === O) throw Error("mergeLow preconditions were not respected");
                        for (j = 0; j < O; j++) F[Q + j] = U[G + j]
                    }
                }
                mergeHigh(_, O, B, N) {
                    let k = this.compare,
                        F = this.array,
                        U = this.tmp,
                        j = 0;
                    for (j = 0; j < N; j++) U[j] = F[B + j];
                    let G = _ + O - 1,
                        Y = N - 1,
                        Q = B + N - 1,
                        K = 0,
                        $ = 0;
                    if (F[Q--] = F[G--], 0 == --O) {
                        for (K = Q - (N - 1), j = 0; j < N; j++) F[K + j] = U[j];
                        return
                    }
                    if (1 === N) {
                        for (Q -= O, G -= O, $ = Q + 1, K = G + 1, j = O - 1; j >= 0; j--) F[$ + j] = F[K + j];
                        F[Q] = U[Y];
                        return
                    }
                    let ee = this.minGallop;
                    for (;;) {
                        let B = 0,
                            et = 0,
                            ei = !1;
                        do
                            if (0 > k(U[Y], F[G])) {
                                if (F[Q--] = F[G--], B++, et = 0, 0 == --O) {
                                    ei = !0;
                                    break
                                }
                            } else if (F[Q--] = U[Y--], et++, B = 0, 1 == --N) {
                            ei = !0;
                            break
                        } while ((B | et) < ee);
                        if (ei) break;
                        do {
                            if (0 != (B = O - u1(U[Y], F, _, O, O - 1, k))) {
                                for (Q -= B, G -= B, O -= B, $ = Q + 1, K = G + 1, j = B - 1; j >= 0; j--) F[$ + j] = F[K + j];
                                if (0 === O) {
                                    ei = !0;
                                    break
                                }
                            }
                            if (F[Q--] = U[Y--], 1 == --N) {
                                ei = !0;
                                break
                            }
                            if (0 != (et = N - c1(F[G], U, 0, N, N - 1, k))) {
                                for (Q -= et, Y -= et, N -= et, $ = Q + 1, K = Y + 1, j = 0; j < et; j++) F[$ + j] = U[K + j];
                                if (N <= 1) {
                                    ei = !0;
                                    break
                                }
                            }
                            if (F[Q--] = F[G--], 0 == --O) {
                                ei = !0;
                                break
                            }
                            ee--
                        } while (B >= 7 || et >= 7);
                        if (ei) break;
                        ee < 0 && (ee = 0), ee += 2
                    }
                    if (this.minGallop = ee, ee < 1 && (this.minGallop = 1), 1 === N) {
                        for (Q -= O, G -= O, $ = Q + 1, K = G + 1, j = O - 1; j >= 0; j--) F[$ + j] = F[K + j];
                        F[Q] = U[Y]
                    } else {
                        if (0 === N) throw Error("mergeHigh preconditions were not respected");
                        for (K = Q - (N - 1), j = 0; j < N; j++) F[K + j] = U[j]
                    }
                }
            };

            function d1(_) {
                let O = (0, M4.default)(new Int32Array(_.shape[0]), [_.shape[0]]),
                    B = (0, M4.default)(new Int32Array(_.shape[0]), [_.shape[0]]);
                return M5.bands(O, _, 1023), M5.lshifts(B, O, 16), M5.bxoreq(O, B), M5.bandseq(O, 4278190335), M5.lshifts(B, O, 8), M5.bxoreq(O, B), M5.bandseq(O, 50393103), M5.lshifts(B, O, 4), M5.bxoreq(O, B), M5.bandseq(O, 51130563), M5.lshifts(B, O, 2), M5.bxoreq(O, B), M5.bandseq(O, 153391689), O
            }

            function Sl(_, O) {
                if (_.shape[0] !== O.shape[0]) throw Error("wrong length");
                let B = (0, M4.default)(new Float32Array(_.size), _.shape, _.stride, _.offset);
                for (let N = 0; N < O.shape[0]; N++) {
                    let k = O.get(N);
                    if (_.shape.length > 1)
                        for (let O = 0; O < _.shape[1]; O++) B.set(N, O, _.get(k, O));
                    else B.set(N, _.get(k))
                }
                return B
            }
            var M9 = class {
                    constructor(_, O, B, N, k, F, U, j, G, Y) {
                        this.propertyDescs = _, this.format = O, this.nsplats = B, this.xyz = N, this.colors = k, this.harmonics = F, this.opacity = U, this.scaling = j, this.rotation = G, this.maxSHDegree = Y
                    }
                    getPlyBinary() {
                        let _ = M9._generateHeaderString(this.propertyDescs, this.format, this.nsplats),
                            O = new TextEncoder().encode(_),
                            B = Object.keys(this.propertyDescs).length,
                            N = (0, M0.default)(new Float32Array(this.nsplats * B), [this.nsplats, B]);
                        if (M2.assign(N.pick(null, this.propertyDescs.x.index), this.xyz.pick(null, 0)), M2.assign(N.pick(null, this.propertyDescs.y.index), this.xyz.pick(null, 1)), M2.assign(N.pick(null, this.propertyDescs.z.index), this.xyz.pick(null, 2)), M2.assign(N.pick(null, this.propertyDescs.f_dc_0.index), this.colors.pick(null, 0)), M2.assign(N.pick(null, this.propertyDescs.f_dc_1.index), this.colors.pick(null, 1)), M2.assign(N.pick(null, this.propertyDescs.f_dc_2.index), this.colors.pick(null, 2)), M2.assign(N.pick(null, this.propertyDescs.opacity.index), this.opacity.pick(null, 0)), M2.assign(N.pick(null, this.propertyDescs.scale_0.index), this.scaling.pick(null, 0)), M2.assign(N.pick(null, this.propertyDescs.scale_1.index), this.scaling.pick(null, 1)), M2.assign(N.pick(null, this.propertyDescs.scale_2.index), this.scaling.pick(null, 2)), M2.assign(N.pick(null, this.propertyDescs.rot_0.index), this.rotation.pick(null, 0)), M2.assign(N.pick(null, this.propertyDescs.rot_1.index), this.rotation.pick(null, 1)), M2.assign(N.pick(null, this.propertyDescs.rot_2.index), this.rotation.pick(null, 2)), M2.assign(N.pick(null, this.propertyDescs.rot_3.index), this.rotation.pick(null, 3)), this.harmonics && this.harmonics.length > 0)
                            for (let _ = 0; _ < this.harmonics.length; _++) {
                                let O = 3 * _;
                                M2.assign(N.pick(null, this.propertyDescs[`f_rest_${O}`].index), this.harmonics[_].pick(null, 0)), M2.assign(N.pick(null, this.propertyDescs[`f_rest_${O+1}`].index), this.harmonics[_].pick(null, 1)), M2.assign(N.pick(null, this.propertyDescs[`f_rest_${O+2}`].index), this.harmonics[_].pick(null, 2))
                            }
                        let k = new Uint8Array(N.data.buffer),
                            F = new Uint8Array(k.length + O.length);
                        return F.set(O), F.set(k, O.length), F.buffer
                    }
                    save(_, O) {
                        let B = this.getPlyBinary(),
                            N = new Blob([B], {
                                type: "application/octet-stream"
                            }),
                            k = new File([N], _),
                            F = new FormData;
                        F.append("file", k), F.append("filename", _), F.append("basedir", O), fetch("http://127.0.0.1:8000/push_file", {
                            method: "POST",
                            body: F
                        })
                    }
                    static async loadFile(_) {
                        return await (await fetch(_)).arrayBuffer()
                    }
                    mortonPositionSplatsSort() {
                        var _, O;
                        let B, N, k, F, U, j, G;
                        let Y = (_ = this.xyz, B = 1e3 / Math.min(1e3, M5.sup(_) - M5.inf(_)), N = (0, M4.default)(new Float32Array(_.data), _.shape), M5.mulseq(N, B), ! function(_, O, B, N) {
                                if (!Array.isArray(_)) throw TypeError("Can only sort arrays");
                                O ? "function" != typeof O && (N = B, B = O, O = bR) : O = bR, B || (B = 0), N || (N = _.length);
                                let k = N - B;
                                if (k < 2) return;
                                let F = 0;
                                if (k < 32) {
                                    F = wR(_, B, N, O), SR(_, B, N, B + F, O);
                                    return
                                }
                                let U = new M8(_, O),
                                    j = function(_) {
                                        let O = 0;
                                        for (; _ >= 32;) O |= 1 & _, _ >>= 1;
                                        return _ + O
                                    }(k);
                                do {
                                    if ((F = wR(_, B, N, O)) < j) {
                                        let N = k;
                                        N > j && (N = j), SR(_, B, B + N, B + F, O), F = N
                                    }
                                    U.pushRun(B, F), U.mergeRuns(), k -= F, B += F
                                } while (0 !== k);
                                U.forceMergeRuns()
                            }(j = Array.from((k = d1((O = (0, M4.default)(new Int32Array(N.data), _.shape)).pick(null, 0)), F = d1(O.pick(null, 1)), M5.lshiftseq(F, 1), U = d1(O.pick(null, 2)), M5.lshiftseq(U, 2), M5.boreq(k, F), M5.boreq(k, U), k).data).map((_, O) => [_, O]), (_, O) => _[0] - O[0]), G = j.map(([_, O]) => O), (0, M4.default)(Uint32Array.from(G))),
                            Q = Sl(this.xyz, Y),
                            K = Sl(this.colors, Y),
                            $ = Sl(this.opacity, Y),
                            ee = Sl(this.scaling, Y),
                            et = Sl(this.rotation, Y),
                            ei = [];
                        for (let _ = 0; _ < this.harmonics.length; _++) ei.push(Sl(this.harmonics[_], Y));
                        return new M9(this.propertyDescs, this.format, this.nsplats, Q, K, ei, $, ee, et, this.maxSHDegree)
                    }
                    static _generateHeaderString(_, O, B) {
                        let N = `ply
format ${O.format} ${O.version}
element vertex ${B}`,
                            k = Array(Object.keys(_).length);
                        for (let O in _) {
                            let B = _[O];
                            k[B.index] = {
                                name: O,
                                dtype: B.dtype
                            }
                        }
                        for (let _ = 0; _ < k.length; _++) N = `${N}
property ${k[_].dtype} ${k[_].name}`;
                        return `${N}
end_header
`
                    }
                    static fromArrayBuffer(_, O = 3) {
                        let {
                            splatCount: B,
                            vertexData: N,
                            propertiesDesc: k,
                            format: F
                        } = M9.decodeHeader(_), U = N.buffer.slice(N.byteOffset), j = Object.keys(k).length, G = (0, M0.default)(new Float32Array(U), [B, j]), Y = 0, Q = {}, K = {
                            double: 8,
                            int: 4,
                            uint: 4,
                            float: 4,
                            short: 2,
                            ushort: 2,
                            uchar: 1
                        };
                        for (let _ in k)
                            if (k.hasOwnProperty(_)) {
                                let O = k[_].dtype;
                                Q[_] = Y, Y += K[O]
                            }
                        let $ = (0, M0.default)(new Float32Array(3 * B), [B, 3]);
                        M2.assign($.pick(null, 0), G.pick(null, Q.x / 4)), M2.assign($.pick(null, 1), G.pick(null, Q.y / 4)), M2.assign($.pick(null, 2), G.pick(null, Q.z / 4));
                        let ee = (0, M0.default)(new Float32Array(3 * B), [B, 3]);
                        M2.assign(ee.pick(null, 0), G.pick(null, Q.scale_0 / 4)), M2.assign(ee.pick(null, 1), G.pick(null, Q.scale_1 / 4)), M2.assign(ee.pick(null, 2), G.pick(null, Q.scale_2 / 4));
                        let et = (0, M0.default)(new Float32Array(3 * B), [B, 3]);
                        M2.assign(et.pick(null, 0), G.pick(null, Q.f_dc_0 / 4)), M2.assign(et.pick(null, 1), G.pick(null, Q.f_dc_1 / 4)), M2.assign(et.pick(null, 2), G.pick(null, Q.f_dc_2 / 4));
                        let ei = (0, M0.default)(new Float32Array(4 * B), [B, 4]);
                        M2.assign(ei.pick(null, 0), G.pick(null, Q.rot_1 / 4)), M2.assign(ei.pick(null, 1), G.pick(null, Q.rot_2 / 4)), M2.assign(ei.pick(null, 2), G.pick(null, Q.rot_3 / 4)), M2.assign(ei.pick(null, 3), G.pick(null, Q.rot_0 / 4));
                        for (let _ = 0; _ < B; _++) {
                            let O = ei.pick(_, null),
                                B = Math.sqrt(O.get(0) ** 2 + O.get(1) ** 2 + O.get(2) ** 2 + O.get(3) ** 2);
                            M2.divseq(O, B)
                        }
                        let er = (0, M0.default)(new Float32Array(1 * B), [B, 1]);
                        M2.assign(er.pick(null, 0), G.pick(null, Q.opacity / 4));
                        let ea = (Math.min(Math.max(O, 0), 3) + 1) ** 2 - 1,
                            en = [];
                        for (let _ = 0; _ < ea; _++) {
                            let O = (0, M0.default)(new Float32Array(3 * B), [B, 3]),
                                N = 3 * _;
                            M2.assign(O.pick(null, 0), G.pick(null, Q[`f_rest_${N}`] / 4)), M2.assign(O.pick(null, 1), G.pick(null, Q[`f_rest_${N+1}`] / 4)), M2.assign(O.pick(null, 2), G.pick(null, Q[`f_rest_${N+2}`] / 4)), en.push(O)
                        }
                        return new M9(k, F, B, $, et, en, er, ee, ei, O)
                    }
                    static async fromPLYFile(_, O = 3) {
                        let B = await M9.loadFile(_);
                        return M9.fromArrayBuffer(B, O)
                    }
                    static decodeHeader(_) {
                        let O = new TextDecoder,
                            B = 0,
                            N = "";
                        for (;;) {
                            if (B + 100 >= _.byteLength) throw Error("End of file reached while searching for end of header");
                            let k = new Uint8Array(_, B, 100);
                            N += O.decode(k);
                            let F = (B += 100) - 200,
                                U = new Uint8Array(_, Math.max(0, F), F > 0 ? 200 : 100);
                            if (O.decode(U).includes("end_header")) break
                        }
                        let k = N.split(`
`),
                            F = 0,
                            U = {},
                            j = {},
                            G = 0,
                            Y;
                        for (let _ = 0; _ < k.length; _++) {
                            let O = k[_].trim();
                            if (O.startsWith("element vertex")) {
                                let _ = O.match(/\d+/);
                                _ && (F = parseInt(_[0]))
                            } else if (O.startsWith("property")) {
                                let _ = O.match(/(\w+)\s+(\w+)\s+(\w+)/);
                                if (_) {
                                    let O = _[2],
                                        B = _[3];
                                    U[B] = G, j[B] = {
                                        dtype: O,
                                        index: G
                                    }, G++
                                }
                            } else if (O.startsWith("format")) {
                                let _ = O.match(/(\w+)\s+(\w+)\s+(\d+\.?\d*)/);
                                _ && (Y = {
                                    format: _[2],
                                    version: _[3]
                                })
                            } else if ("end_header" === O) break
                        }
                        let Q = N.indexOf("end_header") + 10 + 1;
                        return {
                            splatCount: F,
                            vertexData: new DataView(_, Q),
                            headerOffset: B,
                            propertiesDesc: j,
                            format: Y
                        }
                    }
                },
                M7 = class {
                    constructor(_, O, B, N, k, F, U, j) {
                        this.config = _, this.xyz = O, this.scaling = B, this.color = N, this.opacity = k, this.harmonics = U, this.quaternion = F, this.variableChunkSize = j
                    }
                    get isDynamicChunks() {
                        return this.variableChunkSize && this.variableChunkSize.length > 0
                    }
                    get nchunks() {
                        return this.xyz.nchunks
                    }
                    get nsplats() {
                        return this.xyz.length
                    }
                    get chunkSize() {
                        return this.config.chunkSize
                    }
                    static compressFromGaussianData(_, O) {
                        let B = M$.fromArray(_.xyz, O.xyz, O.chunkSize),
                            N = M$.fromArray(_.scaling, O.scaling, O.chunkSize),
                            k = M$.fromArray(_.colors, O.color, O.chunkSize),
                            F = M$.fromArray(_.opacity, O.opacity, O.chunkSize),
                            U = M$.fromArray(_.rotation, O.quaternion, O.chunkSize),
                            j = _.harmonics,
                            G = [];
                        if (O.harmonics)
                            for (let _ = 0; _ < j.length; _++) {
                                let B = M$.fromArray(j[_], O.harmonics, O.chunkSize);
                                G.push(B)
                            }
                        return new M7(O, B, N, k, F, U, G)
                    }
                    _countIndexesInChunks(_) {
                        let O = [],
                            B = this.nchunks,
                            N = this.chunkSize,
                            k = this.nsplats;
                        if (B === M$.getRequiredNChunks(k, N))
                            for (let B = 0; B < _.length; B++) {
                                let N = _[B],
                                    k = Math.floor(N / this.chunkSize);
                                k in O ? O[k].push(N) : O[k] = [N]
                            } else {
                                let k = this.variableChunkSize,
                                    F = {},
                                    U = 0;
                                for (let _ = 0; _ < B; _++) F[_] = U, U += k[_];
                                for (let U = 0; U < _.length; U++) {
                                    let j = _[U],
                                        G = Math.min(Math.floor(j / N), B - 1);
                                    for (; j >= F[G] + k[G];) G++;
                                    G in O ? O[G].push(j) : O[G] = [j]
                                }
                            }
                        return O
                    }
                    pruneSplats(_) {
                        let O = this._countIndexesInChunks(_),
                            B, N = [];
                        return O.length > 0 && (B = this.variableChunkSize ? [...this.variableChunkSize] : Array(this.nchunks).fill(this.chunkSize), O.forEach((_, O) => {
                            B[O] -= _.length, B[O] <= 0 && N.push(O)
                        }), B = B.filter(_ => _ > 0)), new M7(this.config, this.xyz.pruneFeature(_, N, B), this.scaling.pruneFeature(_, N, B), this.color.pruneFeature(_, N, B), this.opacity.pruneFeature(_, N, B), this.quaternion.pruneFeature(_, N, B), this.harmonics ? this.harmonics.map(O => O.pruneFeature(_, N, this.variableChunkSize)) : void 0, B)
                    }
                    static async loadConfig(_) {
                        return await (await fetch(_, {
                            method: "GET",
                            mode: "cors",
                            headers: {
                                Accept: "application/json"
                            }
                        })).json()
                    }
                    toGaussians() {
                        let _ = {},
                            O = 0;
                        if (_.x = {
                                dtype: "float",
                                index: O
                            }, O++, _.y = {
                                dtype: "float",
                                index: O
                            }, O++, _.z = {
                                dtype: "float",
                                index: O
                            }, O++, _.f_dc_0 = {
                                dtype: "float",
                                index: O
                            }, O++, _.f_dc_1 = {
                                dtype: "float",
                                index: O
                            }, O++, _.f_dc_2 = {
                                dtype: "float",
                                index: O
                            }, O++, this.harmonics && this.harmonics.length > 0)
                            for (let B = 0; B < this.harmonics.length; B++) _[`f_rest_${B}`] = {
                                dtype: "float",
                                index: O
                            }, O++, _[`f_rest_${B+1}`] = {
                                dtype: "float",
                                index: O
                            }, O++, _[`f_rest_${B+2}`] = {
                                dtype: "float",
                                index: O
                            }, O++;
                        _.opacity = {
                            dtype: "float",
                            index: O
                        }, O++, _.scale_0 = {
                            dtype: "float",
                            index: O
                        }, O++, _.scale_1 = {
                            dtype: "float",
                            index: O
                        }, O++, _.scale_2 = {
                            dtype: "float",
                            index: O
                        }, O++, _.rot_0 = {
                            dtype: "float",
                            index: O
                        }, O++, _.rot_1 = {
                            dtype: "float",
                            index: O
                        }, O++, _.rot_2 = {
                            dtype: "float",
                            index: O
                        }, O++, _.rot_3 = {
                            dtype: "float",
                            index: O
                        }, O++;
                        let B = this.harmonics ? .map(_ => _.denormDequant());
                        return new M9(_, {
                            format: "binary_little_endian",
                            version: "1.0"
                        }, this.xyz.length, this.xyz.denormDequant(), this.color.denormDequant(), B || [], this.opacity.denormDequant(), this.scaling.denormDequant(), this.quaternion.denormDequant(), 3)
                    }
                },
                Ee = pn(iP()),
                Et = pn(iF()),
                Ei = {
                    xyz: 3,
                    color: 3,
                    opacity: 1,
                    scaling: 3,
                    quaternion: 4,
                    harmonics: 3
                },
                Er = class {
                    constructor(_) {
                        this._buffer = _
                    }
                    get buffer() {
                        return this._buffer
                    }
                    get decoded() {
                        return this._decoded || (this._decoded = this.decodeBuffer()), this._decoded
                    }
                    get colorsA() {
                        let _ = this.decoded.color.denormDequant(),
                            O = this.decoded.opacity.denormDequant(),
                            B = (0, Ee.default)(new Float32Array(4 * _.shape[0]), [_.shape[0], 4]);
                        return Et.mulseq(_, .28209479177387814), Et.addseq(_, .5), Et.mulseq(_, 255), Et.maxseq(_, 0), Et.minseq(_, 255), Et.negeq(O), Et.expeq(O), Et.addseq(O, 1), Et.recipeq(O), Et.mulseq(O, 255), Et.assign(B.hi(_.shape[0], 3).lo(0, 0), _), Et.assign(B.hi(_.shape[0], 4).lo(0, 3), O), (0, Ee.default)(new Uint8Array(B.data), [_.shape[0], 4]).data
                    }
                    get nsplats() {
                        return this.decoded.nsplats
                    }
                    getSplatCount() {
                        return this.decoded.nsplats
                    }
                    get precomputedCovarianceBufferData() {
                        return this._precomputedCovarianceBufferData
                    }
                    decodeBuffer() {
                        let {
                            splatCount: _,
                            chunkCount: O,
                            chunkSize: B,
                            typeChunks: N,
                            vertexData: k,
                            propertiesDesc: F
                        } = this.decodeHeader(), U = {
                            xyz: F.xyz.compressionMethod,
                            color: F.color.compressionMethod,
                            opacity: F.opacity.compressionMethod,
                            scaling: F.scaling.compressionMethod,
                            quaternion: F.quaternion.compressionMethod,
                            chunkSize: B
                        };
                        F.harmonics_0 && (U.harmonics = F.harmonics_0.compressionMethod);
                        let j = k.byteOffset,
                            G = Array(Object.keys(F).length);
                        for (let _ in F) G[F[_].index] = {
                            name: _,
                            method: F[_].compressionMethod
                        };
                        let Y = 8 * O,
                            Q = j,
                            K = "dynamic" === N ? 2 * O : 0,
                            $, ee = !1;
                        if (K > 0) {
                            let _ = new Uint16Array(k.buffer.slice(Q, Q + K));
                            Q += K, $ = Array.from(_), ee = !0
                        }
                        let et = {};
                        for (let N of G) {
                            let F, U, j = 0,
                                G = !0;
                            if ("norm8x" === N.method) j = 1 * _ * Ei[N.name];
                            else if ("norm11" === N.method) j = 4 * _;
                            else if ("norm565" === N.method) j = 2 * _;
                            else throw G = !1, Error(`Not Implemented format: ${N.method}`);
                            if (G) {
                                let _ = k.buffer.slice(Q, Q + Y);
                                F = (0, Ee.default)(new Float32Array(_), [O, 2]), Q += Y
                            } else throw Error("loading chunk byt hasnot minmax!");
                            let K = k.buffer.slice(Q, Q + j);
                            if (Q += j, "norm8x" === N.method) U = (0, Ee.default)(new Uint8Array(K), [_, Ei[N.name]]);
                            else if ("norm11" === N.method) U = (0, Ee.default)(new Uint32Array(K));
                            else if ("norm565" === N.method) U = (0, Ee.default)(new Uint16Array(K));
                            else throw Error(`Not Implemented format: ${N.method}`);
                            et[N.name] = new M$(U, F, B, N.method, $, ee)
                        }
                        let ei = [];
                        for (let _ = 0; _ < 15; _++) {
                            let O = et[`harmonics_${_}`];
                            O && (ei.push(O), delete et[`harmonics_${_}`])
                        }
                        return ei.length > 0 && (et.harmonics = ei), new M7(U, et.xyz, et.scaling, et.color, et.opacity, et.quaternion, et.harmonics, $)
                    }
                    buildPreComputedBuffers() {
                        let _ = this.decoded,
                            O = _.nsplats,
                            B = new ArrayBuffer(24 * O),
                            N = new Float32Array(B),
                            k = _.scaling.denormDequant(),
                            F = _.quaternion.denormDequant(),
                            U = new rm,
                            j = new i$,
                            G = new i$,
                            Y = new i$,
                            Q = new rJ;
                        for (let _ = 0; _ < O; _++) {
                            Q.makeScale(Math.exp(k.get(_, 0)), Math.exp(k.get(_, 1)), Math.exp(k.get(_, 2))), G.setFromMatrix4(Q), U.set(F.get(_, 0), F.get(_, 1), F.get(_, 2), F.get(_, 3)), Q.makeRotationFromQuaternion(U), j.setFromMatrix4(Q), Y.copy(j).multiply(G);
                            let O = Y.elements;
                            N[6 * _] = O[0] * O[0] + O[3] * O[3] + O[6] * O[6], N[6 * _ + 1] = O[0] * O[1] + O[3] * O[4] + O[6] * O[7], N[6 * _ + 2] = O[0] * O[2] + O[3] * O[5] + O[6] * O[8], N[6 * _ + 3] = O[1] * O[1] + O[4] * O[4] + O[7] * O[7], N[6 * _ + 4] = O[1] * O[2] + O[4] * O[5] + O[7] * O[8], N[6 * _ + 5] = O[2] * O[2] + O[5] * O[5] + O[8] * O[8]
                        }
                        this._precomputedCovarianceBufferData = B
                    }
                    decodeHeader() {
                        let _ = this._buffer,
                            O = new TextDecoder,
                            B = 0,
                            N = "";
                        for (;;) {
                            if (B + 100 >= _.byteLength) throw Error("End of file reached while searching for end of header");
                            let k = new Uint8Array(_, B, 100);
                            N += O.decode(k);
                            let F = (B += 100) - 200,
                                U = new Uint8Array(_, Math.max(0, F), F >= 0 ? 200 : 100);
                            if (O.decode(U).includes("end_header")) break
                        }
                        let k = N.split(`
`),
                            F = 0,
                            U = 0,
                            j = 0,
                            G = 0,
                            Y = "",
                            Q = {};
                        for (let _ = 0; _ < k.length; _++) {
                            let O = k[_].trim();
                            if (O.startsWith("element vertex")) {
                                let _ = O.match(/\d+/);
                                _ && (F = parseInt(_[0]))
                            } else if (O.startsWith("property")) {
                                let _ = O.match(/(\w+)\s+(\w+)\s+(\w+)/);
                                if (_) {
                                    let O = _[2],
                                        B = _[3];
                                    Q[O] = {
                                        compressionMethod: B,
                                        index: G
                                    }, G++
                                }
                            } else if (O.startsWith("element chunks")) {
                                let _ = O.match(/\d+/);
                                _ && (U = parseInt(_[0]))
                            } else if (O.startsWith("element chunkSize")) {
                                let _ = O.match(/\d+/);
                                _ && (j = parseInt(_[0]))
                            } else if (O.startsWith("element typeChunks")) {
                                let _ = O.match(/(\w+)\s+(\w+)\s+(\w+)/);
                                _ && (Y = _[3])
                            } else if ("end_header" === O) break
                        }
                        let K = N.indexOf("end_header") + 10 + 1;
                        return {
                            splatCount: F,
                            chunkCount: U,
                            chunkSize: j,
                            typeChunks: Y,
                            vertexData: new DataView(_, K),
                            propertiesDesc: Q
                        }
                    }
                    pruneSplats(_) {
                        let O = this.decodeBuffer().pruneSplats(_);
                        return Er.fromCompressedGaussianSplats(O)
                    }
                    static fromCompressedGaussianSplats(_) {
                        let O = _.xyz.length,
                            B = _.xyz.nchunks,
                            N = `gspline
element vertex ${O}
element chunks ${B}
element chunkSize ${_.chunkSize}
element typeChunks ${_.isDynamicChunks?"dynamic":"static"}
property xyz ${_.xyz.method}
property color ${_.color.method}
property opacity ${_.opacity.method}
property scaling ${_.scaling.method}
property quaternion ${_.quaternion.method}`;
                        if (_.harmonics && _.harmonics.length > 0)
                            for (let O = 0; O < _.harmonics.length; O++) N = `${N}
property harmonics_${O} ${_.harmonics[O].method}`;
                        N = `${N}
end_header
`;
                        let k = new TextEncoder().encode(N),
                            F = 8 * B,
                            U = _.xyz.quantized.data.buffer.byteLength,
                            j = _.xyz instanceof M$ ? F : 0,
                            G = _.color.quantized.data.buffer.byteLength,
                            Y = _.color instanceof M$ ? F : 0,
                            Q = _.opacity.quantized.data.buffer.byteLength,
                            K = _.opacity instanceof M$ ? F : 0,
                            $ = _.scaling.quantized.data.buffer.byteLength,
                            ee = _.scaling instanceof M$ ? F : 0,
                            et = _.quaternion.quantized.data.buffer.byteLength,
                            ei = _.quaternion instanceof M$ ? F : 0,
                            er = _.variableChunkSize ? Uint16Array.from(_.variableChunkSize) : void 0,
                            ea = er ? er.byteLength : 0,
                            en = k.byteLength + ea + U + j + G + Y + Q + K + $ + ee + et + ei,
                            eo = 0,
                            el = 0;
                        if (_.harmonics && _.harmonics.length > 0)
                            for (let O = 0; O < _.harmonics.length; O++) eo += _.harmonics[O].quantized.data.buffer.byteLength, _.harmonics[O];
                        en += (eo = 0) + 0;
                        let eh = new Uint8Array(en),
                            ec = 0;
                        if (eh.set(k, ec), ec += k.byteLength, ea > 0 && (eh.set(new Uint8Array(er.buffer), ec), ec += ea), _.xyz instanceof M$ && (eh.set(new Uint8Array(_.xyz.minmaxMatrix.data.buffer), ec), ec += F), eh.set(new Uint8Array(_.xyz.quantized.data.buffer), ec), ec += U, _.color instanceof M$ && (eh.set(new Uint8Array(_.color.minmaxMatrix.data.buffer), ec), ec += F), eh.set(new Uint8Array(_.color.quantized.data.buffer), ec), ec += G, _.opacity instanceof M$ && (eh.set(new Uint8Array(_.opacity.minmaxMatrix.data.buffer), ec), ec += F), eh.set(new Uint8Array(_.opacity.quantized.data.buffer), ec), ec += Q, _.scaling instanceof M$ && (eh.set(new Uint8Array(_.scaling.minmaxMatrix.data.buffer), ec), ec += F), eh.set(new Uint8Array(_.scaling.quantized.data.buffer), ec), ec += $, _.quaternion instanceof M$ && (eh.set(new Uint8Array(_.quaternion.minmaxMatrix.data.buffer), ec), ec += F), eh.set(new Uint8Array(_.quaternion.quantized.data.buffer), ec), ec += et, eo > 0 && _.harmonics && _.harmonics.length > 0)
                            for (let O = 0; O < _.harmonics.length; O++) {
                                let B = _.harmonics[O];
                                B instanceof M$ && (eh.set(new Uint8Array(B.minmaxMatrix.data.buffer), ec), ec += F), eh.set(new Uint8Array(B.quantized.data.buffer), ec), ec += B.quantized.data.byteLength
                            }
                        return new Er(eh.buffer)
                    }
                },
                Ea = class {};

            function H7(_) {
                let O, B, N, k, F, U, j, G, Y, Q, K, $, ee, et, ei, er;

                function v(_, O, U) {
                    let j = new Float32Array(Q, F, 3 * B);
                    N = 0;
                    let G = new Uint32Array(Q, k, B);
                    for (let B = 0; B < U.length - 1; B++) {
                        let k = O[B],
                            F = _[B].elements,
                            Y = k.filter(_ => _.enabled && "Include" === _.mode).map(_ => "Box" === _.type ? A(_) : M(_)),
                            Q = k.filter(_ => _.enabled && "Exclude" === _.mode).map(_ => "Box" === _.type ? A(_) : M(_));
                        for (let _ = U[B]; _ < U[B + 1]; _++) {
                            let O = ee[3 * _],
                                B = ee[3 * _ + 1],
                                k = ee[3 * _ + 2];
                            if ((0 === Y.length || w(O, B, k, Y)) && (0 === Q.length || !w(O, B, k, Q))) {
                                let U = 1 / (F[3] * O + F[7] * B + F[11] * k + F[15]);
                                j[3 * N] = (F[0] * O + F[4] * B + F[8] * k + F[12]) * U, j[3 * N + 1] = (F[1] * O + F[5] * B + F[9] * k + F[13]) * U, j[3 * N + 2] = (F[2] * O + F[6] * B + F[10] * k + F[14]) * U, G[N] = _, N++
                            }
                        }
                    }
                }

                function w(_, O, B, N, k) {
                    return N["Intersect" === k ? "every" : "some"](N => {
                        var k, F, U, j, G, Y, Q, K;
                        let $, ee, et, ei, er, ea, en;
                        let eo = (k = N.invRotationMatrix, $ = _ - (F = N.cropCenter)[0], ee = O - F[1], et = B - F[2], ei = 1 / (k[3] * $ + k[7] * ee + k[11] * et + k[15]), {
                            x: (k[0] * $ + k[4] * ee + k[8] * et + k[12]) * ei + F[0],
                            y: (k[1] * $ + k[5] * ee + k[9] * et + k[13]) * ei + F[1],
                            z: (k[2] * $ + k[6] * ee + k[10] * et + k[14]) * ei + F[2]
                        });
                        return Array.isArray(N) ? (U = eo.x, j = eo.y, G = eo.z, U >= N[0] && U <= N[3] && j >= N[1] && j <= N[4] && G >= N[2] && G <= N[5]) : (Y = eo.x, Q = eo.y, K = eo.z, er = (Y - N.cropCenter[0]) * N.invRadiusX, er * er + (ea = (Q - N.cropCenter[1]) * N.invRadiusY) * ea + (en = (K - N.cropCenter[2]) * N.invRadiusZ) * en <= 1)
                    })
                }

                function A(_) {
                    let O = _.cropSize[0] / 2,
                        B = _.cropSize[1] / 2,
                        N = _.cropSize[2] / 2;
                    return Object.assign([_.cropCenter[0] - O, _.cropCenter[1] - B, _.cropCenter[2] - N, _.cropCenter[0] + O, _.cropCenter[1] + B, _.cropCenter[2] + N], {
                        invRotationMatrix: E(_.cropRotation),
                        cropCenter: _.cropCenter
                    })
                }

                function E(_) {
                    let O = [],
                        B = _[0] * Math.PI / 180,
                        N = _[1] * Math.PI / 180,
                        k = _[2] * Math.PI / 180,
                        F = Math.cos(B),
                        U = Math.sin(B),
                        j = Math.cos(N),
                        G = Math.sin(N),
                        Y = Math.cos(k),
                        Q = Math.sin(k),
                        K = F * Y,
                        $ = F * Q,
                        ee = U * Y,
                        et = U * Q;
                    return O[0] = j * Y, O[1] = -j * Q, O[2] = G, O[4] = $ + ee * G, O[5] = K - et * G, O[6] = -U * j, O[8] = et - K * G, O[9] = ee + $ * G, O[10] = F * j, O[12] = 0, O[13] = 0, O[14] = 0, O[3] = 0, O[7] = 0, O[11] = 0, O[15] = 1, O
                }

                function M(_) {
                    let O = 2 / _.cropSize[0],
                        B = 2 / _.cropSize[1],
                        N = 2 / _.cropSize[2],
                        k = E(_.cropRotation);
                    return {
                        invRadiusX: O,
                        invRadiusY: B,
                        invRadiusZ: N,
                        cropCenter: _.cropCenter,
                        invRotationMatrix: k
                    }
                }
                _.onmessage = ea => {
                    if (ea.data.getCroppedIndexes) {
                        let O = new Uint32Array(function(_, O) {
                            let B = [],
                                N = O.filter(_ => _.enabled && "Include" === _.mode).map(_ => "Box" === _.type ? A(_) : M(_)),
                                k = O.filter(_ => _.enabled && "Exclude" === _.mode).map(_ => "Box" === _.type ? A(_) : M(_)),
                                F = _.length;
                            for (let O = 0; O < F; O += 3) {
                                let F = _[O],
                                    U = _[O + 1],
                                    j = _[O + 2];
                                (0 === N.length || w(F, U, j, N)) && (0 === k.length || !w(F, U, j, k)) || B.push(O / 3)
                            }
                            return console.log(B), B
                        }(new Float32Array(ea.data.positions), ea.data.crops)).buffer;
                        _.postMessage({
                            outOfBoundsIndexes: O
                        }, [O])
                    } else if (ea.data.positions) K = ea.data.positions, ee = new Float32Array(K), ei = ea.data.meshMatrixWorlds, er = ea.data.cropsArray, et = ea.data.meshIndexIntervals, v(ei, er, et), _.postMessage({
                        sortSetupComplete: !0
                    });
                    else if (ea.data.sort || ea.data.newMatrixWorlds || ea.data.newCropsArray)(ea.data.newMatrixWorlds || ea.data.newCropsArray) && (er = ea.data.newCropsArray || er, v(ei = ea.data.newMatrixWorlds || ei, er, et)),
                        function(K) {
                            let ee, et = new Float64Array(Q, U, 16);
                            for (let _ = 0; _ < 16; _++) et[_] = K[_];
                            if (N > 1) {
                                O.exports.sortIndexes(k, F, Y, U, j, G, $.DepthMapRange, N);
                                let _ = new Uint32Array(N);
                                ee = _.buffer, _.set(new Uint32Array(Q, G, N))
                            } else if (1 === N) {
                                let _ = new Uint32Array(N);
                                _[0] = new Uint32Array(Q, k, B)[0], ee = _.buffer
                            } else ee = new ArrayBuffer(0);
                            _.postMessage({
                                sortDone: !0,
                                indexesBuffer: ee
                            }, [ee])
                        }(ea.data.sort.view, ea.data.sort.cameraPosition);
                    else if (ea.data.init) {
                        $ = ea.data.init.Constants, B = ea.data.init.splatCount;
                        let N = $.BytesPerInt,
                            K = 3 * $.BytesPerFloat,
                            ee = new Uint8Array(ea.data.init.sorterWasmBytes),
                            et = Math.floor((B * (N + K) + (B * $.BytesPerInt * 2 + $.DepthMapRange * $.BytesPerInt * 2) + 32 * $.MemoryPageSize) / $.MemoryPageSize) + 1,
                            ei = {
                                module: {},
                                env: {
                                    memory: new WebAssembly.Memory({
                                        initial: 2 * et,
                                        maximum: 3 * et,
                                        shared: !0
                                    })
                                }
                            };
                        WebAssembly.compile(ee).then(_ => WebAssembly.instantiate(_, ei)).then(ee => {
                            O = ee, k = 0, G = (j = (Y = (U = (F = B * N) + B * K) + 16 * $.BytesPerFloat * 2) + B * $.BytesPerInt) + $.DepthMapRange * $.BytesPerInt, Q = ei.env.memory.buffer, _.postMessage({
                                sortSetupPhase1Complete: !0
                            })
                        })
                    }
                }
            }
            mn(Ea, "DepthMapRange", 65536), mn(Ea, "MemoryPageSize", 65536), mn(Ea, "BytesPerFloat", 4), mn(Ea, "BytesPerInt", 4);
            var En = (t6 = new Float32Array(1), t8 = new Int32Array(t6.buffer), function(_) {
                    return t6[0] = _, t8[0]
                }),
                El = new iJ,
                Eh = class extends at {
                    constructor(_, O, B, N, k = !1, F = 1, U, j) {
                        super(B, N), this.splatCount = O, this.meshIndexIntervals = U, this.meshMatrixWorlds = j, this.splatBuffers = _, this.geometry = B, this.material = N, this.splatDataTextures = null, this.halfPrecisionCovariancesOnGPU = k, this.devicePixelRatio = F, this.resetLocalSplatDataAndTexturesFromSplatBuffer()
                    }
                    static buildMesh(_, O, B = !1, N = 1, k, F) {
                        let U = Eh.buildGeomtery(O),
                            j = Eh.buildMaterial(k);
                        return new Eh(_, O, U, j, B, N, k, F)
                    }
                    static buildMaterial(_) {
                        let O = `
            precision highp float;
            #include <common>

            attribute uint splatIndex;

            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D centersColorsTexture;
            uniform vec2 focal;
            uniform vec2 viewport;
            uniform vec2 basisViewport;
            uniform vec2 covariancesTextureSize;
            uniform vec2 centersColorsTextureSize;
						uniform highp sampler2D meshMatrixWorldsTexture;
						uniform uint meshIndexIntervals[257];
						uniform float orthoZoom;

            varying vec4 vColor;
            varying vec2 vUv;

            varying vec2 vPosition;

            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
            const uvec4 shift4 = uvec4(0, 8, 16, 24);
            vec4 uintToRGBAVec (uint u) {
               uvec4 urgba = mask4 & u;
               urgba = urgba >> shift4;
               vec4 rgba = vec4(urgba) * encodeNorm4;
               return rgba;
            }

            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
                vec2 samplerUV = vec2(0.0, 0.0);
                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
                samplerUV.y = float(floor(d)) / dimensions.y;
                samplerUV.x = fract(d);
                return samplerUV;
            }

            void main () {
                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));
                vColor = uintToRGBAVec(sampledCenterColor.r);

                vPosition = position.xy * 2.0;

								uint meshIndex;
								for (int i = 1; i < 257; i++) {
									if (splatIndex < meshIndexIntervals[i]) {
										meshIndex = uint(i - 1);
										break;
									}
								}

								float strideMulmeshIndex = float(4u*meshIndex);
								float meshMatrixWorldsTextureLength = float(256*4);

								mat4 modelMat = mat4(
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+0.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+1.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+2.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+3.0)/meshMatrixWorldsTextureLength, 0))
								);
								mat4 modelViewMat = viewMatrix * modelMat;
								vec4 viewCenter = modelViewMat * vec4(splatCenter, 1.0); 
                vec4 clipCenter = projectionMatrix * viewCenter;

                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;
                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;
                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;

                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);
                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);

                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix
                mat3 Vrk = mat3(
                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
                );
                float s = 1.0 / (viewCenter.z * viewCenter.z);

                mat3 W = transpose(mat3(modelViewMat));
                mat3 T = orthoZoom > 0.0 ? W : W * mat3(
									focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
									0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
									0., 0., 0.
								);
                mat3 cov2Dm = transpose(T) * Vrk * T;
                cov2Dm[0][0] += 0.3;
                cov2Dm[1][1] += 0.3;

                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
                // need cov2Dm[1][0] because it is a symetric matrix.
                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
                // so that we can determine the 2D basis for the splat. This is done using the method described
                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                //
                // This is a different approach than in the original work at INRIA. In that work they compute the
                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle
                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance
                // matrix (called 'conic') to determine fragment opacity.
                float a = cov2Dv.x;
                float d = cov2Dv.z;
                float b = cov2Dv.y;
                float D = a * d - b * b;
                float trace = a + d;
                float traceOver2 = 0.5 * trace;
                float term2 = sqrt(trace * trace / 4.0 - D);
                float eigenValue1 = traceOver2 + term2;
								float eigenValue2 = max(traceOver2 - term2, 0.00); // prevent negative eigen value

                const float maxSplatSize = 1024.0;
                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
                // since the eigen vectors are orthogonal, we derive the second one from the first
                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);
                vec2 basisVector1 = eigenVector1 * min(sqrt(2.0 * eigenValue1), maxSplatSize);
                vec2 basisVector2 = eigenVector2 * min(sqrt(2.0 * eigenValue2), maxSplatSize);

                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport;

								if (orthoZoom > 0.0) {
									ndcOffset *= orthoZoom;
								}

                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            }`,
                            B = `
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;

            varying vec2 vPosition;
						layout(location = 1) out vec4 gVelocity; 

            void main () {
                // compute the negative squared distance from the center of the splat to the
                // current fragment in the splat's local space.
                float A = -dot(vPosition, vPosition);
                if (A < -4.0) discard;
                vec3 color = vColor.rgb;
                A = exp(A) * vColor.a;
                gl_FragColor = vec4(color.rgb, A);
								gVelocity = vec4(0.0); // so it is ignored by TAA
            }`,
                            N = {
                                covariancesTexture: {
                                    type: "t",
                                    value: null
                                },
                                centersColorsTexture: {
                                    type: "t",
                                    value: null
                                },
                                meshIndexIntervals: {
                                    value: _
                                },
                                meshMatrixWorldsTexture: {
                                    type: "t",
                                    value: null
                                },
                                focal: {
                                    type: "v2",
                                    value: new iJ
                                },
                                viewport: {
                                    type: "v2",
                                    value: new iJ
                                },
                                basisViewport: {
                                    type: "v2",
                                    value: new iJ
                                },
                                debugColor: {
                                    type: "v3",
                                    value: new re
                                },
                                covariancesTextureSize: {
                                    type: "v2",
                                    value: new iJ(1024, 1024)
                                },
                                centersColorsTextureSize: {
                                    type: "v2",
                                    value: new iJ(1024, 1024)
                                },
                                orthoZoom: {
                                    type: "f",
                                    value: -1
                                }
                            };
                        return new an({
                            uniforms: N,
                            vertexShader: O,
                            fragmentShader: B,
                            transparent: !0,
                            alphaTest: 1,
                            blending: 1,
                            depthTest: !0,
                            depthWrite: !1,
                            side: 2
                        })
                    }
                    static buildGeomtery(_) {
                        let O = new sK;
                        O.setIndex([0, 1, 2, 0, 2, 3]);
                        let B = new Float32Array(12),
                            N = new sF(B, 3);
                        O.setAttribute("position", N), N.setXYZ(0, -1, -1, 0), N.setXYZ(1, -1, 1, 0), N.setXYZ(2, 1, 1, 0), N.setXYZ(3, 1, -1, 0), N.needsUpdate = !0;
                        let k = new li().copy(O),
                            F = new Uint32Array(_),
                            U = new nN(F, 1, !1);
                        return U.setUsage(35048), k.setAttribute("splatIndex", U), k.instanceCount = _, k
                    }
                    resetLocalSplatDataAndTexturesFromSplatBuffer() {
                        this.updateLocalSplatDataFromSplatBuffer(), this.allocateAndStoreLocalSplatDataInTextures()
                    }
                    updateLocalSplatDataFromSplatBuffer() {
                        this.splatBuffers.forEach(_ => _.buildPreComputedBuffers()), this.covariances = new Float32Array(6 * this.splatCount), this.colors = new Uint8Array(4 * this.splatCount), this.centers = new Float32Array(3 * this.splatCount);
                        let _ = 0,
                            O = 0,
                            B = 0;
                        for (let N of this.splatBuffers) {
                            let k = N.nsplats;
                            this.colors.subarray(_, _ + 4 * k).set(N.colorsA), _ += 4 * k, this.centers.subarray(O, O + 3 * k).set(N.decoded.xyz.denormDequant().data), O += 3 * k, this.covariances.subarray(B, B + 6 * k).set(new Float32Array(N.precomputedCovarianceBufferData)), B += 6 * k
                        }
                    }
                    allocateAndStoreLocalSplatDataInTextures() {
                        let _, O, B = this.splatCount,
                            N = new iJ(4096, 1024);
                        for (; N.x * N.y * 2 < 6 * B;) N.y *= 2;
                        let k = new iJ(4096, 1024);
                        for (; k.x * k.y * 4 < 4 * B;) k.y *= 2;
                        if (this.halfPrecisionCovariancesOnGPU) {
                            O = new Uint16Array(N.x * N.y * 2);
                            for (let _ = 0; _ < this.covariances.length; _++) O[_] = lY.toHalfFloat(this.covariances[_]);
                            _ = new nI(O, N.x, N.y, 1030, 1016)
                        } else(O = new Float32Array(N.x * N.y * 2)).set(this.covariances), _ = new nI(O, N.x, N.y, 1030, 1015);
                        _.needsUpdate = !0, this.material.uniforms.covariancesTexture.value = _, this.material.uniforms.covariancesTextureSize.value.copy(N);
                        let F = new Uint32Array(k.x * k.y * 4);
                        for (let _ = 0; _ < B; _++) {
                            var U;
                            let O = 4 * _,
                                B = 3 * _,
                                N = 4 * _;
                            F[N] = (U = this.colors[O], U + (this.colors[O + 1] << 8) + (this.colors[O + 2] << 16) + (this.colors[O + 3] << 24)), F[N + 1] = En(this.centers[B]), F[N + 2] = En(this.centers[B + 1]), F[N + 3] = En(this.centers[B + 2])
                        }
                        let j = new nI(F, k.x, k.y, 1033, 1014);
                        j.internalFormat = "RGBA32UI", j.needsUpdate = !0, this.material.uniforms.centersColorsTexture.value = j, this.material.uniforms.centersColorsTextureSize.value.copy(k);
                        let G = new Float32Array(4096);
                        for (let _ = 0; _ < this.meshMatrixWorlds.length; _++) G.set(this.meshMatrixWorlds[_].elements, 16 * _);
                        let Y = new nI(G, 1024, 1, 1023, 1015);
                        Y.needsUpdate = !0, this.material.uniforms.meshMatrixWorldsTexture.value = Y, this.material.uniformsNeedUpdate = !0, this.splatDataTextures = {
                            covariances: {
                                data: O,
                                texture: _,
                                size: N
                            },
                            centerColors: {
                                data: F,
                                texture: j,
                                size: k
                            },
                            meshMatrixWorlds: {
                                data: G,
                                texture: Y
                            }
                        }
                    }
                    updateIndexes(_) {
                        let O = this.geometry;
                        O.attributes.splatIndex.set(_), O.attributes.splatIndex.needsUpdate = !0, O.instanceCount = _.length
                    }
                    updateUniforms(_, O, B, N) {
                        this.splatCount > 0 && (El.set(_.x * this.devicePixelRatio, _.y * this.devicePixelRatio), this.material.uniforms.viewport.value.copy(El), this.material.uniforms.basisViewport.value.set(2 / El.x, 2 / El.y), this.material.uniforms.focal.value.set(O, B), this.material.uniforms.orthoZoom.value = N, this.material.uniformsNeedUpdate = !0)
                    }
                    getSplatDataTextures() {
                        return this.splatDataTextures
                    }
                    getSplatCount() {
                        return this.splatCount
                    }
                    getCenters() {
                        return this.centers
                    }
                    getColors() {
                        return this.colors
                    }
                    getCovariances() {
                        return this.covariances
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose(), this.splatDataTextures && (this.splatDataTextures.covariances.texture.dispose(), this.splatDataTextures.centerColors.texture.dispose(), this.splatDataTextures.meshMatrixWorlds.texture.dispose())
                    }
                },
                Ec = class {
                    constructor(_ = {}) {
                        let O, B, N, k, F, U, j;
                        mn(this, "updateSplatMeshUniforms", (O = new iJ, function() {
                            null !== this.splatMesh && this.splatMesh.getSplatCount() > 0 && (this.renderer.getSize(O), this.cameraFocalLengthX = this.camera.projectionMatrix.elements[0] * this.devicePixelRatio * O.x * .45, this.cameraFocalLengthY = this.camera.projectionMatrix.elements[5] * this.devicePixelRatio * O.y * .45, this.splatMesh.updateUniforms(O, this.cameraFocalLengthX, this.cameraFocalLengthY, this.camera.isPerspectiveCamera ? -1 : this.camera.zoom * this.devicePixelRatio))
                        })), mn(this, "updateView", (B = new rJ, N = [], k = new rv(0, 0, -1), F = new rv(0, 0, -1), U = new rv, j = new rv, function(_ = !1) {
                            let O = this.updateMatrixWorldsInWorkerIfNeeded(),
                                G = this.cropsChanged();
                            if (!_) {
                                F.set(0, 0, -1).applyQuaternion(this.camera.quaternion);
                                let _ = !1,
                                    B = !1;
                                if (.95 >= F.dot(k) && (_ = !0), j.copy(this.camera.position).sub(U).length() >= 1 && (B = !0), !_ && !B && !O && !G) return
                            }
                            U.copy(this.camera.position), k.copy(F), B.copy(this.camera.matrixWorld).invert(), B.premultiply(this.camera.perspCamera.projectionMatrix), N[0] = this.camera.position.x, N[1] = this.camera.position.y, N[2] = this.camera.position.z;
                            let Y = {
                                sort: {
                                    view: B.elements,
                                    cameraPosition: N,
                                    splatRenderCount: this.splatRenderCount,
                                    splatSortCount: this.splatRenderCount
                                },
                                ...O ? {
                                    newMatrixWorlds: this.meshMatrixWorlds
                                } : {},
                                ...G ? {
                                    newCropsArray: this.cropsArray
                                } : {}
                            };
                            this.sortRunning ? this.queuedMessage = Y : (this.queuedMessage = null, this.sortRunning = !0, this.sortWorker.postMessage(Y))
                        })), this.scene = _.scene, this.currentPage = null, this.renderer = _.renderer, this.devicePixelRatio = window.devicePixelRatio, this.sortWorker = null, this.splatRenderCount = 0, this.splatSortCount = 0, this.splatMesh = null, this.sortRunning = !1, this.splatRenderingInitialized = !1, this.meshMatrixWorlds = null, this.meshMatrixWorldsOld = null, this.cropsArray = null, this.splatEntries = null, this.queuedMessage = null
                    }
                    get camera() {
                        return this.scene.activeCamera
                    }
                    reloadSplats() {
                        this.splatRenderingInitialized = !1;
                        let _ = this.loadSplat();
                        this.renderer.pipeline.opaquePass.splatViewer = _ ? this : null
                    }
                    loadSplat(_ = {}) {
                        this.activePage = this.scene.activePage, _.position && (_.position = new rv().fromArray(_.position)), _.orientation && (_.orientation = new rm().fromArray(_.orientation)), _.halfPrecisionCovariances = !!_.halfPrecisionCovariances;
                        let O = [];
                        if (this.splatEntries = O, this.activePage.traverseEntity(_ => {
                                if ("Splat" === _.data.type) {
                                    let B = _.visible;
                                    _.traverseAncestors(_ => {
                                        B && (B = _.visible)
                                    }), B && O.push(_)
                                }
                            }), this.splatMesh && this.splatMesh.dispose(), 0 === O.length) return this.splatMesh = null, !1;
                        this.meshMatrixWorlds = O.map(_ => _.matrixWorld), this.meshMatrixWorldsOld = O.map(_ => _.matrixWorld.clone()), this.cropsArray = O.map(_ => _.data.crops.map(_ => _.data));
                        let B = O.map(_ => new Er(new Uint8Array(_.data.buffer).buffer)),
                            N = 0,
                            k = [0];
                        for (let _ of B) N += _.getSplatCount(), k.push(N);
                        return this.setupSplatMesh(B, N, _.position, _.orientation, _.halfPrecisionCovariances, this.devicePixelRatio, k, this.meshMatrixWorlds), this.setupSortWorker(N), !0
                    }
                    updateMatrixWorldsInWorkerIfNeeded() {
                        let _ = this.splatDataTextures.meshMatrixWorlds.data;
                        for (let O = 0; O < this.meshMatrixWorlds.length; O++) _.set(this.meshMatrixWorlds[O].elements, 16 * O);
                        return this.splatDataTextures.meshMatrixWorlds.texture.needsUpdate = !0, !this.meshMatrixWorlds.every((_, O) => _.equals(this.meshMatrixWorldsOld[O])) && (this.meshMatrixWorldsOld = this.meshMatrixWorlds.map(_ => _.clone()), !0)
                    }
                    cropsChanged() {
                        let _ = !1;
                        return this.splatEntries.forEach((O, B) => {
                            O.data.crops.forEach((O, N) => {
                                void 0 === this.cropsArray[B][N] ? (_ = !0, this.cropsArray[B][N] = O.data) : Object.entries(O.data).forEach(([O, k]) => {
                                    Array.isArray(k) && k.some((_, k) => _ !== this.cropsArray[B][N][O][k]) ? (_ = !0, this.cropsArray[B][N][O] = k) : k !== this.cropsArray[B][N] ? .[O] && (_ = !0, this.cropsArray[B][N][O] = k)
                                })
                            }), O.data.crops.length !== this.cropsArray[B] ? .length && (this.cropsArray[B].length = O.data.crops.length, _ = !0)
                        }), _
                    }
                    setupSplatMesh(_, O, B = new rv, N = new rm, k = !1, F = 1, U, j) {
                        this.splatMesh = Eh.buildMesh(_, O, k, F, U, j), this.splatMesh.position.copy(B), this.splatMesh.quaternion.copy(N), this.splatMesh.frustumCulled = !1, this.splatMesh.renderOrder = 10, this.updateSplatMeshUniforms(), this.splatRenderCount = O
                    }
                    setupSortWorker(_) {
                        this.sortWorker = function(_) {
                            let O = new Worker(URL.createObjectURL(new Blob(["(", H7.toString(), ")(self)"], {
                                    type: "application/javascript"
                                }))),
                                B = atob("AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAETA2AAAGAIf39/f39/f38AYAABfwISAQNlbnYGbWVtb3J5AgMAgIAEAwQDAAECBzkDEV9fd2FzbV9jYWxsX2N0b3JzAAALc29ydEluZGV4ZXMAARNlbXNjcmlwdGVuX3Rsc19pbml0AAIK3gMDAwABC9IDAwF/BnwBfgJAIAdFDQAgAysDUCEMIAMrAzAhDSADKwMQIQ5BACEDRP///////+9/IQtEAAAAAAAAEAAhCgNAIAIgA0ECdGoCfyAOIAEgA0EMbGoiCCoCALuiIA0gCCoCBLuioCAMIAgqAgi7oqBEAAAAAAAAsECiIgmZRAAAAAAAAOBBYwRAIAmqDAELQYCAgIB4CzYCACAJIAsgCSALYxshCyAJIAogCSAKZBshCiADQQFqIgMgB0cNAAsgB0UNACAGuCAKIAuhoyEJQQAhAwNAAn8gCSACIANBAnRqIgEoAgC3IAuhoiIKmUQAAAAAAADgQWMEQCAKqgwBC0GAgICAeAshCCABIAg2AgAgBCAIQQJ0aiIBIAEoAgBBAWo2AgAgA0EBaiIDIAdHDQALCyAGQQJPBEAgBCgCACEIQQEhAwNAIAQgA0ECdGoiASABKAIAIAhqIgg2AgAgA0EBaiIDIAZHDQALCyAHQQFrIgGtIQ8DQCAEIAIgD6dBAnQiA2ooAgBBAnRqIgcgBygCAEEBayIHNgIAIAUgASAHa0ECdGogACADaigCADYCACAPUCEDIA9CAX0hDyADRQ0ACyAGBEAgBEEAIAZBAnT8CwALCwQAQQAL"),
                                N = new Uint8Array(B.length);
                            for (let _ = 0; _ < B.length; _++) N[_] = B.charCodeAt(_);
                            return O.postMessage({
                                init: {
                                    sorterWasmBytes: N.buffer,
                                    splatCount: _,
                                    Constants: {
                                        BytesPerFloat: Ea.BytesPerFloat,
                                        BytesPerInt: Ea.BytesPerInt,
                                        DepthMapRange: Ea.DepthMapRange,
                                        MemoryPageSize: Ea.MemoryPageSize
                                    }
                                }
                            }), O
                        }(_), this.sortWorker.onmessage = _ => {
                            _.data.sortDone ? (this.sortRunning = !1, this.splatMesh ? .updateIndexes(new Uint32Array(_.data.indexesBuffer)), this.lastSortTime = _.data.sortTime, this.queuedMessage && (this.sortWorker.postMessage(this.queuedMessage), this.queuedMessage = null)) : _.data.sortCanceled ? this.sortRunning = !1 : _.data.sortSetupPhase1Complete ? this.sortWorker.postMessage({
                                positions: this.splatMesh.getCenters().buffer,
                                meshMatrixWorlds: this.splatMesh.meshMatrixWorlds,
                                meshIndexIntervals: this.splatMesh.meshIndexIntervals,
                                cropsArray: this.cropsArray
                            }) : _.data.sortSetupComplete && (this.splatDataTextures = this.splatMesh.getSplatDataTextures(), this.updateView(!0, !0), this.splatRenderingInitialized = !0)
                        }
                    }
                    update() {
                        !1 !== this.splatRenderingInitialized && (this.updateSplatMeshUniforms(), this.updateView())
                    }
                    getSplatMesh() {
                        return this.splatMesh
                    }
                },
                Ed = new sz;
            Ed.wireframe = !0;
            var Eu = new rv,
                Ep = class extends nS {
                    constructor(_, O) {
                        super(), this.data = _, this.enableHelpers = !1, this.wireframeState = !1, this.needsTransmissionDirty = !0, this.needsNormalDirty = !0, this._needsTransmission = !1, this._needsNormal = !1, this.geometryCacheChanged = !1, this.splatViewer = null, this.entityByUuid = {}, this.entityIdentityToEntity = {}, this.toExpandCloner = new Set, this.toUpdateCloner = new Set, this.pendingCommands = [], this.pathConstraints = new Mq, this.errorPage = new Mz("fdasfa", { ...gx.defaultData,
                            name: ""
                        }), this.invisibleObjects = new Sy("jflkdsafjasdifjaslk", { ...gd.defaultData,
                            visible: !1,
                            name: "buildin invisible"
                        }), this.needsRecomputeInstances = !1, this.init(_, O), this.matrixAutoUpdate = !1
                    }
                    markGeometryCacheDirty() {
                        this.geometryCacheChanged = !0
                    }
                    markNeedsUpdateRendererDirty() {
                        this.needsTransmissionDirty = !0, this.needsNormalDirty = !0
                    }
                    needsTransmission() {
                        let _;
                        return this.needsTransmissionDirty && (this._needsTransmission = (_ = !1, this.traverseEntity(O => {
                            if (O instanceof _l) {
                                if (Array.isArray(O.material))
                                    for (let B = 0; B < O.material.length; B++) YO(O, O.material[B]) && (_ = !0);
                                else YO(O, O.material) && (_ = !0)
                            }
                        }), _), this.needsTransmissionDirty = !1), this._needsTransmission
                    }
                    needsNormal() {
                        let _;
                        return this.needsNormalDirty && (this._needsNormal = (_ = !1, this.traverseEntity(O => {
                            if (O instanceof _l) {
                                if (Array.isArray(O.material))
                                    for (let B = 0; B < O.material.length; B++) qO(O, O.material[B]) && (_ = !0);
                                else qO(O, O.material) && (_ = !0)
                            }
                        }), _), this.needsNormalDirty = !1), this._needsNormal
                    }
                    registerInstanceAndSetUuid(_) {
                        let O = _.identity.join("-"),
                            B = this.entityIdentityToEntity[O];
                        B && (_.uuid = B.uuid), this.entityIdentityToEntity[O] = _, this.entityByUuid[_.uuid] = _
                    }
                    markPenumbraSizeDirty() {
                        for (let _ of this.children) _ instanceof Mz && (_.penumbraSizeArrayCache = null)
                    }
                    findInstance(_) {
                        return this.entityIdentityToEntity[_.join("-")]
                    }
                    get bgColor() {
                        return this.activePage.bgColor
                    }
                    get postprocessing() {
                        return this.activePage.data.postprocessing
                    }
                    getWithSortKey(_) {
                        let O = this.find(_);
                        if (void 0 === O) return;
                        let B = [],
                            N = O;
                        for (; N !== this;) {
                            let _ = N,
                                O = (N = N.parent).children.indexOf(_);
                            B.splice(0, 0, O)
                        }
                        return {
                            entity: O,
                            sortKey: B
                        }
                    }
                    getAllSorted(_) {
                        let O = [];
                        for (let B of _) {
                            let _ = this.getWithSortKey(B.id);
                            void 0 !== _ && O.push(_)
                        }
                        return O.sort((_, O) => (function(_, O) {
                            let B = 0;
                            for (; B < _.length && B < O.length;) {
                                if (_[B] < O[B]) return -1;
                                if (_[B] > O[B]) return 1;
                                B += 1
                            }
                            return B !== O.length ? -1 : B !== _.length ? 1 : 0
                        })(_.sortKey, O.sortKey)), O.map(_ => _.entity)
                    }
                    nonExistOrDescendantOf(_, O) {
                        let B = this.find(_);
                        if (void 0 === B) return !0;
                        for (; B;) {
                            if (B.uuid === O) return !0;
                            B = B.parent
                        }
                        return !1
                    }
                    find(_) {
                        if (this.activePage && this.activePage.personalCamera.parent && ("f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera" === _ || _ === pq)) return this.activePage.personalCamera;
                        if ("" === _ || void 0 === _) return;
                        let O = this.entityByUuid[_];
                        return void 0 === O ? this.getObjectByProperty("uuid", _) : O
                    }
                    debugEnsureEntity(_) {
                        let O = this.find(_);
                        O ? Array.isArray(O.identity) && void 0 === this.findInstance(O.identity) && console.error("not found instance") : console.error("not found")
                    }
                    addPendingExpandCloner(_) {
                        this.toExpandCloner.add(_)
                    }
                    addPendingUpdateCloner(_) {
                        this.toUpdateCloner.add(_)
                    }
                    markToExpandCloner(_) {
                        this.toExpandCloner.add(_), _.traverseEntityAncestors(_ => {
                            this.toExpandCloner.add(_)
                        })
                    }
                    doPendingExpandCloner() {
                        this.toExpandCloner.forEach(_ => {
                            _.expandCloner(this)
                        }), this.toExpandCloner.clear()
                    }
                    doPendingUpdateCloner() {
                        this.toUpdateCloner.forEach(_ => {
                            _.cloner ? .update()
                        }), this.toUpdateCloner.clear()
                    }
                    doPendingUpdates() {
                        this.doPendingExpandCloner(), this.doPendingUpdateCloner(), this.applyPendingCommands()
                    }
                    addPendingCommand(_) {
                        this.pendingCommands.push(_)
                    }
                    applyPendingCommands() {
                        this.pendingCommands.forEach(_ => _()), this.pendingCommands.length = 0
                    }
                    updateByLibOp(_, O) {
                        1 === _.path.length && "components" === _.path[0] && 1 === _.type && this.createChildrenObjects([{ ..._.data.asset,
                            id: _.id
                        }], this.invisibleObjects, O)
                    }
                    updateTreeByOp(_, O) {
                        if (0 === _.path.length && 7 === _.type) {
                            let B = null === _.parent ? this : this.find(_.parent);
                            if (void 0 === B) throw Error("unexpected");
                            let N = this.createObject(_.id, _.data, _.children, B, _.localIndex, O);
                            N.updateVisible(), N.resetBBoxNeedsUpdate(), Yn(N) && Xn(N.parent) && (N.invalidateUpstreamBooleanData(), N.parent.invalidateDownstreamBooleanData().recomputeBoolean()), this.markNeedsRecomputeInstancesForAncessors(B), this.markNeedsRecomputeInstancesForChildren(N), this.markToExpandCloner(N), this.markPenumbraSizeDirty(), N.updatePathSnapping()
                        } else if (0 === _.path.length && 8 === _.type) {
                            let O = this.find(_.id);
                            if (void 0 === O) throw Error("unexpected");
                            this.markToExpandCloner(O), O.resetBBoxNeedsUpdate(), this.unregisterObject(O);
                            let B = O.parent;
                            this.markNeedsRecomputeInstancesForAncessors(B), this.markNeedsRecomputeInstancesForChildren(O), this.markPenumbraSizeDirty(), O.parent.remove(O), Xn(O.parent) && (O.parent.invalidateUpstreamBooleanData(), O.parent.invalidateDownstreamBooleanData().recomputeBoolean()), Yn(O) && (O.freeBooleanPointer(), B instanceof Sg && B.invalidateDownstreamBooleanData().recomputeBoolean()), O instanceof MF && O.detachShape(), this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(O), this.pathConstraints.removeDependencies(O.uuid), O.updatePathSnapping()
                        } else if (0 === _.path.length && 9 === _.type) {
                            let O = this.find(_.id);
                            if (void 0 === O) throw Error("unexpected");
                            this.markNeedsRecomputeInstancesForChildren(O);
                            let B = O.parent;
                            this.markNeedsRecomputeInstancesForAncessors(B), O.cloner ? .resetOnMove(), this.markToExpandCloner(O);
                            let N = null === _.parent ? this : this.find(_.parent);
                            if (void 0 === N) throw Error("unexpected");
                            N.add(O), this.markNeedsRecomputeInstancesForAncessors(N), this.markToExpandCloner(O), O.invalidateClonerTransform(O), O.updateVisible(), O.resetBBoxNeedsUpdate(), this.markPenumbraSizeDirty();
                            let k = _.localIndex;
                            N.children.splice(k, 0, N.children.pop()), Yn(O) && (O.invalidateUpstreamBooleanData(), Xn(O.parent) ? O.parent.invalidateDownstreamBooleanData().recomputeBoolean() : B instanceof Sg && B.invalidateDownstreamBooleanData().recomputeBoolean()), O.updatePathSnapping()
                        }
                        this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty()
                    }
                    get playPage() {
                        return this.find(this.data.publish.playPage) ? ? this.errorPage
                    }
                    updatePage(_) {
                        for (let O of (this.activePage && this.activePage.onDeactive(), this.activePage = this.errorPage, this.children)) O instanceof Mz && (O.visible = O.uuid === _, O.visible && (this.activePage = O, this.activePage.onActive(this)));
                        this.activePage !== this.splatViewer ? .activePage && this.reloadSplats()
                    }
                    updateEntityByOp(_, O, B, N) {
                        if (0 === O.type) {
                            if (("overrides" in O.props || "component" in O.props) && this.markNeedsRecomputeInstances(), "visible" in O.props && this.markPenumbraSizeDirty(), O.path.includes("overrides") && "states" in O.props) {
                                let {
                                    rest: _
                                } = O.props;
                                O = { ...O,
                                    props: _
                                }, this.markNeedsRecomputeInstances()
                            }
                            "pathSnapping" === O.path[0] && void 0 !== O.props.pathId && this.pathConstraints.setConstraint(_, O.props.pathId)
                        }
                        let k = this.find(_);
                        if (k) try {
                            (function(_, O, B, N) {
                                _.updateByOp(O, B, N, !1)
                            })(k, O, B, {
                                scene: this,
                                shared: N
                            }), k instanceof _m && k.updateGeometryGroupsIfNeeded()
                        } catch (_) {
                            console.error(_)
                        }
                    }
                    get activeCamera() {
                        return this.activePage.activeCamera
                    }
                    switchActiveCamera(_) {
                        this.activePage.switchActiveCamera(_)
                    }
                    isInvisibleObjects(_) {
                        return _ === this.invisibleObjects || _.hasAnccestor(this.invisibleObjects)
                    }
                    init(_, O) {
                        let B = Object.entries(O.data.lib.components).map((_, O) => ({
                            data: _[1].asset.data,
                            children: _[1].asset.children,
                            id: _[0],
                            fi: O
                        }));
                        this.invisibleObjects.updateState(this.invisibleObjects.data, {
                            scene: this,
                            shared: O
                        }), this.add(this.invisibleObjects), this.createChildrenObjects(B, this.invisibleObjects, O), this.createChildrenObjects(_.objects, this, O), this.updatePage(_.publish.playPage), this.activePage.switchToPlayCamera(), this.expandInstances(O, !0), this.traverseEntity(_ => {
                            Xn(_) && _.recomputeBoolean(), _ instanceof Sh && _.updateUp()
                        }), this.doPendingExpandCloner(), this.applyPendingCommands()
                    }
                    markNeedsRecomputeInstances() {
                        this.needsRecomputeInstances = !0
                    }
                    markNeedsRecomputeInstancesForChildren(_) {
                        _.traverseEntity(_ => {
                            ("Component" === _.data.type || "Instance" === _.data.type) && this.markNeedsRecomputeInstances()
                        })
                    }
                    markNeedsRecomputeInstancesForAncessors(_) {
                        xu.is(_) && ("Component" === _.data.type && this.markNeedsRecomputeInstances(), _.traverseAncestors(_ => {
                            xu.is(_) && "Component" === _.data.type && this.markNeedsRecomputeInstances()
                        }))
                    }
                    relativeizeInner(_, O, B, N, k, F, U) {
                        if (_) {
                            let j = N.find(_);
                            j && j !== N && k.forInstancesRec(N => {
                                N.data = Ha(N.data, k => {
                                    let j = k.events.data(U.id),
                                        G = N.goUp(F);
                                    if (G) {
                                        let N = [...hy(G.identity), _].join("-"),
                                            k = this.entityIdentityToEntity[N];
                                        if (k) {
                                            let _ = k.uuid;
                                            uz.zoom(j, O)[B] = _
                                        } else console.warn("cannot find instance")
                                    }
                                }).data
                            })
                        }
                    }
                    rewriteActions(_, O, B, N, k, F) {
                        _.forEach(_ => {
                            "Transition" === _.data.type ? this.relativeizeInner(_.data.object, [...O, _.id], "object", B, N, k, F) : "Animation" === _.data.type && this.relativeizeInner(_.data.object, [...O, _.id], "object", B, N, k, F)
                        })
                    }
                    rewriteEventsBeforeGoToPlayMode() {
                        this.traverseEntity(_ => {
                            if (_ instanceof MU && "string" == typeof _.identity && "Component" === _.data.type) return _.traverseEntity((O, B) => {
                                O.data.events.forEach(N => {
                                    if ("GameControl" === N.data.type) {
                                        let k = !1;
                                        if (O.forInstancesRec(_ => {
                                                _.data = Ha(_.data, O => {
                                                    _.isInstanceRoot || (O.events.delete(N.id), k = !0)
                                                }).data
                                            }), !1 === k)
                                            for (let k of gF.list) this.rewriteActions(N.data.gameActions[k], ["gameActions", k], _, O, B, N)
                                    } else "Conditional" === N.data.type ? ("Distance" === N.data.condition.type ? (this.relativeizeInner(N.data.condition.fromObject, ["condition"], "fromObject", _, O, B, N), this.relativeizeInner(N.data.condition.toObject, ["condition"], "toObject", _, O, B, N)) : "State" === N.data.condition.type ? this.relativeizeInner(N.data.condition.object, ["condition"], "object", _, O, B, N) : "Comparison" === N.data.condition.type && ("Property" === N.data.condition.lOperand.type && this.relativeizeInner(N.data.condition.lOperand.value[0], ["condition", "lOperand", "value"], 0, _, O, B, N), "Property" === N.data.condition.rOperand.type && this.relativeizeInner(N.data.condition.rOperand.value[0], ["condition", "rOperand", "value"], 0, _, O, B, N)), this.rewriteActions(N.data.inActions, ["inActions"], _, O, B, N), this.rewriteActions(N.data.outActions, ["outActions"], _, O, B, N)) : "actions" in N.data && this.rewriteActions(N.data.actions, ["actions"], _, O, B, N)
                                })
                            }), !0
                        })
                    }
                    expandInstances(_, O, B) {
                        let N = new Set;
                        for (let k of (this.traverseEntity(k => {
                                if (k instanceof MU && k.isInstanceRoot) return k.expandInstanceChildren({
                                    scene: this,
                                    shared: _,
                                    pendingDeletes: N
                                }), O || k.resetBBoxNeedsUpdate(), B && k.traverseEntity(_ => {
                                    B.addClip(_)
                                }), !0
                            }), N)) this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(k), C0(k)
                    }
                    recomputeInstances(_, O) {
                        this.needsRecomputeInstances && (this.needsRecomputeInstances = !1, this.traverseEntity(_ => {
                            _ instanceof MU && _.isInstanceRoot && (_.component = void 0)
                        }), this.expandInstances(_, !1, O))
                    }
                    disposeAndUnregisterEntityRecursivelyIfNotReregistered(_) {
                        _.traverseEntity(_ => {
                            let O = "string" == typeof _.identity ? _.identity : _.identity.join("-");
                            this.entityIdentityToEntity[O] === _ && (delete this.entityByUuid[_.uuid], delete this.entityIdentityToEntity[O]), _.dispose()
                        })
                    }
                    clearScene() {
                        for (let _ of this.children) xu.is(_) && _.disposeRecursively();
                        this.children.length = 0
                    }
                    resetAfterClear(_, O) {
                        this.init(_, O)
                    }
                    raycast(_) {
                        return this.raycast1(_, !1)
                    }
                    raycast1(_, O) {
                        let B = [],
                            s = N => {
                                for (let k of N.children) {
                                    let N = k.cloner;
                                    if (xu.is(k) && !k.raycastLock && (k.visible || N ? .object.data.visible)) {
                                        if (!0 === O && k.isInstanceRoot) {
                                            let O = [];
                                            if (_.intersectObject(k, !0, O), O.length) {
                                                let _ = O[0];
                                                _.object = k, _.point.applyMatrix4(_.object.matrixWorld);
                                                let N = k.matrixWorld.clone().invert();
                                                _.point.applyMatrix4(N), B.push(_)
                                            }
                                        } else(Yn(k) || Jp(k) && this.enableHelpers && k.objectHelper.visible) && (_.intersectObject(k, !1, B), nm(k, _, B)), s(k)
                                    }
                                }
                            };
                        return s(this), B
                    }
                    raycastWithClones(_) {
                        let O = [],
                            n = B => {
                                for (let N of B.children) {
                                    let B = N.cloner;
                                    xu.is(N) && (N.visible || B ? .object.data.visible) && ((Yn(N) || Jp(N) && this.enableHelpers && N.objectHelper.visible) && (_.intersectObject(N, !1, O), nm(N, _, O, !0)), n(N))
                                }
                            };
                        return n(this), O
                    }
                    forEachEntity(_) {
                        for (let O of this.children) xu.is(O) && _(O)
                    }
                    traverseConcreteEntity(_) {
                        for (let O of this.children) xu.is(O) && O.isConcreteEntity && O.traverseEntity(_)
                    }
                    traverseEntity(_) {
                        for (let O of this.children) xu.is(O) && O.traverseEntity(_)
                    }
                    updateFont(_, O) {
                        this.traverseEntity(B => {
                            if (B instanceof _m && "Mesh" === B.data.type && "TextGeometry" === B.data.geometry.type && B.data.geometry.font === _) {
                                let N = B.geometry,
                                    k = B.data.geometry;
                                N.updateFont(_, O).then(() => {
                                    N.update(k);
                                    let _ = B.invalidateDownstreamBooleanData();
                                    Xn(_) && _.recomputeBoolean()
                                })
                            }
                        })
                    }
                    traverseObject(_) {
                        for (let O of this.children) vc.is(O) && O.traverseObject(_)
                    }
                    traverseVisibleEntity(_) {
                        for (let O of this.children) xu.is(O) && O.visible && O.traverseVisibleEntity(_)
                    }
                    dispose() {
                        this.clearScene()
                    }
                    createChildrenObjects(_, O, B) {
                        let N = 0;
                        for (let k of _) this.createObject(k.id, k.data, k.children, O, N, B), N += 1
                    }
                    registerObjectCreatedInLegacy(_) {
                        this.entityByUuid[_.uuid] = _
                    }
                    unregisterObject(_) {
                        for (let O of (delete this.entityByUuid[_.uuid], _.children)) this.unregisterObject(O)
                    }
                    createObject(_, O, B, N, k, F) {
                        let U = {
                                scene: this,
                                shared: F
                            },
                            j = D0(_, O, U);
                        return j && (this.entityByUuid[_] = j, N.add(j), N.children.splice(k, 0, N.children.pop()), B.length > 0 && (j.isInstanceRoot ? console.error("instance should not have children!") : this.createChildrenObjects(B, j, F)), j.updateState(O, U), j instanceof _m && j.updateGeometryGroupsIfNeeded(), j.updateVisible(), j.cloner && this.toExpandCloner.add(j), O.pathSnapping ? .pathId && this.pathConstraints.setConstraint(_, O.pathSnapping.pathId)), "Empty" === O.type && O.animations && j.traverseEntity(_ => {
                            let O = _.dataPatched;
                            if (_ instanceof _m && O.bones && O.boneInverses) {
                                let B = O.bones.map(_ => this.find(_)),
                                    N = O.boneInverses.map(_ => new rJ().fromArray(_)),
                                    k = new nB(B, N);
                                _.bind(k, _.bindMatrix)
                            } else _.matrixAutoUpdate = !0
                        }), j
                    }
                    getCenter(_) {
                        let O = [];
                        for (let B = 0, N = _.length; B < N; ++B) {
                            let {
                                id: N,
                                recursive: k
                            } = _[B], F = this.find(N), U = k ? F.recursiveBBox : F.singleBBox;
                            O.push(...U.vertices)
                        }
                        let B = new rb;
                        return B.setFromPoints(O), B.getCenter(Eu), Eu
                    }
                    copyMatrixWorld(_, O) {
                        if (null === _) {
                            O.identity();
                            return
                        }
                        let B = this.find(_);
                        B ? O.copy(B.matrixWorld) : O.identity()
                    }
                    copyParentMatrixWorld(_, O) {
                        if (null === _) {
                            O.identity();
                            return
                        }
                        let B = this.find(_) ? .parent;
                        B ? O.copy(B.matrixWorld) : O.identity()
                    }
                    traverseMaterial(_) {
                        this.traverseEntity(O => {
                            if (O instanceof xK) {
                                if (Array.isArray(O.material))
                                    for (let B = 0; B < O.material.length; B++) O.material[B] instanceof wQ && _(O.material[B]);
                                else O.material instanceof wQ && _(O.material)
                            }
                        })
                    }
                    updateViewPlaneSize(_, O, B = !1) {
                        this.traverseConcreteEntity(N => {
                            N instanceof Sh && N.setViewplaneSize(_, O, B)
                        })
                    }
                    initializeSplatViewer(_) {
                        this.splatViewer = new Ec({
                            scene: this,
                            renderer: _
                        }), this.reloadSplats()
                    }
                    reloadSplats() {
                        this.splatViewer ? .reloadSplats()
                    }
                },
                sm = (_, O) => {
                    let B = O.x - _.x,
                        N = O.y - _.y;
                    return Math.sqrt(B * B + N * N)
                },
                PR = (_, O) => {
                    let B = O.x - _.x;
                    return j7(Math.atan2(O.y - _.y, B))
                },
                DR = (_, O, B) => {
                    let N = {
                        x: 0,
                        y: 0
                    };
                    return B = B0(B), N.x = _.x - O * Math.cos(B), N.y = _.y - O * Math.sin(B), N
                },
                B0 = _ => _ * (Math.PI / 180),
                j7 = _ => _ * (180 / Math.PI),
                IR = _ => isNaN(_.buttons) ? 0 !== _.pressure : 0 !== _.buttons,
                Ef = new Map,
                m1 = _ => {
                    Ef.has(_) && clearTimeout(Ef.get(_)), Ef.set(_, setTimeout(_, 100))
                },
                $d = (_, O, B) => {
                    let N = O.split(/[ ,]+/g),
                        k;
                    for (let O = 0; O < N.length; O += 1) k = N[O], _.addEventListener ? _.addEventListener(k, B, !1) : _.attachEvent && _.attachEvent(k, B)
                },
                g1 = (_, O, B) => {
                    let N = O.split(/[ ,]+/g),
                        k;
                    for (let O = 0; O < N.length; O += 1) k = N[O], _.removeEventListener ? _.removeEventListener(k, B) : _.detachEvent && _.detachEvent(k, B)
                },
                F0 = _ => (_.preventDefault(), _.type.match(/^touch/) ? _.changedTouches : _),
                y1 = () => {
                    if (!(typeof window > "u")) return {
                        x: void 0 !== window.pageXOffset ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft,
                        y: void 0 !== window.pageYOffset ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop
                    }
                },
                k0 = (_, O) => {
                    O.top || O.right || O.bottom || O.left ? (_.style.top = O.top, _.style.right = O.right, _.style.bottom = O.bottom, _.style.left = O.left) : (_.style.left = O.x + "px", _.style.top = O.y + "px")
                },
                V0 = (_, O, B) => {
                    let N = RR(_);
                    for (let _ in N)
                        if (N.hasOwnProperty(_)) {
                            if ("string" == typeof O) N[_] = O + " " + B;
                            else {
                                let k = "";
                                for (let _ = 0, N = O.length; _ < N; _ += 1) k += O[_] + " " + B + ", ";
                                N[_] = k.slice(0, -2)
                            }
                        }
                    return N
                },
                OR = (_, O) => {
                    let B = RR(_);
                    for (let _ in B) B.hasOwnProperty(_) && (B[_] = O);
                    return B
                },
                RR = _ => {
                    let O = {};
                    return O[_] = "", ["webkit", "Moz", "o"].forEach(function(B) {
                        O[B + _.charAt(0).toUpperCase() + _.slice(1)] = ""
                    }), O
                },
                z0 = (_, O) => {
                    for (let B in O) O.hasOwnProperty(B) && (_[B] = O[B]);
                    return _
                },
                LR = (_, O) => {
                    let B = {};
                    for (let N in _) _.hasOwnProperty(N) && O.hasOwnProperty(N) ? B[N] = O[N] : _.hasOwnProperty(N) && (B[N] = _[N]);
                    return B
                },
                om = (_, O) => {
                    if (_.length)
                        for (let B = 0, N = _.length; B < N; B += 1) O(_[B]);
                    else O(_)
                },
                NR = (_, O, B) => ({
                    x: Math.min(Math.max(_.x, O.x - B), O.x + B),
                    y: Math.min(Math.max(_.y, O.y - B), O.y + B)
                });
            "u" > typeof window && (Ex = "ontouchstart" in window, E_ = !!window.PointerEvent, ES = !!window.MSPointerEvent);
            var Eg, Ey, Ex, E_, ES, EA, EM = {
                    touch: {
                        start: "touchstart",
                        move: "touchmove",
                        end: "touchend, touchcancel"
                    },
                    mouse: {
                        start: "mousedown",
                        move: "mousemove",
                        end: "mouseup"
                    },
                    pointer: {
                        start: "pointerdown",
                        move: "pointermove",
                        end: "pointerup, pointercancel"
                    },
                    MSPointer: {
                        start: "MSPointerDown",
                        move: "MSPointerMove",
                        end: "MSPointerUp"
                    }
                },
                EC = {};

            function Nc() {}

            function un(_, O) {
                return this.identifier = O.identifier, this.position = O.position, this.frontPosition = O.frontPosition, this.collection = _, this.defaults = {
                    size: 100,
                    threshold: .1,
                    color: "white",
                    fadeTime: 250,
                    dataOnly: !1,
                    restJoystick: !0,
                    restOpacity: 1,
                    mode: "dynamic",
                    zone: document.body,
                    lockX: !1,
                    lockY: !1,
                    shape: "circle"
                }, this.config(O), "dynamic" === this.options.mode && (this.options.restOpacity = 0), this.id = un.id, un.id += 1, this.buildEl().stylize(), this.instance = {
                    el: this.ui.el,
                    on: this.on.bind(this),
                    off: this.off.bind(this),
                    show: this.show.bind(this),
                    hide: this.hide.bind(this),
                    add: this.addToDom.bind(this),
                    remove: this.removeFromDom.bind(this),
                    destroy: this.destroy.bind(this),
                    setPosition: this.setPosition.bind(this),
                    resetDirection: this.resetDirection.bind(this),
                    computeDirection: this.computeDirection.bind(this),
                    trigger: this.trigger.bind(this),
                    position: this.position,
                    frontPosition: this.frontPosition,
                    ui: this.ui,
                    identifier: this.identifier,
                    id: this.id,
                    options: this.options
                }, this.instance
            }

            function Vr(_, O) {
                this.nipples = [], this.idles = [], this.actives = [], this.ids = [], this.pressureIntervals = {}, this.manager = _, this.id = Vr.id, Vr.id += 1, this.defaults = {
                    zone: document.body,
                    multitouch: !1,
                    maxNumberOfNipples: 10,
                    mode: "dynamic",
                    position: {
                        top: 0,
                        left: 0
                    },
                    catchDistance: 200,
                    size: 100,
                    threshold: .1,
                    color: "white",
                    fadeTime: 250,
                    dataOnly: !1,
                    restJoystick: !0,
                    restOpacity: 1,
                    lockX: !1,
                    lockY: !1,
                    shape: "circle",
                    dynamicPage: !1,
                    follow: !1
                }, this.config(O), ("static" === this.options.mode || "semi" === this.options.mode) && (this.options.multitouch = !1), this.options.multitouch || (this.options.maxNumberOfNipples = 1);
                let B = getComputedStyle(this.options.zone.parentElement);
                return B && "flex" === B.display && (this.parentIsFlex = !0), this.updateBox(), this.prepareNipples(), this.bindings(), this.begin(), this.nipples
            }

            function In(_) {
                var O = this;
                O.ids = {}, O.index = 0, O.collections = [], O.scroll = y1(), O.config(_), O.prepareCollections();
                var e = function() {
                    var _;
                    O.collections.forEach(function(B) {
                        B.forEach(function(B) {
                            _ = B.el.getBoundingClientRect(), B.position = {
                                x: O.scroll.x + _.left,
                                y: O.scroll.y + _.top
                            }
                        })
                    })
                };
                if (typeof window > "u") return O.collections;
                $d(window, "resize", function() {
                    m1(e)
                });
                var r = function() {
                    O.scroll = y1()
                };
                return $d(window, "scroll", function() {
                    m1(r)
                }), O.collections
            }
            E_ ? EA = EM.pointer : ES ? EA = EM.MSPointer : Ex ? (EA = EM.touch, EC = EM.mouse) : EA = EM.mouse, Nc.prototype.on = function(_, O) {
                var B, N = _.split(/[ ,]+/g);
                this._handlers_ = this._handlers_ || {};
                for (var k = 0; k < N.length; k += 1) B = N[k], this._handlers_[B] = this._handlers_[B] || [], this._handlers_[B].push(O);
                return this
            }, Nc.prototype.off = function(_, O) {
                return this._handlers_ = this._handlers_ || {}, void 0 === _ ? this._handlers_ = {} : void 0 === O ? this._handlers_[_] = null : this._handlers_[_] && this._handlers_[_].indexOf(O) >= 0 && this._handlers_[_].splice(this._handlers_[_].indexOf(O), 1), this
            }, Nc.prototype.trigger = function(_, O) {
                var B, N = this,
                    k = _.split(/[ ,]+/g);
                N._handlers_ = N._handlers_ || {};
                for (var F = 0; F < k.length; F += 1) B = k[F], N._handlers_[B] && N._handlers_[B].length && N._handlers_[B].forEach(function(_) {
                    _.call(N, {
                        type: B,
                        target: N
                    }, O)
                })
            }, Nc.prototype.config = function(_) {
                this.options = this.defaults || {}, _ && (this.options = LR(this.options, _))
            }, Nc.prototype.bindEvt = function(_, O) {
                var B = this;
                return B._domHandlers_ = B._domHandlers_ || {}, B._domHandlers_[O] = function() {
                    "function" == typeof B["on" + O] ? B["on" + O].apply(B, arguments) : console.warn('[WARNING] : Missing "on' + O + '" handler.')
                }, $d(_, EA[O], B._domHandlers_[O]), EC[O] && $d(_, EC[O], B._domHandlers_[O]), B
            }, Nc.prototype.unbindEvt = function(_, O) {
                return this._domHandlers_ = this._domHandlers_ || {}, g1(_, EA[O], this._domHandlers_[O]), EC[O] && g1(_, EC[O], this._domHandlers_[O]), delete this._domHandlers_[O], this
            }, un.prototype = new Nc, un.constructor = un, un.id = 0, un.prototype.buildEl = function(_) {
                return this.ui = {}, this.options.dataOnly || (this.ui.el = document.createElement("div"), this.ui.back = document.createElement("div"), this.ui.front = document.createElement("div"), this.ui.el.className = "nipple collection_" + this.collection.id, this.ui.back.className = "back", this.ui.front.className = "front", this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id), this.ui.el.appendChild(this.ui.back), this.ui.el.appendChild(this.ui.front)), this
            }, un.prototype.stylize = function() {
                if (this.options.dataOnly) return this;
                var _ = this.options.fadeTime + "ms",
                    O = OR("borderRadius", "50%"),
                    B = V0("transition", "opacity", _),
                    N = {};
                return N.el = {
                    position: "absolute",
                    opacity: this.options.restOpacity,
                    display: "block",
                    zIndex: 999
                }, N.back = {
                    position: "absolute",
                    display: "block",
                    width: this.options.size + "px",
                    height: this.options.size + "px",
                    marginLeft: -this.options.size / 2 + "px",
                    marginTop: -this.options.size / 2 + "px",
                    background: "rgba(255, 255, 255, .4)",
                    border: "solid 2px rgba(0, 0, 0, .1)"
                }, N.front = {
                    width: this.options.size / 2 + "px",
                    height: this.options.size / 2 + "px",
                    position: "absolute",
                    display: "block",
                    marginLeft: -this.options.size / 4 + "px",
                    marginTop: -this.options.size / 4 + "px",
                    background: "rgba(255, 255, 255, .8)",
                    border: "solid 2px rgba(0, 0, 0, .1)"
                }, z0(N.el, B), "circle" === this.options.shape && z0(N.back, O), z0(N.front, O), this.applyStyles(N), this
            }, un.prototype.applyStyles = function(_) {
                for (var O in this.ui)
                    if (this.ui.hasOwnProperty(O))
                        for (var B in _[O]) this.ui[O].style[B] = _[O][B];
                return this
            }, un.prototype.addToDom = function() {
                return this.options.dataOnly || document.body.contains(this.ui.el) || this.options.zone.appendChild(this.ui.el), this
            }, un.prototype.removeFromDom = function() {
                return this.options.dataOnly || !document.body.contains(this.ui.el) || this.options.zone.removeChild(this.ui.el), this
            }, un.prototype.destroy = function() {
                clearTimeout(this.removeTimeout), clearTimeout(this.showTimeout), clearTimeout(this.restTimeout), this.trigger("destroyed", this.instance), this.removeFromDom(), this.off()
            }, un.prototype.show = function(_) {
                var O = this;
                return O.options.dataOnly || (clearTimeout(O.removeTimeout), clearTimeout(O.showTimeout), clearTimeout(O.restTimeout), O.addToDom(), O.restCallback(), setTimeout(function() {
                    O.ui.el.style.opacity = 1
                }, 0), O.showTimeout = setTimeout(function() {
                    O.trigger("shown", O.instance), "function" == typeof _ && _.call(this)
                }, O.options.fadeTime)), O
            }, un.prototype.hide = function(_) {
                var O = this;
                if (O.options.dataOnly) return O;
                if (O.ui.el.style.opacity = O.options.restOpacity, clearTimeout(O.removeTimeout), clearTimeout(O.showTimeout), clearTimeout(O.restTimeout), O.removeTimeout = setTimeout(function() {
                        var B = "dynamic" === O.options.mode ? "none" : "block";
                        O.ui.el.style.display = B, "function" == typeof _ && _.call(O), O.trigger("hidden", O.instance)
                    }, O.options.fadeTime), O.options.restJoystick) {
                    let B = O.options.restJoystick,
                        N = {};
                    N.x = !0 === B || !1 !== B.x ? 0 : O.instance.frontPosition.x, N.y = !0 === B || !1 !== B.y ? 0 : O.instance.frontPosition.y, O.setPosition(_, N)
                }
                return O
            }, un.prototype.setPosition = function(_, O) {
                var B = this;
                B.frontPosition = {
                    x: O.x,
                    y: O.y
                };
                var N = B.options.fadeTime + "ms",
                    k = {};
                k.front = V0("transition", ["top", "left"], N);
                var F = {
                    front: {}
                };
                F.front = {
                    left: B.frontPosition.x + "px",
                    top: B.frontPosition.y + "px"
                }, B.applyStyles(k), B.applyStyles(F), B.restTimeout = setTimeout(function() {
                    "function" == typeof _ && _.call(B), B.restCallback()
                }, B.options.fadeTime)
            }, un.prototype.restCallback = function() {
                var _ = {};
                _.front = V0("transition", "none", ""), this.applyStyles(_), this.trigger("rested", this.instance)
            }, un.prototype.resetDirection = function() {
                this.direction = {
                    x: !1,
                    y: !1,
                    angle: !1
                }
            }, un.prototype.computeDirection = function(_) {
                var O, B, N, k = _.angle.radian,
                    F = Math.PI / 4,
                    U = Math.PI / 2;
                if (k > F && k < 3 * F && !_.lockX ? O = "up" : k > -F && k <= F && !_.lockY ? O = "left" : k > -(3 * F) && k <= -F && !_.lockX ? O = "down" : _.lockY || (O = "right"), _.lockY || (B = k > -U && k < U ? "left" : "right"), _.lockX || (N = k > 0 ? "up" : "down"), _.force > this.options.threshold) {
                    var j, G = {};
                    for (j in this.direction) this.direction.hasOwnProperty(j) && (G[j] = this.direction[j]);
                    var Y = {};
                    for (j in this.direction = {
                            x: B,
                            y: N,
                            angle: O
                        }, _.direction = this.direction, G) G[j] === this.direction[j] && (Y[j] = !0);
                    if (Y.x && Y.y && Y.angle) return _;
                    Y.x && Y.y || this.trigger("plain", _), Y.x || this.trigger("plain:" + B, _), Y.y || this.trigger("plain:" + N, _), Y.angle || this.trigger("dir dir:" + O, _)
                } else this.resetDirection();
                return _
            }, Vr.prototype = new Nc, Vr.constructor = Vr, Vr.id = 0, Vr.prototype.prepareNipples = function() {
                var _ = this.nipples;
                _.on = this.on.bind(this), _.off = this.off.bind(this), _.options = this.options, _.destroy = this.destroy.bind(this), _.ids = this.ids, _.id = this.id, _.processOnMove = this.processOnMove.bind(this), _.processOnEnd = this.processOnEnd.bind(this), _.get = function(O) {
                    if (void 0 === O) return _[0];
                    for (var B = 0, N = _.length; B < N; B += 1)
                        if (_[B].identifier === O) return _[B];
                    return !1
                }
            }, Vr.prototype.bindings = function() {
                this.bindEvt(this.options.zone, "start"), this.options.zone.style.touchAction = "none", this.options.zone.style.msTouchAction = "none"
            }, Vr.prototype.begin = function() {
                var _ = this.options;
                if ("static" === _.mode) {
                    var O = this.createNipple(_.position, this.manager.getIdentifier());
                    O.add(), this.idles.push(O)
                }
            }, Vr.prototype.createNipple = function(_, O) {
                var B = this.manager.scroll,
                    N = {},
                    k = this.options,
                    F = {
                        x: this.parentIsFlex ? B.x : B.x + this.box.left,
                        y: this.parentIsFlex ? B.y : B.y + this.box.top
                    };
                if (_.x && _.y) N = {
                    x: _.x - F.x,
                    y: _.y - F.y
                };
                else if (_.top || _.right || _.bottom || _.left) {
                    var U = document.createElement("DIV");
                    U.style.display = "hidden", U.style.top = _.top, U.style.right = _.right, U.style.bottom = _.bottom, U.style.left = _.left, U.style.position = "absolute", k.zone.appendChild(U);
                    var j = U.getBoundingClientRect();
                    k.zone.removeChild(U), N = _, _ = {
                        x: j.left + B.x,
                        y: j.top + B.y
                    }
                }
                var G = new un(this, {
                    color: k.color,
                    size: k.size,
                    threshold: k.threshold,
                    fadeTime: k.fadeTime,
                    dataOnly: k.dataOnly,
                    restJoystick: k.restJoystick,
                    restOpacity: k.restOpacity,
                    mode: k.mode,
                    identifier: O,
                    position: _,
                    zone: k.zone,
                    frontPosition: {
                        x: 0,
                        y: 0
                    },
                    shape: k.shape
                });
                return k.dataOnly || (k0(G.ui.el, N), k0(G.ui.front, G.frontPosition)), this.nipples.push(G), this.trigger("added " + G.identifier + ":added", G), this.manager.trigger("added " + G.identifier + ":added", G), this.bindNipple(G), G
            }, Vr.prototype.updateBox = function() {
                this.box = this.options.zone.getBoundingClientRect()
            }, Vr.prototype.bindNipple = function(_) {
                var O, B = this,
                    r = function(_, N) {
                        O = _.type + " " + N.id + ":" + _.type, B.trigger(O, N)
                    };
                _.on("destroyed", B.onDestroyed.bind(B)), _.on("shown hidden rested dir plain", r), _.on("dir:up dir:right dir:down dir:left", r), _.on("plain:up plain:right plain:down plain:left", r)
            }, Vr.prototype.pressureFn = function(_, O, B) {
                var N = this,
                    k = 0;
                clearInterval(N.pressureIntervals[B]), N.pressureIntervals[B] = setInterval((function() {
                    var B = _.force || _.pressure || _.webkitForce || 0;
                    B !== k && (O.trigger("pressure", B), N.trigger("pressure " + O.identifier + ":pressure", B), k = B)
                }).bind(N), 100)
            }, Vr.prototype.onstart = function(_) {
                var O = this,
                    B = O.options,
                    N = _;
                return _ = F0(_), O.updateBox(), om(_, function(k) {
                    O.actives.length < B.maxNumberOfNipples ? O.processOnStart(k) : N.type.match(/^touch/) && (Object.keys(O.manager.ids).forEach(function(B) {
                        if (0 > Object.values(N.touches).findIndex(function(_) {
                                return _.identifier === B
                            })) {
                            var k = [_[0]];
                            k.identifier = B, O.processOnEnd(k)
                        }
                    }), O.actives.length < B.maxNumberOfNipples && O.processOnStart(k))
                }), O.manager.bindDocument(), !1
            }, Vr.prototype.processOnStart = function(_) {
                var O, B = this,
                    N = B.options,
                    k = B.manager.getIdentifier(_),
                    F = _.force || _.pressure || _.webkitForce || 0,
                    U = {
                        x: _.pageX,
                        y: _.pageY
                    },
                    j = B.getOrCreate(k, U);
                j.identifier !== k && B.manager.removeIdentifier(j.identifier), j.identifier = k;
                var l = function(O) {
                    O.trigger("start", O), B.trigger("start " + O.id + ":start", O), O.show(), F > 0 && B.pressureFn(_, O, O.identifier), B.processOnMove(_)
                };
                if ((O = B.idles.indexOf(j)) >= 0 && B.idles.splice(O, 1), B.actives.push(j), B.ids.push(j.identifier), "semi" !== N.mode) l(j);
                else if (sm(U, j.position) <= N.catchDistance) l(j);
                else {
                    j.destroy(), B.processOnStart(_);
                    return
                }
                return j
            }, Vr.prototype.getOrCreate = function(_, O) {
                var B, N = this.options;
                return /(semi|static)/.test(N.mode) ? (B = this.idles[0]) ? (this.idles.splice(0, 1), B) : "semi" === N.mode ? this.createNipple(O, _) : (console.warn("Coudln't find the needed nipple."), !1) : B = this.createNipple(O, _)
            }, Vr.prototype.processOnMove = function(_) {
                var O = this.options,
                    B = this.manager.getIdentifier(_),
                    N = this.nipples.get(B),
                    k = this.manager.scroll;
                if (!IR(_)) {
                    this.processOnEnd(_);
                    return
                }
                if (!N) {
                    console.error("Found zombie joystick with ID " + B), this.manager.removeIdentifier(B);
                    return
                }
                if (O.dynamicPage) {
                    var F = N.el.getBoundingClientRect();
                    N.position = {
                        x: k.x + F.left,
                        y: k.y + F.top
                    }
                }
                N.identifier = B;
                var U = N.options.size / 2,
                    j = {
                        x: _.pageX,
                        y: _.pageY
                    };
                O.lockX && (j.y = N.position.y), O.lockY && (j.x = N.position.x);
                var G, Y, Q = sm(j, N.position),
                    K = PR(j, N.position),
                    $ = B0(K),
                    ee = Q / U,
                    et = {
                        distance: Q,
                        position: j
                    };
                if ("circle" === N.options.shape ? (G = Math.min(Q, U), Y = DR(N.position, G, K)) : G = sm(Y = NR(j, N.position, U), N.position), O.follow) {
                    if (Q > U) {
                        let _ = j.x - Y.x,
                            O = j.y - Y.y;
                        N.position.x += _, N.position.y += O, N.el.style.top = N.position.y - (this.box.top + k.y) + "px", N.el.style.left = N.position.x - (this.box.left + k.x) + "px", Q = sm(j, N.position)
                    }
                } else j = Y, Q = G;
                var ei = j.x - N.position.x,
                    er = j.y - N.position.y;
                N.frontPosition = {
                    x: ei,
                    y: er
                }, O.dataOnly || k0(N.ui.front, N.frontPosition);
                var ea = {
                    identifier: N.identifier,
                    position: j,
                    force: ee,
                    pressure: _.force || _.pressure || _.webkitForce || 0,
                    distance: Q,
                    angle: {
                        radian: $,
                        degree: K
                    },
                    vector: {
                        x: ei / U,
                        y: -er / U
                    },
                    raw: et,
                    instance: N,
                    lockX: O.lockX,
                    lockY: O.lockY
                };
                (ea = N.computeDirection(ea)).angle = {
                    radian: B0(180 - K),
                    degree: 180 - K
                }, N.trigger("move", ea), this.trigger("move " + N.id + ":move", ea)
            }, Vr.prototype.processOnEnd = function(_) {
                var O = this,
                    B = O.options,
                    N = O.manager.getIdentifier(_),
                    k = O.nipples.get(N),
                    F = O.manager.removeIdentifier(k.identifier);
                !k || (B.dataOnly || k.hide(function() {
                    "dynamic" === B.mode && (k.trigger("removed", k), O.trigger("removed " + k.id + ":removed", k), O.manager.trigger("removed " + k.id + ":removed", k), k.destroy())
                }), clearInterval(O.pressureIntervals[k.identifier]), k.resetDirection(), k.trigger("end", k), O.trigger("end " + k.id + ":end", k), O.ids.indexOf(k.identifier) >= 0 && O.ids.splice(O.ids.indexOf(k.identifier), 1), O.actives.indexOf(k) >= 0 && O.actives.splice(O.actives.indexOf(k), 1), /(semi|static)/.test(B.mode) ? O.idles.push(k) : O.nipples.indexOf(k) >= 0 && O.nipples.splice(O.nipples.indexOf(k), 1), O.manager.unbindDocument(), /(semi|static)/.test(B.mode) && (O.manager.ids[F.id] = F.identifier))
            }, Vr.prototype.onDestroyed = function(_, O) {
                this.nipples.indexOf(O) >= 0 && this.nipples.splice(this.nipples.indexOf(O), 1), this.actives.indexOf(O) >= 0 && this.actives.splice(this.actives.indexOf(O), 1), this.idles.indexOf(O) >= 0 && this.idles.splice(this.idles.indexOf(O), 1), this.ids.indexOf(O.identifier) >= 0 && this.ids.splice(this.ids.indexOf(O.identifier), 1), this.manager.removeIdentifier(O.identifier), this.manager.unbindDocument()
            }, Vr.prototype.destroy = function() {
                for (var _ in this.unbindEvt(this.options.zone, "start"), this.nipples.forEach(function(_) {
                        _.destroy()
                    }), this.pressureIntervals) this.pressureIntervals.hasOwnProperty(_) && clearInterval(this.pressureIntervals[_]);
                this.trigger("destroyed", this.nipples), this.manager.unbindDocument(), this.off()
            }, In.prototype = new Nc, In.constructor = In, In.prototype.prepareCollections = function() {
                var _ = this;
                _.collections.create = _.create.bind(_), _.collections.on = _.on.bind(_), _.collections.off = _.off.bind(_), _.collections.destroy = _.destroy.bind(_), _.collections.get = function(O) {
                    var B;
                    return _.collections.every(function(_) {
                        return !(B = _.get(O))
                    }), B
                }
            }, In.prototype.create = function(_) {
                return this.createCollection(_)
            }, In.prototype.createCollection = function(_) {
                var O = new Vr(this, _);
                return this.bindCollection(O), this.collections.push(O), O
            }, In.prototype.bindCollection = function(_) {
                var O, B = this,
                    r = function(_, N) {
                        O = _.type + " " + N.id + ":" + _.type, B.trigger(O, N)
                    };
                _.on("destroyed", B.onDestroyed.bind(B)), _.on("shown hidden rested dir plain", r), _.on("dir:up dir:right dir:down dir:left", r), _.on("plain:up plain:right plain:down plain:left", r)
            }, In.prototype.bindDocument = function() {
                this.binded || (this.bindEvt(document, "move").bindEvt(document, "end"), this.binded = !0)
            }, In.prototype.unbindDocument = function(_) {
                Object.keys(this.ids).length && !0 !== _ || (this.unbindEvt(document, "move").unbindEvt(document, "end"), this.binded = !1)
            }, In.prototype.getIdentifier = function(_) {
                var O;
                return _ ? void 0 === (O = void 0 === _.identifier ? _.pointerId : _.identifier) && (O = this.latest || 0) : O = this.index, void 0 === this.ids[O] && (this.ids[O] = this.index, this.index += 1), this.latest = O, this.ids[O]
            }, In.prototype.removeIdentifier = function(_) {
                var O = {};
                for (var B in this.ids)
                    if (this.ids[B] === _) {
                        O.id = B, O.identifier = this.ids[B], delete this.ids[B];
                        break
                    }
                return O
            }, In.prototype.onmove = function(_) {
                return this.onAny("move", _), !1
            }, In.prototype.onend = function(_) {
                return this.onAny("end", _), !1
            }, In.prototype.oncancel = function(_) {
                return this.onAny("end", _), !1
            }, In.prototype.onAny = function(_, O) {
                var B, N = this,
                    k = "processOn" + _.charAt(0).toUpperCase() + _.slice(1);
                O = F0(O);
                var s = function(_, O, B) {
                    B.ids.indexOf(O) >= 0 && (B[k](_), _._found_ = !0)
                };
                return om(O, function(_) {
                    B = N.getIdentifier(_), om(N.collections, s.bind(null, _, B)), _._found_ || N.removeIdentifier(B)
                }), !1
            }, In.prototype.destroy = function() {
                this.unbindDocument(!0), this.ids = {}, this.index = 0, this.collections.forEach(function(_) {
                    _.destroy()
                }), this.off()
            }, In.prototype.onDestroyed = function(_, O) {
                if (0 > this.collections.indexOf(O)) return !1;
                this.collections.splice(this.collections.indexOf(O), 1)
            };
            var ET = new In,
                EI = {
                    create: function(_) {
                        return ET.create(_)
                    },
                    factory: ET
                },
                EO = new Map,
                EL = new Map,
                ER = class {
                    constructor(_, O, B, N) {
                        this.data = O;
                        let {
                            audio: k,
                            volume: F,
                            delay: U,
                            loop: j
                        } = O;
                        if (!k) throw Error("Missing property");
                        let G = "string" == typeof k ? N.getAudio(k).src : k.data;
                        this.audioPlayer = new w3({
                            src: G,
                            volume: F,
                            delay: U,
                            loop: j
                        }), EL.has(B.uuid) ? EL.get(B.uuid).push(this) : EL.set(B.uuid, [this]), EO.set(_, this)
                    }
                    playByToggle() {
                        "stop" === this.data.toggle ? "playing" === this.audioPlayer.status ? this.audioPlayer.stop() : (this.audioPlayer.stop(), this.audioPlayer.play()) : "pause" === this.data.toggle ? "playing" === this.audioPlayer.status ? this.audioPlayer.pause() : this.audioPlayer.play() : (this.audioPlayer.stop(), this.audioPlayer.play())
                    }
                    dispose() {
                        this.audioPlayer.stop()
                    }
                },
                EB = class {
                    constructor(_) {
                        this.data = _
                    }
                    dispatch() {
                        this.data.playAudio ? this.pauseAudio(this.data.playAudio) : this.data.object ? this.pauseAllAudiosFromObject(this.data.object) : this.pauseAllAudios()
                    }
                    pauseAudio(_) {
                        let O = EO.get(_);
                        O && (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => {
                            O.audioPlayer[this.data.interaction](), this.disposeDelay()
                        }, this.data.delay)) : O.audioPlayer[this.data.interaction]())
                    }
                    pauseAllAudiosFromObject(_) {
                        let O = EL.get(_);
                        O ? .length && (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => {
                            O.forEach(_ => _.audioPlayer[this.data.interaction]()), this.disposeDelay()
                        }, this.data.delay)) : O.forEach(_ => _.audioPlayer[this.data.interaction]()))
                    }
                    pauseAllAudios() {
                        let _ = [...EL.values()];
                        _.length && (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => {
                            _.forEach(_ => {
                                _.forEach(_ => {
                                    _.audioPlayer[this.data.interaction]()
                                })
                            }), this.disposeDelay()
                        }, this.data.delay)) : _.forEach(_ => {
                            _.forEach(_ => {
                                _.audioPlayer[this.data.interaction]()
                            })
                        }))
                    }
                    disposeDelay() {
                        clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                    dispose() {
                        clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                },
                Ez = class {
                    constructor(_, O, B, N, k) {
                        if (this.data = O, this.shared = N, this.condition = k, "play" === O.interaction) this.interaction = new ER(_, O, B, N);
                        else if ("pause" === O.interaction || "stop" === O.interaction) this.interaction = new EB(O);
                        else throw Error("Missing property")
                    }
                    dispatchBasic() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.interaction instanceof ER ? this.interaction.playByToggle() : this.interaction.dispatch()
                    }
                    dispatchConditional() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.interaction instanceof ER ? this.interaction.audioPlayer.play() : this.interaction.dispatch()
                    }
                    dispatchGameControl(_) {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.interaction instanceof ER && ("start" === _ ? this.interaction.audioPlayer.play() : this.interaction.audioPlayer.stop())
                    }
                    dispose() {
                        this.interaction.dispose()
                    }
                },
                WR = (_, O) => O.some(O => O instanceof RegExp ? O.test(_) : O === _),
                Y7 = (_, {
                    stripHash: O
                }) => {
                    let B = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(_);
                    if (!B) throw Error(`Invalid URL: ${_}`);
                    let {
                        type: N,
                        data: k,
                        hash: F
                    } = B.groups, U = N.split(";");
                    F = O ? "" : F;
                    let j = !1;
                    "base64" === U[U.length - 1] && (U.pop(), j = !0);
                    let G = (U.shift() || "").toLowerCase(),
                        Y = [...U.map(_ => {
                            let [O, B = ""] = _.split("=").map(_ => _.trim());
                            return "charset" === O && "us-ascii" === (B = B.toLowerCase()) ? "" : `${O}${B?`=${B}`:""}`
                        }).filter(Boolean)];
                    return j && Y.push("base64"), (Y.length > 0 || G && "text/plain" !== G) && Y.unshift(G), `data:${Y.join(";")},${j?k.trim():k}${F?`#${F}`:""}`
                },
                EN = class {
                    constructor({
                        url: _,
                        context: O
                    }, B, N, k) {
                        if (this.controlsManager = B, this.shared = N, this.condition = k, !_) throw Error("Missing property");
                        this.url = _.startsWith("mailto:") ? _ : function(_, O) {
                            if (O = {
                                    defaultProtocol: "http:",
                                    normalizeProtocol: !0,
                                    forceHttp: !1,
                                    forceHttps: !1,
                                    stripAuthentication: !0,
                                    stripHash: !1,
                                    stripTextFragment: !0,
                                    stripWWW: !0,
                                    removeQueryParameters: [/^utm_\w+/i],
                                    removeTrailingSlash: !0,
                                    removeSingleSlash: !0,
                                    removeDirectoryIndex: !1,
                                    sortQueryParameters: !0,
                                    ...O
                                }, _ = _.trim(), /^data:/i.test(_)) return Y7(_, O);
                            if (/^view-source:/i.test(_)) throw Error("`view-source:` is not supported as it is a non-standard protocol");
                            let B = _.startsWith("//");
                            !B && /^\.*\//.test(_) || (_ = _.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, O.defaultProtocol));
                            let N = new URL(_);
                            if (O.forceHttp && O.forceHttps) throw Error("The `forceHttp` and `forceHttps` options cannot be used together");
                            if (O.forceHttp && "https:" === N.protocol && (N.protocol = "http:"), O.forceHttps && "http:" === N.protocol && (N.protocol = "https:"), O.stripAuthentication && (N.username = "", N.password = ""), O.stripHash ? N.hash = "" : O.stripTextFragment && (N.hash = N.hash.replace(/#?:~:text.*?$/i, "")), N.pathname) {
                                let _ = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g,
                                    O = 0,
                                    B = "";
                                for (;;) {
                                    let k = _.exec(N.pathname);
                                    if (!k) break;
                                    let F = k[0],
                                        U = k.index;
                                    B += N.pathname.slice(O, U).replace(/\/{2,}/g, "/") + F, O = U + F.length
                                }
                                B += N.pathname.slice(O, N.pathname.length).replace(/\/{2,}/g, "/"), N.pathname = B
                            }
                            if (N.pathname) try {
                                N.pathname = decodeURI(N.pathname)
                            } catch {}
                            if (!0 === O.removeDirectoryIndex && (O.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(O.removeDirectoryIndex) && O.removeDirectoryIndex.length > 0) {
                                let _ = N.pathname.split("/");
                                WR(_[_.length - 1], O.removeDirectoryIndex) && (_ = _.slice(0, -1), N.pathname = _.slice(1).join("/") + "/")
                            }
                            if (N.hostname && (N.hostname = N.hostname.replace(/\.$/, ""), O.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(N.hostname) && (N.hostname = N.hostname.replace(/^www\./, ""))), Array.isArray(O.removeQueryParameters))
                                for (let _ of [...N.searchParams.keys()]) WR(_, O.removeQueryParameters) && N.searchParams.delete(_);
                            if (!0 === O.removeQueryParameters && (N.search = ""), O.sortQueryParameters) {
                                N.searchParams.sort();
                                try {
                                    N.search = decodeURIComponent(N.search)
                                } catch {}
                            }
                            O.removeTrailingSlash && (N.pathname = N.pathname.replace(/\/$/, ""));
                            let k = _;
                            return _ = N.toString(), O.removeSingleSlash || "/" !== N.pathname || k.endsWith("/") || "" !== N.hash || (_ = _.replace(/\/$/, "")), (O.removeTrailingSlash || "/" === N.pathname) && "" === N.hash && O.removeSingleSlash && (_ = _.replace(/\/$/, "")), B && !O.normalizeProtocol && (_ = _.replace(/^http:\/\//, "//")), O.stripProtocol && (_ = _.replace(/^(?:https?:)?\/\//, "")), _
                        }(_, {
                            removeTrailingSlash: !1,
                            removeSingleSlash: !1
                        }), this.context = O ? ? "tab"
                    }
                    dispatch() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        dU ? window.location.assign(this.url) : ("tab" === this.context ? window.open(this.url, "_blank") : "window" === this.context ? window.open(this.url, "_blank", `width=${window.innerWidth}, height=${window.innerHeight}`) : window.open(this.url, "_parent"), this.controlsManager.orbitControls ? .onPointerUp(dq[0]), dq.splice(0, dq.length))
                    }
                },
                Ek = class {
                    constructor(_, O, B, N, k) {
                        this.data = _, this.page = O, this.controlsManager = B, this.shared = N, this.condition = k, this.timeoutIdQueue = [], this.dispatchInner = () => {
                            this.objects.forEach(this.destroyCallback)
                        }, this.destroyCallback = _ => {
                            this.timeoutIdQueue.shift();
                            let O = this.page.scene.find(_);
                            if (void 0 === O) return;
                            let B = this.controlsManager.sharedGameControlGlobals.rapierWorld,
                                N = !B || O.dataPatched.physics ? .fusedBody;
                            if (O.cloner) {
                                for (let _ of O.cloner.children) N ? (_.playModeVisible = !1, _.rigidBody && O.dataPatched.physics ? .rigidBody === "positioned" && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(_.rigidBody.collider(0).handle), B.removeRigidBody(_.rigidBody), _.rigidBody = void 0), _.bvhGeometry && (_.bvhGeometry = void 0)) : void 0 === this.clone || this.clone === _ ? (_.playModeVisible = !1, _.rigidBody && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(_.rigidBody.collider(0).handle), B.removeRigidBody(_.rigidBody), _.rigidBody = void 0)) : void 0 === _.playModeVisible && (_.playModeVisible = !0);
                                (N || void 0 === this.clone || !1 === this.clone) && (O.visible = !1, O.rigidBody && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(O.rigidBody.collider(0).handle), B.removeRigidBody(O.rigidBody), O.rigidBody = void 0), O.bvhGeometry && (O.bvhGeometry = void 0))
                            } else O.rigidBody && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(O.rigidBody.collider(0).handle), B.removeRigidBody(O.rigidBody), O.rigidBody = void 0), O.bvhGeometry && (O.bvhGeometry = void 0), O.visible = !1;
                            void 0 === B ? this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim = this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(_ => void 0 !== _.bvhGeometry) : this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim = this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(_ => void 0 !== _.rigidBody), O.destroyedInAction = !0, this.controlsManager.requestRender()
                        }, this.objects = [..._.objects]
                    }
                    dispatch(_) {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.clone = _, this.data.delay ? this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, 1e3 * this.data.delay)) : this.dispatchInner()
                    }
                    dispatchFromStart() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, 1e3 * this.data.delay))
                    }
                    dispose() {
                        this.timeoutIdQueue.forEach(_ => window.clearTimeout(_))
                    }
                },
                EF = class {
                    constructor(_, O, B, N, k) {
                        this.data = _, this.page = O, this.shared = B, this.eventManager = N, this.condition = k, this.shared = B
                    }
                    dispatch() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        clearTimeout(this.timeoutId), delete this.timeoutId, this.timeoutId = window.setTimeout(() => {
                            this.shared.reset(this.shared.data, !0), nf(this.page, this.shared, !0), this.eventManager.reset(), this.eventManager.controlsManager.gameControl ? .reset(!0), this.page.switchToPlayCamera(), this.eventManager.controlsManager.requestRender(), delete this.timeoutId
                        }, (this.data.delay ? ? 0) * 1e3)
                    }
                    dispose() {
                        clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                },
                EU = {
                    update: null,
                    begin: null,
                    loopBegin: null,
                    changeBegin: null,
                    change: null,
                    changeComplete: null,
                    timelineChangeComplete: null,
                    loopComplete: null,
                    complete: null,
                    loop: 1,
                    direction: "normal",
                    autoplay: !0,
                    timelineOffset: 0,
                    rewind: !0
                },
                Ej = {
                    duration: 1e3,
                    delay: 0,
                    endDelay: 0,
                    startOnceDelay: 0,
                    pingPongDelayCorrection: 0,
                    pingPongEndDelayCorrection: 0,
                    easing: "easeOutElastic(1, .5)",
                    round: 0
                },
                EG = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
                EH = {
                    CSS: {},
                    springs: {}
                };

            function Ns(_, O, B) {
                return Math.min(Math.max(_, O), B)
            }

            function fm(_, O) {
                return _.indexOf(O) > -1
            }

            function x1(_, O) {
                return _.apply(null, O)
            }
            var EW = {
                arr: function(_) {
                    return Array.isArray(_)
                },
                obj: function(_) {
                    return fm(Object.prototype.toString.call(_), "Object")
                },
                pth: function(_) {
                    return EW.obj(_) && _.hasOwnProperty("totalLength")
                },
                svg: function(_) {
                    return _ instanceof SVGElement
                },
                inp: function(_) {
                    return _ instanceof HTMLInputElement
                },
                dom: function(_) {
                    return !("isNode" in _) && (_.nodeType || EW.svg(_))
                },
                str: function(_) {
                    return "string" == typeof _
                },
                fnc: function(_) {
                    return "function" == typeof _
                },
                und: function(_) {
                    return typeof _ > "u"
                },
                hex: function(_) {
                    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(_)
                },
                rgb: function(_) {
                    return /^rgb/.test(_)
                },
                hsl: function(_) {
                    return /^hsl/.test(_)
                },
                col: function(_) {
                    return EW.hex(_) || EW.rgb(_) || EW.hsl(_)
                },
                key: function(_) {
                    return !EU.hasOwnProperty(_) && !Ej.hasOwnProperty(_) && "targets" !== _ && "keyframes" !== _
                }
            };

            function JR(_) {
                var O = /\(([^)]+)\)/.exec(_);
                return O ? O[1].split(",").map(function(_) {
                    return parseFloat(_)
                }) : []
            }

            function $R(_, O) {
                var B = JR(_),
                    N = Ns(EW.und(B[0]) ? 1 : B[0], .1, 100),
                    k = Ns(EW.und(B[1]) ? 100 : B[1], .1, 100),
                    F = Ns(EW.und(B[2]) ? 10 : B[2], .1, 100),
                    U = Ns(EW.und(B[3]) ? 0 : B[3], .1, 100),
                    j = Math.sqrt(k / N),
                    G = F / (2 * Math.sqrt(k * N)),
                    Y = G < 1 ? j * Math.sqrt(1 - G * G) : 0,
                    Q = G < 1 ? (G * j + -U) / Y : -U + j;

                function d(_) {
                    var B = O ? O * _ / 1e3 : _;
                    return B = G < 1 ? Math.exp(-B * G * j) * (1 * Math.cos(Y * B) + Q * Math.sin(Y * B)) : (1 + Q * B) * Math.exp(-B * j), 0 === _ || 1 === _ ? _ : 1 - B
                }
                return O ? d : function() {
                    var O = EH.springs[_];
                    if (O) return O;
                    for (var B = 1 / 6, N = 0, k = 0;;)
                        if (1 === d(N += B)) {
                            if (++k >= 16) break
                        } else k = 0;
                    var F = N * B * 1e3;
                    return EH.springs[_] = F, F
                }
            }

            function Q7(_) {
                return void 0 === _ && (_ = 10),
                    function(O) {
                        return Math.ceil(Ns(O, 1e-6, 1) * _) * (1 / _)
                    }
            }
            var Eq = function() {
                    function s(_, O, B) {
                        return (((1 - 3 * B + 3 * O) * _ + (3 * B - 6 * O)) * _ + 3 * O) * _
                    }

                    function o(_, O, B) {
                        return 3 * (1 - 3 * B + 3 * O) * _ * _ + 2 * (3 * B - 6 * O) * _ + 3 * O
                    }
                    return function(_, O, B, N) {
                        if (0 <= _ && _ <= 1 && 0 <= B && B <= 1) {
                            var k = new Float32Array(11);
                            if (_ !== O || B !== N)
                                for (var F = 0; F < 11; ++F) k[F] = s(.1 * F, _, B);
                            return function(F) {
                                return _ === O && B === N || 0 === F || 1 === F ? F : s(function(O) {
                                    for (var N = 0, F = 1; 10 !== F && k[F] <= O; ++F) N += .1;
                                    var U = N + (O - k[--F]) / (k[F + 1] - k[F]) * .1,
                                        j = o(U, _, B);
                                    return j >= .001 ? function(_, O, B, N) {
                                        for (var k = 0; k < 4; ++k) {
                                            var F = o(O, B, N);
                                            if (0 === F) break;
                                            var U = s(O, B, N) - _;
                                            O -= U / F
                                        }
                                        return O
                                    }(O, U, _, B) : 0 === j ? U : function(_, O, B, N, k) {
                                        var F, U, j = 0;
                                        do(F = s(U = O + (B - O) / 2, N, k) - _) > 0 ? B = U : O = U; while (Math.abs(F) > 1e-7 && ++j < 10);
                                        return U
                                    }(O, N, N + .1, _, B)
                                }(F), O, N)
                            }
                        }
                    }
                }(),
                EY = (EQ = {
                    linear: function() {
                        return function(_) {
                            return _
                        }
                    }
                }, EZ = {
                    Sine: function() {
                        return function(_) {
                            return 1 - Math.cos(_ * Math.PI / 2)
                        }
                    },
                    Circ: function() {
                        return function(_) {
                            return 1 - Math.sqrt(1 - _ * _)
                        }
                    },
                    Back: function() {
                        return function(_) {
                            return _ * _ * (3 * _ - 2)
                        }
                    },
                    Bounce: function() {
                        return function(_) {
                            for (var O, B = 4; _ < ((O = Math.pow(2, --B)) - 1) / 11;);
                            return 1 / Math.pow(4, 3 - B) - 7.5625 * Math.pow((3 * O - 2) / 22 - _, 2)
                        }
                    },
                    Elastic: function(_, O) {
                        void 0 === _ && (_ = 1), void 0 === O && (O = .5);
                        var B = Ns(_, 1, 10),
                            N = Ns(O, .1, 2);
                        return function(_) {
                            return 0 === _ || 1 === _ ? _ : -B * Math.pow(2, 10 * (_ - 1)) * Math.sin((_ - 1 - N / (2 * Math.PI) * Math.asin(1 / B)) * (2 * Math.PI) / N)
                        }
                    }
                }, ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function(_, O) {
                    EZ[_] = function() {
                        return function(_) {
                            return Math.pow(_, O + 2)
                        }
                    }
                }), Object.keys(EZ).forEach(function(_) {
                    var O = EZ[_];
                    EQ["easeIn" + _] = O, EQ["easeOut" + _] = function(_, B) {
                        return function(N) {
                            return 1 - O(_, B)(1 - N)
                        }
                    }, EQ["easeInOut" + _] = function(_, B) {
                        return function(N) {
                            return N < .5 ? O(_, B)(2 * N) / 2 : 1 - O(_, B)(-2 * N + 2) / 2
                        }
                    }
                }), EQ);

            function A1(_, O) {
                if (EW.fnc(_)) return _;
                var B = _.split("(")[0],
                    N = EY[B],
                    k = JR(_);
                switch (B) {
                    case "spring":
                        return $R(_, O);
                    case "cubicBezier":
                        return x1(Eq, k);
                    case "steps":
                        return x1(Q7, k);
                    default:
                        return x1(N, k)
                }
            }

            function tL(_) {
                try {
                    return document.querySelectorAll(_)
                } catch {
                    return
                }
            }

            function W0(_, O) {
                for (var B = _.length, N = arguments.length >= 2 ? arguments[1] : void 0, k = [], F = 0; F < B; F++)
                    if (F in _) {
                        var U = _[F];
                        O.call(N, U, F, _) && k.push(U)
                    }
                return k
            }

            function q0(_) {
                return _.reduce(function(_, O) {
                    return _.concat(EW.arr(O) ? q0(O) : O)
                }, [])
            }

            function qR(_) {
                return EW.arr(_) ? _ : (EW.str(_) && (_ = tL(_) || _), _ instanceof NodeList || _ instanceof HTMLCollection ? [].slice.call(_) : [_])
            }

            function _1(_, O) {
                return _.some(function(_) {
                    return _ === O
                })
            }

            function E1(_) {
                var O = {};
                for (var B in _) O[B] = _[B];
                return O
            }

            function b1(_, O) {
                var B = E1(_);
                for (var N in _) B[N] = O.hasOwnProperty(N) ? O[N] : _[N];
                return B
            }

            function Y0(_, O) {
                var B = E1(_);
                for (var N in O) B[N] = EW.und(_[N]) ? O[N] : _[N];
                return B
            }

            function fa(_) {
                var O = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(_);
                if (O) return O[1]
            }

            function w1(_, O) {
                return EW.fnc(_) ? _(O.target, O.id, O.total) : _
            }

            function _o(_, O) {
                return _.getAttribute(O)
            }

            function M1(_, O, B) {
                if (_1([B, "deg", "rad", "turn"], fa(O))) return O;
                var N = EH.CSS[O + B];
                if (!EW.und(N)) return N;
                var k = document.createElement(_.tagName),
                    F = _.parentNode && _.parentNode !== document ? _.parentNode : document.body;
                F.appendChild(k), k.style.position = "absolute", k.style.width = 100 + B;
                var U = 100 / k.offsetWidth;
                F.removeChild(k);
                var j = U * parseFloat(O);
                return EH.CSS[O + B] = j, j
            }

            function rL(_, O, B) {
                if (O in _.style) {
                    var N = O.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                        k = _.style[O] || getComputedStyle(_).getPropertyValue(N) || "0";
                    return B ? M1(_, k, B) : k
                }
            }

            function T1(_, O) {
                return EW.dom(_) && !EW.inp(_) && (_o(_, O) || EW.svg(_) && _[O]) ? "attribute" : EW.dom(_) && _1(EG, O) ? "transform" : EW.dom(_) && "transform" !== O && rL(_, O) ? "css" : null != _[O] ? "object" : void 0
            }

            function nL(_) {
                if (EW.dom(_)) {
                    for (var O, B = _.style.transform || "", N = /(\w+)\(([^)]*)\)/g, k = new Map; O = N.exec(B);) k.set(O[1], O[2]);
                    return k
                }
            }

            function C1(_, O, B, N) {
                switch (T1(_, O)) {
                    case "transform":
                        var k, F;
                        return k = fm(O, "scale") ? 1 : 0 + (fm(O, "translate") || "perspective" === O ? "px" : fm(O, "rotate") || fm(O, "skew") ? "deg" : void 0), F = nL(_).get(O) || k, N && (N.transforms.list.set(O, F), N.transforms.last = O), B ? M1(_, F, B) : F;
                    case "css":
                        return rL(_, O, B);
                    case "attribute":
                        return _o(_, O);
                    default:
                        return _[O] || 0
                }
            }

            function P1(_, O) {
                var B = /^(\*=|\+=|-=)/.exec(_);
                if (!B) return _;
                var N = fa(_) || 0,
                    k = parseFloat(O),
                    F = parseFloat(_.replace(B[0], ""));
                switch (B[0][0]) {
                    case "+":
                        return k + F + N;
                    case "-":
                        return k - F + N;
                    case "*":
                        return k * F + N
                }
            }

            function iL(_, O) {
                if (EW.col(_)) {
                    var B, N, k, F;
                    return B = _, EW.rgb(B) ? (N = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(B)) ? "rgba(" + N[1] + ",1)" : B : EW.hex(B) ? (k = B.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(_, O, B, N) {
                        return O + O + B + B + N + N
                    }), "rgba(" + parseInt((F = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(k))[1], 16) + "," + parseInt(F[2], 16) + "," + parseInt(F[3], 16) + ",1)") : EW.hsl(B) ? function(_) {
                        var O, B, N, k = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(_) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(_),
                            F = parseInt(k[1], 10) / 360,
                            U = parseInt(k[2], 10) / 100,
                            j = parseInt(k[3], 10) / 100,
                            G = k[4] || 1;

                        function o(_, O, B) {
                            return B < 0 && (B += 1), B > 1 && (B -= 1), B < 1 / 6 ? _ + (O - _) * 6 * B : B < .5 ? O : B < 2 / 3 ? _ + (O - _) * (2 / 3 - B) * 6 : _
                        }
                        if (0 == U) O = B = N = j;
                        else {
                            var Y = j < .5 ? j * (1 + U) : j + U - j * U,
                                Q = 2 * j - Y;
                            O = o(Q, Y, F + 1 / 3), B = o(Q, Y, F), N = o(Q, Y, F - 1 / 3)
                        }
                        return "rgba(" + 255 * O + "," + 255 * B + "," + 255 * N + "," + G + ")"
                    }(B) : void 0
                }
                if (/\s/g.test(_)) return _;
                var U = fa(_),
                    j = U ? _.substr(0, _.length - U.length) : _;
                return O ? j + O : j
            }

            function D1(_, O) {
                return Math.sqrt(Math.pow(O.x - _.x, 2) + Math.pow(O.y - _.y, 2))
            }

            function sL(_) {
                for (var O, B = _.points, N = 0, k = 0; k < B.numberOfItems; k++) {
                    var F = B.getItem(k);
                    k > 0 && (N += D1(O, F)), O = F
                }
                return N
            }

            function oL(_) {
                var O;
                if (_.getTotalLength) return _.getTotalLength();
                switch (_.tagName.toLowerCase()) {
                    case "circle":
                        return 2 * Math.PI * _o(_, "r");
                    case "rect":
                        return 2 * _o(_, "width") + 2 * _o(_, "height");
                    case "line":
                        return D1({
                            x: _o(_, "x1"),
                            y: _o(_, "y1")
                        }, {
                            x: _o(_, "x2"),
                            y: _o(_, "y2")
                        });
                    case "polyline":
                        return sL(_);
                    case "polygon":
                        return O = _.points, sL(_) + D1(O.getItem(O.numberOfItems - 1), O.getItem(0))
                }
            }

            function aL(_, O) {
                var B = O || {},
                    N = B.el || function(_) {
                        for (var O = _.parentNode; EW.svg(O) && EW.svg(O.parentNode);) O = O.parentNode;
                        return O
                    }(_),
                    k = N.getBoundingClientRect(),
                    F = _o(N, "viewBox"),
                    U = k.width,
                    j = k.height,
                    G = B.viewBox || (F ? F.split(" ") : [0, 0, U, j]);
                return {
                    el: N,
                    viewBox: G,
                    x: G[0] / 1,
                    y: G[1] / 1,
                    w: U / G[2],
                    h: j / G[3]
                }
            }

            function YR(_, O) {
                var B = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
                    N = iL(EW.pth(_) ? _.totalLength : _, O) + "";
                return {
                    original: N,
                    numbers: N.match(B) ? N.match(B).map(Number) : [0],
                    strings: EW.str(_) || O ? N.split(B) : []
                }
            }

            function lL(_) {
                return W0(_ ? q0(EW.arr(_) ? _.map(qR) : qR(_)) : [], function(_, O, B) {
                    return B.indexOf(_) === O
                })
            }

            function cL(_) {
                var O = lL(_);
                return O.map(function(_, B) {
                    return {
                        target: _,
                        id: B,
                        total: O.length,
                        transforms: {
                            list: nL(_)
                        }
                    }
                })
            }
            var EX = {
                css: function(_, O, B) {
                    return _.style[O] = B
                },
                attribute: function(_, O, B) {
                    return _.setAttribute(O, B)
                },
                object: function(_, O, B) {
                    return _[O] = B
                },
                transform: function(_, O, B, N, k) {
                    if (N.list.set(O, B), O === N.last || k) {
                        var F = "";
                        N.list.forEach(function(_, O) {
                            F += O + "(" + _ + ") "
                        }), _.style.transform = F
                    }
                }
            };

            function hL(_, O) {
                cL(_).forEach(function(_) {
                    for (var B in O) {
                        var N = w1(O[B], _),
                            k = _.target,
                            F = fa(N),
                            U = C1(k, B, F, _),
                            j = P1(iL(N, F || fa(U)), U);
                        EX[T1(k, B)](k, B, j, _.transforms, !0)
                    }
                })
            }

            function dL(_, O) {
                var B = _.length,
                    r = function(_) {
                        return _.timelineOffset ? _.timelineOffset : 0
                    },
                    N = {};
                return N.duration = B ? Math.max.apply(Math, _.map(function(_) {
                    let O = _.startOnceDelay ? ? 0,
                        B = _.pingPongDelayCorrection ? ? 0,
                        N = _.pingPongEndDelayCorrection ? ? 0;
                    return r(_) + O + B + N + _.duration * (_.loop ? ? 1)
                })) : O.duration, N.delay = B ? Math.min.apply(Math, _.map(function(_) {
                    let O = _.startOnceDelay ? ? 0,
                        B = _.pingPongDelayCorrection ? ? 0;
                    return r(_) + O + B + _.delay
                })) : O.delay, N.endDelay = B ? N.duration - Math.max.apply(Math, _.map(function(_) {
                    let O = _.startOnceDelay ? ? 0,
                        B = _.pingPongDelayCorrection ? ? 0,
                        N = _.pingPongEndDelayCorrection ? ? 0;
                    return r(_) + O + B + _.duration * (_.loop ? ? 1) - _.endDelay - N
                })) : O.endDelay, N
            }
            var EQ, EZ, EK, EJ = 0,
                E$ = [],
                E0 = [],
                E2 = function() {
                    function i() {
                        EK = requestAnimationFrame(t)
                    }

                    function t(_) {
                        var O = E$.length;
                        if (O) {
                            for (var B = 0; B < O;) {
                                var N = E$[B];
                                N.paused ? (E$.splice(B, 1), O -= 1) : (N.tick(_), B++)
                            }
                            i()
                        } else EK = cancelAnimationFrame(EK)
                    }
                    return i
                }();

            function zr(_) {
                void 0 === _ && (_ = {});
                var O, B, N, k, F, U, j, G, Y, Q, K = 0,
                    $ = 0,
                    ee = 0,
                    et = 0,
                    ei = null;

                function l(_) {
                    var O = window.Promise && new Promise(function(_) {
                        return ei = _
                    });
                    return _.finished = O, O
                }
                var er = (B = b1(EU, O = _), k = function(_, O) {
                    var B = [],
                        N = O.keyframes;
                    for (var k in N && (O = Y0(function(_) {
                            for (var O = W0(q0(_.map(function(_) {
                                    return Object.keys(_)
                                })), function(_) {
                                    return EW.key(_)
                                }).reduce(function(_, O) {
                                    return 0 > _.indexOf(O) && _.push(O), _
                                }, []), B = {}, N = 0; N < O.length; N++) ! function(N) {
                                var k = O[N];
                                B[k] = _.map(function(_) {
                                    var O = {};
                                    for (var B in _) EW.key(B) ? B == k && (O.value = _[B]) : O[B] = _[B];
                                    return O
                                })
                            }(N);
                            return B
                        }(N), O)), O) EW.key(k) && B.push({
                        name: k,
                        tweens: function(_, O) {
                            var B = E1(O);
                            if (/^spring/.test(B.easing) && (B.duration = $R(B.easing)), EW.arr(_)) {
                                var N = _.length;
                                2 !== N || EW.obj(_[0]) ? EW.fnc(O.duration) || (B.duration = O.duration / N) : _ = {
                                    value: _
                                }
                            }
                            var k = EW.arr(_) ? _ : [_];
                            return k.map(function(_, B) {
                                var N = EW.obj(_) && !EW.pth(_) ? _ : {
                                    value: _
                                };
                                return EW.und(N.delay) && (N.delay = B ? 0 : O.delay), EW.und(N.endDelay) && (N.endDelay = B === k.length - 1 ? O.endDelay : 0), N
                            }).map(function(_) {
                                return Y0(_, B)
                            })
                        }(O[k], _)
                    });
                    return B
                }(N = b1(Ej, O), O), j = dL(U = W0(q0((F = cL(O.targets)).map(function(_) {
                    return k.map(function(O) {
                        return function(_, O) {
                            var B = T1(_.target, O.name);
                            if (B) {
                                var N, k = O.tweens.map(function(B) {
                                        var k = function(_, O) {
                                                var B = {};
                                                for (var N in _) {
                                                    var k = w1(_[N], O);
                                                    EW.arr(k) && 1 === (k = k.map(function(_) {
                                                        return w1(_, O)
                                                    })).length && (k = k[0]), B[N] = k
                                                }
                                                return B.duration = parseFloat(B.duration), B.delay = parseFloat(B.delay), B
                                            }(B, _),
                                            F = k.value,
                                            U = EW.arr(F) ? F[1] : F,
                                            j = fa(U),
                                            G = C1(_.target, O.name, j, _),
                                            Y = N ? N.to.original : G,
                                            Q = EW.arr(F) ? F[0] : Y,
                                            K = fa(Q) || fa(G),
                                            $ = j || K;
                                        return EW.und(U) && (U = Y), k.from = YR(Q, $), k.to = YR(P1(U, Q), $), k.start = N ? N.end : 0, k.end = k.start + k.delay + k.duration + k.endDelay, k.easing = A1(k.easing, k.duration), k.isPath = EW.pth(F), k.isColor = EW.col(k.from.original), k.isColor && (k.round = 1), N = k, k
                                    }),
                                    F = k[k.length - 1];
                                return {
                                    type: B,
                                    property: O.name,
                                    animatable: _,
                                    tweens: k,
                                    duration: F.end,
                                    delay: k[0].delay,
                                    endDelay: F.endDelay
                                }
                            }
                        }(_, O)
                    })
                })), function(_) {
                    return !EW.und(_)
                }), N), G = EJ, EJ++, Y0(B, {
                    id: G,
                    children: [],
                    animatables: F,
                    animations: U,
                    duration: j.duration,
                    delay: j.delay,
                    endDelay: j.endDelay,
                    startOnceDelay: N.startOnceDelay,
                    pingPongDelayCorrection: N.pingPongDelayCorrection,
                    pingPongEndDelayCorrection: N.pingPongEndDelayCorrection
                }));

                function h() {
                    var _ = er.direction;
                    "alternate" !== _ && (er.direction = "normal" !== _ ? "normal" : "reverse"), er.reversed = !er.reversed, Q.forEach(function(_) {
                        (1 === _.loop || _.loop % 2 == 0) && (_.reversed = er.reversed)
                    })
                }

                function f(_) {
                    return er.reversed ? er.duration - _ : _
                }

                function m(_, O, B = !1) {
                    O && (er.reversed ? O.seek(O.duration * O.loop - (_ - O.timelineOffset - O.pingPongDelayCorrection), B) : O.seek(_ - O.timelineOffset - O.startOnceDelay - O.pingPongDelayCorrection, B))
                }

                function y(_) {
                    var O = 0,
                        B = er.animations,
                        N = B.length;
                    for ("alternate" !== er.direction && er.parent ? .direction === "alternate" ? er.parent ? .rewind === !1 && !0 === er.reversePlayback && !1 === er.rewind && (_ = er.parent ? .reversed && "alternate" === er.direction ? er.duration - er.delay + er.endDelay - _ : er.duration + er.delay - er.endDelay - _) : S(!1, er.parent ? .rewind, er.rewind, er.parent ? .reversePlayback, er.reversePlayback) && (_ = er.parent ? .reversed && "alternate" === er.direction ? er.duration - er.delay + er.endDelay - _ : er.duration + er.delay - er.endDelay - _); O < N;) {
                        let N;
                        var k = B[O],
                            F = k.animatable,
                            U = k.tweens,
                            j = U.length - 1,
                            G = U[j];
                        j && (G = W0(U, function(O) {
                            return _ < O.end
                        })[0] || G), N = er.parent ? .reversed && "alternate" === er.direction ? Ns(_ - G.start - G.endDelay, 0, G.duration) / G.duration : Ns(_ - G.start - G.delay, 0, G.duration) / G.duration;
                        for (var Y = isNaN(N) ? 1 : G.easing(N), Q = G.to.strings, K = G.round, $ = [], ee = G.to.numbers.length, et = void 0, ei = 0; ei < ee; ei++) {
                            let _, O;
                            var ea = void 0;
                            "alternate" !== er.direction ? er.parent ? .rewind === !1 && !0 === er.reversePlayback && !1 === er.rewind ? (_ = G.to.numbers[ei], O = G.from.numbers[ei] || 0) : (O = G.to.numbers[ei], _ = G.from.numbers[ei] || 0) : S(!0, er.parent ? .rewind, er.rewind, er.parent ? .reversePlayback, er.reversePlayback) ? (_ = G.to.numbers[ei], O = G.from.numbers[ei] || 0) : (O = G.to.numbers[ei], _ = G.from.numbers[ei] || 0), ea = G.isPath ? function(_, O) {
                                function e(B) {
                                    void 0 === B && (B = 0);
                                    var N = O + B >= 1 ? O + B : 0;
                                    return _.el.getPointAtLength(N)
                                }
                                var B = aL(_.el, _.svg),
                                    N = e(),
                                    k = e(-1),
                                    F = e(1);
                                switch (_.property) {
                                    case "x":
                                        return (N.x - B.x) * B.w;
                                    case "y":
                                        return (N.y - B.y) * B.h;
                                    case "angle":
                                        return 180 * Math.atan2(F.y - k.y, F.x - k.x) / Math.PI
                                }
                            }(G.value, Y * O) : _ + Y * (O - _), K && (G.isColor && ei > 2 || (ea = Math.round(ea * K) / K)), $.push(ea)
                        }
                        var en = Q.length;
                        if (en) {
                            et = Q[0];
                            for (var eo = 0; eo < en; eo++) {
                                Q[eo];
                                var el = Q[eo + 1],
                                    eh = $[eo];
                                isNaN(eh) || (el ? et += eh + el : et += eh + " ")
                            }
                        } else et = $[0];
                        EX[k.type](F.target, k.property, et, F.transforms), k.currentValue = et, O++
                    }
                }

                function v(_) {
                    er[_] && !er.passThrough && er[_](er)
                }
                l(er);
                let ea = {
                    0: !1,
                    1: !0,
                    2: !1,
                    3: !0,
                    4: !1,
                    5: !1,
                    6: !1,
                    7: !1,
                    8: !1,
                    9: !0,
                    10: !0,
                    11: !1,
                    12: !1,
                    13: !1,
                    14: !0,
                    15: !0,
                    16: !1,
                    17: !0,
                    18: !0,
                    19: !1,
                    20: !1,
                    21: !1,
                    22: !0,
                    23: !0,
                    24: !1,
                    25: !0,
                    26: !1,
                    27: !0,
                    28: !1,
                    29: !1,
                    30: !1,
                    31: !1
                };

                function S(_, O, B, N, k) {
                    return ea[_ << 4 | O << 3 | B << 2 | N << 1 | k]
                }

                function A(_, O = !1) {
                    var B = er.duration;
                    let N = er.delay,
                        k = B - er.endDelay;
                    er.parent ? .reversed && "alternate" === er.direction && (N = er.endDelay, k = B - er.delay);
                    var F = f(_);
                    if (er.progress = Ns(F / B * 100, 0, 100), O || (er.reversePlayback = F < er.currentTime), et && function(_, O = !1) {
                            if (er.reversed)
                                for (var B = et; B--;) m(_, Q[B], O);
                            else
                                for (var N = 0; N < et; N++) m(_, Q[N], O)
                        }(F, O), !er.began && er.currentTime >= 0 && (er.began = !0, v("begin")), !er.loopBegan && er.currentTime > 0 && (er.loopBegan = !0, v("loopBegin")), (er.reversed || F >= 0) && F <= N && 0 !== er.currentTime && (y(0), v("change")), (F >= k && er.currentTime !== B + er.pingPongDelayCorrection || !B) && (y(B), v("change")), F > N && F < k ? (er.changeBegan || (er.changeBegan = !0, er.changeCompleted = !1, v("changeBegin")), y(F), v("change")) : er.changeBegan ? (er.changeCompleted = !0, er.changeBegan = !1, v("change"), et && v("timelineChangeComplete")) : er.began && F > k && v("changeComplete"), er.currentTime = Ns(F, 0, B + er.pingPongDelayCorrection), er.began && v("update"), _ >= B) {
                        if (er.remaining && !0 !== er.remaining && er.remaining--, er.remaining) {
                            for (let _ of (et ? K += er.duration / zr.speed : K += er.duration, Q)) _.setStartTime(0), _.remaining = _.loop;
                            v("loopComplete"), er.loopBegan = !1, "alternate" === er.direction ? h() : et && (er.direction = "normal", er.reversed = !1, Q.forEach(function(_) {
                                return _.reversed = !1
                            }))
                        } else er.paused = !0, er.completed || (er.completed = !0, v("loopComplete"), v("complete"), !er.passThrough && "Promise" in window && (ei(), l(er)))
                    }
                }
                return er.reset = function() {
                    var _ = er.direction;
                    er.passThrough = !1, er.currentTime = 0, er.progress = 0, er.paused = !0, er.began = !1, er.loopBegan = !1, er.changeBegan = !1, er.completed = !1, er.changeCompleted = !1, er.reversePlayback = !1, er.reversed = "reverse" === _, er.remaining = er.loop, et = (Q = er.children).length;
                    for (var O = et; O--;) er.children[O].reset();
                    y(er.reversed ? er.duration : 0)
                }, er.setStartTime = function(_) {
                    K = _
                }, er.set = function(_, O) {
                    return hL(_, O), er
                }, er.tick = function(_) {
                    ee = _, K || (K = ee), A((ee + ($ - K)) * zr.speed)
                }, er.seek = function(_, O = !1) {
                    A(_ - K, O)
                }, er.pause = function(_) {
                    er.paused = !0, et && (Y = _ ? ? performance.now())
                }, er.play = function(_) {
                    !er.paused || (er.completed && er.reset(), er.paused = !1, E$.push(er), et && void 0 !== Y && (K += (_ ? ? performance.now()) - Y), EK || E2())
                }, er.reverse = function() {
                    h(), er.completed = !er.reversed, K = 0, $ = f(er.currentTime) * (1 / zr.speed)
                }, er.restart = function() {
                    er.reset(), er.play()
                }, er.reset(), er.autoplay && er.play(), er
            }

            function KR(_, O) {
                for (var B = O.length; B--;) _1(_, O[B].animatable.target) && O.splice(B, 1)
            }
            "u" > typeof document && document.addEventListener("visibilitychange", function(_) {
                document.hidden ? (E$.forEach(function(O) {
                    return O.pause(_.timeStamp)
                }), E0 = E$.slice(0), zr.running = E$ = []) : E0.forEach(function(O) {
                    return O.play(_.timeStamp)
                })
            }), zr.version = "3.2.0", zr.speed = 1, zr.running = E$, zr.remove = function(_) {
                for (var O = lL(_), B = E$.length; B--;) {
                    var N = E$[B],
                        k = N.animations,
                        F = N.children;
                    KR(O, k);
                    for (var U = F.length; U--;) {
                        var j = F[U],
                            G = j.animations;
                        KR(O, G), G.length || j.children.length || F.splice(U, 1)
                    }
                    k.length || F.length || N.pause()
                }
            }, zr.get = C1, zr.set = hL, zr.convertPx = M1, zr.path = function(_, O) {
                var B = EW.str(_) ? tL(_)[0] : _,
                    N = O || 100;
                return function(_) {
                    return {
                        property: _,
                        el: B,
                        svg: aL(B),
                        totalLength: oL(B) * (N / 100)
                    }
                }
            }, zr.setDashoffset = function(_) {
                var O = oL(_);
                return _.setAttribute("stroke-dasharray", O), O
            }, zr.stagger = function(_, O) {
                void 0 === O && (O = {});
                var B = O.direction || "normal",
                    N = O.easing ? A1(O.easing) : null,
                    k = O.grid,
                    F = O.axis,
                    U = O.from || 0,
                    j = "first" === U,
                    G = "center" === U,
                    Y = "last" === U,
                    Q = EW.arr(_),
                    K = parseFloat(Q ? _[0] : _),
                    $ = Q ? parseFloat(_[1]) : 0,
                    ee = fa(Q ? _[1] : _) || 0,
                    et = O.start || 0 + (Q ? K : 0),
                    ei = [],
                    er = 0;
                return function(_, O, ea) {
                    if (j && (U = 0), G && (U = (ea - 1) / 2), Y && (U = ea - 1), !ei.length) {
                        for (var en = 0; en < ea; en++) {
                            if (k) {
                                var eo = G ? (k[0] - 1) / 2 : U % k[0],
                                    el = G ? (k[1] - 1) / 2 : Math.floor(U / k[0]),
                                    eh = en % k[0],
                                    ec = Math.floor(en / k[0]),
                                    eu = eo - eh,
                                    ep = el - ec,
                                    ef = Math.sqrt(eu * eu + ep * ep);
                                "x" === F && (ef = -eu), "y" === F && (ef = -ep), ei.push(ef)
                            } else ei.push(Math.abs(U - en));
                            er = Math.max.apply(Math, ei)
                        }
                        N && (ei = ei.map(function(_) {
                            return N(_ / er) * er
                        })), "reverse" === B && (ei = ei.map(function(_) {
                            return F ? _ < 0 ? -1 * _ : -_ : Math.abs(er - _)
                        }))
                    }
                    return et + (Q ? ($ - K) / er : K) * (Math.round(100 * ei[O]) / 100) + ee
                }
            }, zr.timeline = function(_) {
                void 0 === _ && (_ = {});
                var O = zr(_);
                return O.duration = 0, O.add = function(B, N) {
                    var k = E$.indexOf(O),
                        F = O.children;

                    function o(_) {
                        _.passThrough = !0
                    }
                    k > -1 && E$.splice(k, 1);
                    for (var U = 0; U < F.length; U++) o(F[U]);
                    var j = Y0(B, b1(Ej, _));
                    j.targets = j.targets || _.targets;
                    var G = O.duration;
                    j.autoplay = !1, j.timelineOffset = EW.und(N) ? G : P1(N, G), o(O);
                    var Y = zr(j);
                    o(Y), F.push(Y), Y.parent = O;
                    var Q = dL(F, _);
                    return O.delay = Q.delay, O.endDelay = Q.endDelay, O.duration = Q.duration, !0 === Y.loop && (O.duration = 1 / 0), O.seek(0), O.reset(), O.autoplay && O.play(), O
                }, O
            }, zr.easing = A1, zr.penner = EY, zr.random = function(_, O) {
                return Math.floor(Math.random() * (O - _ + 1)) + _
            };
            var E3 = new rv,
                E4 = new rv,
                E5 = new rm;

            function Bs(_, O, B, N, k, F) {
                let U = B[_] ? B[_] : void 0,
                    j = N[_];
                if (null == j) return;
                let G = null != U ? "string" == typeof U ? Number(k.getVariable(U) ? ? 0) : U : O[_],
                    Y = "string" == typeof j ? Number(k.getVariable(j) ? ? 0) : j;
                if (G !== Y) return {
                    update: B => {
                        let N = iK.lerp(G, Y, B);
                        F ? O[_] = Math.trunc(N) : O[_] = N
                    },
                    start: () => {
                        O[_] = G
                    },
                    end: () => {
                        O[_] = Y
                    }
                }
            }

            function I1(_, O, B, N, k, F) {
                let U = B[_] ? B[_] : void 0,
                    j = N[_];
                if (!j) return;
                let G = O[_],
                    Y = [...U ? ? G].map(_ => "string" == typeof _ ? Number(k.getVariable(_) ? ? 0) : _),
                    Q = [...j].map(_ => "string" == typeof _ ? Number(k.getVariable(_) ? ? 0) : _);
                if (!(Y.length !== Q.length || np(Y, Q))) return {
                    update: B => {
                        Y.forEach((N, k) => {
                            let U = iK.lerp(N, Q[k], B);
                            O[_][k] = F ? Math.trunc(U) : U
                        })
                    },
                    start: () => {
                        Object.assign(O[_], Y)
                    },
                    end: () => {
                        Object.assign(O[_], Q)
                    }
                }
            }

            function pm(_, O, B) {
                return O.forEach((O, N) => {
                    _.setComponent(N, "string" == typeof O ? Number(B.getVariable(O) ? ? 0) : O)
                }), _
            }

            function O1(_, O, B, N, k) {
                let F = B[_] ? B[_] : void 0,
                    U = N[_];
                if (!U) return;
                let j = O[_],
                    G = F ? pm(new rv, F, k) : j.clone(),
                    Y = pm(new rv, U, k);
                if (!G.equals(Y)) return {
                    update: _ => {
                        j.lerpVectors(G, Y, _)
                    },
                    start: () => {
                        j.copy(G)
                    },
                    end: () => {
                        j.copy(Y)
                    }
                }
            }

            function Eo(_, O, B, N, k) {
                return "number" == typeof O[_] ? Bs(_, O, B ? ? {}, N, k) : Array.isArray(O[_]) ? I1(_, O, B ? ? {}, N, k) : void 0
            }

            function SL(_, O, B, N) {
                let k = [],
                    F = _c(B, N) || !!O.layers && _c(O, N);
                for (let U of (k.push({
                        update: () => {
                            _.transparent = F
                        }
                    }), _.layers)) {
                    let _ = O.layers ? .data(U.uuid),
                        F = B.layers.data(U.uuid);
                    if (F && ("light" === U.type || (U.visible ? ? !0) && (F.visible ? ? !0)))
                        for (let O of U.getNames().filter(_ => !f7.some(O => _.includes(O)))) try {
                            let B = U.getValue(O),
                                j;
                            if ("colors" === O) j = function(_, O, B, N = "colors") {
                                if (!_.hasValue(N) || !(N in B)) return;
                                let k = [],
                                    F = _.getValue(N),
                                    U = O ? O[N] : F.map(_ => _.toArray()),
                                    j = B[N];
                                for (let _ = 0; _ < F.length; ++_) {
                                    let O = [...U[_]],
                                        B = [...j[_]];
                                    fF.isEqual(O, B) || k.push({
                                        update: N => {
                                            F[_].fromArray(fF.lerp(O, B, N))
                                        },
                                        start: () => {
                                            F[_].fromArray(O)
                                        },
                                        end: () => {
                                            F[_].fromArray(B)
                                        }
                                    })
                                }
                                return k.length ? k : void 0
                            }(U, _, F, O);
                            else if (Array.isArray(B)) "steps" === O && (j = function(_, O, B, N = "steps") {
                                if (!_.hasValue(N) || !(N in B)) return;
                                let k = [],
                                    F = _.getValue(N),
                                    U = O ? O[N] : F,
                                    j = B[N];
                                for (let _ = 0; _ < F.length; ++_) {
                                    let O = U[_],
                                        B = j[_];
                                    O !== B && k.push({
                                        update: N => {
                                            F[_] = iK.lerp(O, B, N)
                                        },
                                        start: () => {
                                            F[_] = O
                                        },
                                        end: () => {
                                            F[_] = B
                                        }
                                    })
                                }
                                return k.length ? k : void 0
                            }(U, _, F, O));
                            else if ("number" == typeof B) j = function(_, O, B, N, k) {
                                if (!_.hasValue(N) || !(N in B)) return;
                                let F = O ? O[N] : _.getValue(N),
                                    U = B[N],
                                    j = "string" == typeof F ? Number(k.getVariable(F) ? ? 0) : F,
                                    G = "string" == typeof U ? Number(k.getVariable(U) ? ? 0) : U;
                                if (j !== G) return {
                                    update: O => {
                                        _.setValue(N, iK.lerp(j, G, O))
                                    },
                                    start: () => {
                                        _.setValue(N, j)
                                    },
                                    end: () => {
                                        _.setValue(N, G)
                                    }
                                }
                            }(U, _, F, O, N);
                            else {
                                if ("boolean" == typeof B) continue;
                                B instanceof iJ ? j = function(_, O, B, N) {
                                    if (!_.hasValue(N) || !(N in B)) return;
                                    let k = _.getValue(N),
                                        F = O ? new iJ().fromArray(O[N]) : k.clone(),
                                        U = new iJ().fromArray(B[N]);
                                    if (!F.equals(U)) return {
                                        update: _ => {
                                            k.lerpVectors(F, U, _)
                                        },
                                        start: () => {
                                            k.copy(F)
                                        },
                                        end: () => {
                                            k.copy(U)
                                        }
                                    }
                                }(U, _, F, O) : B instanceof rv ? j = function(_, O, B, N, k) {
                                    if (!_.hasValue(N) || !(N in B)) return;
                                    let F = _.getValue(N),
                                        U = O ? O[N] : void 0,
                                        j = B[N],
                                        G = U ? pm(new rv, U, k) : F.clone(),
                                        Y = pm(new rv, j, k);
                                    if (!G.equals(Y)) return {
                                        update: _ => {
                                            F.lerpVectors(G, Y, _)
                                        },
                                        start: () => {
                                            F.copy(G)
                                        },
                                        end: () => {
                                            F.copy(Y)
                                        }
                                    }
                                }(U, _, F, O, N) : B instanceof x8 ? j = function(_, O, B, N, k) {
                                    if (!_.hasValue(N) || !(N in B)) return;
                                    let F = O ? O[N] : void 0,
                                        U = B[N],
                                        j = _.getValue(N),
                                        G = F ? "string" == typeof F ? k.getColor(F).clone() : new re().setRGB(F.r, F.g, F.b) : j.clone(),
                                        Y = "string" == typeof U ? k.getColor(U).clone() : new x8(U.r, U.g, U.b, U.a);
                                    if (G.equals(Y)) return;
                                    let Q = j.clone();
                                    return {
                                        update: O => {
                                            _.getValue(N) !== Q && _.setValue(N, Q), Q.lerpColors(G, Y, O)
                                        },
                                        start: () => {
                                            Q.copy(G)
                                        },
                                        end: () => {
                                            Q.copy(Y)
                                        }
                                    }
                                }(U, _, F, O, N) : B instanceof re ? j = function(_, O, B, N, k) {
                                    if (!_.hasValue(N) || !(N in B)) return;
                                    let F = O ? O[N] : void 0,
                                        U = B[N],
                                        j = _.getValue(N),
                                        G = F ? "string" == typeof F ? k.getColor(F).clone() : new re().setRGB(F.r, F.g, F.b) : j.clone(),
                                        Y = "string" == typeof U ? k.getColor(U).clone() : new re().setRGB(U.r, U.g, U.b);
                                    if (G.equals(Y)) return;
                                    let Q = j.clone();
                                    return {
                                        update: O => {
                                            _.getValue(N) !== Q && _.setValue(N, Q), Q.lerpColors(G, Y, O)
                                        },
                                        start: () => {
                                            Q.copy(G)
                                        },
                                        end: () => {
                                            Q.copy(Y)
                                        }
                                    }
                                }(U, _, F, O, N) : "isTexture" in B && (j = function(_, O, B, N = "texture") {
                                    if (!_.hasValue(N) || !(N in B)) return;
                                    let k = _.getNode("mat");
                                    if (!k) return;
                                    let F = O ? O[N] : k,
                                        U = B[N],
                                        j = [...F.repeat],
                                        G = [...F.offset],
                                        Y = [...U.repeat],
                                        Q = [...U.offset];
                                    if (!fN.isEqual(j, Y) || !fN.isEqual(G, Q)) return {
                                        update: _ => {
                                            k.repeat = fN.lerp(j, Y, _), k.offset = fN.lerp(G, Q, _), k.updateMatrix()
                                        },
                                        start: () => {
                                            k.repeat = [...j], k.offset = [...G], k.updateMatrix()
                                        },
                                        end: () => {
                                            k.repeat = [...Y], k.offset = [...Q], k.updateMatrix()
                                        }
                                    }
                                }(U, _, F, O))
                            }
                            j && (Array.isArray(j) ? k.push(...j) : k.push(j))
                        } catch (_) {
                            console.error(`lerpMaterial: unexpected material layer for ${O}`, _)
                        }
                }
                return k
            }
            var E6 = new rv,
                E8 = new r9;

            function L1(_, O, B, N, k) {
                let F = [];
                return _.data.visible && F.push(... function(_, O, B, N, k) {
                    let F = [],
                        U, j, G, Y, Q, K, $ = {
                            slide: O.pathSnapping ? .slide ? ? _.updatedPathSnapping ? .slide ? ? _.dataPatched.pathSnapping ? .slide ? ? 0,
                            offset: O.pathSnapping ? .offset ? ? _.updatedPathSnapping ? .offset ? ? _.dataPatched.pathSnapping ? .offset ? ? 0
                        };
                    if ((Q = Bs("slide", $, O.pathSnapping ? ? _.updatedPathSnapping ? ? _.dataPatched.pathSnapping, B.pathSnapping ? ? _.dataPatched.pathSnapping, k)) && F.push(Q), (K = Bs("offset", $, O.pathSnapping ? ? _.updatedPathSnapping ? ? _.dataPatched.pathSnapping, B.pathSnapping ? ? _.dataPatched.pathSnapping, k)) && F.push(K), !Q && !K && ((U = O1("position", _, O, B, k)) && F.push(U), (j = O1("scale", _, O, B, k)) && F.push(j), (G = function(_, O, B, N, k) {
                            let F = O ? .rotation ? O.rotation.map(_ => ("string" == typeof _ ? Number(k.getVariable(_) ? ? 0) : _) * iK.DEG2RAD) : void 0,
                                U = B.rotation ? .map(_ => ("string" == typeof _ ? Number(k.getVariable(_) ? ? 0) : _) * iK.DEG2RAD);
                            if (!U) return;
                            let j = F ? new rv().fromArray(F) : new rv().setFromEuler(_.rotation),
                                G = new rv().fromArray(U);
                            if (j.equals(G)) return;
                            let Y = E6.subVectors(G, j);
                            if (!(N && Y.toArray().every(_ => Math.abs(_) < 2 * Math.PI))) return {
                                update: O => {
                                    E6.lerpVectors(j, G, O), _.rotation.setFromVector3(E6)
                                },
                                start: () => {
                                    _.rotation.setFromVector3(j)
                                },
                                end: () => {
                                    _.rotation.setFromVector3(G)
                                }
                            }; {
                                let O = new rm().setFromEuler(E8.setFromVector3(j)),
                                    B = new rm().setFromEuler(E8.setFromVector3(G));
                                return {
                                    update: N => {
                                        ! function(_, O, B, N) {
                                            if (0 === N) return B.copy(_);
                                            if (1 === N) return B.copy(O);
                                            let k = _.w * O.w + _.x * O.x + _.y * O.y + _.z * O.z;
                                            if (k >= 1) return B.copy(_);
                                            let F = 1 - k * k;
                                            if (F <= Number.EPSILON) {
                                                let k = 1 - N;
                                                return B.w = k * _.w + N * O.w, B.x = k * _.x + N * O.x, B.y = k * _.y + N * O.y, B.z = k * _.z + N * O.z, B.normalize()
                                            }
                                            let U = Math.sqrt(F),
                                                j = Math.atan2(U, k),
                                                G = Math.sin((1 - N) * j) / U,
                                                Y = Math.sin(N * j) / U;
                                            B.w = _.w * G + O.w * Y, B.x = _.x * G + O.x * Y, B.y = _.y * G + O.y * Y, B.z = _.z * G + O.z * Y
                                        }(O, B, _.quaternion, N)
                                    },
                                    start: () => {
                                        _.rotation.setFromVector3(j)
                                    },
                                    end: () => {
                                        _.rotation.setFromVector3(G)
                                    }
                                }
                            }
                        }(_, O, B, N, k)) && F.push(G), (Y = function(_, O, B, N) {
                            let k = B[_] ? B[_] : void 0,
                                F = N[_];
                            if (!F) return;
                            let U = O[_],
                                j = k ? new rJ().fromArray(k) : U.clone(),
                                G = new rv,
                                Y = new rm,
                                Q = new rv;
                            j.decompose(G, Y, Q);
                            let K = new rJ().fromArray(F),
                                $ = new rv,
                                ee = new rm,
                                et = new rv;
                            if (K.decompose($, ee, et), !j.equals(K)) return {
                                update: _ => {
                                    E5.slerpQuaternions(Y, ee, _), E3.lerpVectors(G, $, _), E4.lerpVectors(Q, et, _), U.compose(E3, E5, E4)
                                },
                                start: () => {
                                    U.compose(G, Y, Q)
                                },
                                end: () => {
                                    U.compose($, ee, et)
                                }
                            }
                        }("hiddenMatrix", _, O, B)) && F.push(Y)), U || j || G || Y || Q || K) {
                        let f = () => {
                            _.updateMatrix(), _.hasNonUniformScale && (_.updateMatrixWorld(), _.updateMatrixWorldSVD()), _.parent ? .matrixWorldFusedFalse && (_.matrixWorld.multiplyMatrices(_.parent.matrixWorldFusedFalse, _.matrix), _.matrixWorldNeedsUpdate = !1), Yn(_) && Xn(_.parent) && _.invalidateDownstreamBooleanData(!0), _.updatePathSnapping(Object.assign({}, O.pathSnapping, $))
                        };
                        F.push({
                            update: f,
                            start: f,
                            end: f
                        })
                    }
                    return F
                }(_, O, B, k, N)), _.data.visible && F.push(... function(_, O, B, N) {
                    let k = [];
                    if (!("cloner" in B) || !_.cloner) return k;
                    let F = _.cloner,
                        U = "cloner" in O ? O.cloner : {},
                        j = B.cloner;
                    pX.forEach(_ => {
                        let O;
                        (O = "count" === _ ? Bs("count", F.parameters, U, j, N, !0) : Eo(_, F.parameters, U ? ? {}, j, N)) && k.push(O)
                    });
                    let G = function(_, O, B, N) {
                        if ("radial" !== _.parameters.type) return;
                        let k = O.radial,
                            F = B.radial;
                        if (!F) return;
                        let U = _.parameters.radial,
                            j = [];
                        return pQ.forEach(_ => {
                            let O = Eo(_, U, k ? ? {}, F, N);
                            O && j.push(O)
                        }), j
                    }(F, U, j, N);
                    G ? .length && k.push(...G);
                    let Y = function(_, O, B, N) {
                        if ("linear" !== _.parameters.type) return;
                        let k = O.linear,
                            F = B.linear;
                        if (!F) return;
                        let U = [],
                            j = _.parameters.linear;
                        return pZ.forEach(_ => {
                            let O = Eo(_, j, k ? ? {}, F, N);
                            O && U.push(O)
                        }), U
                    }(F, U, j, N);
                    Y ? .length && k.push(...Y);
                    let Q = function(_, O, B, N) {
                        if ("grid" !== _.parameters.type) return;
                        let k = O.grid,
                            F = B.grid;
                        if (!F) return;
                        let U = [],
                            j = _.parameters.grid;
                        return pK.forEach(_ => {
                            let O;
                            (O = "count" === _ ? I1(_, j, k ? ? {}, F, N, !0) : Eo(_, j, k ? ? {}, F, N)) && U.push(O)
                        }), U
                    }(F, U, j, N);
                    Q ? .length && k.push(...Q);
                    let K = function(_, O, B, N) {
                        if ("toObject" !== _.parameters.type) return;
                        let k = O.toObject,
                            F = B.toObject;
                        if (!F) return;
                        let U = [],
                            j = _.parameters.toObject;
                        return pJ.forEach(_ => {
                            let O;
                            (O = "count" === _ ? Bs(_, j, k ? ? {}, F, N, !0) : Eo(_, j, k ? ? {}, F, N)) && U.push(O)
                        }), U
                    }(F, U, j, N);
                    K ? .length && k.push(...K);
                    let $ = function(_, O, B, N) {
                        if (!_.parameters.randomness) return;
                        let k = O.randomnessObject,
                            F = B.randomnessObject;
                        if (!F) return;
                        let U = [],
                            j = _.parameters.randomnessObject;
                        return p$.forEach(_ => {
                            let O = Eo(_, j, k ? ? {}, F, N);
                            O && U.push(O)
                        }), U
                    }(F, U, j, N);
                    return $ ? .length && k.push(...$), k.length && k.push({
                        update: () => {
                            F.update()
                        }
                    }), k
                }(_, O, B, N)), Yn(_) ? (_ instanceof _m && _.data.visible && F.push(... function(_, O, B, N) {
                    let k = [];
                    if (!("geometry" in B)) return k;
                    let F = _.geometry.userData.parameters,
                        U = "geometry" in O ? O.geometry : {},
                        j = B.geometry;
                    if (_ instanceof _x) {
                        let O = function(_, O, B, N) {
                            if (void 0 === B.scaleBaked) return;
                            let k = (O.scaleBaked ? ? _.data.geometry.scaleBaked).map(_ => "string" == typeof _ ? Number(N.getVariable(_) ? ? 0) : _),
                                F = B.scaleBaked.map(_ => "string" == typeof _ ? Number(N.getVariable(_) ? ? 0) : _);
                            if (fk.isEqual(k, F)) return;
                            let U = [];
                            return U.push({
                                update: O => {
                                    _.updateGeometryInteractions({
                                        scaleBaked: [iK.lerp(k[0], F[0], O), iK.lerp(k[1], F[1], O), iK.lerp(k[2], F[2], O)]
                                    }, N), _.invalidateDownstreamBooleanData()
                                },
                                start: () => {
                                    _.updateGeometryInteractions({
                                        scaleBaked: k
                                    }, N), _.invalidateDownstreamBooleanData()
                                },
                                end: () => {
                                    _.updateGeometryInteractions({
                                        scaleBaked: F
                                    }, N), _.invalidateDownstreamBooleanData()
                                }
                            }), U
                        }(_, U, j, N);
                        O && k.push(...O)
                    } else {
                        let O = {};
                        if (Object.assign(O, dk(F, ms)), ms.forEach(_ => {
                                let B = Eo(_, O, U, j, N);
                                B && k.push(B)
                            }), _ instanceof MF) {
                            Object.assign(O, {
                                extrusion: { ...F.extrusion
                                }
                            });
                            let _ = function(_, O, B, N) {
                                if (!B.extrusion) return;
                                let k = _.extrusion,
                                    F = O.extrusion ? ? {},
                                    U = B.extrusion,
                                    j = [];
                                return mr.forEach(_ => {
                                    let O = Eo(_, k, F, U, N);
                                    O && j.push(O)
                                }), j
                            }(O, U, j, N);
                            _ && k.push(..._)
                        }
                        k.length && k.push({
                            update: B => {
                                _.updateGeometryInteractions(O, N), _.updateGeometryGroupsIfNeeded()
                            },
                            start: B => {
                                _.updateGeometryInteractions(O, N), _.updateGeometryGroupsIfNeeded()
                            },
                            end: B => {
                                _.updateGeometryInteractions(O, N), _.updateGeometryGroupsIfNeeded()
                            }
                        })
                    }
                    return k
                }(_, O, B, N)), _.data.visible && F.push(... function(_, O, B, N) {
                    let k = [];
                    if (Array.isArray(_.material)) {
                        if (!("materials" in B && B.materials)) return k;
                        let F = "materials" in O && O.materials ? O.materials : [],
                            U = B.materials;
                        _.material.forEach((_, O) => {
                            if (!U[O]) return;
                            let B = F[O] ? ? {},
                                j = U[O];
                            "string" == typeof B || "string" == typeof j || k.push(...SL(_, B, j, N))
                        })
                    } else {
                        if (!("material" in B && B.material)) return k;
                        let F = "material" in O && O.material ? O.material : {},
                            U = B.material;
                        if ("string" == typeof F || "string" == typeof U) return k;
                        k.push(...SL(_.material, F, U, N))
                    }
                    return k
                }(_, O, B, N))) : rO(_) ? _.data.visible && F.push(... function(_, O, B, N) {
                    let k = [];
                    if (void 0 !== B.intensity) {
                        let F = Bs("intensity", _, O, B, N);
                        F && k.push(F)
                    }
                    if (void 0 !== B.color) {
                        let F = function(_, O, B, N, k) {
                            let F = B[_] ? B[_] : void 0,
                                U = N[_];
                            if (!U) return;
                            let j = O[_],
                                G = F ? "string" == typeof F ? k.getColor(F).clone() : new re().setRGB(F.r, F.g, F.b) : j.clone(),
                                Y = "string" == typeof U ? k.getColor(U).clone() : new re().setRGB(U.r, U.g, U.b);
                            if (G.equals(Y)) return;
                            let Q = j.clone();
                            return O[_] = Q, {
                                update: _ => {
                                    Q.lerpColors(G, Y, _)
                                },
                                start: () => {
                                    Q.copy(G)
                                },
                                end: () => {
                                    Q.copy(Y)
                                }
                            }
                        }("color", _, O, B, N);
                        F && k.push(F)
                    }
                    return k
                }(_, O, B, N)) : tO(_) && F.push(... function(_, O, B, N) {
                    let k = [],
                        F = "OrthographicCamera" === _.cameraType ? O.orthographic ? .zoom : O.perspective ? .zoom,
                        U = "OrthographicCamera" === _.cameraType ? B.orthographic ? .zoom : B.perspective ? .zoom;
                    if (void 0 !== U) {
                        let O = F ? ? _.zoom;
                        O !== U && k.push({
                            update: B => {
                                _.zoom = iK.lerp(O, U, B), _.updateProjectionMatrix()
                            },
                            start: () => {
                                _.zoom = O, _.updateProjectionMatrix()
                            },
                            end: () => {
                                _.zoom = U, _.updateProjectionMatrix()
                            }
                        })
                    }
                    if (void 0 !== B.targetOffset) {
                        let F = Bs("targetOffset", _, O, B, N);
                        F && k.push(F)
                    }
                    return k
                }(_, O, B, N)), F.length ? {
                    update: _ => {
                        F.forEach(O => O.update(_))
                    },
                    start: _ => {
                        F.forEach(O => O.start ? .(_))
                    },
                    end: _ => {
                        F.forEach(O => O.end ? .(_))
                    }
                } : void 0
            }
            var E9 = new rv;

            function nf(_, O, B = !1) {
                let N = [];
                _.traverseChildren(k => {
                    if (B && (k.rigidBody ? .setTranslation(k.position0, !0), k.rigidBody ? .setRotation(k.rotation0, !0), k.rigidBody ? .setLinvel(E9, !0), k.rigidBody ? .setAngvel(E9, !0)), !xu.is(k)) return;
                    let F = k.uuid,
                        U = k.data;
                    if (delete k.states, k.uuid === pq) return;
                    let j = !1;
                    for (let O of (N.some(O => _.scene.find(F) ? .isDescendantOf(O)) ? j = !0 : U.physics ? .fusedBody === !0 && "dynamic" === U.physics.rigidBody && N.push(F), k.data = U, k.currentState = null, k.reversibleToState = null, k.currentTransitionEvent = null, U.states)) {
                        let B = { ...O.data
                        };
                        !0 === _.data.globalPhysics.usePhysics && U.physics && ("dynamic" === U.physics.rigidBody || j) && (void 0 !== O.data.position && delete B.position, void 0 !== O.data.rotation && delete B.rotation, void 0 !== O.data.hiddenMatrix && delete B.hiddenMatrix), k.states || (k.states = {}), k.states[O.id] = gS.patch(U, B)
                    }(function(_, O, B, N, k = !1) {
                        if (O instanceof _m && O.removeInteractionGeometry(), O.changeSelectedState(null, {
                                scene: _,
                                shared: N
                            }, k), O instanceof _m && O.updateGeometryGroupsIfNeeded(), O instanceof Sh && O.updateCameraState(O.dataPatched, {
                                scene: _,
                                shared: N
                            }), O.cloner)
                            for (let _ of O.cloner.children) _.playModeVisible = void 0;
                        O.updateVisible()
                    })(_.scene, k, 0, O, void 0 !== U.events.find(_ => "Follow" === _.data.type || "LookAt" === _.data.type)),
                    function(_) {
                        _.traverseEntity(O => {
                            for (let B of O.data.events) {
                                let O = [];
                                switch (B.data.type) {
                                    case "Follow":
                                    case "MouseHover":
                                    case "Scroll":
                                    case "MouseDown":
                                    case "MouseUp":
                                    case "MousePress":
                                    case "KeyUp":
                                    case "KeyDown":
                                    case "KeyPress":
                                    case "Collision":
                                        O.push(...B.data.actions);
                                        break;
                                    case "GameControl":
                                        for (let _ of Object.values(B.data.gameActions)) O.push(..._);
                                        break;
                                    case "DragDrop":
                                        O.push(...B.data.dragDropActions.drag, ...B.data.dragDropActions.drop);
                                        break;
                                    case "Conditional":
                                        O.push(...B.data.inActions, ...B.data.outActions)
                                }
                                for (let B of O)
                                    if ("Create" === B.data.type && "Yes" === B.data.hideBase) {
                                        let O = _.scene.find(B.data.object);
                                        O && (O.visible = !1)
                                    }
                            }
                        })
                    }(_)
                })
            }

            function B1(_) {
                let O;
                if (5 === _.easing) {
                    let {
                        control1: B,
                        control2: N
                    } = _;
                    O = `cubicBezier(
			${B[0]}, ${B[1]}, ${N[0]}, ${N[1]}
		)`
                } else if (6 === _.easing) {
                    let {
                        mass: B,
                        stiffness: N,
                        damping: k,
                        velocity: F
                    } = _;
                    O = `spring( ${B}, ${N}, ${k}, ${F} )`
                } else {
                    let B;
                    switch (_.easing) {
                        case 0:
                        default:
                            B = fq.linear;
                            break;
                        case 1:
                            B = fq.ease;
                            break;
                        case 2:
                            B = fq.easeIn;
                            break;
                        case 3:
                            B = fq.easeOut;
                            break;
                        case 4:
                            B = fq.easeInOut
                    }
                    let [N, k, F, U] = B;
                    O = `cubicBezier( ${N}, ${k}, ${F}, ${U} )`
                }
                return {
                    duration: _.duration,
                    easing: O
                }
            }

            function N1(_) {
                let O = {
                    delay: 0,
                    loop: -1 === _.repeat || _.repeat + 1
                };
                if (0 === _.repeat) O.direction = "normal", O.rewind = !1;
                else switch (_.direction) {
                    case "pingpong":
                        O.direction = "alternate", O.rewind = !1;
                        break;
                    case "pingpong-rewind":
                        O.direction = "alternate", O.rewind = !0;
                        break;
                    default:
                        O.direction = "normal", O.rewind = !1
                }
                switch (O.delay = 0, O.endDelay = 0, O.startOnceDelay = 0, O.pingPongDelayCorrection = 0, O.pingPongEndDelayCorrection = 0, _.delayDirection) {
                    case "start-once":
                        O.startOnceDelay = _.delay;
                        break;
                    case "start":
                        O.delay = _.delay;
                        break;
                    case "end":
                        O.endDelay = _.delay;
                        break;
                    case "start-end":
                    case void 0:
                        O.delay = _.delay, O.endDelay = _.delay
                }
                return "alternate" === O.direction && (O.delay /= 2, O.endDelay /= 2, "start" === _.delayDirection ? (O.pingPongDelayCorrection = O.delay, "number" == typeof O.loop && O.loop % 2 == 0 && (O.pingPongEndDelayCorrection = O.delay)) : "end" === _.delayDirection ? "number" == typeof O.loop && O.loop % 2 != 0 && (O.pingPongEndDelayCorrection = O.endDelay) : "start-end" === _.delayDirection && (O.pingPongDelayCorrection = O.delay, O.pingPongEndDelayCorrection = O.endDelay)), O
            }
            var E7 = {
                    type: "beginState"
                },
                Ce = {
                    type: "completeState",
                    isfromEntity: !1
                },
                Ct = class {
                    constructor(_, O, B, N, k, F) {
                        if (this.object = _, this.data = N, this.sharedAssets = k, this.allowSlerp = F, this.targets = {
                                t: 0
                            }, this.firstLoop = !0, this._changeBegan = !1, this._changeCompleted = !0, this.onChange = () => {
                                this.callback && (this.callback.update(this.targets.t), this.object.dispatchEvent({
                                    type: "requestRender"
                                })), 0 === this.targets.t || 1 === this.targets.t ? this._changeCompleted || (this._changeCompleted = !0, this._changeBegan = !1, this.onChangeComplete()) : (this._changeCompleted && (this._changeCompleted = !1), this._changeBegan || (this._changeBegan = !0, this.onChangeBegin()))
                            }, this.onChangeBegin = () => {
                                this.object.reversibleToState = this.to.id;
                                let _ = this.targets.t > .5 ? this.from.id : this.to.id;
                                this.object.prevState !== this.object.currentState && (this.object.prevState = this.object.currentState), this.object.currentState = _, this.object.dispatchEvent({
                                    type: "beginState",
                                    state: _
                                }), this.object.traverseEntity(_ => {
                                    _ !== this.object && _ instanceof Sh && _.dispatchEvent(E7)
                                })
                            }, this.onChangeComplete = () => {
                                this.firstLoop && (this.onFirstLoop(), this.firstLoop = !1), this.object.reversibleToState = this.to.id;
                                let _ = this.targets.t < .5 ? this.from.id : this.to.id;
                                this.object.prevState !== this.object.currentState && (this.object.prevState = this.object.currentState), this.object.currentState = _, this.object.dispatchEvent({
                                    type: "completeState",
                                    state: _
                                }), this.object.traverseEntity(_ => {
                                    _ !== this.object && _ instanceof Sh && _.dispatchEvent(Ce)
                                })
                            }, this.onFirstLoop = () => {
                                this.useCurrentState && (this.callback = L1(this.object, this.from.data, this.to.data, this.sharedAssets, this.allowSlerp))
                            }, void 0 === O) {
                            let _ = Q0(this.object, this.object.currentState === B ? this.object.prevState : this.object.currentState);
                            if (!_) throw Error("Missing property");
                            this.from = _
                        } else {
                            let _ = Q0(this.object, O);
                            if (!_) throw Error("Missing property");
                            this.from = _
                        }
                        if (void 0 === B) throw Error("Missing property"); {
                            let _ = Q0(this.object, B);
                            if (!_) throw Error("Missing property");
                            this.to = _
                        }
                        this.useCurrentState = void 0 === O || void 0 === B, this.params = {
                            targets: this.targets,
                            t: 1,
                            autoplay: !1,
                            ...N1(N),
                            ...B1(N),
                            change: this.onChange
                        }, this.callback = L1(this.object, void 0 === O ? {} : this.from.data, void 0 === B ? {} : this.to.data, this.sharedAssets, this.allowSlerp)
                    }
                    get changeBegan() {
                        return this._changeBegan
                    }
                    get changeCompleted() {
                        return this._changeCompleted
                    }
                },
                Ci = class extends iq {
                    constructor(_, O, B, N) {
                        if (super(), this.data = _, this.page = O, this.shared = B, this.condition = N, this.toggleIsForward = !1, this.timelineNeedsRebuild = !1, this.useToggle = !1, this.onTimelineChangeComplete = () => {
                                "normal" !== this.data.tweens[0].data.direction && (this.toggleIsForward = !this.toggleIsForward), !1 !== this.timelineNeedsRebuild && (this.timeline ? .pause(), this.buildTimeline({
                                    isForward: this.toggleIsForward,
                                    needsRebuild: !1,
                                    isRebuild: !0
                                }), this.timeline.play())
                            }, !_.object) throw Error("Missing property");
                        let k = this.page.scene.find(_.object);
                        if (!k || !k.states || (this.object = k, _.tweens.length < 2)) throw Error("Missing property");
                        this.tweens = Array(this.data.tweens.length - 1), this.startOnceDelay = "start-once" === _.tweens[0].data.delayDirection ? _.tweens[0].data.delay : 0, this.init()
                    }
                    get playing() {
                        return this.timeline && !1 === this.timeline.paused
                    }
                    init() {
                        this.initialCurrentState = Q0(this.object, this.object.currentState).id, this.toggleIsForward = !1
                    }
                    get currentState() {
                        return this.useToggle ? this.initialCurrentState : this.object.currentState
                    }
                    buildTimeline({
                        isForward: _ = !0,
                        needsRebuild: O = !1,
                        isRebuild: B = !1
                    } = {}) {
                        try {
                            let N = N1(this.data.tweens[0].data);
                            B && "number" == typeof N.loop && N.loop--, this.timeline ? .pause(), this.timeline = zr.timeline({
                                autoplay: !1,
                                ...N,
                                ...!0 === N.loop || N.loop > 1 ? {
                                    timelineChangeComplete: this.onTimelineChangeComplete
                                } : {}
                            });
                            let k = this.tweens.findIndex(_ => _ ? .changeBegan);
                            if (!0 === O && (this.timelineNeedsRebuild = !0), _) {
                                let _ = -1 === k ? 0 : k;
                                for (let O = _; O < this.data.tweens.length - 1; O++) {
                                    let B = this.data.tweens[O],
                                        F = this.data.tweens[O + 1],
                                        U;
                                    O === _ && (!0 === this.object.wasMovedByUser || this.object.previousAction ? .playing === !0) ? (U = void 0, this.object instanceof Sh && (this.object.wasMovedByUser = !1)) : U = void 0 === B.data.state ? this.currentState : B.data.state;
                                    let j = new Ct(this.object, U, void 0 === F.data.state ? this.currentState : F.data.state, F.data, this.shared, this.data.allowSlerp ? ? !1); - 1 !== k && O === _ && Object.assign(j.params, {
                                        startOnceDelay: 0
                                    }), this.tweens[O] = j, this.timeline.add(j.params, this.timeline.duration + (O === _ ? N.delay : 0))
                                }
                                this.timeline.duration += N.endDelay
                            } else {
                                let _ = -1 === k ? this.data.tweens.length - 1 : k + 1;
                                for (let O = _; O > 0; O--) {
                                    let B = this.data.tweens[O],
                                        F = this.data.tweens[O - 1],
                                        U;
                                    O === _ && (!0 === this.object.wasMovedByUser || this.object.previousAction ? .playing === !0) ? (U = void 0, this.object instanceof Sh && (this.object.wasMovedByUser = !1)) : U = void 0 === B.data.state ? this.currentState : B.data.state;
                                    let j = new Ct(this.object, U, void 0 === F.data.state ? this.currentState : F.data.state, B.data, this.shared, this.data.allowSlerp ? ? !1); - 1 !== k && O === _ && Object.assign(j.params, {
                                        startOnceDelay: 0
                                    }), this.tweens[O - 1] = j, this.timeline.add(j.params, this.timeline.duration + (O === _ ? N.endDelay : 0))
                                }
                                this.timeline.duration += N.delay
                            }
                        } catch (_) {
                            _ instanceof Error && console.error(_.message)
                        }
                        this.object.previousAction ? .playing === !0 && this.object.previousAction.pause(), this.object.previousAction = this
                    }
                    play() {
                        if (!1 === Bt(this.shared, this.condition) || this.playing) return !1;
                        clearTimeout(this.timeoutId);
                        let _ = N1(this.data.tweens[0].data).pingPongDelayCorrection;
                        this.timeoutId = window.setTimeout(() => {
                            try {
                                this.buildTimeline(), this.timeline.play()
                            } catch (_) {
                                _ instanceof Error && console.error(_.message)
                            }
                        }, this.startOnceDelay + _)
                    }
                    pause() {
                        this.timeline ? .pause(), clearTimeout(this.timeoutId), this.tweens = Array(this.data.tweens.length - 1), delete this.timeoutId
                    }
                    stop() {
                        this.pause();
                        let _ = void 0 === this.data.tweens[0].data.state ? this.initialCurrentState : this.data.tweens[0].data.state;
                        this.object.changeSelectedState(_, {
                            scene: this.page.scene,
                            shared: this.shared
                        }), this.object.currentState = _
                    }
                    seek(_) {
                        void 0 === this.timeline && this.buildTimeline(), this.timeline ? .seek(_ * this.timeline.duration, !0)
                    }
                    toggle(_) {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.useToggle = !0, clearTimeout(this.timeoutId), this.toggleIsForward = _ ? ? !this.toggleIsForward, this.playing ? (this.timeline ? .pause(), this.buildTimeline({
                            isForward: this.toggleIsForward,
                            needsRebuild: !0
                        }), this.timeline.play()) : this.timeoutId = window.setTimeout(() => {
                            this.timeline ? .pause(), this.buildTimeline({
                                isForward: this.toggleIsForward
                            }), this.timeline.play()
                        }, this.startOnceDelay)
                    }
                    playFromCurrent() {
                        this.toggle(!0)
                    }
                    reverseFromCurrent() {
                        this.toggle(!1)
                    }
                    dispose() {
                        this.pause()
                    }
                };

            function Q0(_, O) {
                let B, N;
                if ("string" == typeof O ? (B = O, N = _.states ? .[B]) : null === O && (B = null, N = _.data), !(void 0 === B || void 0 === N)) return {
                    id: B,
                    data: N
                }
            }
            var Cr = {
                    type: "beginState"
                },
                Cs = {
                    type: "completeState",
                    isfromEntity: !1
                },
                Ca = {
                    type: "requestRender"
                },
                Cn = class extends iq {
                    constructor(_, O, B, N) {
                        super(), this.data = _, this.page = O, this.shared = B, this.condition = N, this.toggleIsForward = !1, this.useToggle = !1, this.posStart = new rv, this.posEnd = new rv, this.qStart = new rm, this.qEnd = new rm, this.zoomStart = 1, this.zoomEnd = 1
                    }
                    init() {}
                    get playing() {
                        return this.animation && this.animation.began && !this.animation.completed
                    }
                    buildAnimation(_ = !1) {
                        if (!this.data.animate) return;
                        let O = this.page.scene.find(this.data.targetCamera);
                        if (!O || !O.visible) throw ReferenceError("Target camera not founded or not visible");
                        let B = {
                            t: 0
                        };
                        this.posStart.copy(this.page.activeCamera.position), this.qStart.copy(this.page.activeCamera.quaternion), this.zoomStart = this.page.activeCamera.zoom, this.animation = zr({
                            targets: B,
                            t: 1,
                            ...B1(this.data),
                            update: () => {
                                0 === B.t && (this.useToggle && !this.toggleIsForward ? (this.posEnd.copy(this.fromCamera.position), this.qEnd.copy(this.fromCamera.quaternion), this.zoomEnd = this.fromCamera.zoom, this.switchCamera(this.fromCamera.uuid)) : (this.posEnd.copy(O.position), this.qEnd.copy(O.quaternion), this.zoomEnd = O.zoom, this.fromCamera = this.page.activeCamera, this.switchCamera(O.uuid)), this.page.activeCamera.dispatchEvent(Cr));
                                let _ = this.page.activeCamera;
                                _.position.lerpVectors(this.posStart, this.posEnd, B.t), _.quaternion.slerpQuaternions(this.qStart, this.qEnd, B.t), _.zoom = this.zoomStart + (this.zoomEnd - this.zoomStart) * B.t, _.wasMovedBySwitchCameraAction = !0, _.updateMatrix(), _.updateMatrixWorld(), _.updateProjectionMatrix(), _.dispatchEvent(Ca), 1 === B.t && _.dispatchEvent(Cs)
                            }
                        })
                    }
                    switchCamera(_) {
                        let O = this.page.scene.find(_);
                        if (!O || !O.visible) throw ReferenceError("Target camera not founded or not visible");
                        this.page.switchActiveCamera(O), this.page.activeCamera.dispatchEvent({
                            type: "cameraChange",
                            camera: O
                        })
                    }
                    play() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        if (!this.playing && this.page.activeCamera.uuid !== this.data.targetCamera) try {
                            clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {
                                delete this.timeoutId, this.data.animate ? (this.buildAnimation(), this.animation ? .play()) : this.switchCamera(this.data.targetCamera)
                            }, 1e3 * this.data.delay)
                        } catch {}
                    }
                    pause() {
                        this.animation ? .pause(), clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                    toggle(_) {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.useToggle = !0, clearTimeout(this.timeoutId), this.toggleIsForward = _ ? ? !this.toggleIsForward;
                        try {
                            this.playing ? (this.animation ? .pause(), this.buildAnimation(!0), this.animation ? .play()) : this.timeoutId = window.setTimeout(() => {
                                delete this.timeoutId, this.data.animate ? (this.animation ? .pause(), this.buildAnimation(), this.animation ? .play()) : (this.toggleIsForward ? (this.fromCamera = this.page.activeCamera, this.switchCamera(this.data.targetCamera)) : this.switchCamera(this.fromCamera.uuid), this.page.activeCamera.dispatchEvent(Cs), this.page.activeCamera.dispatchEvent(Ca))
                            }, 1e3 * this.data.delay)
                        } catch {}
                    }
                    playFromCurrent() {
                        this.toggle(!0)
                    }
                    reverseFromCurrent() {
                        this.toggle(!1)
                    }
                    dispose() {
                        this.pause(), this.toggleIsForward = !1
                    }
                },
                Cl = class extends iq {
                    constructor(_, O, B, N, k) {
                        super(), this.page = O, this.animationControls = B, this.shared = N, this.condition = k, this.startOnceDelay = 0, this.toggleIsForward = !1;
                        let F = _.object,
                            U = O.scene.find(_.object);
                        U && Array.isArray(U.identity) && (F = U.identity[0]), this.data = { ..._,
                            object: F
                        };
                        let j = this.animationControls.clipIdToAction[_.clipId + "/" + F];
                        this.duration = j ? .getClip() ? .duration ? ? 1;
                        let G = j ? .getClip() ? .tracks[0] ? .times.length ? ? 1 / 0;
                        this.leftFrameTime = this.data.crop[0] / G * this.duration, this.rightFrameTime = this.data.crop[1] / G * this.duration, this.startOnceDelay = _.delay
                    }
                    get playing() {
                        return this.threeAnimAction ? .isRunning() ? ? !1
                    }
                    play(_ = !1) {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {
                            if (this.threeAnimAction = this.animationControls.play(this.data), !this.threeAnimAction) return;
                            this.threeAnimAction.reset(), this.threeAnimAction.time = this.leftFrameTime, this.threeAnimAction._clip.start = this.leftFrameTime, this.threeAnimAction._clip.duration = this.rightFrameTime;
                            let O = this.data.object;
                            Object.entries(this.animationControls.clipIdToAction).forEach(([B, N]) => {
                                let k = B.split("/")[1];
                                this.threeAnimAction !== N && k === O && N.isRunning() && (_ ? N.fadeOut(.2) : N.stop())
                            }), _ && this.threeAnimAction ? .fadeIn(.2)
                        }, this.startOnceDelay)
                    }
                    pause() {
                        this.threeAnimAction && (this.threeAnimAction.paused = !0), window.clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                    stop() {
                        this.threeAnimAction ? .fadeOut(.2)
                    }
                    seek(_) {
                        this.threeAnimAction = this.animationControls.play(this.data), this.threeAnimAction && (this.threeAnimAction.paused = !0, this.threeAnimAction.time = iK.clamp(this.threeAnimAction.time + 1 / 60 * _, this.leftFrameTime, this.rightFrameTime - 16e-5), this.animationControls.needsUpdate = !0, this.animationControls.requestRender())
                    }
                    toggle(_, O = !1) {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.toggleIsForward = _ ? ? !this.toggleIsForward, this.threeAnimAction && (this.threeAnimAction._loopCount = 0), this.playing ? this.threeAnimAction && (this.threeAnimAction.timeScale = this.toggleIsForward ? 1 : -1, this.toggleIsForward ? (this.threeAnimAction._clip.start = this.leftFrameTime, this.threeAnimAction._clip.duration = this.rightFrameTime) : (this.threeAnimAction._clip.start = this.rightFrameTime, this.threeAnimAction._clip.duration = this.leftFrameTime)) : this.timeoutId = window.setTimeout(() => {
                            if (this.threeAnimAction = this.animationControls.play(this.data), this.threeAnimAction) {
                                this.toggleIsForward ? (this.threeAnimAction.time = this.leftFrameTime, this.threeAnimAction._clip.start = this.leftFrameTime, this.threeAnimAction._clip.duration = this.rightFrameTime) : (this.threeAnimAction.time = this.rightFrameTime, this.threeAnimAction._clip.start = this.rightFrameTime, this.threeAnimAction._clip.duration = this.leftFrameTime), this.threeAnimAction.paused = !1, this.threeAnimAction.timeScale = this.toggleIsForward ? 1 : -1;
                                let _ = this.data.clipId.split("/")[1];
                                Object.entries(this.animationControls.clipIdToAction).forEach(([B, N]) => {
                                    let k = B.split("/")[1];
                                    this.threeAnimAction !== N && k === _ && N.isRunning() && (O ? N.fadeOut(.2) : N.stop())
                                }), O && this.threeAnimAction ? .fadeIn(.2)
                            }
                        }, this.startOnceDelay)
                    }
                    playFromCurrent() {
                        this.toggle(!0)
                    }
                    reverseFromCurrent() {
                        this.toggle(!1)
                    }
                    dispose() {
                        let _ = this.animationControls.clipIdToAction[this.data.clipId + "/" + this.data.object] ? .getClip();
                        _ && (_.duration = this.duration), this.pause()
                    }
                },
                Cc = class {
                    constructor(_, O, B, N, k) {
                        this.data = _, this.page = O, this.eventManager = B, this.shared = N, this.condition = k, this.timeOutId = -1, this.scene = O.scene
                    }
                    dispatch() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.data.target !== this.page.uuid && (window.clearTimeout(this.timeOutId), this.timeOutId = window.setTimeout(() => {
                            this.play()
                        }, 1e3 * this.data.delay))
                    }
                    dispose() {
                        window.clearTimeout(this.timeOutId)
                    }
                    play() {
                        if (this.scene.children.every(_ => _.uuid !== this.data.target)) return;
                        "fade" === this.data.transition && this.data.duration > 0 && this.eventManager.eventContext.renderer.renderFromSceneForSceneTransitionPass(this.scene, this.scene.activeCamera, 1e3 * this.data.duration), this.eventManager.deactivate(), this.eventManager.controlsManager.deactivate();
                        let _ = this.scene.activeCamera;
                        this.scene.updatePage(this.data.target), this.scene.activePage.switchToPlayCamera(), this.scene.activeCamera.copyViewPlaneSize(_), nf(this.scene.activePage, this.shared), this.eventManager.activate(), this.eventManager.controlsManager.activate(this.eventManager)
                    }
                },
                Cu = class {
                    constructor(_, O, B, N) {
                        this.data = _, this.page = O, this.shared = B, this.condition = N, this.evaluatedCondition = !1
                    }
                    checkConditions() {
                        this.evaluatedCondition = Bt(this.shared, this.condition)
                    }
                    dispatch() {
                        if (!1 === this.evaluatedCondition) return !1;
                        let _ = this.shared.getVariable(this.data.variableId),
                            O = Ov(this.data.expression, this.shared, gL.typeOfVariable(_));
                        void 0 !== O && this.shared.updateVariable(this.data.variableId, "string" == typeof O ? {
                            textValue: O
                        } : O)
                    }
                    dispose() {}
                },
                Cm = class {
                    constructor(_, O, B, N) {
                        this.data = _, this.page = O, this.shared = B, this.condition = N, this.timeoutId = null
                    }
                    dispatchInner() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        let _ = this.shared.getDynamicVariablePlayState(this.data.variableId);
                        if ("PlayPause" === this.data.mode) void 0 === this.shared.getDynamicVariableToggleIsForward(this.data.variableId) && this.shared.setDynamicVariableToggleIsForward(this.data.variableId, !0), this.shared.setDynamicVariablePlayState(this.data.variableId, "Playing" === _ ? "Paused" : "Playing");
                        else if ("Play" === this.data.mode && "Playing" !== _) void 0 === this.shared.getDynamicVariableToggleIsForward(this.data.variableId) && this.shared.setDynamicVariableToggleIsForward(this.data.variableId, !0), this.shared.setDynamicVariablePlayState(this.data.variableId, "Playing");
                        else if ("Stop" === this.data.mode && "Stopped" !== _) this.shared.setDynamicVariablePlayState(this.data.variableId, "Stopped");
                        else if ("Pause" === this.data.mode && "Paused" !== _) this.shared.setDynamicVariablePlayState(this.data.variableId, "Paused");
                        else if ("Restart" === this.data.mode) this.shared.setDynamicVariablePlayState(this.data.variableId, "Restarted");
                        else if ("Toggle" === this.data.mode) {
                            let O = this.shared.getDynamicVariableToggleIsForward(this.data.variableId);
                            "Playing" === _ ? this.shared.setDynamicVariableToggleIsForward(this.data.variableId, void 0 !== O && !O) : (this.shared.setDynamicVariableToggleIsForward(this.data.variableId, !O), this.shared.setDynamicVariablePlayState(this.data.variableId, "Playing"))
                        }
                    }
                    dispatch() {
                        let _ = this.data.delay,
                            O = this.shared.getDynamicVariablePlayState(this.data.variableId);
                        "PlayPause" === this.data.mode && "Playing" === O && (_ = this.data.pauseDelay), 0 !== _ ? (this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {
                            this.timeoutId = null, this.dispatchInner()
                        }, _)) : this.dispatchInner()
                    }
                    dispose() {
                        this.timeoutId && window.clearTimeout(this.timeoutId)
                    }
                };

            function Bt(_, O) {
                if (void 0 === O) return !0;
                if (0 === O.expression.length) return !1;
                let B = Ov(O.expression, _, "boolean");
                return O.negate ? !B : !!B
            }

            function nr(_, O, B, N, k, F) {
                let U = {
                        Audio: [],
                        Video: [],
                        Link: [],
                        Destroy: [],
                        Create: [],
                        Reset: [],
                        Transition: [],
                        SwitchCamera: [],
                        Animation: [],
                        SceneTransition: [],
                        SetVariable: [],
                        DynamicVariablePlay: []
                    },
                    a = O => ({
                        id: j,
                        data: G
                    }) => {
                        try {
                            "Audio" === G.type ? pW[_.type].includes("Audio") && U.Audio.push(new Ez(j, G, F, N, O)) : "Video" === G.type ? pW[_.type].includes("Video") && U.Video.push(new Cw(j, G, F, N, O)) : "Link" === G.type ? pW[_.type].includes("Link") && U.Link.push(new EN(G, k.controlsManager, N, O)) : "Create" === G.type ? pW[_.type].includes("Create") && U.Create.push(new CT(G, B, k.controlsManager, N, O)) : "Destroy" === G.type ? pW[_.type].includes("Destroy") && U.Destroy.push(new Ek(G, B, k.controlsManager, N, O)) : "Reset" === G.type ? pW[_.type].includes("Reset") && U.Reset.push(new EF(G, B, N, k, O)) : "Transition" === G.type ? pW[_.type].includes("Transition") && U.Transition.push(new Ci(G, B, N, O)) : "SwitchCamera" === G.type ? pW[_.type].includes("SwitchCamera") && U.SwitchCamera.push(new Cn(G, B, N, O)) : "SceneTransition" === G.type ? pW[_.type].includes("SceneTransition") && U.SceneTransition.push(new Cc(G, B, k, N, O)) : "Animation" === G.type ? pW[_.type].includes("Animation") && U.Animation.push(new Cl(G, B, k.animationControls, N, O)) : "SetVariable" === G.type ? pW[_.type].includes("SetVariable") && U.SetVariable.push(new Cu(G, B, N, O)) : "DynamicVariablePlay" === G.type ? pW[_.type].includes("DynamicVariablePlay") && U.DynamicVariablePlay.push(new Cm(G, B, N, O)) : "Conditional" === G.type && pW[_.type].includes("Conditional") && (G.ifActions.forEach(a({
                                expression: G.condition,
                                negate: !1
                            })), G.elseActions.forEach(a({
                                expression: G.condition,
                                negate: !0
                            })))
                        } catch (_) {}
                    };
                return O.forEach(a()), U
            }

            function qt(_) {
                Object.values(_).forEach(_ => {
                    _.forEach(_ => {
                        (_ instanceof Ez || _ instanceof Cw || _ instanceof Cl || _ instanceof Ci || _ instanceof CT || _ instanceof Ek || _ instanceof Cn || _ instanceof Cc || _ instanceof EF || _ instanceof Cu || _ instanceof Cm) && _.dispose()
                    })
                })
            }
            var Cg = new Map,
                Cv = new Map,
                Cx = class {
                    constructor(_, O, B) {
                        this.data = O, this.delay = 0, this.status = "stopped";
                        let {
                            layerId: N,
                            loop: k,
                            volume: F,
                            delay: U
                        } = O;
                        if (this.object = B, void 0 === N) throw Error("Missing property");
                        let j = function(_, O) {
                            let B;
                            if ("material" in _ && (B = Array.isArray(_.material) ? _.material[0].layers.find(_ => _.uuid === O) : _.material.layers.find(_ => _.uuid === O)), B) return B.color.texture.image.img instanceof HTMLVideoElement ? B.color.texture.image.img : void 0
                        }(B, N);
                        j && (this.videoElement = j, this.videoElement.loop = k === 1 / 0, dU && (this.videoElement.autoplay = !0), void 0 !== F && (this.videoElement.volume = F)), void 0 !== U && (this.delay = U), Cv.has(B.uuid) ? Cv.get(B.uuid).push(this) : Cv.set(B.uuid, [this]), Cg.set(_, this), this.pause()
                    }
                    mute() {
                        this.videoElement && (this.videoElement.muted = !0)
                    }
                    unMute() {
                        this.videoElement && (this.videoElement.muted = !1)
                    }
                    play(_) {
                        if (!this.videoElement) return;
                        let O = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        _ ? (this.mute(), this.delay += 150) : O ? (this.mute(), window.setTimeout(() => {
                            this.unMute()
                        }, 100)) : this.unMute(), this.delayTimerId = window.setTimeout(() => {
                            if (!this.videoElement) return;
                            let _ = this.videoElement.play();
                            void 0 !== _ && _.then(_ => {}).catch(_ => {
                                this.play()
                            }), this.clearDelay()
                        }, this.delay), this.status = "playing"
                    }
                    clearDelay() {
                        this.delayTimerId && (clearTimeout(this.delayTimerId), delete this.delayTimerId)
                    }
                    pause() {
                        this.videoElement && (this.videoElement.pause(), this.status = "paused")
                    }
                    stop() {
                        this.videoElement && (this.videoElement.pause(), this.videoElement.currentTime = 0, this.status = "stopped", this.clearDelay())
                    }
                    playByToggle() {
                        "stop" === this.data.toggle ? "playing" === this.status ? this.stop() : (this.stop(), this.play()) : "pause" === this.data.toggle ? "playing" === this.status ? this.pause() : this.play() : (this.stop(), this.play())
                    }
                    dispose() {
                        this.videoElement && (this.stop(), this.videoElement.muted = !0)
                    }
                },
                Cb = class {
                    constructor(_) {
                        this.data = _
                    }
                    dispatch() {
                        this.data.playVideo ? this.pauseVideo(this.data.playVideo) : this.data.object ? this.pauseAllVideosFromObject(this.data.object) : this.pauseAllVideos()
                    }
                    pauseVideo(_) {
                        let O = Cg.get(_);
                        O && (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => {
                            O[this.data.interaction](), this.disposeDelay()
                        }, this.data.delay)) : O[this.data.interaction]())
                    }
                    pauseAllVideosFromObject(_) {
                        let O = Cv.get(_);
                        O ? .length && (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => {
                            O.forEach(_ => _[this.data.interaction]()), this.disposeDelay()
                        }, this.data.delay)) : O.forEach(_ => _[this.data.interaction]()))
                    }
                    pauseAllVideos() {
                        let _ = [...Cv.values()];
                        _.length && (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => {
                            _.forEach(_ => {
                                _.forEach(_ => {
                                    _[this.data.interaction]()
                                })
                            }), this.disposeDelay()
                        }, this.data.delay)) : _.forEach(_ => {
                            _.forEach(_ => {
                                _[this.data.interaction]()
                            })
                        }))
                    }
                    disposeDelay() {
                        clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                    dispose() {
                        clearTimeout(this.timeoutId), delete this.timeoutId
                    }
                },
                Cw = class {
                    constructor(_, O, B, N, k) {
                        if (this.data = O, this.shared = N, this.condition = k, "play" === O.interaction) this.interaction = new Cx(_, O, B);
                        else if ("pause" === O.interaction || "stop" === O.interaction) this.interaction = new Cb(O);
                        else throw Error("Missing property")
                    }
                    dispatchBasic() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.interaction instanceof Cx ? this.interaction.playByToggle() : this.interaction.dispatch()
                    }
                    dispatchConditional() {
                        if (!1 === Bt(this.shared, this.condition)) return !1;
                        this.interaction instanceof Cx ? this.interaction.play() : this.interaction.dispatch()
                    }
                    dispose() {
                        this.interaction.dispose()
                    }
                },
                C_ = (() => {
                    let _, O, B, N;

                    function n(B) {
                        !_ && !RL() && O ? .sharedGameControlGlobals.createdObjects.length > 0 && (_ = requestAnimationFrame(s)), B && (O = B, N = B.requestRender)
                    }

                    function s(k) {
                        let F = B ? k - B : 0,
                            U = O.sharedGameControlGlobals.createdObjects,
                            j = O.sharedGameControlGlobals.nCreatedPerAction,
                            G = U.length,
                            Y = 0;
                        for (; Y < G;) {
                            let _ = U[Y];
                            void 0 === _.userData.createdTime && (_.userData.createdTime = k), void 0 === _.userData.lifetime && void 0 === _.userData.quantity || _.userData.lifetime && k - _.userData.createdTime < _.userData.lifetime || _.userData.quantity && j[_.userData.actionId] <= _.userData.quantity ? (_.userData.velocity && (_.position.addScaledVector(_.userData.velocity, F / 1e3), _.updateMatrix(), N()), Y++) : (j[_.userData.actionId] > _.userData.quantity && j[_.userData.actionId]--, U.splice(Y, 1), _.removeFromParent(), O.sharedGameControlGlobals.rapierWorld && _.rigidBody ? (O.sharedGameControlGlobals.colliderToEntity.delete(_.rigidBody.collider(0).handle), O.sharedGameControlGlobals.rapierWorld.removeRigidBody(_.rigidBody)) : (_.bvhGeometry = void 0, O.sharedGameControlGlobals.entitiesWithTransformAnim = O.sharedGameControlGlobals.entitiesWithTransformAnim.filter(_ => void 0 !== _.bvhGeometry)), G--, N())
                        }
                        _ = Y > 0 ? requestAnimationFrame(s) : void 0, B = Y > 0 ? k : void 0
                    }
                    return "u" > typeof document && document.addEventListener("visibilitychange", function() {
                        RL() ? _ && (cancelAnimationFrame(_), _ = void 0, B = void 0) : n()
                    }), n
                })();

            function RL() {
                return !!document && document.hidden
            }
            var CS = new rm,
                CE = new rv,
                CC = new rv,
                CT = class {
                    constructor(_, O, B, N, k) {
                        this.data = _, this.page = O, this.controlsManager = B, this.shared = N, this.condition = k, this.intervalId = null, this.timeoutIdQueue = [], this.uniqueId = iK.generateUUID(), this.dispatch = () => {
                            if (!1 === Bt(this.shared, this.condition)) return !1;
                            this.data.delay ? this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, 1e3 * this.data.delay)) : this.dispatchInner()
                        }, this.dispatchFromStart = () => {
                            if (!1 === Bt(this.shared, this.condition)) return !1;
                            this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, 1e3 * this.data.delay))
                        }, this.dispatchThrottled = ww(this.dispatch, 1e3 / this.data.creationSpeed), this.dispatchStart = () => {
                            null === this.intervalId && (this.intervalId = window.setInterval(this.dispatch, 1e3 / this.data.creationSpeed))
                        }, this.dispatchStop = () => {
                            null !== this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null)
                        }, this.dispatchInner = () => {
                            this.timeoutIdQueue.shift();
                            let _ = new vb(this.object);
                            if (_.playModeVisible = !0, _.expand(), "world" !== this.data.coordinateSystem) {
                                let O = this.data.coordinateSystem,
                                    B = this.page.scene.find(O);
                                B && (B.updateMatrixWorldSVD(), _.hiddenMatrix.copy(B.matrixWorldRigid))
                            }
                            _.position.fromArray(this.data.position), _.rotation.fromArray(this.data.rotation), _.updateMatrix(), this.page.add(_);
                            let O = this.controlsManager.sharedGameControlGlobals;
                            O.createdObjects.push(_), void 0 === O.nCreatedPerAction[this.uniqueId] ? O.nCreatedPerAction[this.uniqueId] = 1 : O.nCreatedPerAction[this.uniqueId]++, _.updateWorldMatrix(!0, !0), _.traverseObject(this.traverseObjectCB), C_(), this.controlsManager.requestRender()
                        }, this.traverseObjectCB = _ => {
                            let O;
                            if (_.hasNonUniformScale && _.updateMatrixWorldSVD(), this.controlsManager.sharedGameControlGlobals.rapierWorld) {
                                if (_ instanceof _3) {
                                    if (!_.objectForSample) return !0 === _.object.dataPatched.physics.fusedBody && "dynamic" === _.object.dataPatched.physics.rigidBody || void 0;
                                    if (_.objectForSample.dataPatched.physics.fusedBody) return;
                                    O = _.object
                                } else if (_ instanceof vb) O = _.object;
                                else if (O = _, O.dataPatched.cloner ? .hideBase) return !0
                            } else {
                                if (_ instanceof _3) return;
                                O = _ instanceof vb ? _.object : _
                            }
                            "Time" === this.data.destroy ? _.userData.lifetime = 1e3 * this.data.lifetime : "Quantity" === this.data.destroy && (_.userData.quantity = this.data.destroyAfterQuantity, _.userData.actionId = this.uniqueId);
                            let B = new rv().fromArray(this.data.velocity),
                                N = O.dataPatched;
                            if (!("visibility" === N.physics.enabled ? !N.visible : !N.physics.enabled) && (this.controlsManager.sharedGameControlGlobals.rapierWorld ? (this.controlsManager.addRigidBody(_, O, {
                                    fromCreate: !0,
                                    dynamic: this.data.dynamic
                                }), "Collision" === this.data.destroy && (_.rigidBody ? .collider(0).setActiveEvents(1), _.userData.hasCollisionDestroy = !0), _.matrixWorld.decompose(CE, CS, CC), B.applyQuaternion(CS), this.data.velocity.some(_ => 0 !== _) && this.data.dynamic && _.rigidBody ? .setLinvel(B.divideScalar(this.controlsManager.pixelsPerMeter), !0)) : ("geometry" in _.object && this.controlsManager.addBoundsTree(_), this.data.velocity.some(_ => 0 !== _) && this.data.dynamic && (_.userData.velocity = B)), O.dataPatched.physics ? .fusedBody === !0)) return !0
                        };
                        let F = this.page.scene.find(this.data.object);
                        if (!F || (this.object = F, "world" !== this.data.coordinateSystem && !this.page.scene.find(this.data.coordinateSystem))) throw Error("Missing Property");
                        C_(B)
                    }
                    dispose() {
                        null !== this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null), this.timeoutIdQueue.forEach(_ => window.clearTimeout(_)), this.dispatchThrottled.cancel(), this.page.remove(...this.controlsManager.sharedGameControlGlobals.createdObjects), this.controlsManager.sharedGameControlGlobals.createdObjects = []
                    }
                };
            new rv;
            var CD = new rv,
                CP = new rv,
                CI = new rv,
                CO = new rv,
                CL = new rv,
                CR = new rv,
                CB = new rJ,
                Cz = new rJ,
                CN = new rJ,
                Ck = (new rJ, new rm),
                CF = new rm,
                CU = new r9(0, 0, 0, "YXZ"),
                Cj = new rv(1, 0, 0),
                CG = new rv(0, 1, 0),
                CH = new rv(0, 0, 1),
                CW = new rv(1, 1, 1),
                Cq = (new rG, new lP),
                CY = new rb,
                CX = {
                    type: "requestRender"
                },
                CQ = {
                    type: "updateMatrix"
                },
                CZ = Math.PI / 6,
                CK = class extends iq {
                    constructor(_, O, B, N, k, F, U, j, G) {
                        super(), this.object = _, this.domElement = O, this.data = B, this.gloabalPhysics = N, this.controlsManager = k, this.cameraFollow = F, this.camera = U, this.page = j, this.sharedAssets = G, this.enableDamping = !0, this.hiddenMatrix0 = new rJ, this.target0 = new rv, this.zoom0 = 1, this.rotForce = 1, this.moveForce = 1, this.pixelsPerMeter = 200, this.euler0 = new r9(0, 0, 0, "YXZ"), this.position0Cam = new rv, this.quat0Cam = new rm, this.scale0Cam = new rv, this.hiddenMatrix0Cam = new rJ, this.threshEndTranslate = .01, this.threshEndRotate = 1e-8, this.threshEndRotVel = .005, this.collider = {
                            type: "capsule",
                            radius: 40,
                            segment: new lP(new rv(0, -40, 0), new rv(0, 40, 0)),
                            matrix: new rJ,
                            position: new rv,
                            rotation: new rm
                        }, this.euler = new r9(0, 0, 0, "YXZ"), this.eulerDelta = new rv, this.lastPosition = new rv, this.lastCameraQuaternion = new rm, this.lastCameraPosition = new rv, this.PI_2 = Math.PI / 2, this.prevMouse = new iJ, this.velocityTarget = new rv, this.velocity = new rv, this.directionXZ = new rv, this.rotVelocityStick = new rv, this.rotVelocityTarget = new rv, this.rotVelocity = new rv, this.rotDirection = new rv, this.nonColliderRotOffset = new rJ, this.nonColliderPosOffset = new rJ, this.firstPointerId = -1, this.rot = new rv, this.path = [], this.movementState = {
                            moveNegZ: 0,
                            movePosZ: 0,
                            moveNegX: 0,
                            movePosX: 0,
                            moveNegY: 0,
                            movePosY: 0,
                            rotPosX: 0,
                            rotNegX: 0,
                            rotPosY: 0,
                            rotNegY: 0,
                            jump: 0,
                            run: 0
                        }, this.vrEulerYOffset = 0, this.onObject = !1, this.actionState = {}, this.keyAssignments = [
                            ["moveNegZ", "W"],
                            ["moveNegX", "A"],
                            ["movePosZ", "S"],
                            ["movePosX", "D"],
                            ["rotPosX", "ArrowUp"],
                            ["rotPosY", "ArrowLeft"],
                            ["rotNegX", "ArrowDown"],
                            ["rotNegY", "ArrowRight"],
                            ["jump", " "]
                        ], this.collisionEnabled = !0, this.offsetMatrix = new rJ, this.objectToTarget = new rv, this.objectToTarget0 = new rv, this.objectToCamXZ = new rv, this.objectToCamXZ0 = new rv, this.targetToCamera = new rv, this.targetToCamera0 = new rv, this.cameraPolarAxis0 = new rv, this.targetPos = new rv, this.targetQuat = new rm, this.lerpFactorPos = new rv().setScalar(.3), this.lerpFactorPosStart = .3, this.lerpFactorPosEnd = .3, this.lerpFactorRotStart = .3, this.lerpFactorRotEnd = .3, this.lerpFactorPosCamera = .3, this.lerpFactorRotCamera = .3, this.objXZQuat = new rm, this.objXZQuatInv = new rm, this.objXZRotMat = new rJ, this.isFirstPerson = !1, this.didHit = !1, this.groundVelocity = new rv, this.pushedVelocity = new rv, this.groundYRotation = 0, this.objectRealQuat = new rm, this.colliderWorldQuat = new rm, this.groundNormal = new rv, this.groundTilt = new rm, this.groundTiltInv = new rm, this.lastHitObj = null, this.isFirstFrame = !0, this.rotationAccumWhenOrientWithCamera = 0, this.navMeshPathDest = null, this.position = new rv, this.quaternion = new rm, this.scale = new rv, this.initialAction = !0, this.onPointerDown = _ => {
                            _.target !== this.domElement || -1 !== this.firstPointerId || (this.firstPointerId = _.pointerId, this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp), "keys" === this.rotBy || dG || dH && !(dW >= 15.5) || this.domElement.requestPointerLock(), this.prevMouse.set(_.clientX, _.clientY))
                        }, this.onPointerUp = _ => {
                            this.firstPointerId = -1, this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this.onPointerUp), "mouse" === _.pointerType && this.domElement.ownerDocument.exitPointerLock()
                        }, this.onPointerMove = _ => {
                            if (_.pointerId !== this.firstPointerId) return;
                            let O = _.clientX - this.prevMouse.x,
                                B = _.clientY - this.prevMouse.y;
                            this.prevMouse.set(_.clientX, _.clientY), "mouse" === _.pointerType && "keys" !== this.rotBy && (dH && dW < 15.5 && !dG ? (this.eulerDelta.y = -O * this.mouseOrbitSensitivity, this.eulerDelta.x = -B * this.mouseOrbitSensitivity) : (this.eulerDelta.y = -_.movementX * this.mouseOrbitSensitivity, this.eulerDelta.x = -_.movementY * this.mouseOrbitSensitivity)), "mouse" !== _.pointerType && "drag" === this.rotByTouch && (this.eulerDelta.y = -O * this.mouseOrbitSensitivity * 5, this.eulerDelta.x = -B * this.mouseOrbitSensitivity * 5), this.controlsManager.requestRender()
                        }, this.onPointerlockChange = _ => {
                            this.domElement.ownerDocument.pointerLockElement === this.domElement ? CK.isLocked = !0 : CK.isLocked = !1
                        }, this.onPointerlockError = () => {
                            console.error("SPE.GameControls: Unable to use Pointer Lock API")
                        }, this.handleVisibilityChange = () => {
                            if (document ? .hidden)
                                for (let _ in this.movementState) this.movementState[_] = 0
                        }, this.onKeyDown = _ => {
                            for (let O of (_.target instanceof HTMLInputElement || "ArrowLeft" !== _.code && "ArrowUp" !== _.code && "ArrowRight" !== _.code && "ArrowDown" !== _.code && "Space" !== _.code || _.preventDefault(), this.keyAssignments))
                                if (_.key.toUpperCase() === O[1] || _.key === O[1]) {
                                    this.movementState[O[0]] = 1;
                                    break
                                }
                            this.controlsManager.requestRender()
                        }, this.onKeyUp = _ => {
                            for (let O of this.keyAssignments)
                                if (_.key.toUpperCase() === O[1] || _.key === O[1] || _.code.slice(3, _.code.length).toUpperCase() === O[1]) {
                                    this.movementState[O[0]] = 0;
                                    break
                                }
                        }, this.copyVRGamePadValues = (_, O) => {
                            for (let B = 2; B < 4; B++) {
                                let N = _.axes[B];
                                0 === O ? 2 === B ? this.movementState.movePosX = N : this.movementState.movePosZ = N : (_.buttons[3].pressed ? this.movementState.jump = 1 : this.movementState.jump = 0, 2 === B ? (.3 > Math.abs(this.movementState.rotPosY) && Math.abs(N) >= .3 && (this.vrEulerYOffset += N < 0 ? 1 : -1), this.movementState.rotPosY = N) : "fly" === this.moveMode && (this.movementState.moveNegY = N))
                            }
                        }, this.sharedGameControlGlobals = k.sharedGameControlGlobals, _ === U && (this.isFirstPerson = !0), this.hiddenMatrix0.copy(this.object.hiddenMatrix), this.object.parent ? this.object.hiddenMatrix.copy(this.object.parent.matrixWorld).invert() : this.object.hiddenMatrix.identity(), this.object.matrix.copy(this.object.matrixWorld), this.object.matrix.decompose(this.position, this.quaternion, this.scale), this.euler0.setFromQuaternion(this.quaternion, "YXZ");
                        let Y = this.euler0.clone(),
                            Q = Y.y;
                        if (this.objectRealQuat.copy(this.quaternion), Y.y = 0, this.quaternion.setFromEuler(Y), this.objXZQuat.copy(this.quaternion), this.objXZQuatInv.copy(this.objXZQuat).invert(), this.objXZRotMat.makeRotationFromQuaternion(this.quaternion), Y.set(0, Q, 0), this.quaternion.setFromEuler(Y), this.rot.setFromEuler(Y), this.object.matrixAutoUpdate = !1, (this.isFirstPerson || !0 === this.cameraFollow) && (this.target0.copy(this.camera.getTarget()), this.zoom0 = this.camera.zoom), !0 === this.cameraFollow) {
                            let _, O;
                            this.position0Cam.copy(this.camera.position), this.quat0Cam.copy(this.camera.quaternion), this.scale0Cam.copy(this.camera.scale), this.hiddenMatrix0Cam.copy(this.camera.hiddenMatrix), this.camera.parent ? (this.camera.hiddenMatrix.copy(this.camera ? .parent.matrixWorld), this.camera.matrix.copy(this.camera.matrixWorld)) : this.camera.hiddenMatrix.identity(), this.camera.matrix.copy(this.camera.matrixWorld), this.camera.matrix.decompose(this.camera.position, this.camera.quaternion, this.camera.scale), this.camera.matrixAutoUpdate = !1, this.offsetMatrix.copy(this.object.matrix).invert().multiply(this.camera.matrix);
                            let B = new rv(0, 0, -1).applyQuaternion(this.camera.quaternion),
                                N = new rv().subVectors(this.position, this.camera.position);
                            this.objectToCamXZ.copy(N), this.objectToCamXZ.y = 0, this.objectToCamXZ0.copy(this.objectToCamXZ), 1e-6 > Math.abs(B.y) ? (N.y = 0, B.y = 0, O = N.projectOnVector(B)) : O = N.y / B.y > 0 ? B.multiplyScalar(N.y / B.y) : B.multiplyScalar(N.length()), this.targetToCamera0.copy(O).negate(), _ = this.camera.position.clone().add(O), this.objectToTarget0.subVectors(_, this.position);
                            let k = new r9().setFromQuaternion(this.camera.quaternion, "YXZ");
                            this.cameraPolarOffset = -k.x, k.x = 0, k.z = 0, k.y -= Math.PI / 2, this.cameraPolarAxis0.set(0, 0, -1).applyEuler(k)
                        }
                        if (this.object instanceof Sh && (this.object.matrixAutoUpdate = !1), this.euler.setFromQuaternion(this.quaternion, "YXZ"), this.rotByTouch = B.rotByTouch ? ? "joystick", this.rotBy = B.rotBy ? ? "keys", this.rotationMode = B.rotationMode ? ? "normal", this.moveMode = B.moveMode ? ? "walk", this.collisionEnabled = B.collisionEnabled, this.speedTranslate = (B.speedTranslate ? ? 250) * 1, this.speedOrbit = (B.speedRotate ? ? 100) * .025, this.mouseOrbitSensitivity = (B.speedRotate ? ? 100) * 16e-6, this.keyAssignments = B.keyAssignments.map(_ => {
                                let O = [_[0], _[1]];
                                return "▲" === O[1] ? O[1] = "ArrowUp" : "◀" === O[1] ? O[1] = "ArrowLeft" : "▼" === O[1] ? O[1] = "ArrowDown" : "▶" === O[1] ? O[1] = "ArrowRight" : "⇧" === O[1] ? O[1] = "Shift" : "↵" === O[1] ? O[1] = "Enter" : "Space" === O[1] ? O[1] = " " : "⌘" === O[1] ? O[1] = "Meta" : "Ctrl" === O[1] ? O[1] = "Control" : "Esc" === O[1] && (O[1] = "Escape"), O
                            }), "mouse" === B.rotBy) {
                            let _; - 1 !== (_ = this.keyAssignments.findIndex(_ => "rotNegX" === _[0])) && (this.keyAssignments[_][1] = ""), -1 !== (_ = this.keyAssignments.findIndex(_ => "rotPosX" === _[0])) && (this.keyAssignments[_][1] = ""), -1 !== (_ = this.keyAssignments.findIndex(_ => "rotPosY" === _[0])) && (this.keyAssignments[_][1] = ""), -1 !== (_ = this.keyAssignments.findIndex(_ => "rotNegY" === _[0])) && (this.keyAssignments[_][1] = "")
                        }
                        this.lerpFactorPosStart = 1 - .02 ** (1 / ((B.delayPos[0] ? ? .3) * 60)), this.lerpFactorPosEnd = 1 - .02 ** (1 / ((B.delayPos[1] ? ? .3) * 60)), this.lerpFactorPos.setScalar(this.lerpFactorPosStart), this.lerpFactorRotStart = 1 - .02 ** (1 / ((B.delayRot[0] ? ? .3) * 60)), this.lerpFactorRotEnd = 1 - .02 ** (1 / ((B.delayRot[1] ? ? .3) * 60)), this.lerpFactorPosCamera = 1 - .02 ** (1 / ((B.delayPosCamera ? ? .3) * 60)), this.lerpFactorRotCamera = 1 - .02 ** (1 / ((B.delayRotCamera ? ? .3) * 60)), this.gravity = (this.gloabalPhysics.gravity ? ? gr.defaultData.gravity) * 12, this.usePhysics = this.gloabalPhysics.usePhysics ? ? gr.defaultData.usePhysics, this.jumpPower = 20 * B.jumpPower, this.resetYPosition = this.position.y + Math.abs(B.resetYPosition) * (this.gravity > 0 ? 1 : -1), this.alignToGround = B.alignToGround ? ? !1, this.orientMode = B.autoOrientMove ? B.orientMode : "none", this.orientWith = B.orientWith ? ? gU.defaultDataThirdPerson.orientWith, this.slopeThresh = 65 * Math.PI / 180, "capsule" === B.collider.type ? (this.collider.radius = B.collider.radius, this.collider.segment.start.y = B.collider.height / 2 - B.collider.radius, this.collider.segment.end.y = -this.collider.segment.start.y, this.offset = .02 * B.collider.height / this.pixelsPerMeter, this.stepThresh = .3 * B.collider.height / this.pixelsPerMeter, this.colliderHeight = B.collider.height) : "sphere" === B.collider.type ? (this.collider.radius = B.collider.radius, this.collider.segment.start.y = 0, this.collider.segment.end.y = 0, this.offset = 2 * B.collider.radius * .02 / this.pixelsPerMeter, this.stepThresh = 2 * B.collider.radius * .3 / this.pixelsPerMeter, this.colliderHeight = 2 * B.collider.radius) : (this.offset = .02 * B.collider.height / this.pixelsPerMeter, this.stepThresh = .3 * B.collider.height / this.pixelsPerMeter, this.colliderHeight = B.collider.height), this.collider.type = B.collider.type;
                        let K = new rv().fromArray(B.collider.position),
                            $ = new rm().setFromEuler(new r9().fromArray([...B.collider.rotation, "XYZ"]));
                        this.collider.position.copy(K).multiply(this.scale), this.collider.rotation.copy($), this.collider.matrix.compose(K, $, CW), void 0 !== B.cameraXAxis && (this.cameraXAxis = B.cameraXAxis, this.cameraYAxis = B.cameraYAxis, this.minPolarAngle = B.cameraRotXLimits[0], this.maxPolarAngle = B.cameraRotXLimits[1], this.minAzimuthAngleRel = B.cameraRotYLimits[0], this.maxAzimuthAngleRel = B.cameraRotYLimits[1]), this.forwardDir = B.forwardDirection ? ? "-z", this.runMultiplier = B.runMultiplier ? ? 2;
                        let ee = 2 * B.navmesh.destinationHelperRadius;
                        if (ee > 0) {
                            let _ = new ur;
                            _.push({
                                fi: 0,
                                data: { ...f9.defaultData("light", "phong"),
                                    alpha: 0
                                },
                                id: "layer1"
                            }), _.push({
                                fi: 0,
                                data: { ...f9.defaultData("color"),
                                    color: B.navmesh.destinationHelperColor,
                                    alpha: B.navmesh.destinationHelperColor.a
                                },
                                id: "layer2"
                            });
                            let O = new wK({
                                layers: _
                            }, {
                                scene: this.page.scene,
                                shared: this.sharedAssets
                            });
                            this.navMeshPathDest = new at(vk.create({
                                parameters: {
                                    width: ee,
                                    height: ee / 10,
                                    hollow: .7
                                }
                            }), O), this.navMeshPathDest.material.userData.opacity0 = B.navmesh.destinationHelperColor.a
                        }
                        this.activate()
                    }
                    reset(_ = !1) {
                        if (this.object.hiddenMatrix.copy(this.hiddenMatrix0), _) {
                            this.object.updateMatrix(), this.object.updateMatrixWorld(), this.object.matrix.copy(this.object.matrixWorld), this.object.matrix.decompose(this.position, this.quaternion, this.scale), this.object.parent ? this.object.hiddenMatrix.copy(this.object.parent.matrixWorld).invert() : this.object.hiddenMatrix.identity();
                            let _ = new r9().setFromQuaternion(this.quaternion, "YXZ"),
                                O = _.y;
                            this.objectRealQuat.copy(this.quaternion), _.y = 0, this.quaternion.setFromEuler(_), this.objXZQuat.copy(this.quaternion), this.objXZQuatInv.copy(this.objXZQuat).invert(), this.objXZRotMat.makeRotationFromQuaternion(this.quaternion), _.set(0, O, 0), this.quaternion.setFromEuler(_), this.rot.setFromEuler(_), this.euler.setFromQuaternion(this.quaternion, "YXZ"), this.velocityTarget.set(0, 0, 0), this.velocity.set(0, 0, 0)
                        } else this.object instanceof Sh ? this.object.matrixAutoUpdate = !0 : this.object.updateMatrix();
                        !0 === this.cameraFollow && (this.camera.quaternion.copy(this.quat0Cam), this.camera.position.copy(this.position0Cam), this.camera.scale.copy(this.scale0Cam), this.camera.hiddenMatrix.copy(this.hiddenMatrix0Cam), this.camera.matrixAutoUpdate = !0), this.controlsManager.requestRender()
                    }
                    activate() {
                        this.instantiateActions(), this.domElement.ownerDocument.addEventListener("pointerdown", this.onPointerDown), this.domElement.ownerDocument.addEventListener("keydown", this.onKeyDown), this.domElement.ownerDocument.addEventListener("keyup", this.onKeyUp), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError), this.domElement.ownerDocument.addEventListener("visibilitychange", this.handleVisibilityChange)
                    }
                    deactivate() {
                        this.disposeActions(), this.domElement.ownerDocument.removeEventListener("pointerdown", this.onPointerDown), this.domElement.ownerDocument.removeEventListener("keydown", this.onKeyDown), this.domElement.ownerDocument.removeEventListener("keyup", this.onKeyUp), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError), this.domElement.ownerDocument.removeEventListener("visibilitychange", this.handleVisibilityChange)
                    }
                    dispose() {
                        this.deactivate(), this.navMeshPathDest ? .parent && this.page.remove(this.navMeshPathDest)
                    }
                    instantiateActions() {
                        let _ = this.data,
                            O = this.sharedAssets;
                        void 0 !== _.gameActions && (this.actions = {}, gF.list.forEach(B => {
                            this.actions[B] = nr({ ..._,
                                disabled: !1,
                                type: "GameControl"
                            }, _.gameActions[B], this.page, O, this.controlsManager.eventManager, this.object)
                        })), this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.dispatchStopEvent("jump"), this.dispatchStartEvent("idle"), this.initialAction && (this.initialAction = !1)
                    }
                    disposeActions() {
                        this.initialAction = !1, this.dispatchStopEvent("idle"), this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.dispatchStopEvent("jump"), qt(this.actions.idle), qt(this.actions.move), qt(this.actions.run), qt(this.actions.jump)
                    }
                    dispatchStartEvent(_) {
                        void 0 !== this.actions[_] && (this.actionState[_] || (this.actionState[_] = !0, this.actions[_].Transition.forEach(_ => {
                            _.play()
                        }), this.actions[_].Animation.forEach(_ => {
                            _.play(!1 === this.initialAction)
                        }), this.actions[_].Create.forEach(_ => {
                            _.dispatchStart()
                        }), this.actions[_].Audio.forEach(_ => {
                            _.dispatchGameControl("start")
                        })))
                    }
                    dispatchStopEvent(_) {
                        void 0 === this.actions[_] || this.actionState[_] && (this.actionState[_] = !1, this.actions[_].Transition.forEach(_ => {
                            _.stop(), null !== _.object.currentState && _.object.changeSelectedState(null, {
                                scene: this.page.scene,
                                shared: this.sharedAssets
                            })
                        }), this.actions[_].Create.forEach(_ => {
                            _.dispatchStop()
                        }), this.actions[_].Audio.forEach(_ => {
                            _.dispatchGameControl("stop")
                        }))
                    }
                    get colliderWorldPosition() {
                        return CO.copy(this.collider.position).applyQuaternion(this.objectRealQuat).add(this.position)
                    }
                    update(_, O, B) {
                        if (this.gravity < 0 ? this.position.y < this.resetYPosition : this.position.y > this.resetYPosition) return this.reset(!0), !0;
                        this.sharedGameControlGlobals.gamePads.forEach(this.copyVRGamePadValues);
                        let N = (this.isFirstFrame ? 16.6 : _) / 1e3;
                        this.isFirstFrame && (this.isFirstFrame = !1);
                        let k = 60 * N,
                            F = !1;
                        if (this.usePhysics && this.collisionEnabled) {
                            let _ = CL.set(0, (0 === this.velocity.y ? this.pixelsPerMeter * Math.max(Math.abs(this.gravity) / 120, 1) * (this.gravity > 0 ? 1 : -1) : this.velocity.y) * N, 0).divideScalar(this.pixelsPerMeter),
                                O = this.sharedGameControlGlobals.rapierWorld.castShape(this.colliderWorldPosition.divideScalar(this.pixelsPerMeter), this.colliderWorldQuat, _, this.object.rigidBody ? .collider(0).shape, 1, !1, 16, void 0, void 0, this.object.rigidBody);
                            if (O) {
                                this.onObject = !0, this.groundNormal.set(O.normal2.x, O.normal2.y, O.normal2.z).applyQuaternion(this.colliderWorldQuat).negate(), this.alignToGround && this.groundTiltAdjustment(this.groundNormal), Math.acos(this.groundNormal.y) < this.slopeThresh && (F = !0), O.collider.parent() ? .bodyType() === 0 && Math.acos(this.groundNormal.y) * (180 / Math.PI) > 45 && (this.onObject = !1);
                                let _ = O.collider.parent();
                                for (let O of (this.groundYRotation = 0, this.groundVelocity.set(0, 0, 0), this.sharedGameControlGlobals.entitiesWithTransformAnim))
                                    if (O.rigidBody === _ && O.userData.isFollowingObj !== this.object.uuid) {
                                        (O.hasNonUniformScale ? O.matrixWorldRigid : O.matrixWorld).decompose(CO, CF, CL), this.groundVelocity.subVectors(CO, O.prevT), this.object.getWorldPosition(CL).add(this.collider.position).sub(CO), this.groundYRotation = CU.setFromQuaternion(CF).y - O.prevR.y, CR.copy(CL).applyAxisAngle(CG, this.groundYRotation), this.groundVelocity.add(CR.sub(CL)).divideScalar(N);
                                        break
                                    }
                            } else this.onObject = !1
                        }
                        if ("walk" === this.moveMode && this.collisionEnabled && (1 === this.movementState.jump && this.onObject && (this.velocityTarget.y = this.jumpPower, this.movementState.jump = 0, this.dispatchStopEvent("idle"), this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.dispatchStopEvent("jump"), this.dispatchStartEvent("jump"), this.onObject = !1), this.onObject ? this.velocityTarget.y /= 2 : this.velocityTarget.y += this.gravity * k), "fly" === this.moveMode && (this.velocityTarget.y = (this.movementState.movePosY - this.movementState.moveNegY) * this.speedTranslate), this.directionXZ.z = this.movementState.movePosZ - this.movementState.moveNegZ, this.directionXZ.x = this.movementState.movePosX - this.movementState.moveNegX, "+z" === this.forwardDir && this.directionXZ.multiplyScalar(-1), this.directionXZ.manhattanLength() > 0 && (this.path = []), this.navMeshPathDest) {
                            let _ = this.navMeshPathDest.material;
                            if ("walk" === this.moveMode && this.path.length > 1) {
                                this.navMeshPathDest.position.copy(this.path[this.path.length - 1]), this.navMeshPathDest.parent || this.page.add(this.navMeshPathDest);
                                let O = CO.subVectors(this.path[1], this.position),
                                    B = CL.subVectors(this.path[1], this.path[0]);
                                0 > O.dot(B) ? this.path.shift() : (this.directionXZ.x = B.x, this.directionXZ.z = B.z), _.opacity = _.userData.opacity0
                            } else _.opacity -= .05 * _.userData.opacity0, this.navMeshPathDest.material.opacity <= 0 && this.navMeshPathDest.parent && this.page.remove(this.navMeshPathDest)
                        }
                        this.directionXZ.normalize(), this.movementState.run ? this.moveForce = this.runMultiplier : this.moveForce = 1, this.velocityTarget.z = this.directionXZ.z * this.speedTranslate * this.moveForce, this.velocityTarget.x = this.directionXZ.x * this.speedTranslate * this.moveForce, ("walk" === this.moveMode ? this.velocityTarget.x + this.velocityTarget.z === 0 : 0 === this.velocityTarget.manhattanLength()) ? this.lerpFactorPos.setScalar(this.lerpFactorPosEnd) : this.lerpFactorPos.setScalar(this.lerpFactorPosStart), "walk" === this.moveMode && (this.lerpFactorPos.y = 1), !1 === this.didHit && 0 === this.pushedVelocity.manhattanLength() || !1 === this.usePhysics ? (this.velocity.x += (this.velocityTarget.x - this.velocity.x) * (1 - (1 - this.lerpFactorPos.x) ** k), this.velocity.y += (this.velocityTarget.y - this.velocity.y) * (1 - (1 - this.lerpFactorPos.y) ** k), this.velocity.z += (this.velocityTarget.z - this.velocity.z) * (1 - (1 - this.lerpFactorPos.z) ** k)) : this.velocity.copy(this.velocityTarget), ("walk" === this.moveMode ? this.velocity.x ** 2 + this.velocity.z ** 2 < this.speedTranslate : this.velocity.lengthSq() < this.speedTranslate) ? (this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.onObject && (this.dispatchStopEvent("jump"), this.dispatchStartEvent("idle"))) : (this.dispatchStopEvent("idle"), this.onObject && (this.dispatchStopEvent("jump"), this.movementState.run ? (this.dispatchStopEvent("move"), this.dispatchStartEvent("run")) : (this.dispatchStopEvent("run"), this.dispatchStartEvent("move"))));
                        let U = CI.copy(this.velocity);
                        if ("none" !== this.orientMode && !1 === this.isFirstPerson) {
                            let _ = CL.copy(U);
                            _.y = 0, U.set(0, U.y, _.length() * ("+z" === this.forwardDir ? 1 : -1))
                        }
                        if (this.directionXZ.manhattanLength() > 0 && "none" !== this.orientMode) {
                            if ("camera" === this.orientWith && this.path.length <= 1) {
                                this.camera.getWorldDirection(CO);
                                let _ = CR.copy(CG).multiplyScalar(CO.dot(CG));
                                CO.sub(_);
                                let O = CL.copy(this.directionXZ);
                                O.x *= -1, this.rot.y = CO.angleTo(O) * (CO.cross(O).y > 0 ? -1 : 1) + this.rotationAccumWhenOrientWithCamera
                            } else this.rot.y = (this.path.length > 1 ? 0 : this.euler.y) + Math.atan2(-this.directionXZ.z, this.directionXZ.x) + Math.PI / 2 * ("+z" === this.forwardDir ? 1 : -1)
                        }
                        if (CU.setFromVector3(this.rot), "walk" === this.moveMode && (CU.x = 0), U.applyEuler(CU), F && (CF.setFromUnitVectors(CG, this.groundNormal), U.applyQuaternion(CF)), B) {
                            let _ = CU.set(0, this.vrEulerYOffset * CZ, 0);
                            B.applyEuler(_), U.x += B.x, U.z += B.z, this.nonColliderPosOffset.elements[13] += B.y * N
                        }
                        if (!0 === this.usePhysics) {
                            for (let _ of (this.pushedVelocity.set(0, 0, 0), this.sharedGameControlGlobals.entitiesWithTransformAnim)) {
                                let O = CR.setFromMatrixPosition(_.matrixWorld).sub(_.prevT).divideScalar(N).divideScalar(this.pixelsPerMeter),
                                    B = _.rigidBody.collider(0).castCollider(O, this.object.rigidBody.collider(0), CO.copy(U).divideScalar(this.pixelsPerMeter), N, !1);
                                O.multiplyScalar(this.pixelsPerMeter);
                                let k = xu.is(_) ? _ : _.object;
                                if (null !== B && this.lastHitObj !== k) {
                                    let O;
                                    _ instanceof vb && (O = _);
                                    let B = this.sharedGameControlGlobals.entityToCollisionEvents[k.uuid];
                                    if (B)
                                        for (let _ of B) "character" === _.data.target && (_.dispatch(O), k.dispatchEvent(D7));
                                    this.lastHitObj = k
                                }
                                if (null !== B) {
                                    this.pushedVelocity.copy(O), CL.copy(B.normal1).applyQuaternion(_.quaternion);
                                    break
                                }
                            }
                            if (0 !== this.pushedVelocity.manhattanLength()) {
                                let _ = CL.dot(U);
                                _ < 0 && U.addScaledVector(CL, -_), U.add(this.pushedVelocity)
                            } else U.add(this.groundVelocity)
                        }
                        if (this.rotDirection.y = Number(this.movementState.rotPosY) - Number(this.movementState.rotNegY), this.rotDirection.x = Number(this.movementState.rotPosX) - Number(this.movementState.rotNegX), this.rotDirection.normalize(), "normal" === this.rotationMode && (this.movementState.rotPosX || this.movementState.rotNegX) || "steer" === this.rotationMode && (this.movementState.rotPosX || this.movementState.rotNegX) && (this.movementState.movePosZ || this.movementState.moveNegZ || "walk" === this.moveMode) ? this.rotVelocityStick.x = -this.rotDirection.x * this.speedOrbit * this.rotForce : this.rotVelocityStick.x = 0, "normal" === this.rotationMode && (this.movementState.rotPosY || this.movementState.rotNegY) || "steer" === this.rotationMode && (this.movementState.rotPosY || this.movementState.rotNegY) && (this.movementState.movePosZ || this.movementState.moveNegZ) ? this.rotVelocityStick.y = -this.rotDirection.y * this.speedOrbit * this.rotForce : this.rotVelocityStick.y = 0, this.rotVelocityTarget.subVectors(this.eulerDelta.divideScalar(N), this.rotVelocityStick), 0 === this.rotVelocityTarget.manhattanLength() ? this.rotVelocity.lerp(this.rotVelocityTarget, 1 - (1 - this.lerpFactorRotEnd) ** k) : this.rotVelocity.lerp(this.rotVelocityTarget, 1 - (1 - this.lerpFactorRotStart) ** k), this.euler.x += this.rotVelocity.x * N, this.euler.y += this.rotVelocity.y * N + this.groundYRotation, 0 === this.rotVelocityTarget.y && 0 === this.directionXZ.manhattanLength() ? this.rotationAccumWhenOrientWithCamera = 0 : (!1 === this.cameraFollow || "Locked" === this.cameraYAxis) && (this.rotationAccumWhenOrientWithCamera += this.rotVelocity.y * N), !1 === this.isFirstPerson && "none" !== this.orientMode && this.directionXZ.manhattanLength() > 0) {
                            if ("radial" === this.orientMode) {
                                this.objectToCamXZ.copy(this.objectToCamXZ0).applyAxisAngle(CG, this.euler.y - this.euler0.y);
                                let _ = CL.copy(this.objectToCamXZ).normalize(),
                                    O = CR.copy(U).multiplyScalar(N);
                                O.y = 0;
                                let B = O.sub(CO.copy(_).multiplyScalar(O.dot(_))).cross(_).y;
                                this.euler.y -= Math.atan2(B, this.objectToCamXZ.length())
                            }
                        } else this.rot.y += this.rotVelocity.y * N + this.groundYRotation, 0 !== this.rotVelocityTarget.y && (!1 === this.cameraFollow || "Locked" === this.cameraYAxis) && (this.euler.y = this.rot.y);
                        if (!0 === this.cameraFollow && ("walk" === this.moveMode ? "Limit" === this.cameraXAxis ? this.euler.x = iK.clamp(this.euler.x, -this.maxPolarAngle + this.cameraPolarOffset + 1e-6, -this.minPolarAngle + this.cameraPolarOffset - 1e-6) : this.euler.x = iK.clamp(this.euler.x, -this.PI_2 + this.cameraPolarOffset, this.PI_2 + this.cameraPolarOffset) : "Limit" === this.cameraXAxis && (this.euler.x = iK.clamp(this.euler.x, -this.PI_2, this.PI_2))), "fly" === this.moveMode ? this.rot.x = this.euler.x : this.isFirstPerson && (O ? CU.copy(O) : CU.copy(this.euler), CU.y = 0, this.nonColliderRotOffset.makeRotationFromEuler(CU)), O && ("walk" === this.moveMode ? (this.rot.y = O.y, this.rot.x = 0, this.rot.z = 0) : this.rot.setFromEuler(O), this.rot.y += this.vrEulerYOffset * CZ), Ck.setFromAxisAngle(Cj, this.rot.x), CF.setFromAxisAngle(CG, this.rot.y), CF.multiply(Ck), Ck.setFromAxisAngle(CH, this.rot.z), CF.multiply(Ck), this.quaternion.copy(CF), this.objectRealQuat.multiplyQuaternions(this.quaternion, this.objXZQuat), this.objectRealQuat.multiply(this.objXZQuat), this.colliderWorldQuat.copy(this.objectRealQuat).multiply(this.collider.rotation), this.collisionEnabled) {
                            if (this.usePhysics) {
                                let _ = CL.copy(U).multiplyScalar(N / this.pixelsPerMeter),
                                    O = null;
                                this.didHit = !1;
                                let B = new rv;
                                for (let N = 0; N < 5; N++) {
                                    let k = _.length(),
                                        F = CR.copy(_).normalize();
                                    if (null !== (O = this.sharedGameControlGlobals.rapierWorld.castShape(this.colliderWorldPosition.divideScalar(this.pixelsPerMeter).add(B), this.colliderWorldQuat, F, this.object.rigidBody ? .collider(0).shape, k, !1, 24, void 0, void 0, this.object.rigidBody))) {
                                        this.didHit = !0;
                                        let U = this.sharedGameControlGlobals.colliderToEntity.get(O.collider.handle);
                                        if (U !== this.lastHitObj && 0 === N) {
                                            this.lastHitObj = U;
                                            let _ = this.sharedGameControlGlobals.entityToCollisionEvents[U ? .uuid];
                                            if (_) {
                                                for (let B of _)
                                                    if ("character" === B.data.target) {
                                                        let _ = this.sharedGameControlGlobals.rapierWorld ? .getCollider(O.collider.handle)._parent,
                                                            N;
                                                        if (U.cloner) {
                                                            for (let O of U.cloner.children)
                                                                if (O.rigidBody === _) {
                                                                    N = O;
                                                                    break
                                                                }
                                                        }
                                                        B.dispatch(N), U.dispatchEvent(D7)
                                                    }
                                            }
                                        }
                                        let j = CD.set(O.normal2.x, O.normal2.y, O.normal2.z).applyQuaternion(this.colliderWorldQuat),
                                            G = CP.copy(F).multiplyScalar(O.toi).dot(j),
                                            Y = O.toi;
                                        if (0 === Y && (this.position.y += this.offset * this.pixelsPerMeter), G > this.offset && (Y = O.toi * (G - this.offset) / G, B.addScaledVector(F, Y)), _.copy(F).multiplyScalar(k - Y), Math.acos(-j.y) > this.slopeThresh) {
                                            let N = this.colliderWorldPosition.divideScalar(this.pixelsPerMeter).add(B),
                                                k = CR.copy(O.witness2).applyQuaternion(this.colliderWorldQuat);
                                            k.y = 0;
                                            let F = N.add(k);
                                            F.y += this.stepThresh;
                                            let U = this.sharedGameControlGlobals.rapierWorld.castShape(F, this.colliderWorldQuat, _, this.object.rigidBody ? .collider(0).shape, 1, !1, 24, void 0, void 0, this.object.rigidBody);
                                            null !== U && 0 === U.toi && (j.y = 0, j.normalize())
                                        }
                                        _.addScaledVector(j, -_.dot(j))
                                    } else {
                                        0 === N && 0 !== this.directionXZ.manhattanLength() && (this.lastHitObj = null), B.add(_);
                                        break
                                    }
                                }
                                this.position.addScaledVector(B, this.pixelsPerMeter), this.object.rigidBody ? .setTranslation(CO.copy(this.position).divideScalar(this.pixelsPerMeter), !0), this.object.rigidBody ? .setRotation(Ck.copy(this.quaternion).premultiply(this.groundTilt).multiply(this.objXZQuat), !0)
                            } else {
                                let _ = this.onObject ? 1 : 5,
                                    O = U.multiplyScalar(N / _);
                                for (let B = 0; B < _; B++) this.position.add(O), this.collisionAdjustment(N / _)
                            }
                        } else this.position.addScaledVector(U, N);
                        if ("walk" === this.moveMode && this.onObject && (this.velocityTarget.y = 0, this.velocity.y = 0), this.quaternion.premultiply(this.groundTilt).multiply(this.objXZQuat), this.object.matrix.compose(this.position, this.quaternion, this.scale), this.object.matrixWorldNeedsUpdate = !0, this.object.matrix.multiply(this.nonColliderPosOffset).multiply(this.nonColliderRotOffset), this.quaternion.premultiply(this.groundTiltInv).multiply(this.objXZQuatInv), !0 === this.cameraFollow) {
                            this.updateFollowArms();
                            let _ = this.objectToTarget.add(this.position),
                                O = this.targetToCamera.add(_);
                            CB.lookAt(O, _, CG).setPosition(O), CB.decompose(this.targetPos, this.targetQuat, CO), this.camera.quaternion.slerp(this.targetQuat, 1 - (1 - this.lerpFactorRotCamera) ** k), this.camera.position.lerp(this.targetPos, 1 - (1 - this.lerpFactorPosCamera) ** k), this.camera.updateMatrix(), this.camera.updateMatrixWorld(), "Limit" === this.cameraYAxis && "cartesian" === this.orientMode && (this.euler.y = iK.clamp(this.euler.y, this.minAzimuthAngleRel, this.maxAzimuthAngleRel)), this.euler.x = iK.clamp(this.euler.x, -this.PI_2 + (this.cameraPolarOffset < 0 ? this.cameraPolarOffset : 0), this.PI_2 + (this.cameraPolarOffset > 0 ? this.cameraPolarOffset : 0))
                        }
                        return this.eulerDelta.set(0, 0, 0), this.object.dispatchEvent(CQ), !(this.path.length < 2 && this.lastPosition.distanceToSquared(this.position) < this.threshEndTranslate && Math.abs(this.rotVelocity.x) < this.threshEndRotVel && Math.abs(this.rotVelocity.y) < this.threshEndRotVel && (void 0 === this.camera || this.isFirstPerson || this.lastCameraPosition.distanceToSquared(this.camera.position) < this.threshEndTranslate && 8 * (1 - this.lastCameraQuaternion.dot(this.camera.quaternion)) < this.threshEndRotate) && ("fly" === this.moveMode || !0 === this.onObject || !1 === this.collisionEnabled) && (null === this.navMeshPathDest || this.navMeshPathDest.material.opacity < -.04 * this.navMeshPathDest ? .material ? .userData.opacity0)) && (this.camera && (this.lastCameraPosition.copy(this.camera.position), this.lastCameraQuaternion.copy(this.camera.quaternion)), this.lastPosition.copy(this.position), this.object.dispatchEvent(CX), !0)
                    }
                    updateFollowArms() {
                        let _;
                        this.objectToTarget.copy(this.objectToTarget0), this.targetToCamera.copy(this.targetToCamera0);
                        let O = Ck.setFromAxisAngle(CG, "Limit" === this.cameraYAxis && "radial" !== this.orientMode ? iK.clamp(this.euler.y - this.euler0.y, this.minAzimuthAngleRel, this.maxAzimuthAngleRel) : this.euler.y - this.euler0.y);
                        ("Locked" !== this.cameraYAxis || "radial" === this.orientMode) && this.objectToTarget.applyQuaternion(O), _ = "Limit" === this.cameraXAxis ? iK.clamp(this.euler.x, -this.maxPolarAngle + this.cameraPolarOffset + 1e-6, -this.minPolarAngle + this.cameraPolarOffset - 1e-6) : iK.clamp(this.euler.x, -this.PI_2 + this.cameraPolarOffset + 1e-6, this.PI_2 + this.cameraPolarOffset - 1e-6);
                        let B = CO.copy(this.cameraPolarAxis0);
                        ("Locked" !== this.cameraYAxis || "radial" === this.orientMode) && B.applyQuaternion(O);
                        let N = CF.setFromAxisAngle(B, _);
                        "Locked" !== this.cameraYAxis && this.targetToCamera.applyQuaternion(O), "Locked" !== this.cameraXAxis && this.targetToCamera.applyQuaternion(N)
                    }
                    groundTiltAdjustment(_) {
                        180 * CG.angleTo(_) / Math.PI < 15 || 180 * CG.angleTo(_) / Math.PI > 85 ? Ck.identity() : Ck.setFromUnitVectors(CG, _), this.groundTilt.slerp(Ck, .06), this.groundTiltInv.copy(this.groundTilt).invert()
                    }
                    collisionAdjustment(_) {
                        let O = CP.set(0, 0, 0);
                        this.object.matrix.compose(this.position, this.quaternion, this.scale);
                        let B = CB.multiplyMatrices(this.object.matrix, this.objXZRotMat).multiply(this.collider.matrix).decompose(CO, Ck, CL).compose(CO, Ck, CW);
                        this.sharedGameControlGlobals.entitiesWithTransformAnim.forEach(_ => {
                            if (_ === this.object || _.isDescendantOf(this.object)) return;
                            CY.makeEmpty(), _.updateMatrixWorldSVD();
                            let N = _.matrixWorldRigid,
                                k = Cz.copy(N).invert(),
                                F = CN.copy(Cz).multiply(B);
                            Cq.copy(this.collider.segment), Cq.start.applyMatrix4(F), Cq.end.applyMatrix4(F);
                            let U = CD.copy(this.position).applyMatrix4(k);
                            CY.expandByPoint(Cq.start), CY.expandByPoint(Cq.end), CY.min.addScalar(-this.collider.radius), CY.max.addScalar(this.collider.radius), _.bvhGeometry.boundsTree.shapecast({
                                traverseBoundsOrder: _ => _.distanceToPoint(Cq.end),
                                intersectsBounds: _ => _.intersectsBox(CY),
                                intersectsTriangle: _ => {
                                    let B = _.closestPointToSegment(Cq, CO, CL);
                                    if (B < this.collider.radius) {
                                        let _ = this.collider.radius - B,
                                            k = CL.sub(CO).normalize(),
                                            F = CR.copy(U);
                                        F.addScaledVector(k, _);
                                        let j = F.applyMatrix4(N).sub(this.position);
                                        O.add(j), Cq.start.addScaledVector(k, _), Cq.end.addScaledVector(k, _)
                                    }
                                }
                            })
                        }), CY.makeEmpty(), Cq.copy(this.collider.segment), Cq.start.applyMatrix4(B), Cq.end.applyMatrix4(B), CY.expandByPoint(Cq.start), CY.expandByPoint(Cq.end), CY.min.addScalar(-this.collider.radius), CY.max.addScalar(this.collider.radius), this.sharedGameControlGlobals.staticMeshBVH ? .shapecast({
                            traverseBoundsOrder: _ => _.distanceToPoint(Cq.end),
                            intersectsBounds: _ => _.intersectsBox(CY),
                            intersectsTriangle: _ => {
                                let B = _.closestPointToSegment(Cq, CO, CL);
                                if (B < this.collider.radius) {
                                    let _ = this.collider.radius - B,
                                        N = CL.sub(CO).normalize();
                                    this.alignToGround && this.groundTiltAdjustment(N), O.addScaledVector(N, _), Cq.start.addScaledVector(N, _), Cq.end.addScaledVector(N, _)
                                }
                            }
                        }), this.onObject = Math.abs(O.y) > Math.abs(_ * this.velocity.y * .25), this.onObject && this.dispatchStopEvent("jump");
                        let N = Math.max(0, O.length() - 1e-5);
                        O.normalize().multiplyScalar(N), this.position.add(O)
                    }
                };
            CK.isLocked = !1;
            var CJ = pn(ib());

            function Vs(_, O) {
                let B = new sK;
                if (!_.getAttribute("position")) return B.setAttribute("position", new sG([], 3)), B.setIndex([]), B;
                let {
                    positions: N,
                    triIndices: k
                } = yc(_.getAttribute("position"), _.getIndex());
                return B.setAttribute("position", new sG(N, 3)), B.setIndex(k), O && B.applyMatrix4(O), B
            }
            var C$ = new rJ,
                C2 = new rJ,
                C4 = [
                    [0, 0, 0],
                    [0, 0, 0],
                    [0, 0, 0]
                ];

            function U1(_) {
                let O = _.elements;
                C4[0][0] = O[0], C4[0][1] = O[4], C4[0][2] = O[8], C4[1][0] = O[1], C4[1][1] = O[5], C4[1][2] = O[9], C4[2][0] = O[2], C4[2][1] = O[6], C4[2][2] = O[10];
                let {
                    u: B,
                    v: N
                } = (0, CJ.SVD)(C4), k = C$.set(B[0][0], B[0][1], B[0][2], 0, B[1][0], B[1][1], B[1][2], 0, B[2][0], B[2][1], B[2][2], 0, 0, 0, 0, 1), F = C2.set(N[0][0], N[0][1], N[0][2], 0, N[1][0], N[1][1], N[1][2], 0, N[2][0], N[2][1], N[2][2], 0, 0, 0, 0, 1);
                return k.multiply(F.transpose())
            }
            var C5 = class extends lA {
                    constructor() {
                        super(), this.layers.enable(3), this.layers.enable(8)
                    }
                    setFromCamera(_, O) {
                        O.isOrthographicCamera ? (this.ray.origin.set(_.x, _.y, -1).unproject(O), this.ray.direction.set(0, 0, -1).transformDirection(O.matrixWorld), this.camera = O) : O.isPerspectiveCamera ? (this.ray.origin.set(_.x, _.y, -1).unproject(O), this.ray.direction.set(_.x, _.y, .5).unproject(O).sub(this.ray.origin).normalize(), this.camera = O) : console.error("Raycaster: Unsupported camera type.")
                    }
                    intersectVisibleObjects(_, O = !0, B = []) {
                        return _.forEach(_ => {
                            _.visible && this.intersectObject(_, O, B)
                        }), B
                    }
                    createRaycastLineHelper() {
                        let _ = new nk({
                                color: 65280,
                                linewidth: 10
                            }),
                            O = new rv(this.ray.origin.x, this.ray.origin.y, this.ray.origin.z),
                            B = new rv(this.ray.direction.x, this.ray.direction.y, this.ray.direction.z),
                            N = this.camera.far - this.camera.near,
                            k = new rv().addVectors(O, B.multiplyScalar(N)),
                            F = new sK;
                        return F.setFromPoints([O, k]), new nW(F, _)
                    }
                },
                GL = _ => _ instanceof Sy || _ instanceof MU;

            function aQ(_, O) {
                return _.distance - O.distance
            }

            function of (_, O, B, N = !1) {
                if (!N && !B.some(O => void 0 !== af(_, O))) return [];
                let k = [];
                return O.children.forEach(O => (function HL(_, O, B) {
                    if (!(!oo(O) || !O.visible))
                        for (let N of (Yn(O) && O.raycast(_, B), O.children)) HL(_, N, B)
                })(_, O, k)), k.sort(aQ), k
            }

            function Em(_) {
                let O = [];
                if (_.length) {
                    let B = _[0].object;
                    oo(B) && O.push(B);
                    let N = B.parent;
                    for (; N;) GL(N) && O.push(N), N = N.parent
                }
                return O
            }

            function af(_, O) {
                if (Yn(O)) {
                    if (O.visible) {
                        let B = [];
                        return O.raycast(_, B), B.length ? B[0] : void 0
                    }
                } else if (GL(O)) return function jL(_, O) {
                    if (!(!oo(O) || !O.visible)) {
                        if (Yn(O)) {
                            let B = [];
                            if (O.raycast(_, B), B.length) return B[0]
                        }
                        for (let B of O.children) {
                            let O = jL(_, B);
                            if (O) return O
                        }
                    }
                }(_, O)
            }
            var C6 = class {
                    constructor(_, O, B, N, k, F, U, j) {
                        this.renderer = _, this.publish = O, this.scene = B, this.getCamera = N, this.sharedAssets = k, this.requestRender = F, this.isExport = U, this.frame = j, this.raycaster = new C5, this._useWindowEvents = !1, this._useWindowEvents = "window" === O.mouseEventTarget, this.domElement = _.domElement, this.eventElement = this._useWindowEvents ? window : _.domElement, this._domRect = this.domElement.getBoundingClientRect()
                    }
                    get stopRaycast() {
                        return this.publish.stopRaycast
                    }
                    get page() {
                        return this.scene.activePage
                    }
                    set useWindowEvents(_) {
                        this._useWindowEvents = _, this.eventElement = _ ? window : this.renderer.domElement
                    }
                    get useWindowEvents() {
                        return this._useWindowEvents
                    }
                    set domRect(_) {
                        this._domRect = _
                    }
                    updateRaycaster(_) {
                        var O;
                        let {
                            pageX: B,
                            pageY: N
                        } = _.touches ? .length > 0 ? _.touches[0] : _;
                        this.raycaster.setFromCamera({
                            x: (B - ((O = this._domRect).left + window.scrollX)) / O.width * 2 - 1,
                            y: -(2 * ((N - (O.top + window.scrollY)) / O.height)) + 1
                        }, this.getCamera())
                    }
                },
                C8 = class {
                    constructor(_) {
                        this.eventContext = _, this.domEventsNeeded = new Set, this.hasVideoAction = !1
                    }
                    connect() {}
                    disconnect() {}
                },
                C9 = [
                    ["start", "Start"],
                    ["keyDown", "KeyDown"],
                    ["keyUp", "KeyUp"],
                    ["mouseDown", "MouseDown"],
                    ["mouseUp", "MouseUp"],
                    ["mouseHover", "MouseHover"],
                    ["collision", "Collision"],
                    ["lookAt", "LookAt"],
                    ["follow", "Follow"],
                    ["scroll", "Scroll"]
                ],
                WL = _ => C9.find(([O, B]) => B === _) ? .[0],
                Co = _ => C9.find(([O]) => O === _) ? .[1],
                cQ = (_, O) => {
                    let B = WL(_);
                    if (B) {
                        let _ = new CustomEvent(B, {
                            bubbles: !0
                        });
                        return Object.defineProperty(_, "target", {
                            writable: !1,
                            value: O
                        }), _
                    }
                },
                C7 = class extends C8 {
                    constructor(_) {
                        super(_), this.objectsPerEvents = new Map, this.splineEvents = {}, this.onBeginEvent = _ => {
                            if (!_.eventName || !_.target || "Scroll" === _.eventName) return;
                            let O = this.splineEvents[WL(_.eventName)] ? .[_.target.uuid];
                            if (!O) return;
                            "Scroll" === _.eventName && void 0 !== _.deltaY && Object.assign(O, {
                                deltaY: _.deltaY
                            });
                            let {
                                domElement: B
                            } = this.eventContext;
                            B.dispatchEvent(O)
                        };
                        let {
                            page: O
                        } = this.eventContext;
                        O.traverseEntity(_ => {
                            if (_.data ? .events.length) {
                                for (let [O, B] of C9)
                                    if (_.data.events.some(_ => _.data.type === B && !_.data.disabled)) {
                                        this.objectsPerEvents.has(O) ? this.objectsPerEvents.get(O) ? .push(_) : this.objectsPerEvents.set(O, [_]);
                                        let N = cQ(B, {
                                                id: _.uuid,
                                                name: _.name
                                            }),
                                            k = this.splineEvents[O];
                                        k ? k[_.uuid] = N : this.splineEvents[O] = {
                                            [_.uuid]: N
                                        }
                                    }
                            }
                        })
                    }
                    connect() {
                        this.objectsPerEvents.forEach(_ => {
                            _.forEach(_ => {
                                _.addEventListener("beginEvent", this.onBeginEvent)
                            })
                        })
                    }
                    disconnect() {
                        this.objectsPerEvents.forEach(_ => {
                            _.forEach(_ => {
                                _.removeEventListener("beginEvent", this.onBeginEvent)
                            })
                        })
                    }
                },
                Te = class {
                    constructor(_, O, B, N, k, F) {
                        if (this.id = _, this.data = O, this.object = B, this.entered = !1, this.alreadyPlayedNonTogglingActions = new Set, this.useToggle = "Toggle" === O.runMode, ("KeyDown" === O.type || "KeyUp" === O.type || "KeyPress" === O.type) && !O.key) throw Error("Missing property");
                        this.actions = nr(O, O.actions, N, k, F, B)
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    dispatchHeld(_) {
                        this.actions.Create.forEach(O => {
                            _ && O.dispatchThrottled.cancel(), O.dispatchThrottled()
                        })
                    }
                    dispatch(_ = !1) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this ? (_.object.currentTransitionEvent = this, _.init()) : "Once" === this.data.runMode && this.alreadyPlayedNonTogglingActions.add(_)
                        }), this.useToggle ? (this.actions.Transition.forEach(_ => {
                            _.toggle()
                        }), this.actions.Animation.forEach(_ => {
                            _.toggle()
                        }), this.actions.SwitchCamera.forEach(_ => {
                            _.toggle()
                        })) : "MousePress" === this.data.type || "KeyPress" === this.data.type ? this.entered || (this.entered = !0, this.actions.Transition.forEach(_ => _.playFromCurrent()), this.actions.Animation.forEach(_ => _.playFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.playFromCurrent()), this.actions.Create.forEach(_ => _.dispatchStart())) : (this.actions.Transition.some(_ => _.playing) || this.actions.Transition.forEach(_ => {
                            !1 === this.alreadyPlayedNonTogglingActions.has(_) && _.play()
                        }), this.actions.SwitchCamera.some(_ => _.playing) || this.actions.SwitchCamera.forEach(_ => {
                            _.play()
                        }), this.actions.Animation.forEach(_ => {
                            _.play()
                        })), this.actions.Link.forEach(_ => {
                            _.dispatch()
                        }), this.actions.SceneTransition.forEach(_ => {
                            _.dispatch()
                        }), !1 === _ && this.actions.Create.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Destroy.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Reset.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Audio.forEach(_ => {
                            _.dispatchBasic()
                        }), this.actions.Video.forEach(_ => {
                            _.dispatchBasic()
                        }), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                    dispatchRelease() {
                        this.entered && (this.entered = !1, this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.Animation.forEach(_ => _.reverseFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.reverseFromCurrent()), this.actions.Create.forEach(_ => _.dispatchStop()))
                    }
                    dispatchUserEvent(_) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), _ ? (this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.Animation.forEach(_ => _.reverseFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.reverseFromCurrent())) : (this.actions.Transition.forEach(_ => _.playFromCurrent()), this.actions.Animation.forEach(_ => _.playFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.playFromCurrent())), this.actions.Link.forEach(_ => {
                            _.dispatch()
                        }), this.actions.SceneTransition.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Create.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Destroy.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Reset.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Audio.forEach(_ => {
                            _.dispatchBasic()
                        }), this.actions.Video.forEach(_ => {
                            _.dispatchBasic()
                        }), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                },
                Tt = class extends C8 {
                    constructor(_, O, B) {
                        super(_), this.useForRaycastProperty = B, this.objectsPerTypes = {
                            MouseDown: [],
                            MouseUp: [],
                            MousePress: [],
                            KeyDown: [],
                            KeyUp: [],
                            KeyPress: []
                        }, this.canvasMouseEvents = [], this.eventsPerObjects = {
                            MouseDown: {},
                            MouseUp: {},
                            MousePress: {},
                            KeyDown: {},
                            KeyUp: {},
                            KeyPress: {}
                        }, this.heldKeys = {}, this.heldKeysPress = {}, this._prevObjects = [], this.sceneInterects = null, this.onCanvasRaycast = _ => {
                            if (!0 === this.useForRaycastProperty && null === this.sceneInterects) {
                                this.eventContext.updateRaycaster(_);
                                let {
                                    raycaster: O,
                                    page: B
                                } = this.eventContext, N = of (O, B, [], !0);
                                this.sceneInterects = N, N.length && (this.eventContext.sharedAssets.raycastProperty = {
                                    x: N[0].point.x,
                                    y: N[0].point.y,
                                    z: N[0].point.z,
                                    objX: N[0].object.matrixWorld.elements[12],
                                    objY: N[0].object.matrixWorld.elements[13],
                                    objZ: N[0].object.matrixWorld.elements[14]
                                })
                            }
                        }, this.onCanvasMouseDown = _ => {
                            (_.target === this.eventContext.domElement || "SPLINE-VIEWER" === _.target.tagName) && this.canvasMouseEvents.forEach(O => {
                                ("MouseDown" === O.data.type || "MousePress" === O.data.type) && (this.onCanvasRaycast(_), O.dispatch())
                            })
                        }, this.onCanvasMouseUp = _ => {
                            (_.target === this.eventContext.domElement || "SPLINE-VIEWER" === _.target.tagName) && this.canvasMouseEvents.forEach(O => {
                                "MouseUp" === O.data.type ? (this.onCanvasRaycast(_), O.dispatch()) : "MousePress" === O.data.type && O.dispatchRelease()
                            })
                        }, this.onMouseDown = _ => {
                            dq.length > 1 || (this.eventContext.updateRaycaster(_), this.handleMouseEvent("MouseDown"))
                        }, this.onMouseUp = _ => {
                            dq.length > 1 || (this.eventContext.updateRaycaster(_), this.handleMouseEvent("MouseUp"))
                        }, this.onMousePressDown = _ => {
                            dq.length > 1 || (this.eventContext.updateRaycaster(_), this.handleMousePressEvent())
                        }, this.onMousePressRelease = _ => {
                            dq.length > 1 || (this.eventContext.updateRaycaster(_), this.handleMousePressEvent(!0))
                        }, this.onKeyDown = _ => {
                            this.heldKeys[_.key] || (this.handleKeyEvent(_, "KeyDown"), this.handleKeyEventHeld(_, "KeyDown", !0)), this.heldKeys[_.key] = !0
                        }, this.onKeyUp = _ => {
                            this.handleKeyEvent(_, "KeyUp"), this.handleKeyEventHeld(_, "KeyUp", !0)
                        }, this.onKeyPressDown = _ => {
                            this.heldKeysPress[_.key] ? this.handleKeyEventHeld(_, "KeyPress") : (this.handleKeyEvent(_, "KeyPress"), this.handleKeyEventHeld(_, "KeyPress", !0)), this.heldKeysPress[_.key] = !0
                        }, this.onKeyPressUp = _ => {
                            this.handleKeyEvent(_, "KeyPress", !0)
                        }, this.releaseHeldKey = _ => {
                            delete this.heldKeys[_.key]
                        }, this.releaseHeldKeyPress = _ => {
                            delete this.heldKeysPress[_.key]
                        }, this._onUserEvent = ({
                            eventName: _,
                            target: O,
                            reverse: B
                        }) => {
                            if (!_ || !O) return;
                            let N = Co(_);
                            N && ("MouseDown" === N || "MouseUp" === N || "MousePress" === N ? (O.dispatchEvent({
                                type: "beginEvent",
                                eventName: N
                            }), this.eventsPerObjects[N] ? .[O.uuid] ? .forEach(_ => {
                                _.dispatchUserEvent(B)
                            })) : ("KeyDown" === N || "KeyUp" === N || "KeyPress" === N) && (O.dispatchEvent({
                                type: "beginEvent",
                                eventName: N
                            }), this.eventsPerObjects[N] ? .[O.uuid] ? .forEach(_ => {
                                _.dispatchUserEvent()
                            })))
                        };
                        let {
                            page: N,
                            sharedAssets: k
                        } = this.eventContext;
                        N.traverseEntity(_ => {
                            if (_.data ? .events.length)
                                for (let B of ["MouseDown", "MouseUp", "MousePress", "KeyDown", "KeyUp", "KeyPress"]) {
                                    let F = this.eventsPerObjects[B];
                                    _.data.events.filter(({
                                        data: _
                                    }) => _.type === B && !0 !== _.disabled).forEach(({
                                        id: B,
                                        data: U
                                    }) => {
                                        try {
                                            let j = new Te(B, U, _, N, k, O);
                                            j.actions.Video.length && (this.hasVideoAction = !0), ("MouseDown" === U.type || "MouseUp" === U.type || "MousePress" === U.type) && ("Canvas" === U.mode || "Window" === U.mode) ? this.canvasMouseEvents.push(j) : F[_.uuid] ? F[_.uuid].push(j) : F[_.uuid] = [j]
                                        } catch (_) {}
                                    }), F[_.uuid] ? .length && this.objectsPerTypes[B].push(_)
                                }
                        })
                    }
                    connect() {
                        let {
                            domElement: _
                        } = this.eventContext;
                        this.heldKeys = {}, this.heldKeysPress = {}, this.domEventsNeeded.clear(), _.addEventListener("pointerdown", this.onCanvasMouseDown), _.addEventListener("pointerup", this.onCanvasMouseUp), (this.objectsPerTypes.MouseDown ? .length || this.useForRaycastProperty) && (this.domEventsNeeded.add("pointerdown"), _.addEventListener("pointerdown", this.onMouseDown)), this.objectsPerTypes.MouseUp ? .length && (this.domEventsNeeded.add("pointerup"), _.addEventListener("pointerup", this.onMouseUp)), this.objectsPerTypes.MousePress ? .length && (this.domEventsNeeded.add("pointerdown"), _.addEventListener("pointerdown", this.onMousePressDown), this.domEventsNeeded.add("pointerup"), _.addEventListener("pointerup", this.onMousePressRelease)), this.objectsPerTypes.KeyDown ? .length && (this.domEventsNeeded.add("keydown"), document.addEventListener("keydown", this.onKeyDown), document.addEventListener("keyup", this.releaseHeldKey)), this.objectsPerTypes.KeyUp ? .length && (this.domEventsNeeded.add("keyup"), document.addEventListener("keyup", this.onKeyUp)), this.objectsPerTypes.KeyPress ? .length && (this.domEventsNeeded.add("keydown"), document.addEventListener("keydown", this.onKeyPressDown), document.addEventListener("keyup", this.releaseHeldKeyPress), this.domEventsNeeded.add("keyup"), document.addEventListener("keyup", this.onKeyPressUp)), Object.entries(this.objectsPerTypes).forEach(([_, O]) => {
                            O.forEach(_ => {
                                _.addEventListener("userEvent", this._onUserEvent)
                            })
                        })
                    }
                    disconnect() {
                        let {
                            domElement: _
                        } = this.eventContext;
                        this.domEventsNeeded.clear(), this.heldKeys = {}, this.heldKeysPress = {}, _.removeEventListener("pointerdown", this.onCanvasMouseDown), _.removeEventListener("pointerup", this.onCanvasMouseUp), _.removeEventListener("pointerdown", this.onMouseDown), _.removeEventListener("pointerdown", this.onMousePressDown), _.removeEventListener("pointerup", this.onMouseUp), _.removeEventListener("pointerup", this.onMousePressRelease), document.removeEventListener("keydown", this.onKeyDown), document.removeEventListener("keyup", this.onKeyUp), document.removeEventListener("keydown", this.onKeyPressDown), document.removeEventListener("keyup", this.onKeyPressUp), document.removeEventListener("keyup", this.releaseHeldKey), Object.values(this.eventsPerObjects).forEach(_ => {
                            Object.values(_).forEach(_ => {
                                _.forEach(_ => {
                                    _.disconnect()
                                })
                            })
                        }), this.canvasMouseEvents.forEach(_ => {
                            _.disconnect()
                        }), Object.entries(this.objectsPerTypes).forEach(([_, O]) => {
                            O.forEach(_ => {
                                _.removeEventListener("userEvent", this._onUserEvent)
                            })
                        })
                    }
                    handleMouseEvent(_) {
                        let {
                            stopRaycast: O,
                            raycaster: B,
                            page: N
                        } = this.eventContext, k = this.objectsPerTypes[_];
                        if (!(!k.length && !this.useForRaycastProperty)) {
                            if (O || this.useForRaycastProperty) {
                                let F;
                                null === this.sceneInterects ? F = of (B, N, k, this.useForRaycastProperty) : (F = this.sceneInterects, this.sceneInterects = null), this.useForRaycastProperty && F.length && (this.eventContext.sharedAssets.raycastProperty = {
                                    x: F[0].point.x,
                                    y: F[0].point.y,
                                    z: F[0].point.z,
                                    objX: F[0].object.matrixWorld.elements[12],
                                    objY: F[0].object.matrixWorld.elements[13],
                                    objZ: F[0].object.matrixWorld.elements[14]
                                }), O && Em(F).forEach(O => {
                                    this.eventsPerObjects[_][O.uuid] && this.handleObjectMouseEventDispatch(O, _)
                                })
                            }
                            O || k.forEach(O => {
                                af(B, O) && this.handleObjectMouseEventDispatch(O, _)
                            })
                        }
                    }
                    handleMousePressEvent(_ = !1) {
                        let O = "MousePress",
                            B = this.objectsPerTypes[O],
                            N = [];
                        if (B.length) {
                            if (!_) {
                                let {
                                    stopRaycast: _,
                                    raycaster: O,
                                    page: k
                                } = this.eventContext;
                                _ ? N = Em( of (O, k, B)) : B.forEach(_ => {
                                    af(O, _) && N.push(_)
                                })
                            }
                            this._prevObjects.length && this._prevObjects.forEach(_ => {
                                N.includes(_) || this.handleObjectMouseEventDispatchRelease(_, O)
                            }), N.length && N.forEach(_ => {
                                this.handleObjectMouseEventDispatch(_, O)
                            }), this._prevObjects = N
                        }
                    }
                    handleObjectMouseEventDispatch(_, O) {
                        _.dispatchEvent({
                            type: "beginEvent",
                            eventName: O
                        }), this.eventsPerObjects[O] ? .[_.uuid] ? .forEach(_ => {
                            _.dispatch()
                        })
                    }
                    handleObjectMouseEventDispatchRelease(_, O) {
                        _.dispatchEvent({
                            type: "beginEvent",
                            eventName: O
                        }), this.eventsPerObjects[O] ? .[_.uuid] ? .forEach(_ => {
                            _.dispatchRelease()
                        })
                    }
                    handleKeyEvent(_, O, B = !1) {
                        this.objectsPerTypes[O].forEach(N => {
                            let k = this.eventsPerObjects[O][N.uuid];
                            k.some(({
                                data: O
                            }) => "key" in O && O.key === _.key) && N.dispatchEvent({
                                type: "beginEvent",
                                eventName: O
                            }), k.forEach(O => {
                                "key" in O.data && O.data.key === _.key && (B ? O.dispatchRelease() : O.dispatch(!0))
                            })
                        })
                    }
                    handleKeyEventHeld(_, O, B = !1) {
                        this.objectsPerTypes[O].forEach(N => {
                            this.eventsPerObjects[O][N.uuid].forEach(O => {
                                "key" in O.data && O.data.key === _.key && O.dispatchHeld(B)
                            })
                        })
                    }
                },
                Ti = new rv,
                Tr = new rv,
                Ts = class {
                    constructor(_, O, B, N, k) {
                        this.actionsIn = nr(_, _.inActions, B, N, k, O), this.actionsOut = nr(_, _.outActions, B, N, k, O)
                    }
                    disconnect() {
                        qt(this.actionsIn), qt(this.actionsOut)
                    }
                },
                Ta = class extends Ts {
                    constructor(_, O, B, N, k, F) {
                        super(O, B, N, k, F), this.id = _, this.data = O, this.object = B, this.stage = "out", this.objects = [], this.onUpdateMatrixWorld = () => {
                            for (let _ of this.objects)
                                if (!_.visible) return;
                            let _ = Ti.setFromMatrixPosition(this.objects[0].matrixWorld),
                                O = Tr.setFromMatrixPosition(this.objects[1].matrixWorld),
                                B = _.distanceTo(O) <= this.distance ? "in" : "out";
                            if (this.stage !== B) {
                                this.stage = B;
                                let _ = "in" === B ? this.actionsIn : this.actionsOut;
                                _.Audio.forEach(_ => _.dispatchConditional()), _.Video.forEach(_ => _.dispatchConditional()), _.Link.forEach(_ => _.dispatch()), _.Create.forEach(_ => _.dispatch()), _.Destroy.forEach(_ => _.dispatch()), _.Reset.forEach(_ => _.dispatch()), _.Transition.forEach(_ => {
                                    _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this), _.init()
                                }), _.Transition.forEach(_ => _.play()), _.Animation.forEach(_ => _.play()), _.SwitchCamera.forEach(_ => _.play()), _.SceneTransition.forEach(_ => _.dispatch()), _.SetVariable.forEach(_ => _.checkConditions()), _.SetVariable.forEach(_ => _.dispatch()), _.DynamicVariablePlay.forEach(_ => _.dispatch())
                            }
                        };
                        let {
                            distance: U,
                            fromObject: j,
                            toObject: G
                        } = O.condition;
                        for (let _ of (this.distance = U, [j, G])) {
                            if (!_) throw Error("Missing property");
                            let O = N.find(_);
                            if (!O) throw Error("Missing property");
                            this.objects.push(O)
                        }
                    }
                    connect() {
                        window.setTimeout(() => {
                            this.objects.forEach(_ => {
                                _.addEventListener("updateMatrixWorld", this.onUpdateMatrixWorld)
                            }), this.onUpdateMatrixWorld()
                        }, 0)
                    }
                    disconnect() {
                        super.disconnect(), this.stage = "out", this.objects.forEach(_ => {
                            _.removeEventListener("updateMatrixWorld", this.onUpdateMatrixWorld)
                        })
                    }
                },
                Tn = class extends Ts {
                    constructor(_, O, B, N, k, F) {
                        super(O, B, N, k, F), this.id = _, this.data = O, this.object = B, this.onBegin = ({
                            target: _,
                            state: O
                        }) => {
                            this.toState !== O && (this.actionsOut.Audio.forEach(_ => _.dispatchConditional()), this.actionsOut.Video.forEach(_ => _.dispatchConditional()), this.actionsOut.Link.forEach(_ => _.dispatch()), this.actionsOut.Create.forEach(_ => _.dispatch()), this.actionsOut.Destroy.forEach(_ => _.dispatch()), this.actionsOut.Reset.forEach(_ => _.dispatch()), this.actionsIn.Transition.forEach(_ => _.pause()), this.object.currentTransitionEvent = this, this.actionsOut.Transition.forEach(_ => _.play()), this.actionsOut.Animation.forEach(_ => _.play()), this.actionsIn.SwitchCamera.forEach(_ => _.pause()), this.actionsOut.SwitchCamera.forEach(_ => _.play()), this.actionsOut.SceneTransition.forEach(_ => _.dispatch()), this.actionsOut.SetVariable.forEach(_ => _.checkConditions()), this.actionsOut.SetVariable.forEach(_ => _.dispatch()), this.actionsOut.DynamicVariablePlay.forEach(_ => _.dispatch()))
                        }, this.onComplete = ({
                            target: _,
                            state: O
                        }) => {
                            this.toState === O && (this.actionsIn.Audio.forEach(_ => _.dispatchConditional()), this.actionsIn.Video.forEach(_ => _.dispatchConditional()), this.actionsIn.Link.forEach(_ => _.dispatch()), this.actionsIn.Create.forEach(_ => _.dispatch()), this.actionsIn.Destroy.forEach(_ => _.dispatch()), this.actionsIn.Reset.forEach(_ => _.dispatch()), this.actionsOut.Transition.forEach(_ => _.pause()), this.actionsOut.Transition.forEach(_ => _.pause()), this.object.currentTransitionEvent = this, this.actionsIn.Transition.forEach(_ => _.play()), this.actionsIn.Animation.forEach(_ => _.play()), this.actionsOut.SwitchCamera.forEach(_ => _.pause()), this.actionsIn.SwitchCamera.forEach(_ => _.play()), this.actionsIn.SceneTransition.forEach(_ => _.dispatch()), this.actionsIn.SetVariable.forEach(_ => _.checkConditions()), this.actionsIn.SetVariable.forEach(_ => _.dispatch()), this.actionsIn.DynamicVariablePlay.forEach(_ => _.dispatch()))
                        };
                        let {
                            condition: U
                        } = O;
                        if (!U.object) throw Error("Missing property");
                        let j = N.find(U.object);
                        if (!j || (this.toObject = j, U.state && !this.toObject.states ? .[U.state])) throw Error("Missing property");
                        this.toState = U.state
                    }
                    connect() {
                        qi(this.actionsOut).forEach(_ => {
                            this.actionsOut[_] ? .length && this.toObject.addEventListener("beginState", this.onBegin)
                        }), qi(this.actionsIn).forEach(_ => {
                            this.actionsIn[_] ? .length && this.toObject.addEventListener("completeState", this.onComplete)
                        })
                    }
                    disconnect() {
                        super.disconnect(), qi(this.actionsOut).forEach(_ => {
                            this.actionsIn[_] ? .length && this.toObject.removeEventListener("beginState", this.onBegin)
                        }), qi(this.actionsIn).forEach(_ => {
                            this.actionsIn[_] ? .length && this.toObject.removeEventListener("completeState", this.onComplete)
                        })
                    }
                },
                To = class extends C8 {
                    constructor(_, O) {
                        super(_), this.eventsPerConditions = {
                            Comparison: [],
                            Distance: [],
                            State: []
                        }, this.hasVideoAction = !1;
                        let {
                            page: B,
                            sharedAssets: N
                        } = this.eventContext;
                        B.traverseEntity(_ => {
                            if (_.data ? .events.length) {
                                for (let {
                                        id: k,
                                        data: F
                                    } of _.data.events)
                                    if (!F.disabled && "Conditional" === F.type) try {
                                        let U;
                                        "Comparison" === F.condition.type || ("Distance" === F.condition.type ? U = new Ta(k, F, _, B, N, O) : "State" === F.condition.type && (U = new Tn(k, F, _, B, N, O))), U && (this.eventsPerConditions[F.condition.type].push(U), (U.actionsIn.Video.length || U.actionsOut.Video.length) && (this.hasVideoAction = !0))
                                    } catch (_) {}
                            }
                        })
                    }
                    connect() {
                        super.connect(), Object.values(this.eventsPerConditions).forEach(_ => _.forEach(_ => _.connect()))
                    }
                    disconnect() {
                        super.disconnect(), Object.values(this.eventsPerConditions).forEach(_ => _.forEach(_ => _.disconnect()))
                    }
                },
                Tl = new rv,
                Th = new rv,
                Tc = new rv,
                Tu = new av,
                Tf = new rv,
                Tm = new rv,
                Tg = new rv,
                Tx = new rm,
                Tb = new r9,
                Tw = new rJ,
                T_ = new i$,
                TA = new rv,
                TT = new rv;

            function X1(_, O) {
                !O || (O[0] < O[1] && (_.x = Math.min(Math.max(_.x, O[0]), O[1])), O[2] < O[3] && (_.y = Math.min(Math.max(_.y, O[2]), O[3])), O[4] < O[5] && (_.z = Math.min(Math.max(_.z, O[4]), O[5])))
            }
            var TI = (t9 = new rJ, (_, O, B) => {
                    let N = _.obj;
                    t9.copy(N.hiddenMatrix), null !== N.parent && t9.premultiply(N.parent.matrixWorld), t9.invert(), N.position.copy(O), "global" === _.reference && X1(N.position, _.limits), N.position.applyMatrix4(t9), "parent" === _.reference ? X1(N.position, _.limits) : "local" === _.reference && (Tx.copy(_.quat0).invert(), N.position.sub(_.position0), N.position.applyQuaternion(Tx), X1(N.position, _.limits), Tx.invert(), N.position.applyQuaternion(Tx), N.position.add(_.position0)), t9.multiply(B ? ? N.matrixWorld).decompose(Tf, N.quaternion, Tm), N.updateMatrix(), N.hasNonUniformScale && (N.updateMatrixWorld(), N.updateMatrixWorldSVD()), N instanceof xK && Xn(N.parent) && N.invalidateDownstreamBooleanData(!0)
                }),
                TO = class {
                    constructor(_, O, B, N, k, F) {
                        this.object = _, this.data = O, this.dropDestIds = [], this.activeIdx = null, this.wasDragEventTriggered = !1, this.resetDampingFactor = 0 === this.data.resetSpeed ? 1 : 8 / this.data.resetSpeed + 1, this.snapDampingFactor = 0 === this.data.snapSpeed ? 1 : 8 / this.data.snapSpeed + 1, this.actionsDrag = nr(O, O.dragDropActions.drag, B, N, k, this.object), this.actionsDrop = nr(O, O.dragDropActions.drop, B, N, k, this.object);
                        let U = [];
                        this.data.objects.forEach(_ => {
                            let O = B.find(_);
                            !O || !1 !== O.data.visible && (U.push(O), F[O.uuid] && F[O.uuid].forEach(_ => {
                                let O = B.find(_);
                                O && !1 !== O.data.visible && U.push(O)
                            }))
                        }), this.data.dropDestinations.forEach(_ => {
                            let O = B.find(_);
                            !O || !1 !== O.data.visible && (this.dropDestIds.push(O.uuid), F[O.uuid] && F[O.uuid].forEach(_ => {
                                let O = B.find(_);
                                O && !1 !== O.data.visible && this.dropDestIds.push(O.uuid)
                            }))
                        }), this.dragItems = U.map(_ => ("locked" === this.data.planeMode && (_.userData.lockedPlane = !0), _.userData.worldPosition0 = new rv().setFromMatrixPosition(_.matrixWorld), {
                            obj: _,
                            fromPosition: new rv().setFromMatrixPosition(_.matrixWorld),
                            pointStart: new rv,
                            pointEnd: new rv,
                            paused: !0,
                            currentDampingFactor: this.data.dampingFactor,
                            reset: !1,
                            position0: new rv().copy(_.position),
                            quat0: new rm().copy(_.quaternion),
                            snapped: !1,
                            orientationMatrix: new rJ,
                            limits: this.data.limits,
                            reference: this.data.referenceFrame
                        }))
                    }
                    get activeDragItem() {
                        return null !== this.activeIdx ? this.dragItems[this.activeIdx] : null
                    }
                    dispose() {
                        qt(this.actionsDrag), qt(this.actionsDrop), this.dragItems.forEach(_ => {
                            _.fromPosition.copy(_.obj.userData.worldPosition0), _.pointStart.copy(_.fromPosition), _.pointEnd.copy(_.pointStart), _.obj.recursiveBBoxNeedsUpdate = !0, _.obj.userData.lockedPlane = void 0, _.obj.position.copy(_.position0), _.obj.quaternion.copy(_.quat0), _.obj.updateMatrix()
                        })
                    }
                },
                TL = class extends C8 {
                    constructor(_, O) {
                        super(_), this.eventManager = O, this.events = [], this.lastDropDestination = null, this.dragTimeout = null, this.onPointerDown = _ => {
                            if (dq.length > 1) return;
                            this.eventContext.updateRaycaster(_);
                            let {
                                raycaster: O,
                                page: B
                            } = this.eventContext, N = B.raycastWithClones(O);
                            if (this.lastDropDestination = null, 0 === N.length) {
                                this.activeEvent = null;
                                return
                            }
                            for (let _ of this.events) {
                                let O = 0;
                                for (let {
                                        obj: B,
                                        pointEnd: k,
                                        pointStart: F
                                    } of _.dragItems) {
                                    if (B === N[0].object || B === N[0].object.object || xu.is(B) && B.isAncestorOf(N[0].object.uuid)) {
                                        if (_.activeIdx = O, _.activeDragItem.reset = !1, _.activeDragItem.currentDampingFactor = _.data.dampingFactor, _.activeDragItem.snapped = !1, "hand" === _.data.cursor && this.setCursor("grabbing"), this.eventManager.controlsManager.usePhysics) {
                                            _.activeDragItem.obj.rigidBody && _.activeDragItem.obj.rigidBody.setBodyType(2, !0);
                                            let O = _.activeDragItem.obj;
                                            B.hasNonUniformScale && B.updateMatrixWorldSVD(), (O.hasNonUniformScale ? O.matrixWorldRigid : O.matrixWorld).decompose(Tf, Tx, Tm), Tb.setFromQuaternion(Tx), void 0 === O.prevR ? (O.prevR = Tb.clone(), O.prevT = Tf.clone()) : (O.prevR.copy(Tb), O.prevT.copy(Tf)), this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.push(_.activeDragItem.obj)
                                        }
                                        this.calcPlaneIntersectPos(B, F, _.data.plane, _.data.referenceFrame), k.copy(F), (this.eventManager.controlsManager.usePhysics && B.data.physics ? .rigidBody === "dynamic" || !1 === _.data.drop || !1 === _.data.resetOnSnapFail) && _.activeDragItem.fromPosition.setFromMatrixPosition(_.activeDragItem.obj.matrixWorld), this.activeEvent = _, this.eventManager.controlsManager.orbitControls && (this.eventManager.controlsManager.orbitControls.enabled = !1);
                                        return
                                    }
                                    O++
                                }
                            }
                            this.activeEvent = null
                        }, this.onPointerMove = _ => {
                            if (dq.length > 1) return;
                            this.eventContext.updateRaycaster(_);
                            let {
                                raycaster: O,
                                page: B
                            } = this.eventContext, N = B.raycastWithClones(O);
                            if (0 === dq.length) {
                                let _ = !1;
                                for (let O of this.events) {
                                    for (let {
                                            obj: B
                                        } of O.dragItems)
                                        if (B === N[0] ? .object || B === N[0] ? .object ? .object || xu.is(B) && B.isAncestorOf(N[0] ? .object.uuid)) {
                                            switch (_ = !0, O.data.cursor) {
                                                case "hand":
                                                    this.setCursor("grab");
                                                    break;
                                                case "move":
                                                    this.setCursor("move")
                                            }
                                            break
                                        }
                                    if (_) break
                                }
                                _ || this.setCursor("default");
                                return
                            }
                            if (this.activeEvent && this.activeEvent.activeDragItem) {
                                let _, O = this.activeEvent.activeDragItem;
                                if (O.snapped = !1, this.activeEvent.data.drop && (_ = N.filter(_ => O.obj !== _.object && !O.obj.isAncestorOf(_.object.uuid) && !(_.object instanceof Sy) && ("all" === this.activeEvent.data.dropOn || this.activeEvent.dropDestIds.some(O => O === _.object.uuid || B.scene.find(O).isAncestorOf(_.object.uuid))))[0]), _) {
                                    let B = Tg.copy(_.face.normal).applyMatrix3(T_.getNormalMatrix(_.object.matrixWorld));
                                    if ("center" === this.activeEvent.data.snapTo) O.fromPosition.setFromMatrixPosition(_.object.matrixWorld);
                                    else if ("surface" === this.activeEvent.data.snapTo) {
                                        if (O.fromPosition.copy(_.point), "bbox" === this.activeEvent.data.snapSurfaceMode) {
                                            Tf.copy(B).applyMatrix3(T_.setFromMatrix4(O.obj.matrixWorld).transpose());
                                            let _ = O.obj;
                                            Tf.x > .2 ? Tm.x = -_.recursiveBBox.min.x : Tf.x < -.2 && (Tm.x = -_.recursiveBBox.max.x), Tf.y > .2 ? Tm.y = -_.recursiveBBox.min.y : Tf.y < -.2 && (Tm.y = -_.recursiveBBox.max.y), Tf.z > .2 ? Tm.z = -_.recursiveBBox.min.z : Tf.z < -.2 && (Tm.z = -_.recursiveBBox.max.z), Tm.applyMatrix3(T_.invert())
                                        } else Tm.copy(B).multiplyScalar(this.activeEvent.data.snapSurfaceOffset);
                                        O.fromPosition.add(Tm)
                                    }
                                    this.activeEvent.data.autoOrient && (Tf.set(0, 1, 0).cross(B), 1e-4 > Tf.length() && Tf.set(-1, 0, 0).cross(B), Tm.crossVectors(Tg, Tf), O.orientationMatrix.makeBasis(Tf, Tm, B)), O.pointStart.copy(O.fromPosition), O.pointEnd.copy(O.pointStart), O.currentDampingFactor = this.activeEvent.snapDampingFactor, O.snapped = !0, this.lastDropDestination !== _.object && (this.lastDropDestination = _.object, this.activeEvent.actionsDrop.Transition.forEach(_ => {
                                        _.play()
                                    }), this.activeEvent.actionsDrop.Animation.forEach(_ => {
                                        _.play()
                                    }), this.activeEvent.actionsDrop.Audio.forEach(_ => {
                                        _.dispatchGameControl("start")
                                    }), this.activeEvent.actionsDrop.Create.forEach(_ => {
                                        _.dispatchThrottled()
                                    }))
                                } else O.orientationMatrix.makeRotationFromQuaternion(O.quat0), this.lastDropDestination = null, O.currentDampingFactor = this.activeEvent.data.dampingFactor, this.calcPlaneIntersectPos(O.obj, O.pointEnd, this.activeEvent.data.plane, this.activeEvent.data.referenceFrame), this.activeEvent.actionsDrop.Transition.forEach(_ => {
                                    _.stop(), null !== _.object.currentState && _.object.changeSelectedState(null, {
                                        scene: this.eventContext.page.scene,
                                        shared: this.eventContext.sharedAssets
                                    })
                                }), this.activeEvent.actionsDrop.Animation.forEach(_ => {
                                    _.stop()
                                }), this.activeEvent.actionsDrop.Audio.forEach(_ => {
                                    _.dispatchGameControl("stop")
                                });
                                this.activeEvent.actionsDrag.Create.forEach(_ => {
                                    _.dispatchThrottled()
                                }), this.activeEvent.actionsDrag.SetVariable.forEach(_ => _.checkConditions()), this.activeEvent.actionsDrag.SetVariable.forEach(_ => _.dispatch()), this.activeEvent.actionsDrag.DynamicVariablePlay.forEach(_ => _.dispatch()), !1 === this.activeEvent.wasDragEventTriggered && (this.activeEvent.wasDragEventTriggered = !0, this.activeEvent.actionsDrag.Transition.forEach(_ => {
                                    _.play()
                                }), this.activeEvent.actionsDrag.Animation.forEach(_ => {
                                    _.play()
                                }), this.activeEvent.actionsDrag.Audio.forEach(_ => {
                                    _.dispatchGameControl("start")
                                })), this.dragTimeout && window.clearTimeout(this.dragTimeout), this.dragTimeout = window.setTimeout(() => {
                                    this.activeEvent && (this.activeEvent.wasDragEventTriggered = !1, this.activeEvent.actionsDrag.Audio.forEach(_ => {
                                        _.dispatchGameControl("stop")
                                    }), this.activeEvent.actionsDrag.Transition.forEach(_ => {
                                        _.stop(), null !== _.object.currentState && _.object.changeSelectedState(null, {
                                            scene: this.eventContext.page.scene,
                                            shared: this.eventContext.sharedAssets
                                        })
                                    }), this.activeEvent.actionsDrag.Animation.forEach(_ => {
                                        _.stop()
                                    }))
                                }, 500), this.updateDragItem(O), O.obj.dispatchEvent({
                                    type: "requestRender"
                                })
                            }
                        }, this.onPointerUp = _ => {
                            if (this.activeEvent && this.activeEvent.activeDragItem) {
                                "hand" === this.activeEvent.data.cursor && this.setCursor("grab");
                                let _ = this.activeEvent.activeDragItem.obj.data.physics ? .rigidBody === "dynamic";
                                !1 === this.activeEvent.activeDragItem.snapped && this.activeEvent.data.drop && this.activeEvent.data.resetOnSnapFail && (!1 === this.eventManager.controlsManager.usePhysics || !_) && (this.activeEvent.activeDragItem.reset = this.activeEvent.data.resetOnSnapFail, this.activeEvent.activeDragItem.paused = !1, this.activeEvent.activeDragItem.currentDampingFactor = this.activeEvent.resetDampingFactor), this.eventManager.controlsManager.usePhysics && _ && (this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.pop(), this.activeEvent.activeDragItem.obj.rigidBody.setBodyType(0, !0), this.activeEvent.activeDragItem.paused = !0), !0 === this.activeEvent.wasDragEventTriggered && (this.activeEvent.wasDragEventTriggered = !1, this.activeEvent.actionsDrag.Transition.forEach(_ => {
                                    _.stop(), null !== _.object.currentState && _.object.changeSelectedState(null, {
                                        scene: this.eventContext.page.scene,
                                        shared: this.eventContext.sharedAssets
                                    })
                                }), this.activeEvent.actionsDrag.Animation.forEach(_ => {
                                    _.stop()
                                }), this.activeEvent.actionsDrag.Audio.forEach(_ => {
                                    _.dispatchGameControl("stop")
                                }), this.activeEvent.actionsDrop.SetVariable.forEach(_ => _.checkConditions()), this.activeEvent.actionsDrop.SetVariable.forEach(_ => _.dispatch()), this.activeEvent.actionsDrop.DynamicVariablePlay.forEach(_ => _.dispatch())), this.eventManager.controlsManager.orbitControls && (this.eventManager.controlsManager.orbitControls.enabled = !0)
                            }
                        };
                        let B = {};
                        _.page.traverseEntity(_ => {
                            _.component && (B[_.component.uuid] ? B[_.component.uuid].push(_.uuid) : B[_.component.uuid] = [_.uuid])
                        }), _.page.traverseEntity(N => {
                            N.data ? .events.filter(_ => "DragDrop" === _.data.type && !_.data.disabled).forEach(k => {
                                this.events.push(new TO(N, k.data, _.page, _.sharedAssets, O, B))
                            })
                        })
                    }
                    connect() {
                        if (!this.events.length) return;
                        this.domEventsNeeded.clear(), this.domEventsNeeded.add("pointerdown");
                        let _ = this.eventContext.domElement;
                        _.addEventListener("pointerdown", this.onPointerDown), _.addEventListener("pointermove", this.onPointerMove), _.addEventListener("pointerup", this.onPointerUp), this.domEventsNeeded.add("pointermove")
                    }
                    disconnect() {
                        if (!this.events.length) return;
                        this.domEventsNeeded.clear();
                        let _ = this.eventContext.domElement;
                        _.removeEventListener("pointerdown", this.onPointerDown), _.removeEventListener("pointermove", this.onPointerMove), _.removeEventListener("pointerup", this.onPointerUp), this.events.forEach(_ => _.dispose())
                    }
                    setCursor(_) {
                        this.eventContext.domElement.style.cursor = _
                    }
                    onAnimationFrameDamping() {
                        for (let _ of this.events)
                            for (let O of _.dragItems) O.paused || this.updateDragItem(O, !0)
                    }
                    calcPlaneIntersectPos(_, O, B, N) {
                        let {
                            getCamera: k,
                            raycaster: F
                        } = this.eventContext;
                        k().getWorldDirection(Th), Th.negate();
                        let U = Tx.identity();
                        switch ("parent" === N ? Tw.multiplyMatrices(_.parent.matrixWorld, _.hiddenMatrix).decompose(Tf, U, Tm) : "local" === N && _.matrixWorld.decompose(Tf, U, Tm), B) {
                            case "x":
                                Tf.set(1, 0, 0).applyQuaternion(U), TA.copy(Th).cross(Tf), TT.copy(Tf).cross(TA);
                                break;
                            case "y":
                                Tf.set(0, 1, 0).applyQuaternion(U), TA.copy(Th).cross(Tf), TT.copy(Tf).cross(TA);
                                break;
                            case "z":
                                Tf.set(0, 0, 1).applyQuaternion(U), TA.copy(Th).cross(Tf), TT.copy(Tf).cross(TA);
                                break;
                            case "xy":
                                TT.set(0, 0, 1).applyQuaternion(U);
                                break;
                            case "yz":
                                TT.set(1, 0, 0).applyQuaternion(U);
                                break;
                            case "xz":
                                TT.set(0, 1, 0).applyQuaternion(U);
                                break;
                            case "adaptive":
                                Th.angleTo(Tm.set(0, 1, 0)) > Math.PI / 6 ? (Tf.crossVectors(Tm.set(0, 1, 0), Th), TT.crossVectors(Tf, Tm)) : TT.set(0, 1, 0);
                                break;
                            default:
                                TT.copy(Th)
                        }
                        Tc.setFromMatrixPosition(_.matrixWorld);
                        let j = _.userData.lockedPlane ? _.userData.worldPosition0 : Tc;
                        if (Tu.setFromNormalAndCoplanarPoint(TT, j), F.ray.intersectPlane(Tu, O) && ("x" === B || "y" === B || "z" === B)) {
                            let _ = Tm.subVectors(O, j).dot(Tf);
                            O.copy(j).addScaledVector(Tf, _)
                        }
                    }
                    updateDragItem(_, O = !1) {
                        Tc.setFromMatrixPosition(_.obj.matrixWorld), "current" === _.reset ? Tl.subVectors(_.fromPosition, Tc).divideScalar(_.currentDampingFactor) : "original" === _.reset ? (Tl.subVectors(_.obj.userData.worldPosition0, Tc).divideScalar(_.currentDampingFactor), _.fromPosition.copy(_.obj.userData.worldPosition0), _.pointStart.copy(_.fromPosition), _.pointEnd.copy(_.pointStart)) : Tl.subVectors(_.pointEnd, _.pointStart).add(_.fromPosition).sub(Tc).divideScalar(_.currentDampingFactor), _.paused = !(_.currentDampingFactor > 1) || .01 > Tl.length(), (this.activeEvent && 1 === this.activeEvent.data.dampingFactor || O) && TI(_, Tl.add(Tc), this.activeEvent ? .data.drop && this.activeEvent ? .data.autoOrient ? _.orientationMatrix : null), _.obj.dispatchEvent({
                            type: "beginEvent",
                            eventName: "DragDrop"
                        }), this.eventManager.requestRender()
                    }
                },
                TR = new rv,
                TB = new rv,
                Tz = new rv,
                TN = new rv,
                Tk = new av,
                TF = {
                    type: "requestRender"
                },
                TU = (t7 = new rv, ie = new rv, (_, O, B) => B > 0 ? (t7.subVectors(_, O), t7.length() <= B ? _ : ie.copy(O).add(t7.normalize().multiplyScalar(B))) : O),
                Tj = (it = new rJ, (_, O) => {
                    _.position.copy(O), null !== _.parent && (it.copy(_.parent.matrixWorld).invert(), _.position.applyMatrix4(it)), it.copy(_.hiddenMatrix).invert(), _.position.applyMatrix4(it), _.updateMatrix(), _.hasNonUniformScale && (_.updateMatrixWorld(), _.updateMatrixWorldSVD()), _ instanceof xK && Xn(_.parent) && _.invalidateDownstreamBooleanData(!0)
                }),
                TG = class {
                    constructor(_, O, B, N, k) {
                        this.data = _, this.object = O, this.paused = !1, this.currentDampingFactor = 1, this.snapComplete = !1, this.isReset = !1, this.worldPosition0 = new rv, this.timeoutId = null, this.delayFinished = !0, this.wasOutside = !1, this.data = { ...fE.defaultData,
                            ..._,
                            ...void 0 === _.resetOnPointerLeave && {
                                resetOnPointerLeave: !1
                            }
                        }, void 0 === _.target || "cursor" === _.target || (this.target = B.find(_.target)), this.data.dampingFactor && (this.currentDampingFactor = this.data.dampingFactor), this.resetDampingFactor = 80 / this.data.resetSpeed + 1, this.object.getWorldPosition(this.worldPosition0), this.actions = nr(_, _.actions, B, N, k, O)
                    }
                },
                TH = class extends C8 {
                    constructor(_, O) {
                        super(_), this.events = [], this.pairOfEventListeners = [], this.onMouseMove = _ => {
                            if (!(dq.length > 1))
                                for (let O of (this.eventContext.updateRaycaster(_), this.events)) void 0 === O.target && this.updateSingleEvent(O)
                        }, this.onMouseEnter = _ => {
                            for (let _ of this.events) void 0 === _.target && (_.isReset = !1, _.currentDampingFactor = _.data.dampingFactor)
                        }, this.onMouseLeave = _ => {
                            for (let _ of this.events) void 0 === _.target && (_.data.resetOnPointerLeave && (_.isReset = !0, _.currentDampingFactor = _.resetDampingFactor), this.updateSingleEvent(_))
                        }, this.onTargetChange = _ => () => {
                            this.updateSingleEvent(_)
                        };
                        let {
                            page: B
                        } = this.eventContext;
                        B.traverseEntity(N => {
                            let k = N.data ? .events.find(_ => "Follow" === _.data.type && !_.data.disabled);
                            k && (!B.data.globalPhysics.usePhysics || N.dataPatched.physics ? .rigidBody !== "dynamic") && this.events.push(new TG(k.data, N, B, _.sharedAssets, O))
                        })
                    }
                    connect() {
                        if (!this.events.length) return;
                        let {
                            domElement: _,
                            eventElement: O
                        } = this.eventContext;
                        for (let B of (this.domEventsNeeded.clear(), dG && (this.domEventsNeeded.add("pointerdown"), _.addEventListener("pointerdown", this.onMouseMove)), this.domEventsNeeded.add("pointermove"), O.addEventListener("pointermove", this.onMouseMove), this.eventContext.useWindowEvents || (_.addEventListener("pointerenter", this.onMouseEnter), _.addEventListener("pointerleave", this.onMouseLeave)), this.events))
                            if (void 0 !== B.target) {
                                let _ = B.target,
                                    O = this.onTargetChange(B);
                                this.pairOfEventListeners.push([_, O]), _.addEventListener("requestRender", O)
                            }
                    }
                    disconnect() {
                        if (!this.events.length) return;
                        let {
                            domElement: _,
                            eventElement: O
                        } = this.eventContext;
                        for (let [B, N] of (this.domEventsNeeded.clear(), dG && _.removeEventListener("pointerdown", this.onMouseMove), O.removeEventListener("pointermove", this.onMouseMove), _.removeEventListener("pointerenter", this.onMouseEnter), _.removeEventListener("pointerleave", this.onMouseLeave), this.pairOfEventListeners)) B.removeEventListener("requestRender", N);
                        for (let _ of this.events) _.paused = !0, _.isReset = !1, qt(_.actions)
                    }
                    onAnimationFrameDamping() {
                        for (let _ of this.events) _.paused || this.updateSingleEvent(_, !0)
                    }
                    updateSingleEvent(_, O = !1) {
                        this.events.forEach(_ => {
                            _.actions.Create.forEach(_ => {
                                _.dispatchThrottled()
                            })
                        });
                        let {
                            plane: B,
                            limitDistance: N,
                            limitDistanceEnabled: k
                        } = _.data;
                        if (_.object.getWorldPosition(Tz), _.isReset) TN.copy(_.worldPosition0);
                        else if (_.target) _.target.getWorldPosition(TN);
                        else {
                            let {
                                getCamera: _,
                                raycaster: O
                            } = this.eventContext;
                            if ("custom" === B ? (_().getWorldDirection(TB), TB.negate(), TR.copy(TB)) : "xy" === B ? TR.set(0, 0, 1) : "xz" === B ? TR.set(0, 1, 0) : "yz" === B && TR.set(1, 0, 0), Tk.setFromNormalAndCoplanarPoint(TR, Tz), !O.ray.intersectPlane(Tk, TN)) return
                        }
                        if (!_.isReset) {
                            if (TN.distanceTo(_.worldPosition0) > N && k && _.target) {
                                if (_.snapComplete = !1, _.data.snapDelay && (_.delayFinished = !1, "u" > typeof window && null !== _.timeoutId && (window.clearTimeout(_.timeoutId), _.timeoutId = null)), _.wasOutside = !0, !_.data.resetAfterDistanceLimit) return;
                                TN.copy(_.worldPosition0), _.currentDampingFactor = _.resetDampingFactor
                            } else if (_.wasOutside && (_.data.snapDelay && "u" > typeof window && (_.timeoutId = window.setTimeout(() => {
                                    _.delayFinished = !0, _.paused = !1, this.updateSingleEvent(_)
                                }, 1e3 * _.data.snapDelay)), _.currentDampingFactor = _.data.dampingFactor, _.wasOutside = !1), !1 === _.delayFinished) return
                        }!1 === _.data.enabledTranslation[0] && (TN.x = Tz.x), !1 === _.data.enabledTranslation[1] && (TN.y = Tz.y), !1 === _.data.enabledTranslation[2] && (TN.z = Tz.z);
                        let F = TU(Tz, TN, _.wasOutside ? 0 : _.data.maxDelta);
                        if (_.currentDampingFactor > 1) {
                            let B = TR.subVectors(F, Tz).divideScalar(_.currentDampingFactor);
                            Tz.add(B), O && Tj(_.object, Tz), _.paused = .01 > B.length()
                        } else Tj(_.object, F), _.paused = !0;
                        _.object ? .dispatchEvent({
                            type: "beginEvent",
                            eventName: "Follow"
                        }), _.object.dispatchEvent(TF)
                    }
                },
                TW = new rv,
                Tq = new rv,
                TY = new rJ,
                TX = new rm,
                TQ = new rm,
                TZ = new rv,
                TK = new rv,
                TJ = new rv,
                T$ = new rv,
                T0 = new av,
                T2 = {
                    type: "requestRender"
                },
                T3 = {
                    type: "changeRotation"
                },
                T4 = (ii = new rJ, function(_, O) {
                    null !== _.parent ? ii.multiplyMatrices(_.parent.matrixWorld, _.hiddenMatrix) : ii.copy(_.hiddenMatrix), O.premultiply(U1(ii).invert()), _.rotation.setFromRotationMatrix(O), _.updateMatrix(), _ instanceof xK && Xn(_.parent) && _.invalidateDownstreamBooleanData(!0)
                }),
                T5 = class {
                    constructor(_, O, B) {
                        this.object = O, this.paused = !1, this.currentDampingFactor = 1, this.isReset = !1, this.worldQuaternion0 = new rm, this.timeoutId = null, this.delayFinished = !0, this.wasOutside = !1, this.data = { ...fC.defaultData,
                            ..._,
                            ...void 0 === _.resetOnPointerLeave && {
                                resetOnPointerLeave: !1
                            }
                        }, void 0 === _.target || "cursor" === _.target || (this.target = B.find(_.target)), this.data.dampingFactor && (this.currentDampingFactor = this.data.dampingFactor), this.object.getWorldQuaternion(this.worldQuaternion0), this.resetDampingFactor = 80 / this.data.resetSpeed + 1
                    }
                },
                T6 = class extends C8 {
                    constructor(_) {
                        super(_), this.events = [], this.pairOfEventListeners = [], this.pairOfUserEventListeners = [], this.onMouseMove = _ => {
                            if (!(dq.length > 1))
                                for (let O of (this._lastMouseEvent = _, this.eventContext.updateRaycaster(_), this.events)) void 0 === O.target && this.updateSingleEvent(O)
                        }, this.onMouseEnter = _ => {
                            for (let _ of this.events) void 0 === _.target && (_.isReset = !1, _.currentDampingFactor = _.data.dampingFactor)
                        }, this.onMouseLeave = _ => {
                            for (let _ of this.events) void 0 === _.target && (_.data.resetOnPointerLeave && (_.isReset = !0, _.currentDampingFactor = _.resetDampingFactor), this.updateSingleEvent(_))
                        }, this.onScroll = _ => {
                            if (this._lastMouseEvent) {
                                let _ = new PointerEvent("pointermove", {
                                    clientX: this._lastMouseEvent.clientX,
                                    clientY: this._lastMouseEvent.clientY,
                                    bubbles: !0,
                                    cancelable: !0,
                                    view: window
                                });
                                this.eventContext.eventElement.dispatchEvent(_)
                            }
                        }, this.onTargetChange = _ => () => {
                            this.updateSingleEvent(_)
                        }, this.createUserEventListener = _ => ({
                            eventName: O,
                            target: B
                        }) => {
                            if (!O || !B) return;
                            let N = Co(O);
                            N && "LookAt" === N && this.updateSingleEvent(_)
                        };
                        let {
                            page: O
                        } = this.eventContext;
                        O.traverseEntity(_ => {
                            let B = _.data ? .events.find(_ => "LookAt" === _.data.type && !_.data.disabled);
                            B && (!O.data.globalPhysics.usePhysics || _.dataPatched.physics ? .rigidBody !== "dynamic") && this.events.push(new T5(B.data, _, O))
                        })
                    }
                    connect() {
                        if (!this.events.length) return;
                        let {
                            domElement: _,
                            eventElement: O
                        } = this.eventContext;
                        for (let B of (this.domEventsNeeded.clear(), dG && (this.domEventsNeeded.add("pointerdown"), _.addEventListener("pointerdown", this.onMouseMove)), this.domEventsNeeded.add("pointermove"), O.addEventListener("pointermove", this.onMouseMove), this.eventContext.useWindowEvents ? O.addEventListener("scroll", this.onScroll) : (_.addEventListener("pointerenter", this.onMouseEnter), _.addEventListener("pointerleave", this.onMouseLeave)), this.events)) {
                            if (void 0 !== B.target) {
                                let _ = this.onTargetChange(B),
                                    O = B.target;
                                this.pairOfEventListeners.push([O, _]), O.addEventListener("requestRender", _)
                            }
                            let _ = this.createUserEventListener(B),
                                O = B.object;
                            this.pairOfUserEventListeners.push([O, _]), O.addEventListener("userEvent", _)
                        }
                    }
                    disconnect() {
                        if (!this.events.length) return;
                        let {
                            domElement: _,
                            eventElement: O
                        } = this.eventContext;
                        for (let [B, N] of (this.domEventsNeeded.clear(), dG && _.removeEventListener("pointerdown", this.onMouseMove), O.removeEventListener("pointermove", this.onMouseMove), _.removeEventListener("pointerenter", this.onMouseEnter), _.removeEventListener("pointerleave", this.onMouseLeave), O.removeEventListener("scroll", this.onScroll), this.pairOfEventListeners)) B.removeEventListener("requestRender", N);
                        for (let [_, O] of this.pairOfUserEventListeners) _.removeEventListener("userEvent", O);
                        for (let _ of this.events) _.paused = !0, _.isReset = !1
                    }
                    onAnimationFrameDamping() {
                        for (let _ of this.events) _.paused || this.updateSingleEvent(_)
                    }
                    updateSingleEvent(_) {
                        let {
                            tilt: O,
                            axis: B,
                            distance: N,
                            plane: k,
                            limitDistance: F,
                            enabledRotation: U,
                            limitDistanceEnabled: j
                        } = _.data, {
                            getCamera: G,
                            raycaster: Y
                        } = this.eventContext, {
                            object: Q,
                            target: K
                        } = _;
                        if (Q.getWorldPosition(TZ), !_.isReset) {
                            if (_.target) _.target.getWorldPosition(TK);
                            else {
                                if ("custom" === k ? (G().getWorldDirection(Tq), Tq.negate(), T0.setFromNormalAndCoplanarPoint(Tq, TZ)) : ("xy" === k ? TW.set(0, 0, 1) : "xz" === k ? TW.set(0, 1, 0) : "yz" === k && TW.set(1, 0, 0), T0.setFromNormalAndCoplanarPoint(TW, TZ)), !Y.ray.intersectPlane(T0, TK)) return;
                                N > 0 && ("custom" === k || void 0 === k) && TK.addScaledVector(Tq, N)
                            }
                        }
                        if (_.isReset || (K ? "target" === O ? TJ.copy(K.up).applyMatrix4(TY.extractRotation(K.matrixWorld)).normalize() : U.some(_ => !1 === _) ? ("x" === B ? (T$.set(0, 0, 1), !1 === U[2] && T$.set(0, 1, 0)) : "y" === B ? (T$.set(1, 0, 0), !1 === U[0] && T$.set(0, 0, 1)) : (T$.set(0, 1, 0), !1 === U[1] && T$.set(1, 0, 0)), TJ.copy(T$).applyQuaternion(_.worldQuaternion0).normalize()) : TJ.set(0, 1, 0) : "custom" === k ? TJ.set(0, 1, 0) : TJ.copy(TW)), _.isReset) TQ.copy(_.worldQuaternion0);
                        else if (TZ.distanceTo(TK) > F && j && K) {
                            if (_.data.snapDelay && (_.delayFinished = !1, "u" > typeof window && null !== _.timeoutId && (window.clearTimeout(_.timeoutId), _.timeoutId = null)), _.wasOutside = !0, !_.data.resetAfterDistanceLimit) return;
                            TQ.copy(_.worldQuaternion0), _.currentDampingFactor = _.resetDampingFactor
                        } else {
                            let N;
                            if (_.wasOutside && (_.data.snapDelay && "u" > typeof window && (_.timeoutId = window.setTimeout(() => {
                                    _.delayFinished = !0, _.paused = !1, this.updateSingleEvent(_)
                                }, 1e3 * _.data.snapDelay)), _.currentDampingFactor = _.data.dampingFactor, _.wasOutside = !1), !1 === _.delayFinished) return;
                            N = TY.elements, T7.subVectors(TK, TZ), 0 === T7.lengthSq() && (T7.z = 1), T7.normalize(), T9.crossVectors(TJ, T7), 0 === T9.lengthSq() && (1 === Math.abs(TJ.z) ? T7.x += 1e-4 : T7.z += 1e-4, T7.normalize(), T9.crossVectors(TJ, T7)), T9.normalize(), T8.crossVectors(T7, T9), "x" === B ? 1 === T$.z ? [T9, T8, T7] = [T7, T9, T8] : (T9.negate(), [T9, T7] = [T7, T9]) : "y" === B ? 1 === T$.x ? [T9, T8, T7] = [T8, T7, T9] : (T9.negate(), [T8, T7] = [T7, T8]) : 1 === T$.x && (T9.negate(), [T9, T8] = [T8, T9]), N[0] = T9.x, N[4] = T8.x, N[8] = T7.x, N[1] = T9.y, N[5] = T8.y, N[9] = T7.y, N[2] = T9.z, N[6] = T8.z, N[10] = T7.z, TQ.setFromRotationMatrix(TY), TX.setFromUnitVectors(T$.applyQuaternion(TQ), TJ), U.some(_ => !1 === _) && "target" !== O && TQ.premultiply(TX).normalize()
                        }
                        _.currentDampingFactor > 1 ? (Q.updateWorldMatrix(!0, !1), TX.setFromRotationMatrix(U1(Q.matrixWorld)), TX.slerp(TQ, 1 / _.currentDampingFactor), T4(Q, TY.makeRotationFromQuaternion(TX)), _.paused = 8 * (1 - TX.dot(TQ)) < 1e-6) : (T4(Q, TY.makeRotationFromQuaternion(TQ)), _.paused = !0), _.object ? .dispatchEvent({
                            type: "beginEvent",
                            eventName: "LookAt"
                        }), Q.dispatchEvent(T2), Q.dispatchEvent(T3)
                    }
                },
                T8 = new rv,
                T9 = new rv,
                T7 = new rv,
                De = class {
                    constructor(_, O, B, N, k, F) {
                        this.id = _, this.data = O, this.object = B, this.entered = !1, this.actions = nr(O, O.actions, N, k, F, B)
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    dispatchEnter() {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), this.entered || (this.entered = !0, this.actions.Transition.forEach(_ => _.playFromCurrent()), this.actions.Animation.forEach(_ => _.play()), this.actions.Create.forEach(_ => _.dispatch()), this.actions.Destroy.forEach(_ => _.dispatch()), this.actions.SwitchCamera.forEach(_ => _.playFromCurrent()), this.actions.SceneTransition.forEach(_ => _.dispatch()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch()))
                    }
                    dispatchLeave() {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), this.entered && (this.entered = !1, this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.reverseFromCurrent()))
                    }
                    dispatchUserEvent(_) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), _ ? (this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.Animation.forEach(_ => _.reverseFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.reverseFromCurrent())) : (this.actions.Transition.forEach(_ => _.playFromCurrent()), this.actions.Animation.forEach(_ => _.playFromCurrent()), this.actions.Create.forEach(_ => _.dispatch()), this.actions.Destroy.forEach(_ => _.dispatch()), this.actions.SwitchCamera.forEach(_ => _.playFromCurrent())), this.actions.SceneTransition.forEach(_ => _.dispatch()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                },
                Di = class extends C8 {
                    constructor(_, O) {
                        super(_), this.eventsPerObjects = {}, this.objects = [], this._prevObjects = [], this.onMouseDown = _ => {
                            dq.length > 1 || (this.eventContext.updateRaycaster(_), this.handleMouseHoverEvent())
                        }, this.onMouseUp = _ => {
                            dq.length > 1 || this.handleMouseHoverEvent(!0)
                        }, this.onMouseMove = _ => {
                            dq.length > 1 || (this.eventContext.updateRaycaster(_), this.handleMouseHoverEvent())
                        }, this.onUserEvent = ({
                            eventName: _,
                            target: O,
                            reverse: B
                        }) => {
                            if (!_ || !O) return;
                            let N = Co(_);
                            N && "MouseHover" === N && (O.dispatchEvent({
                                type: "beginEvent",
                                eventName: "MouseHover"
                            }), this.eventsPerObjects[O.uuid] ? .forEach(_ => _.dispatchUserEvent(B)))
                        };
                        let {
                            page: B,
                            sharedAssets: N
                        } = this.eventContext;
                        B.traverseEntity(_ => {
                            if (!(!_.visible || !_.data ? .events.length)) {
                                for (let {
                                        id: k,
                                        data: F
                                    } of _.data.events)
                                    if (!F.disabled && "MouseHover" === F.type) try {
                                        let U = new De(k, F, _, B, N, O);
                                        this.eventsPerObjects[_.uuid] ? this.eventsPerObjects[_.uuid].push(U) : this.eventsPerObjects[_.uuid] = [U]
                                    } catch (_) {}
                                this.eventsPerObjects[_.uuid] ? .length && this.objects.push(_)
                            }
                        })
                    }
                    connect() {
                        if (!this.objects.length) return;
                        let {
                            domElement: _
                        } = this.eventContext;
                        this.domEventsNeeded.clear(), dG && (this.domEventsNeeded.add("pointerdown"), _.addEventListener("pointerdown", this.onMouseDown), this.domEventsNeeded.add("pointerup"), _.addEventListener("pointerup", this.onMouseUp)), this.domEventsNeeded.add("pointermove"), _.addEventListener("pointermove", this.onMouseMove), this.objects.forEach(_ => {
                            _.addEventListener("userEvent", this.onUserEvent)
                        })
                    }
                    disconnect() {
                        if (!this.objects.length) return;
                        let {
                            domElement: _
                        } = this.eventContext;
                        this.domEventsNeeded.clear(), dG && (_.removeEventListener("pointerdown", this.onMouseDown), _.removeEventListener("pointerup", this.onMouseUp)), _.removeEventListener("pointermove", this.onMouseMove), Object.values(this.eventsPerObjects).forEach(_ => {
                            _.forEach(_ => {
                                _.disconnect()
                            })
                        }), this.objects.forEach(_ => {
                            _.removeEventListener("userEvent", this.onUserEvent)
                        })
                    }
                    handleMouseHoverEvent(_ = !1) {
                        let O = [];
                        if (!_) {
                            let {
                                stopRaycast: _,
                                raycaster: B,
                                page: N
                            } = this.eventContext;
                            _ ? O = Em( of (B, N, this.objects)) : this.objects.forEach(_ => {
                                af(B, _) && O.push(_)
                            })
                        }
                        this._prevObjects.length && this._prevObjects.forEach(_ => {
                            O.includes(_) || (_.dispatchEvent({
                                type: "beginEvent",
                                eventName: "MouseHover"
                            }), this.eventsPerObjects[_.uuid] ? .forEach(_ => _.dispatchLeave()))
                        }), O.length && O.forEach(_ => {
                            _.dispatchEvent({
                                type: "beginEvent",
                                eventName: "MouseHover"
                            }), this.eventsPerObjects[_.uuid] ? .forEach(_ => _.dispatchEnter())
                        }), this._prevObjects = O
                    }
                },
                Ds = class {
                    constructor(_, O, B, N, k, F) {
                        this.id = _, this.data = O, this.object = B, this.scrollCounter = 0, this.actions = nr(O, O.actions, N, k, F, B)
                    }
                    connect() {
                        this.scrollCounter = 0
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    dispatch(_) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        });
                        let O = _ > 0 ? 1 : -1;
                        this.scrollCounter += O, this.scrollCounter = Math.min(Math.max(this.scrollCounter, 0), this.data.steps);
                        let B = this.scrollCounter / this.data.steps;
                        this.actions.Transition.forEach(_ => _.seek(B)), this.actions.Animation.forEach(_ => _.seek(O)), this.actions.Create.forEach(_ => _.dispatchThrottled()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                    dispatchUserEvent(_) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), _ ? (this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.Animation.forEach(_ => _.reverseFromCurrent())) : (this.actions.Transition.forEach(_ => {
                            _.playFromCurrent()
                        }), this.actions.Animation.forEach(_ => {
                            _.playFromCurrent()
                        })), this.actions.Create.forEach(_ => _.dispatchThrottled()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                },
                Da = class {
                    constructor(_, O, B, N, k, F, U) {
                        this.id = _, this.data = O, this.object = B, this.domElement = F, this.eventManager = U, this.scrollStart = 0, this.scrollEnd = 0, this.actions = nr(O, O.actions, N, k, U, B)
                    }
                    computeScrollBounds() {
                        let _ = this.domElement.getBoundingClientRect(),
                            O = document.body,
                            B = document.documentElement,
                            N = window.pageYOffset || B.scrollTop || O.scrollTop,
                            k = B.clientTop || O.clientTop || 0,
                            F = Math.round(_.top + N - k);
                        if ("enter" === this.data.startFrom) {
                            let O = window.innerHeight,
                                B = _.height,
                                N = this.data.enterAnchor;
                            this.scrollStart = F - ("top" === N ? O : "bottom" === N ? O - B : O - .5 * B)
                        } else this.scrollStart = 0;
                        this.scrollStart += this.data.startOffset ? ? 0, this.scrollEnd = this.scrollStart + (this.data.endAfter ? ? 400), this.box = _, this.computeScroll({
                            x: window.scrollX,
                            y: window.scrollY
                        })
                    }
                    connect() {
                        this.computeScrollBounds()
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    handleResize() {
                        this.computeScrollBounds()
                    }
                    get isInvalidBox() {
                        return void 0 === this.box || 0 === this.box.width && 0 === this.box.height && 0 === this.box.top && 0 === this.box.bottom
                    }
                    computeScroll({
                        x: _,
                        y: O
                    }) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        });
                        let B = this.scrollEnd - this.scrollStart,
                            N = Math.min(1, Math.max(0, (O - this.scrollStart) / B));
                        this.actions.Transition.forEach(_ => _.seek(N)), this.actions.Animation.forEach(_ => _.seek(N)), this.actions.Create.forEach(_ => _.dispatchThrottled()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                    dispatch(_) {
                        this.isInvalidBox && this.computeScrollBounds(), this.computeScroll(_)
                    }
                    dispatchUserEvent(_) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), _ ? (this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.Animation.forEach(_ => _.reverseFromCurrent())) : (this.actions.Transition.forEach(_ => {
                            _.playFromCurrent()
                        }), this.actions.Animation.forEach(_ => {
                            _.playFromCurrent()
                        })), this.actions.Create.forEach(_ => _.dispatchThrottled()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                },
                Dn = class extends C8 {
                    constructor(_, O) {
                        super(_), this.wheelEventsPerObject = new Map, this.scrollEventsPerObject = new Map, this.isInview = !0, this.handleResize = () => {
                            [...this.scrollEventsPerObject.entries()].forEach(([_, O]) => {
                                O.forEach(_ => _.handleResize())
                            })
                        }, this.onScroll = _ => {
                            if (!this.isInview) return;
                            let O = {
                                y: window.scrollY,
                                x: window.scrollX
                            };
                            [...this.scrollEventsPerObject.entries()].forEach(([_, B]) => {
                                _.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Scroll",
                                    scroll: O
                                }), B.forEach(_ => _.dispatch(O))
                            })
                        }, this.onWheel = _ => {
                            !this.isInview || _.ctrlKey || [...this.wheelEventsPerObject.entries()].forEach(([O, B]) => {
                                O.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Scroll",
                                    deltaY: _.deltaY
                                }), B.forEach(O => O.dispatch(_.deltaY))
                            })
                        }, this.onUserEvent = ({
                            eventName: _,
                            target: O,
                            reverse: B
                        }) => {
                            if (!_ || !O) return;
                            let N = Co(_);
                            N && "Scroll" === N && (O.dispatchEvent({
                                type: "beginEvent",
                                eventName: "Scroll"
                            }), this.wheelEventsPerObject.get(O) ? .forEach(_ => {
                                _.dispatchUserEvent(B)
                            }))
                        };
                        let {
                            page: B,
                            sharedAssets: N,
                            domElement: k,
                            isExport: F
                        } = this.eventContext;
                        B.traverseEntity(_ => {
                            if (_.data ? .events.length) {
                                for (let {
                                        id: U,
                                        data: j
                                    } of _.data.events)
                                    if (!j.disabled && "Scroll" === j.type) {
                                        if ("load" !== j.trigger && F) {
                                            let F = new Da(U, j, _, B, N, k, O);
                                            this.scrollEventsPerObject.has(_) ? this.scrollEventsPerObject.get(_) ? .push(F) : this.scrollEventsPerObject.set(_, [F])
                                        } else {
                                            let k = new Ds(U, j, _, B, N, O);
                                            this.wheelEventsPerObject.has(_) ? this.wheelEventsPerObject.get(_) ? .push(k) : this.wheelEventsPerObject.set(_, [k])
                                        }
                                    }
                            }
                        }), this.intersectionObserver = new IntersectionObserver(_ => {
                            let O = _[0];
                            O && (this.isInview = O.isIntersecting)
                        }, {
                            root: null
                        })
                    }
                    connect() {
                        this.intersectionObserver.observe(this.eventContext.domElement), [...this.wheelEventsPerObject.entries()].forEach(([_, O]) => {
                            O.forEach(_ => _.connect()), _.addEventListener("userEvent", this.onUserEvent)
                        }), [...this.scrollEventsPerObject.entries()].forEach(([_, O]) => {
                            O.forEach(_ => _.connect()), _.addEventListener("userEvent", this.onUserEvent)
                        }), [...this.wheelEventsPerObject.values()].some(_ => _.length) && (this.domEventsNeeded.add("wheel"), window.addEventListener("wheel", this.onWheel)), [...this.scrollEventsPerObject.values()].some(_ => _.length) && (this.domEventsNeeded.add("scroll"), window.addEventListener("scroll", this.onScroll), window.addEventListener("resize", this.handleResize))
                    }
                    disconnect() {
                        window.removeEventListener("wheel", this.onWheel), window.removeEventListener("scroll", this.onScroll), window.removeEventListener("resize", this.handleResize), this.intersectionObserver.unobserve(this.eventContext.domElement), this.domEventsNeeded.clear(), [...this.wheelEventsPerObject.entries()].forEach(([_, O]) => {
                            O.forEach(_ => _.disconnect()), _.removeEventListener("userEvent", this.onUserEvent)
                        }), [...this.scrollEventsPerObject.entries()].forEach(([_, O]) => {
                            O.forEach(_ => _.disconnect()), _.removeEventListener("userEvent", this.onUserEvent)
                        })
                    }
                },
                Dl = class {
                    constructor(_, O, B, N, k, F) {
                        this.id = _, this.data = O, this.object = B, this.actions = nr(O, O.actions, N, k, F, B)
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    dispatch() {
                        this.actions.Transition.forEach(_ => {
                            _.play()
                        }), this.actions.Animation.forEach(_ => {
                            _.play()
                        }), this.actions.SwitchCamera.forEach(_ => {
                            _.play()
                        }), this.actions.SceneTransition.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Reset.forEach(_ => _.dispatch()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch()), this.actions.Create.forEach(_ => {
                            _.dispatchFromStart()
                        }), this.actions.Destroy.forEach(_ => {
                            _.dispatchFromStart()
                        })
                    }
                    dispatchAfter(_) {
                        this.actions.Audio.forEach(O => {
                            (O.interaction.data.triggerAfter ? ? "any") === _ && (O.interaction instanceof ER ? O.interaction.audioPlayer.play() : O.interaction instanceof EB && O.interaction.dispatch())
                        }), this.actions.Video.forEach(O => {
                            let B = O.interaction.data.triggerAfter ? ? "autoplay";
                            B === _ && (O.interaction instanceof Cx ? O.interaction.play("autoplay" === B) : O.interaction instanceof Cb && O.interaction.dispatch())
                        })
                    }
                    dispatchUserEvent(_) {
                        this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), _ ? (this.actions.Transition.forEach(_ => _.reverseFromCurrent()), this.actions.Animation.forEach(_ => _.reverseFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.reverseFromCurrent())) : (this.actions.Transition.forEach(_ => _.playFromCurrent()), this.actions.Animation.forEach(_ => _.playFromCurrent()), this.actions.SwitchCamera.forEach(_ => _.playFromCurrent())), this.actions.SceneTransition.forEach(_ => _.dispatch()), this.actions.Reset.forEach(_ => _.dispatch()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch()), this.actions.Create.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Destroy.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Audio.forEach(_ => {
                            _.interaction instanceof ER ? _.interaction.audioPlayer.play() : _.interaction instanceof EB && _.interaction.dispatch()
                        }), this.actions.Video.forEach(_ => {
                            _.interaction instanceof Cx ? _.interaction.play() : _.interaction instanceof Cb && _.interaction.dispatch()
                        })
                    }
                },
                Dh = class extends C8 {
                    constructor(_, O) {
                        super(_), this.eventManager = O, this.eventsPerObject = new Map, this.eventsAfterPerObject = new Map, this.onMouseDown = () => {
                            [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                _.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Start"
                                }), O.forEach(_ => {
                                    _.dispatchAfter("mouseDown")
                                })
                            })
                        }, this.onKeyDown = () => {
                            [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                _.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Start"
                                }), O.forEach(_ => {
                                    _.dispatchAfter("keyDown")
                                })
                            })
                        }, this.onAny = () => {
                            let {
                                domElement: _,
                                isExport: O
                            } = this.eventContext;
                            (O ? document : _).removeEventListener("pointerdown", this.onAny), document.removeEventListener("keydown", this.onAny), [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                _.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Start"
                                }), O.forEach(_ => {
                                    _.dispatchAfter("any")
                                })
                            })
                        }, this.onSceneTransitionAudioVideoPlay = () => {
                            [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                _.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Start"
                                }), O.forEach(_ => {
                                    _.actions.Audio.forEach(_ => {
                                        _.interaction instanceof ER && _.interaction.audioPlayer.play()
                                    }), _.actions.Video.forEach(_ => {
                                        let O = _.interaction.data.triggerAfter ? ? "autoplay";
                                        _.interaction instanceof Cx && _.interaction.play("autoplay" === O)
                                    })
                                })
                            })
                        }, this.onPlay = () => {
                            [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                _.dispatchEvent({
                                    type: "beginEvent",
                                    eventName: "Start"
                                }), O.forEach(_ => {
                                    _.dispatchAfter("autoplay")
                                })
                            })
                        }, this.onUserEvent = ({
                            eventName: _,
                            target: O,
                            reverse: B
                        }) => {
                            if (!_ || !O) return;
                            let N = Co(_);
                            N && "Start" === N && (O.dispatchEvent({
                                type: "beginEvent",
                                eventName: "Start"
                            }), this.eventsPerObject.get(O) ? .forEach(_ => {
                                _.dispatchUserEvent(B)
                            }), this.eventsAfterPerObject.get(O) ? .forEach(_ => {
                                _.dispatchUserEvent(B)
                            }))
                        }
                    }
                    connect() {
                        let {
                            sharedAssets: _,
                            page: O
                        } = this.eventContext;
                        if (O.traverseEntity(B => {
                                if (B.data ? .events.length)
                                    for (let {
                                            id: N,
                                            data: k
                                        } of B.data.events) {
                                        if (k.disabled || "Start" !== k.type) continue;
                                        let F = new Dl(N, k, B, O, _, this.eventManager);
                                        (F.actions.Transition.length || F.actions.Animation.length || F.actions.SwitchCamera.length || F.actions.Create.length || F.actions.Destroy.length || F.actions.SceneTransition.length || F.actions.Reset.length || F.actions.SetVariable.length || F.actions.DynamicVariablePlay.length) && (this.eventsPerObject.has(B) ? this.eventsPerObject.get(B) ? .push(F) : this.eventsPerObject.set(B, [F])), F.actions.Audio.length && (this.eventsAfterPerObject.has(B) ? this.eventsAfterPerObject.get(B) ? .push(F) : this.eventsAfterPerObject.set(B, [F])), F.actions.Video.length && (this.hasVideoAction = !0, this.eventsAfterPerObject.has(B) ? this.eventsAfterPerObject.get(B) ? .push(F) : this.eventsAfterPerObject.set(B, [F]))
                                    }
                            }), [...this.eventsAfterPerObject.values()].some(_ => _.length)) {
                            if (0 === this.eventManager.activateCount) {
                                let {
                                    domElement: _,
                                    isExport: O
                                } = this.eventContext, B = O ? document : _;
                                B.addEventListener("pointerdown", this.onMouseDown, {
                                    once: !0
                                }), B.addEventListener("mousedown", this.onMouseDown, {
                                    once: !0
                                }), document.addEventListener("keydown", this.onKeyDown, {
                                    once: !0
                                }), B.addEventListener("pointerdown", this.onAny), B.addEventListener("mousedown", this.onAny), document.addEventListener("keydown", this.onAny), [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                    _.addEventListener("userEvent", this.onUserEvent)
                                })
                            } else this.onSceneTransitionAudioVideoPlay();
                            this.onPlay()
                        }[...this.eventsPerObject.entries()].forEach(([_, O]) => {
                            _.dispatchEvent({
                                type: "beginEvent",
                                eventName: "Start"
                            }), O.forEach(_ => _.dispatch()), _.addEventListener("userEvent", this.onUserEvent)
                        })
                    }
                    disconnect() {
                        if ([...this.eventsAfterPerObject.values()].some(_ => _.length)) {
                            let {
                                domElement: _,
                                isExport: O
                            } = this.eventContext, B = O ? document : _;
                            B.removeEventListener("pointerdown", this.onMouseDown), B.removeEventListener("mousedown", this.onMouseDown), document.removeEventListener("keydown", this.onKeyDown), B.removeEventListener("pointerdown", this.onAny), B.removeEventListener("mousedown", this.onAny), document.removeEventListener("keydown", this.onAny), [...this.eventsAfterPerObject.entries()].forEach(([_, O]) => {
                                _.removeEventListener("userEvent", this.onUserEvent), O.forEach(_ => _.disconnect())
                            })
                        }[...this.eventsPerObject.entries()].forEach(([_, O]) => {
                            _.removeEventListener("userEvent", this.onUserEvent), O.forEach(_ => _.disconnect())
                        }), this.eventsPerObject.clear(), this.eventsAfterPerObject.clear()
                    }
                },
                Dc = class {
                    constructor(_, O, B, N, k, F) {
                        this.id = _, this.data = O, this.object = B, this.disabled = !1, this.alreadyPlayedNonTogglingActions = new Set, this.actions = nr(O, O.actions, N, k, F, B), this.target = O.target, this.useToggle = "Toggle" === O.runMode
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    dispatch(_) {
                        this.disabled || (this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this ? (_.object.currentTransitionEvent = this, _.init()) : "Once" === this.data.runMode && this.alreadyPlayedNonTogglingActions.add(_)
                        }), this.object.dispatchEvent({
                            type: "beginEvent",
                            eventName: "Collision"
                        }), this.useToggle ? (this.actions.Transition.forEach(_ => {
                            _.toggle()
                        }), this.actions.Animation.forEach(_ => {
                            _.toggle()
                        })) : (this.actions.Transition.forEach(_ => {
                            !1 === this.alreadyPlayedNonTogglingActions.has(_) && _.play()
                        }), this.actions.Animation.forEach(_ => {
                            _.play()
                        })), this.actions.Reset.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Link.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Reset.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Create.forEach(_ => {
                            _.dispatch()
                        }), this.actions.Destroy.forEach(O => {
                            O.dispatch(_ ? ? !1)
                        }), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch()), this.actions.Audio.forEach(_ => {
                            _.dispatchBasic()
                        }), this.actions.Video.forEach(_ => {
                            _.dispatchBasic()
                        }))
                    }
                },
                Dd = class extends C8 {
                    constructor(_, O, B, N, k) {
                        super(_), this.sharedVariables = O, this.eventManager = B, this.needsMouse = N, this.needsRaycast = k, this.dynamicVars = [], this.variablesToWatch = [], this.prevMouseProperty = null, this.prevRaycastProperty = null, this.pauseTime = 0, this.events = [], this.onFrame = _ => {
                            this.rafId = window.requestAnimationFrame(this.onFrame);
                            let O = new Date,
                                B = [],
                                N = [];
                            for (let _ = 0; _ < this.propertiesToWatch.length; _++) {
                                let {
                                    objectId: O,
                                    property: B,
                                    prevValue: k
                                } = this.propertiesToWatch[_], F = this.eventContext.scene.find(O), U = fB.propertyPaths[B];
                                if ("width" === U[0] || "height" === U[0] || "depth" === U[0]) F = F.geometry.userData.parameters[U[0]];
                                else
                                    for (let _ = 0; _ < U.length; _++) F = F[U[_]];
                                null === k ? this.propertiesToWatch[_].prevValue = F instanceof rv ? F.clone() : F : (F instanceof rv ? F.equals(k) : k === F) || (N.push({
                                    objId: O,
                                    property: B
                                }), F instanceof rv ? this.propertiesToWatch[_].prevValue.copy(F) : this.propertiesToWatch[_].prevValue = F)
                            }
                            for (let _ = 0; _ < this.variablesToWatch.length; _++) {
                                let {
                                    id: O,
                                    prevValue: N
                                } = this.variablesToWatch[_], k = this.shared.getVariable(O);
                                k !== N && (B.push(O), this.variablesToWatch[_].prevValue = k)
                            }
                            for (let N = 0; N < this.dynamicVars.length; N++) {
                                let {
                                    id: k,
                                    expectedTime: F,
                                    last: U,
                                    data: j,
                                    timerSeconds: G,
                                    startValue: Y
                                } = this.dynamicVars[N], Q = 1e3;
                                if (("timer" === j.dynamicVariableType || "stopwatch" === j.dynamicVariableType) && "number3decimal" === j.format ? Q = 1 : "counter" === j.dynamicVariableType ? Q = j.updateInterval : "random" === j.dynamicVariableType && (Q = j.isStatic ? 1 / 0 : j.updateInterval), -1 === F) {
                                    this.dynamicVars[N].last = _, this.dynamicVars[N].expectedTime = _ + Q;
                                    continue
                                }
                                if (!(("Stopped" === this.shared.getDynamicVariablePlayState(k) || "Restarted" === this.shared.getDynamicVariablePlayState(k)) && (this.dynamicVars[N].last = _, this.dynamicVars[N].expectedTime = _ + Q, "counter" === j.dynamicVariableType && this.shared.getVariable(k) !== Y && (this.shared.updateVariable(k, Y), this.eventManager.requestRender()), ("timer" === j.dynamicVariableType || "stopwatch" === j.dynamicVariableType) && this.dynamicVars[N].timerSeconds !== Y && (this.dynamicVars[N].timerSeconds = Y, this.shared.updateVariable(k, gk.getFormattedTimerTime(Y, j)), this.eventManager.requestRender()), "Restarted" === this.shared.getDynamicVariablePlayState(k) && this.shared.setDynamicVariablePlayState(k, "Playing"), "Stopped" === this.shared.getDynamicVariablePlayState(k)))) {
                                    if ("Paused" === this.shared.getDynamicVariablePlayState(k)) {
                                        void 0 === this.dynamicVars[N].deltaToExpectedTime && (this.dynamicVars[N].deltaToExpectedTime = Math.max(this.dynamicVars[N].expectedTime - _, 0)), this.dynamicVars[N].last = _ - (Q - this.dynamicVars[N].deltaToExpectedTime), this.dynamicVars[N].expectedTime = _ + this.dynamicVars[N].deltaToExpectedTime;
                                        continue
                                    }
                                    if (this.dynamicVars[N].deltaToExpectedTime = void 0, _ >= F) {
                                        if (this.dynamicVars[N].last = _, this.dynamicVars[N].expectedTime += Q, "random" === j.dynamicVariableType) {
                                            let _ = j.min + Math.random() * (j.max - j.min),
                                                O = j.decimals;
                                            _ = Math.round(_ * Math.pow(10, O)) / Math.pow(10, O), this.shared.updateVariable(k, _), B.push(k), this.eventManager.requestRender()
                                        } else if ("counter" === j.dynamicVariableType) {
                                            if (0 === j.increment) continue;
                                            let _ = this.shared.getVariable(k),
                                                O = this.shared.getDynamicVariableToggleIsForward(k) ? ? !0,
                                                N = this.shared.getVariable(k) + j.increment * (O ? 1 : -1);
                                            j.hasEnd && ((N = j.increment > 0 ? iK.clamp(N, Y, j.endValue) : iK.clamp(N, j.endValue, Y)) === Y && this.shared.setDynamicVariableToggleIsForward(k, void 0), j.repeat ? N === j.endValue && (N = Y) : (N === Y || N === j.endValue) && this.shared.setDynamicVariablePlayState(k, "Paused")), N !== _ && (B.push(k), this.shared.updateVariable(k, N), this.eventManager.requestRender())
                                        } else if ("time" === j.dynamicVariableType) this.shared.updateVariable(k, IA(O, j)), B.push(k), this.eventManager.requestRender();
                                        else {
                                            let O = gL.isTextValue(j.endValue) ? ZL(j.endValue.textValue) : j.endValue,
                                                F = this.shared.getDynamicVariableToggleIsForward(k) ? ? !0,
                                                Q = G + (_ - U) / 1e3 * ("timer" === j.dynamicVariableType ? -1 : 1) * (F ? 1 : -1);
                                            Q = Math.max(Q, 0), j.hasEnd && ((Q = "stopwatch" === j.dynamicVariableType ? iK.clamp(Q, Y, O) : iK.clamp(Q, O, Y)) === Y && this.shared.setDynamicVariableToggleIsForward(k, void 0), j.repeat ? Math.abs(Q - O) < ("number3decimal" === j.format ? 1e-4 : .1) && (Q = Y) : (Math.abs(Q - Y) < ("number3decimal" === j.format ? 1e-4 : .1) || Math.abs(Q - O) < ("number3decimal" === j.format ? 1e-4 : .1)) && this.shared.setDynamicVariablePlayState(k, "Paused")), Q !== G && (B.push(k), this.dynamicVars[N].timerSeconds = Q, this.shared.updateVariable(k, gk.getFormattedTimerTime(Q, j)), this.eventManager.requestRender())
                                        }
                                    }
                                }
                            }
                            this.needsMouse && this.shared.mouseProperty !== this.prevMouseProperty && (this.prevMouseProperty = this.shared.mouseProperty, this.events.forEach(_ => {
                                "mouseProperty" === _.data.variableId && (_.dispatch(), this.eventManager.requestRender())
                            }));
                            let k = !1;
                            this.shared.mouseProperty !== this.prevMouseProperty && (this.prevMouseProperty = this.shared.mouseProperty, k = !0);
                            let F = !1;
                            this.shared.raycastProperty !== this.prevRaycastProperty && (this.prevRaycastProperty = this.shared.raycastProperty, F = !0), this.events.forEach(_ => {
                                (B.includes(_.data.variableId) || N.find(O => O.objId === _.data.objectId && O.property === _.data.property) || "mouseProperty" === _.data.variableId && k || "raycastProperty" === _.data.variableId && F) && (_.dispatch(), this.eventManager.requestRender())
                            })
                        }, this.onBlur = () => {
                            this.pause()
                        }, this.onFocus = () => {
                            this.resume()
                        }, _.page.traverseEntity(O => {
                            O.data ? .events.filter(_ => "VariableChange" === _.data.type && !_.data.disabled).forEach(N => {
                                this.events.push(new Dp(O.uuid, N.data, O, _.page, _.sharedAssets, B))
                            })
                        }), this.propertiesToWatch = this.events.filter(_ => "objectProperty" === _.data.variableId && null !== _.data.objectId).map(_ => ({
                            objectId: _.data.objectId,
                            property: _.data.property,
                            prevValue: null
                        })), this.shared = _.sharedAssets, this.sharedVariables.forEach(({
                            id: _,
                            data: O
                        }) => {
                            let B;
                            if (!("dynamicVariableType" in O)) {
                                this.events.find(O => O.data.variableId === _) && this.variablesToWatch.push({
                                    id: _,
                                    prevValue: this.shared.getVariable(_)
                                });
                                return
                            }
                            if ("timer" === O.dynamicVariableType || "stopwatch" === O.dynamicVariableType) {
                                let N;
                                if (gL.isTextValue(O.value) && Array.isArray(O.value.textValue)) {
                                    let _ = O.value.textValue;
                                    N = 3 === _.length ? _[2] + 60 * _[1] + 3600 * _[0] : _[1] + 60 * _[0]
                                } else N = O.value;
                                B = N, this.dynamicVars.push({
                                    id: _,
                                    last: -1,
                                    expectedTime: -1,
                                    data: O,
                                    timerSeconds: N,
                                    startValue: B
                                })
                            } else "time" === O.dynamicVariableType && this.shared.updateVariable(_, IA(new Date, O)), "counter" === O.dynamicVariableType && (B = gL.isTextValue(O.value) ? ZL(O.value.textValue) : O.value), this.dynamicVars.push({
                                id: _,
                                last: -1,
                                expectedTime: -1,
                                data: O,
                                startValue: B
                            })
                        })
                    }
                    pause() {
                        this.pauseTime = Date.now()
                    }
                    resume() {
                        let _ = Date.now() - this.pauseTime;
                        for (let O = 0; O < this.dynamicVars.length; O++) this.dynamicVars[O].last += _, this.dynamicVars[O].expectedTime += _
                    }
                    connect() {
                        this.rafId = window.requestAnimationFrame(this.onFrame), window.addEventListener("blur", this.onBlur), window.addEventListener("focus", this.onFocus)
                    }
                    disconnect() {
                        window.removeEventListener("blur", this.onBlur), window.removeEventListener("focus", this.onFocus), this.rafId && (window.cancelAnimationFrame(this.rafId), this.rafId = void 0), this.events.forEach(_ => _.dispose())
                    }
                },
                Dp = class {
                    constructor(_, O, B, N, k, F) {
                        this.id = _, this.data = O, this.object = B, this.actions = nr(O, O.actions, N, k, F, B)
                    }
                    dispatch() {
                        let _ = this.actions;
                        _.Audio.forEach(_ => _.dispatchConditional()), _.Video.forEach(_ => _.dispatchConditional()), _.Create.forEach(_ => _.dispatch()), _.Destroy.forEach(_ => _.dispatch()), _.Reset.forEach(_ => _.dispatch()), _.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this), _.init()
                        }), _.Transition.forEach(_ => _.play()), _.Animation.forEach(_ => _.play()), _.SwitchCamera.forEach(_ => _.play()), _.SceneTransition.forEach(_ => _.dispatch()), _.SetVariable.forEach(_ => _.checkConditions()), _.SetVariable.forEach(_ => _.dispatch()), _.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                    dispose() {
                        qt(this.actions)
                    }
                };

            function ZL(_) {
                return 3 === _.length ? _[2] + 60 * _[1] + 3600 * _[0] : _[1] + 60 * _[0]
            }
            var Dm, Dg, Dv, Dy = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import('https://unpkg.com/@splinetool/runtime@0.9.519/build/' + 'navmesh.js'),
		fetch('https://unpkg.com/@splinetool/navmesh-wasm@0.9.519/build/' + 'navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`,
                Dx = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import(self.location.origin + '/_libraries/navmesh.js'),
		fetch(self.location.origin + '/_libraries/navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`,
                Db = `

onmessage = function(messageEvent) {
	const meshData = messageEvent.data;
	const positions = meshData[0];
	const offset = meshData[1];
	const indices = meshData[2];
	const indicesLength = meshData[3];
	const parameters = meshData[4];

	const module = self.module;
	const rc = new module.rcConfig();
	rc.cs = parameters.cs;
	rc.ch = parameters.ch;
	rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;
	rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;
	rc.walkableSlopeAngle = parameters.walkableSlopeAngle;
	rc.walkableHeight = parameters.walkableHeight;
	rc.walkableClimb = parameters.walkableClimb;
	rc.walkableRadius = parameters.walkableRadius;
	rc.maxEdgeLen = parameters.maxEdgeLen;
	rc.maxSimplificationError = parameters.maxSimplificationError;
	rc.minRegionArea = parameters.minRegionArea;
	rc.mergeRegionArea = parameters.mergeRegionArea;
	rc.maxVertsPerPoly = parameters.maxVertsPerPoly;
	rc.detailSampleDist = parameters.detailSampleDist;
	rc.detailSampleMaxError = parameters.detailSampleMaxError;

	if (!self.navMesh) {
		self.navMesh = new module.NavMesh();
	}
	self.navMesh.build(positions, offset, indices, indicesLength, rc);

	const navmeshData = navMesh.getNavmeshData();
	const arrView = new Uint8Array(module.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);
	const ret = new Uint8Array(navmeshData.size);
	ret.set(arrView);
	navMesh.freeNavmeshData(navmeshData);

	postMessage(ret);
}
`,
                D_ = {
                    cs: 6,
                    ch: 2,
                    walkableSlopeAngle: 90,
                    walkableHeight: 20,
                    walkableClimb: 5,
                    walkableRadius: 0,
                    maxEdgeLen: 12,
                    maxSimplificationError: 1.3,
                    minRegionArea: 8,
                    mergeRegionArea: 20,
                    maxVertsPerPoly: 6,
                    detailSampleDist: 6,
                    detailSampleMaxError: 1
                };
            d6.then(_ => {
                Dm = _, Dg = new _.Vec3, Dv = new _.Vec3
            });
            var DS = new rv,
                DA = class {
                    constructor(_ = !1, O = !1) {
                        this.usePhysics = _, this.isExport = O, this.onPointerDown = _ => {
                            if (1 !== dq.length) return;
                            let {
                                raycaster: O,
                                page: B
                            } = this.eventContext;
                            this.eventContext.updateRaycaster(_);
                            let N = B.raycastWithClones(O);
                            if (0 !== N.length) {
                                if (this.gameControl) {
                                    let _ = DS.copy(this.gameControl.colliderWorldPosition);
                                    _.y -= this.gameControl.colliderHeight / 2, this.gameControl.path = this.computePath(_, N[0].point)
                                }
                                this.eventContext.requestRender()
                            }
                        }, this.traverseWithPhysics = (_, O) => B => {
                            let N;
                            if (B instanceof _3) {
                                if (!B.objectForSample) return !0 === B.object.dataPatched.physics.fusedBody && "dynamic" === B.object.dataPatched.physics.rigidBody || void 0;
                                if (B.objectForSample.dataPatched.physics.fusedBody) return;
                                N = B.object
                            } else if (B instanceof vb) N = B.object;
                            else if (N = B, N.dataPatched.cloner ? .disabled === !1 && N.dataPatched.cloner ? .hideBase && N.dataPatched.physics ? .fusedBody !== !0) return !0;
                            if (O && !N.userData.navmesh) return;
                            let k = N.dataPatched;
                            if (!k.visible && k.physics ? .enabled !== !0) return !0;
                            B.updateMatrixWorldSVD();
                            let F = Im(k),
                                U = N.userData.hasDestroy,
                                j = N.userData.hasDrag,
                                G = !1,
                                Y = !1;
                            for (let _ of k.events) !0 !== _.data.disabled && ("GameControl" === _.data.type ? G = !0 : "Follow" === _.data.type && (Y = !0));
                            if (G || F || Y || U || j) return !0;
                            if (this.usePhysics && k.physics ? .rigidBody === "dynamic") {
                                if (this.usePhysics && k.physics ? .fusedBody) return !0
                            } else if ("geometry" in B && B.geometry && _.push(Vs(B.geometry, B.matrixWorld)), this.usePhysics && k.physics ? .fusedBody) return B.traverseObject((O, B) => {
                                let N;
                                if (0 === B) return;
                                if (O instanceof _3) {
                                    if (!O.objectForSample) return !0 === O.object.dataPatched.physics.fusedBody && "dynamic" === O.object.dataPatched.physics.rigidBody || void 0;
                                    if (O.objectForSample.dataPatched.physics.fusedBody) return;
                                    N = O.object
                                } else if (O instanceof vb) N = O.object;
                                else if (N = O, O.dataPatched.cloner ? .hideBase) return !0;
                                let k = N.dataPatched;
                                if (!k.visible && k.physics ? .enabled !== !0) return !0;
                                "geometry" in O && O.geometry && _.push(Vs(O.geometry, O.matrixWorld))
                            }), !0
                        }, this.traverseNoPhysics = (_, O) => B => {
                            let N;
                            if (B instanceof _3) return;
                            let k = (N = B instanceof vb ? B.object : B).dataPatched;
                            if ("visibility" === k.physics.enabled ? !k.visible : !k.physics.enabled) return !0;
                            if (O && !N.userData.navmesh) return;
                            let F = B.geometry,
                                U = !0 === N.userData.hasDestroy,
                                j = !0 === N.userData.hasDrag;
                            if (Im(k) || U || j || N.dataPatched.events.some(_ => !0 !== _.data.disabled && "GameControl" === _.data.type)) return !0;
                            F && _.push(Vs(F, B.matrixWorld))
                        }, this.navmeshWasm = Dm, this.navMesh = new this.navmeshWasm.NavMesh, this._workerURL = URL.createObjectURL(new Blob([(O ? Dy : Dx) + Db])), this._worker = new Worker(this._workerURL)
                    }
                    init(_, O, B) {
                        this.gameControl = O, this.eventContext = B, this.resolution = _.ch, this.setDefaultQueryExtent(new rv().setScalar(_.ch * _.walkableRadius * 1.2)), this._worker.onmessage = () => {
                            this.createNavMesh(B.page, _, _ => {
                                this.buildFromNavmeshData(_.data)
                            })
                        }, this.eventContext.renderer.domElement.addEventListener("pointerdown", this.onPointerDown)
                    }
                    createNavMesh(_, O, B) {
                        O.objects.forEach(O => {
                            let B = _.scene.find(O);
                            B.traverseEntity(_ => {
                                _.userData.navmesh = !0
                            }), B.cloner ? .traverseObject(_ => {
                                _.userData.navmesh = !0
                            })
                        });
                        let N = [],
                            k = (this.usePhysics ? this.traverseWithPhysics : this.traverseNoPhysics)(N, "custom" === O.zones);
                        if (_.traverseChildren(k), O.objects.forEach(O => {
                                let B = _.scene.find(O);
                                B.traverseEntity(_ => {
                                    _.userData.navmesh = void 0
                                }), B.cloner ? .traverseObject(_ => {
                                    _.userData.navmesh = void 0
                                })
                            }), 0 === N.length) return !1;
                        let F = ws(N),
                            {
                                positions: U,
                                triIndices: j
                            } = yc(F.getAttribute("position"), F.getIndex());
                        return this._worker.postMessage([U, U.length / 3, j, j.length, { ...D_,
                            ...O
                        }]), this._worker.onmessage = B, !0
                    }
                    createDebugNavGeometry() {
                        let _, O, B = this.navMesh.getDebugNavMesh(),
                            N = B.getTriangleCount(),
                            k = new Uint32Array(3 * N),
                            F = new Float32Array(9 * N);
                        for (_ = 0; _ < 3 * N; _++) k[_] = _;
                        for (_ = 0; _ < N; _++)
                            for (O = 0; O < 3; O++) {
                                let N = B.getTriangle(_).getPoint(O);
                                F[9 * _ + 3 * O + 0] = N.x, F[9 * _ + 3 * O + 1] = N.y, F[9 * _ + 3 * O + 2] = N.z
                            }
                        let U = new sK;
                        return U.setIndex(new sF(k, 1)), U.setAttribute("position", new sF(F, 3)), U
                    }
                    getClosestPoint(_) {
                        return Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, this.navMesh.getClosestPoint(Dg)
                    }
                    getClosestPointToRef(_, O) {
                        Dg.x = _.x, Dg.y = _.y, Dg.z = _.z;
                        let B = this.navMesh.getClosestPoint(Dg);
                        O.set(B.x, B.y, B.z)
                    }
                    getRandomPointAround(_, O) {
                        return Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, this.navMesh.getRandomPointAround(Dg, O)
                    }
                    getRandomPointAroundToRef(_, O, B) {
                        Dg.x = _.x, Dg.y = _.y, Dg.z = _.z;
                        let N = this.navMesh.getRandomPointAround(Dg, O);
                        B.set(N.x, N.y, N.z)
                    }
                    moveAlong(_, O) {
                        return Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, Dv.x = O.x, Dv.y = O.y, Dv.z = O.z, this.navMesh.moveAlong(Dg, Dv)
                    }
                    moveAlongToRef(_, O, B) {
                        return Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, Dv.x = O.x, Dv.y = O.y, Dv.z = O.z, this.navMesh.moveAlong(Dg, Dv)
                    }
                    computePath(_, O) {
                        let B = this.getClosestPoint(O);
                        Dv.x = B.x, Dv.y = B.y, Dv.z = B.z, this.getClosestPoint(_);
                        let N = this.navMesh.computePath(Dg, Dv),
                            k = N.getPointCount(),
                            F = [];
                        for (let _ = 0; _ < k; _++) {
                            let O = N.getPoint(_);
                            F.push(new rv(O.x, O.y, O.z))
                        }
                        return F
                    }
                    createCrowd(_, O) {
                        return new DM(this, _, O)
                    }
                    setDefaultQueryExtent(_) {
                        Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, this.navMesh.setDefaultQueryExtent(Dg)
                    }
                    getDefaultQueryExtent() {
                        return this.navMesh.getDefaultQueryExtent()
                    }
                    buildFromNavmeshData(_) {
                        let O = _.length * _.BYTES_PER_ELEMENT,
                            B = this.navmeshWasm._malloc(O),
                            N = new Uint8Array(this.navmeshWasm.HEAPU8.buffer, B, O);
                        N.set(_);
                        let k = new this.navmeshWasm.NavmeshData;
                        k.dataPointer = N.byteOffset, k.size = _.length, this.navMesh.buildFromNavmeshData(k), this.navmeshWasm._free(N.byteOffset)
                    }
                    getNavmeshData() {
                        let _ = this.navMesh.getNavmeshData(),
                            O = new Uint8Array(this.navmeshWasm.HEAPU8.buffer, _.dataPointer, _.size),
                            B = new Uint8Array(_.size);
                        return B.set(O), this.navMesh.freeNavmeshData(_), B
                    }
                    getDefaultQueryExtentToRef(_) {
                        let O = this.navMesh.getDefaultQueryExtent();
                        _.set(O.x, O.y, O.z)
                    }
                    dispose() {
                        this.navMesh.destroy(), this._worker.terminate(), URL.revokeObjectURL(this._workerURL), this.eventContext ? .renderer.domElement.removeEventListener("pointerdown", this.onPointerDown)
                    }
                    addCylinderObstacle(_, O, B) {
                        return Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, this.navMesh.addCylinderObstacle(Dg, O, B)
                    }
                    addBoxObstacle(_, O, B) {
                        return Dg.x = _.x, Dg.y = _.y, Dg.z = _.z, Dv.x = O.x, Dv.y = O.y, Dv.z = O.z, this.navMesh.addBoxObstacle(Dg, Dv, B)
                    }
                    removeObstacle(_) {
                        this.navMesh.removeObstacle(_)
                    }
                    isSupported() {
                        return void 0 !== this.navmeshWasm
                    }
                },
                DM = class {
                    constructor(_, O, B) {
                        this.navmeshWasmWrapper = _, this.transforms = [], this.agents = [], this.reachRadii = [], this._agentDestinationArmed = [], this._agentDestination = [], this.crowd = new this.navmeshWasmWrapper.navmeshWasm.Crowd(O, B, this.navmeshWasmWrapper.navMesh.getNavMesh())
                    }
                    onReachTarget(_, O) {}
                    addAgent(_, O, B) {
                        let N = new this.navmeshWasmWrapper.navmeshWasm.dtCrowdAgentParams;
                        N.radius = O.radius, N.height = O.height, N.maxAcceleration = O.maxAcceleration, N.maxSpeed = O.maxSpeed, N.collisionQueryRange = O.collisionQueryRange, N.pathOptimizationRange = O.pathOptimizationRange, N.separationWeight = O.separationWeight, N.updateFlags = 7, N.obstacleAvoidanceType = 0, N.queryFilterType = 0, N.userData = 0;
                        let k = this.crowd.addAgent(new this.navmeshWasmWrapper.navmeshWasm.Vec3(_.x, _.y, _.z), N);
                        return this.transforms.push(B), this.agents.push(k), this.reachRadii.push(O.reachRadius ? O.reachRadius : O.radius), this._agentDestinationArmed.push(!1), this._agentDestination.push(new rv(0, 0, 0)), k
                    }
                    getAgentPosition(_) {
                        return this.crowd.getAgentPosition(_)
                    }
                    getAgentPositionToRef(_, O) {
                        let B = this.crowd.getAgentPosition(_);
                        O.set(B.x, B.y, B.z)
                    }
                    getAgentVelocity(_) {
                        return this.crowd.getAgentVelocity(_)
                    }
                    getAgentVelocityToRef(_, O) {
                        let B = this.crowd.getAgentVelocity(_);
                        O.set(B.x, B.y, B.z)
                    }
                    getAgentNextTargetPath(_) {
                        return this.crowd.getAgentNextTargetPath(_)
                    }
                    getAgentNextTargetPathToRef(_, O) {
                        let B = this.crowd.getAgentNextTargetPath(_);
                        O.set(B.x, B.y, B.z)
                    }
                    getAgentState(_) {
                        return this.crowd.getAgentState(_)
                    }
                    overOffmeshConnection(_) {
                        return this.crowd.overOffmeshConnection(_)
                    }
                    agentGoto(_, O) {
                        this.crowd.agentGoto(_, new this.navmeshWasmWrapper.navmeshWasm.Vec3(O.x, O.y, O.z));
                        let B = this.agents.indexOf(_);
                        B > -1 && (this._agentDestinationArmed[B] = !0, this._agentDestination[B].set(O.x, O.y, O.z))
                    }
                    agentTeleport(_, O) {
                        this.crowd.agentTeleport(_, new this.navmeshWasmWrapper.navmeshWasm.Vec3(O.x, O.y, O.z))
                    }
                    updateAgentParameters(_, O) {
                        let B = this.crowd.getAgentParameters(_);
                        void 0 !== O.radius && (B.radius = O.radius), void 0 !== O.height && (B.height = O.height), void 0 !== O.maxAcceleration && (B.maxAcceleration = O.maxAcceleration), void 0 !== O.maxSpeed && (B.maxSpeed = O.maxSpeed), void 0 !== O.collisionQueryRange && (B.collisionQueryRange = O.collisionQueryRange), void 0 !== O.pathOptimizationRange && (B.pathOptimizationRange = O.pathOptimizationRange), void 0 !== O.separationWeight && (B.separationWeight = O.separationWeight), this.crowd.setAgentParameters(_, B)
                    }
                    removeAgent(_) {
                        this.crowd.removeAgent(_);
                        let O = this.agents.indexOf(_);
                        O > -1 && (this.agents.splice(O, 1), this.transforms.splice(O, 1), this.reachRadii.splice(O, 1), this._agentDestinationArmed.splice(O, 1), this._agentDestination.splice(O, 1))
                    }
                    getAgents() {
                        return this.agents
                    }
                    update(_) {
                        if (this.navmeshWasmWrapper.navMesh.update(), !(_ <= .001)) {
                            if (1 / 60 <= .001) this.crowd.update(_);
                            else {
                                let O = Math.floor(_ / (1 / 60));
                                O > 10 && (O = 10), O < 1 && (O = 1);
                                let B = _ / O;
                                for (let _ = 0; _ < O; _++) this.crowd.update(B)
                            }
                            for (let _ = 0; _ < this.agents.length; _++) {
                                let O = this.agents[_],
                                    B = this.getAgentPosition(O);
                                if (this.transforms[_].copy(B), this._agentDestinationArmed[_]) {
                                    let N = B.x - this._agentDestination[_].x,
                                        k = B.z - this._agentDestination[_].z,
                                        F = this.reachRadii[_],
                                        U = this._agentDestination[_].y - this.reachRadii[_],
                                        j = this._agentDestination[_].y + this.reachRadii[_],
                                        G = N * N + k * k;
                                    B.y > U && B.y < j && G < F * F && (this.onReachTarget(O, this._agentDestination[_]), this._agentDestinationArmed[_] = !1)
                                }
                            }
                        }
                    }
                    setDefaultQueryExtent(_) {
                        let O = new this.navmeshWasmWrapper.navmeshWasm.Vec3(_.x, _.y, _.z);
                        this.crowd.setDefaultQueryExtent(O)
                    }
                    getDefaultQueryExtent() {
                        return this.crowd.getDefaultQueryExtent()
                    }
                    getDefaultQueryExtentToRef(_) {
                        let O = this.crowd.getDefaultQueryExtent();
                        _.set(O.x, O.y, O.z)
                    }
                    getCorners(_) {
                        let O, B = this.crowd.getCorners(_),
                            N = B.getPointCount(),
                            k = [];
                        for (O = 0; O < N; O++) {
                            let _ = B.getPoint(O);
                            k.push(new rv(_.x, _.y, _.z))
                        }
                        return k
                    }
                    dispose() {
                        this.crowd.destroy()
                    }
                },
                DE = {
                    type: "change"
                },
                DD = {
                    type: "changeZoom"
                },
                DP = {
                    type: "changePan"
                },
                DI = {
                    type: "start"
                },
                DO = {
                    type: "end",
                    changed: !0
                },
                DL = {
                    type: "end",
                    changed: !1
                },
                DB = new rm,
                Dz = new iJ,
                DN = 2 * Math.PI,
                Dk = new rv,
                DF = new iJ,
                DU = new rv,
                Dj = new rm,
                DG = new rJ,
                DH = {
                    type: "requestRender"
                },
                DW = class extends iq {
                    constructor(_, O, B = {
                        isPlayMode: !1,
                        isExport: !1
                    }) {
                        super(), this.object = _, this.domElement = O, this.options = B, this.enabled = !0, this.useKeyEvents = !0, this.enableDamping = !1, this.enableZoom = !0, this.enableRotate = !0, this.enablePan = !0, this.autoRotate = !1, this.rotationLimitsMode = 0, this.panLimitsMode = 0, this.rotationSoftLimit = 2, this.panSoftLimit = 2, this.hoverRotatePanMode = 0, this.zoomLimitsEnabled = !1, this.mouseButtons = [0, 5], this.mouseButtonsPlay = [3, 4, 5], this.touches = [null, ij.DOLLY_ROTATE, ij.PAN], this.offset = new rv, this.eye = new rv, this.lastPosition = new rv, this.lastQuaternion = new rm, this.current = new iJ, this.overShoot = new iJ, this.overRatio = new iJ, this.spherical = new lM, this.sphericalDelta = new lM, this.panOffset = new rv, this.panLeftV = new rv, this.panUpV = new rv, this.panV = new rv, this.rotateStart = new iJ, this.rotateEnd = new iJ, this.rotateDelta = new iJ, this.panStart = new iJ, this.panEnd = new iJ, this.panDelta = new iJ, this.dollyStart = new iJ, this.dollyEnd = new iJ, this.dollyDelta = new iJ, this.rotationRangeFactor = new iJ, this.panRangeFactor = new iJ, this.state = -1, this.zoomChanged = !1, this.isPointerDown = !1, this.isThetaFlipped = !1, this.prevScale = 0, this.scale = 1, this.gesture = !1, this.timer = -1, this.timerHover = -1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPhi = 0, this.maxPhi = Math.PI, this.minTheta = -1 / 0, this.maxTheta = 1 / 0, this.minH = 0, this.maxH = Math.PI, this.minV = -1 / 0, this.maxV = 1 / 0, this.autoRotateClockwise = !0, this.isPanOverShoot = !1, this.isRotateOverShoot = !1, this.resetHoverEffectOnPointerLeave = !1, this.hasChange = !1, this.useWindowEvents = !1, this.isTouchZoom = !0, this.autoRotateSpeed = 2, this.dampingFactor = .125, this.zoomSpeed = 2, this.rotateSpeed = 1, this.panSpeed = 1, this.hoverRotatePanStrength = .1, this.hoverRotateDamping = this.dampingFactor, this.thetaIsFree = !1, this.phiIsFree = !1, this.needsUpdate = !0, this.onCameraChange = _ => {
                            this.object.removeEventListener("beginState", this.onBeginState), this.object.removeEventListener("completeState", this.onCompleteState), this.object.removeEventListener("cameraChange", this.onCameraChange), this.object = _.camera, this.object.addEventListener("beginState", this.onBeginState), this.object.addEventListener("completeState", this.onCompleteState), this.object.addEventListener("cameraChange", this.onCameraChange)
                        }, this.update = () => {
                            this.object.updateWorldMatrix(!0, !1), this.object.matrixWorld.decompose(DU, Dj, Dk), this.offset.copy(DU).sub(this.target), this.spherical.setFromVector3(this.offset), this.object.isUpVectorFlipped && (this.spherical.phi *= -1, this.spherical.theta -= Math.PI), this.autoRotate && -1 === this.state && this.rotateLeft((!0 === this.autoRotateClockwise ? 1 : -1) * this.getAutoRotationAngle()), 0 !== this.rotationLimitsMode && this.applyLimits(this.sphericalDelta, this.rotationLimitsMode, this.rotationSoftLimit, this.maxTheta, this.minTheta, this.maxPhi, this.minPhi, this.rotationRangeFactor), 2 !== this.rotationLimitsMode && (this.spherical.phi += this.sphericalDelta.phi), (1 !== this.rotationLimitsMode || !0 === this.autoRotate) && (this.spherical.theta += this.sphericalDelta.theta), this.spherical.radius *= this.scale, this.zoomLimitsEnabled && (this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius))), 0 !== this.panLimitsMode && (this.target.applyQuaternion(DB.copy(Dj).invert()), this.panOffset.applyQuaternion(DB), this.applyLimits(this.panOffset, this.panLimitsMode, this.panSoftLimit, this.maxH, this.minH, this.maxV, this.minV, this.panRangeFactor), this.target.applyQuaternion(Dj), this.panOffset.applyQuaternion(Dj)), 2 === this.panLimitsMode && (this.panOffset.y = 0), 1 === this.panLimitsMode && (this.panOffset.x = 0), -1 !== this.state || this.gesture ? (this.target.add(this.panOffset), this.panOffset.set(0, 0, 0)) : (this.panOffset.multiplyScalar(1 - this.dampingFactor), this.target.add(this.panOffset)), this.offset.setFromSpherical(this.spherical), DU.copy(this.target).add(this.offset), this.object.position.copy(this.target).add(this.offset), this.object.parent && (DG.copy(this.object.parent.matrixWorld).invert(), this.object.position.applyMatrix4(DG));
                            let _ = this.spherical.phi % DN;
                            if (this.eye.copy(this.offset).normalize(), this.object.up.copy(sv.DEFAULT_UP).applyAxisAngle(this.eye, this.object.angleOffsetFromUp), _ > 0 && _ > Math.PI || _ < 0 && _ > -Math.PI ? (this.object.up.negate(), this.object.lookAt(this.target), this.object.isUpVectorFlipped = !0) : (this.object.lookAt(this.target), this.object.isUpVectorFlipped = !1), -1 === this.state || !0 === this.enableDamping) {
                                let _ = 1 === this.hoverRotatePanMode ? this.hoverRotateDamping : this.dampingFactor;
                                this.sphericalDelta.theta *= 1 - _, this.sphericalDelta.phi *= 1 - _
                            } else this.sphericalDelta.set(0, 0, 0);
                            return this.scale = 1, this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > .01 || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > 1e-8 ? (this.dispatchEvent(DE), this.object.dispatchEvent(DH), this.lastPosition.copy(this.object.position), this.lastQuaternion.copy(this.object.quaternion), this.zoomChanged = !1, !0) : (this.isPanOverShoot = !1, this.isRotateOverShoot = !1, this.object.wasMovedBySwitchCameraAction = !1, this.sphericalDelta.set(0, 0, 0), this.panOffset.set(0, 0, 0), !1)
                        }, this.onPointerDown = _ => {
                            !1 !== this.enabled && ("touch" === _.pointerType || "pen" === _.pointerType && dG ? this.onPointerDownTouch(_) : this.onPointerDownMouse(_), -1 !== this.state && (this.isPointerDown = !0, this.dispatchEvent(DI), this.domElement.addEventListener("pointermove", this.onPointerMove), this.domElement.addEventListener("pointerup", this.onPointerUp), _.stopPropagation(), "touch" === _.pointerType || "pen" === _.pointerType && dG || this.domElement.setPointerCapture(_.pointerId)))
                        }, this.onPointerLeave = _ => {
                            this.resetHoverEffectOnPointerLeave && !this.useWindowEvents ? (1 === this.hoverRotatePanMode ? (this.sphericalDelta.theta = -this.spherical.theta, this.sphericalDelta.phi = -this.spherical.phi, Dk.subVectors(this.position0, this.target0), this.spherical.setFromVector3(Dk), this.sphericalDelta.theta += this.spherical.theta, this.sphericalDelta.phi += this.spherical.phi, this.sphericalDelta.theta /= 8, this.sphericalDelta.phi /= 8) : 2 === this.hoverRotatePanMode && this.panOffset.subVectors(this.target0, this.target).divideScalar(8), this.update()) : this.pointerLeaveEvent = _
                        }, this.onPointerEnter = _ => {
                            this.resetHoverEffectOnPointerLeave || void 0 === this.pointerLeaveEvent ? DF.set(_.clientX - this.domElement.clientWidth / 2, _.clientY - this.domElement.clientHeight / 2) : DF.set(_.clientX - this.pointerLeaveEvent.clientX, _.clientY - this.pointerLeaveEvent.clientY), 1 === this.hoverRotatePanMode ? (this.rotateDelta.copy(DF).multiplyScalar(this.rotateSpeed * this.hoverRotatePanStrength).rotateAround(Dz, -this.object.angleOffsetFromUp), this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientHeight), this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight), this.rotateStart.set(_.clientX, _.clientY)) : 2 === this.hoverRotatePanMode && (this.panDelta.copy(DF).multiplyScalar(this.panSpeed * this.hoverRotatePanStrength), this.pan(this.panDelta.x, this.panDelta.y), this.panStart.set(_.clientX, _.clientY)), this.update()
                        }, this.onPointerMove = _ => {
                            !1 !== this.enabled && (this.checkRaycastLock() || ("touch" === _.pointerType || "pen" === _.pointerType && dG ? this.onPointerMoveTouch(_) : this.onPointerMoveMouse(_), _.stopPropagation()))
                        }, this.onPointerUp = _ => {
                            this.isPointerDown = !1, 0 === dq.length && (this.domElement.removeEventListener("pointermove", this.onPointerMove), this.domElement.removeEventListener("pointerup", this.onPointerUp)), dq.length > 1 && _.preventDefault(), this.hasChange ? this.dispatchEvent(DO) : this.dispatchEvent(DL), this.state = -1, _ && (_.stopPropagation(), "touch" === _.pointerType || "pen" === _.pointerType && dG || this.domElement.releasePointerCapture(_.pointerId))
                        }, this.onPointerDownMouse = _ => {
                            switch (this.useKeyEvents ? this.mouseButtons[_.button] : this.mouseButtonsPlay[_.button]) {
                                case 0:
                                    if (!0 !== _.altKey || _.shiftKey || ip(_)) {
                                        if (" " === this.key) {
                                            if (!1 === this.enablePan) return;
                                            this.handleMouseDownPan(_), this.state = 2
                                        }
                                    } else {
                                        if (!1 === this.enableRotate) return;
                                        this.handleMouseDownRotate(_), this.state = 0
                                    }
                                    break;
                                case 4:
                                    if (!1 === this.enablePan) return;
                                    this.handleMouseDownPan(_), this.state = 2;
                                    break;
                                case 3:
                                    if (ip(_) || _.shiftKey) {
                                        if (!1 === this.enablePan) return;
                                        this.handleMouseDownPan(_), this.state = 2
                                    } else {
                                        if (!1 === this.enableRotate) return;
                                        this.handleMouseDownRotate(_), this.state = 0
                                    }
                                    break;
                                case 5:
                                    if (ip(_) || _.shiftKey) {
                                        if (!1 === this.enableRotate) return;
                                        this.handleMouseDownRotate(_), this.state = 0
                                    } else {
                                        if (!1 === this.enablePan) return;
                                        this.handleMouseDownPan(_), this.state = 2
                                    }
                                    break;
                                default:
                                    this.state = -1
                            }
                        }, this.onPointerMoveMouse = _ => {
                            switch (this.state) {
                                case 0:
                                    if (!1 === this.enableRotate) return;
                                    this.handleMouseMoveRotate(_);
                                    break;
                                case 1:
                                    if (!1 === this.enableZoom) return;
                                    this.handleMouseMoveDolly(_);
                                    break;
                                case 2:
                                    if (!1 === this.enablePan) return;
                                    this.handleMouseMovePan(_)
                            }
                            this.object.wasMovedByUser = !0
                        }, this.onPointerDownTouch = _ => {
                            switch (dq.length > 1 && _.preventDefault(), this.touches[dq.length - 1]) {
                                case ij.ROTATE:
                                    if (!1 === this.enableRotate) {
                                        this.state = -1;
                                        return
                                    }
                                    this.handleTouchStartRotate(), this.state = 3;
                                    break;
                                case ij.PAN:
                                    if (!1 === this.enablePan) {
                                        this.state = -1;
                                        return
                                    }
                                    this.handleTouchStartPan(), this.state = 4;
                                    break;
                                case ij.DOLLY_PAN:
                                    if (!1 === this.enableZoom && !1 === this.enablePan) return;
                                    this.handleTouchStartDollyPan(), this.state = 5;
                                    break;
                                case ij.DOLLY_ROTATE:
                                    if (!1 === this.enableZoom && !1 === this.enableRotate) return;
                                    this.handleTouchStartDollyRotate(), this.state = 6;
                                    break;
                                default:
                                    this.state = -1
                            }
                        }, this.onPointerMoveTouch = _ => {
                            switch (dq.length > 1 && _.preventDefault(), this.state) {
                                case 3:
                                    if (!1 === this.enableRotate) return;
                                    this.handleTouchMoveRotate(_), this.update();
                                    break;
                                case 4:
                                    if (!1 === this.enablePan) return;
                                    this.handleTouchMovePan(_), this.update();
                                    break;
                                case 5:
                                    if (!1 === this.enableZoom && !1 === this.enablePan) return;
                                    this.handleTouchMoveDollyPan(_), this.update();
                                    break;
                                case 6:
                                    if (!1 === this.enableZoom && !1 === this.enableRotate) return;
                                    this.handleTouchMoveDollyRotate(_), this.update();
                                    break;
                                default:
                                    this.state = -1
                            }
                            this.object.wasMovedByUser = !0
                        }, this.dispatchEndDebounced = rc(() => this.dispatchEvent(DO), 33), this.onMouseWheel = _ => {
                            !1 === this.enabled || !1 === this.enableZoom && !1 === this.enablePan || this.checkRaycastLock() || (this.options.isExport || this.domElement.clientHeight !== document.body.clientHeight || this.domElement.clientWidth !== document.body.clientWidth || _.preventDefault(), this.dispatchEvent(DI), this.handleMouseWheel(_), this.dispatchEndDebounced(), this.object.wasMovedByUser = !0)
                        }, this.onGesture = _ => {
                            _.preventDefault(), !1 === this.enabled || this.checkRaycastLock() || dU || ("gesturechange" === _.type ? !1 !== this.enableZoom && !1 !== this.isTouchZoom && (this.dispatchEvent(DI), _.scale > this.prevScale ? this.dollyIn(this.getZoomScale()) : _.scale < this.prevScale && this.dollyOut(this.getZoomScale()), this.prevScale = _.scale, this.update(), this.object.wasMovedByUser = !0) : this.dispatchEvent(DO))
                        }, this.onContextMenu = _ => {
                            _.preventDefault()
                        }, this.onTouchEnd = _ => {
                            _.preventDefault()
                        }, this.onKeyDown = _ => {
                            !1 !== this.enabled && (this.key = _.key, " " === _.key && this.dispatchEvent(DI))
                        }, this.onKeyUp = _ => {
                            !1 !== this.enabled && (this.key = void 0, -1 !== this.state && "Alt" === _.key && this.onPointerUp(dq[0]), " " === _.key && this.dispatchEvent(DO))
                        }, this.onPointerHover = _ => {
                            "mouse" !== _.pointerType || !1 === this.enabled || -1 !== this.state || 2 === this.hoverRotatePanMode && this.isPanOverShoot || 1 === this.hoverRotatePanMode && this.isRotateOverShoot || (this.isPointerDown = !0, 2 === this.hoverRotatePanMode ? this.handleMouseMovePan(_, this.hoverRotatePanStrength) : 1 === this.hoverRotatePanMode && this.handleMouseMoveRotate(_, this.hoverRotatePanStrength))
                        }, this.onBeginState = () => {
                            this.enabled = !1, this.needsUpdate = !1
                        }, this.onCompleteState = _ => {
                            _.isfromEntity && this.options.isPlayMode || (this.enabled = !0, this.needsUpdate = !0, this.object.updateUp(), this.object.getTarget(this.target))
                        }, this.target = this.object.getTarget(), this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.quat0 = this.object.quaternion.clone(), this.isUpVectorFlipped0 = this.object.isUpVectorFlipped, this.offset.copy(this.object.position).sub(this.target), this.spherical.setFromVector3(this.offset), this.object.isUpVectorFlipped && (this.spherical.phi *= -1, this.spherical.theta -= Math.PI), this.addEventListenersToCamera()
                    }
                    dispatchEvent(_) {
                        "start" === _.type ? this.hasChange = !1 : this.hasChange = !0, super.dispatchEvent(_)
                    }
                    addEventListenersToCamera() {
                        this.object.addEventListener("beginState", this.onBeginState), this.object.addEventListener("completeState", this.onCompleteState), this.object.addEventListener("cameraChange", this.onCameraChange)
                    }
                    removeEventListenersFromCamera() {
                        this.object.removeEventListener("beginState", this.onBeginState), this.object.removeEventListener("completeState", this.onCompleteState), this.object.removeEventListener("cameraChange", this.onCameraChange)
                    }
                    updateUseWindowEvents(_) {
                        if (window.removeEventListener("pointermove", this.onPointerHover), this.domElement.removeEventListener("pointermove", this.onPointerHover), this.useWindowEvents = _, 0 !== this.hoverRotatePanMode && (this.useWindowEvents ? window.addEventListener("pointermove", this.onPointerHover) : this.domElement.addEventListener("pointermove", this.onPointerHover)), this.domElement.removeEventListener("pointerleave", this.onPointerLeave), this.domElement.removeEventListener("pointerenter", this.onPointerEnter), window.removeEventListener("pointerleave", this.onPointerLeave), window.removeEventListener("pointerenter", this.onPointerEnter), 0 !== this.hoverRotatePanMode && !this.useWindowEvents) {
                            let _ = this.useWindowEvents ? window : this.domElement;
                            _.addEventListener("pointerleave", this.onPointerLeave), _.addEventListener("pointerenter", this.onPointerEnter)
                        }
                    }
                    fromJSON(_, O) {
                        this.setEnableDampingSpeed(_.enableDamping), this.enablePan = _.enablePan, this.enableZoom = _.enableZoom, this.enableRotate = _.enableRotate, this.rotationLimitsMode = _.rotationLimitsMode, this.thetaIsFree = _.rotationHorizontalOffset.min === _.rotationHorizontalOffset.max && _.rotationHorizontalOffset.min === Math.PI, this.phiIsFree = _.rotationVerticalOffset.min === _.rotationVerticalOffset.max && _.rotationVerticalOffset.min === Math.PI, this.panLimitsMode = _.panLimitsMode, this.panSoftLimit = _.panSoftLimit, this.rotationSoftLimit = _.rotationSoftLimit, this.hoverRotatePanMode = _.hoverRotatePanMode, this.hoverRotateDamping = _.hoverRotateDamping ? ? this.dampingFactor, this.useWindowEvents = "window" === O, 0 !== this.hoverRotatePanMode && (this.useWindowEvents ? window.addEventListener("pointermove", this.onPointerHover) : this.domElement.addEventListener("pointermove", this.onPointerHover));
                        let B = _.hoverRotatePanStrength / 100;
                        this.hoverRotatePanStrength = B ** 2, this.zoomLimitsEnabled = _.zoomLimitsEnabled, this.minZoom = _.zoomLimits.min, this.maxZoom = Math.max(_.zoomLimits.min, _.zoomLimits.max), this.minDistance = 1e3 / _.zoomLimits.max, this.maxDistance = Math.max(this.minDistance, 1e3 / _.zoomLimits.min), this.autoRotate = _.autoRotate, this.autoRotateSpeed = _.autoRotateSpeed, this.autoRotateClockwise = _.autoRotateClockwise;
                        let N = this.object.getTarget().applyQuaternion(DB.copy(this.object.quaternion).invert());
                        this.minV = -_.panVerticalOffset.min + N.y, this.maxV = _.panVerticalOffset.max + N.y, this.minH = -_.panHorizontalOffset.min + N.x, this.maxH = _.panHorizontalOffset.max + N.x, this.panRangeFactor.set(this.maxH - this.minH, this.maxV - this.minV).divideScalar(2), this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4), this.minPhi = Do(this.spherical.phi - _.rotationVerticalOffset.min), this.maxPhi = Do(this.spherical.phi + _.rotationVerticalOffset.max), this.minTheta = Do(Do(this.spherical.theta) - _.rotationHorizontalOffset.min), this.maxTheta = Do(Do(this.spherical.theta) + _.rotationHorizontalOffset.max), this.isThetaFlipped = this.minTheta > this.maxTheta, 1 === _.orbitTouches && (this.touches[0] = ij.ROTATE), 1 === _.panTouches && (this.touches[0] = ij.PAN), 2 === _.orbitTouches && (this.touches[1] = ij.DOLLY_ROTATE), 2 === _.panTouches && (this.touches[1] = ij.DOLLY_PAN), 3 === _.orbitTouches && (this.touches[2] = ij.ROTATE), 3 === _.panTouches && (this.touches[2] = ij.PAN), this.isTouchZoom = _.isTouchZoom, this.resetHoverEffectOnPointerLeave = _.resetHoverEffectOnPointerLeave ? ? !1
                    }
                    connect() {
                        if (this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("wheel", this.onMouseWheel), window.addEventListener("keydown", this.onKeyDown, !1), window.addEventListener("keyup", this.onKeyUp, !1), this.domElement.addEventListener("gesturestart", this.onGesture), this.domElement.addEventListener("gesturechange", this.onGesture), this.domElement.addEventListener("gestureend", this.onGesture), this.domElement.addEventListener("touchend", this.onTouchEnd), 0 !== this.hoverRotatePanMode && !this.useWindowEvents) {
                            let _ = this.useWindowEvents ? window : this.domElement;
                            _.addEventListener("pointerleave", this.onPointerLeave), _.addEventListener("pointerenter", this.onPointerEnter)
                        }
                        this.pointerLeaveEvent = void 0
                    }
                    dispose() {
                        this.removeEventListenersFromCamera(), this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("pointerdown", this.onPointerDown), this.domElement.removeEventListener("wheel", this.onMouseWheel), window.removeEventListener("keydown", this.onKeyDown, !1), window.removeEventListener("keyup", this.onKeyUp, !1), this.domElement.removeEventListener("pointermove", this.onPointerHover), window.removeEventListener("pointermove", this.onPointerHover), this.domElement.removeEventListener("gesturestart", this.onGesture), this.domElement.removeEventListener("gesturechange", this.onGesture), this.domElement.removeEventListener("gestureend", this.onGesture), this.domElement.removeEventListener("touchend", this.onTouchEnd), this.domElement.removeEventListener("pointerleave", this.onPointerLeave), this.domElement.removeEventListener("pointerenter", this.onPointerEnter), window.removeEventListener("pointerleave", this.onPointerLeave), window.removeEventListener("pointerenter", this.onPointerEnter), this.domElement.removeEventListener("pointermove", this.onPointerMove), this.domElement.removeEventListener("pointerup", this.onPointerUp)
                    }
                    applyLimits(_, O, B, N, k, F, U, j) {
                        let G, Y, Q;
                        this.overShoot.set(0, 0), _ instanceof rv ? (G = _.x, Y = _.y, this.current.set(this.target.x, this.target.y), Q = !0) : (G = _.theta, Y = _.phi, this.current.set(Do(this.spherical.theta), Do(this.spherical.phi)), Q = !1), 0 === B && (this.current.x += G, this.current.y += Y), (3 === O || 2 === O) && (!Q && this.isThetaFlipped ? this.current.x > N && this.current.x < 0 ? this.overShoot.x = N - this.current.x : this.current.x < k && this.current.x > 0 && (this.overShoot.x = k - this.current.x) : this.current.x > N ? this.overShoot.x = N - this.current.x : this.current.x < k && (this.overShoot.x = k - this.current.x)), (3 === O || 1 === O) && (this.current.y > F ? this.overShoot.y = F - this.current.y : this.current.y < U && (this.overShoot.y = U - this.current.y)), Q || (this.overShoot.x = Do(this.overShoot.x), this.overShoot.y = Do(this.overShoot.y)), 0 !== B ? (this.overRatio.copy(this.overShoot).divide(j), this.overRatio.x = Math.min(Math.abs(this.overRatio.x), 1), this.overRatio.y = Math.min(Math.abs(this.overRatio.y), 1), 1 === B && (this.overRatio.x = i3(Math.abs(this.overRatio.x)), this.overRatio.y = i3(Math.abs(this.overRatio.y))), this.isPointerDown || 1 === B ? 2 === B && (this.overRatio.x > .9 && !this.thetaIsFree || this.overRatio.y > .9 && !this.phiIsFree) ? this.isPointerDown = !1 : (G * this.overShoot.x < 0 && !this.thetaIsFree && (G *= 1 - this.overRatio.x), Y * this.overShoot.y < 0 && !this.phiIsFree && (Y *= 1 - this.overRatio.y)) : 2 === B && (!Q && (this.overRatio.x > .002 && !this.thetaIsFree || this.overRatio.y > .002 && !this.phiIsFree) || Q && (Math.abs(this.overShoot.x) > 2 || Math.abs(this.overShoot.y) > 2) ? (this.thetaIsFree || (G = .05 * this.overShoot.x), this.phiIsFree || (Y = .05 * this.overShoot.y), Q ? this.isPanOverShoot = !0 : this.isRotateOverShoot = !0) : Q ? this.isPanOverShoot = !1 : this.isRotateOverShoot = !1)) : (G += this.overShoot.x, Y += this.overShoot.y), _ instanceof rv ? (_.x = G, _.y = Y) : (this.thetaIsFree || (_.theta = G), this.phiIsFree || (_.phi = Y))
                    }
                    setEnableDampingSpeed(_) {
                        this.enableDamping = _, this.rotateSpeed = !0 === _ ? .2 : 1
                    }
                    stopDamping() {
                        this.sphericalDelta.theta = 0, this.sphericalDelta.phi = 0
                    }
                    getAutoRotationAngle() {
                        return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed
                    }
                    getZoomScale() {
                        return Math.pow(.95, this.zoomSpeed)
                    }
                    rotateLeft(_) {
                        this.sphericalDelta.theta -= _
                    }
                    rotateUp(_) {
                        this.sphericalDelta.phi -= _
                    }
                    panLeft(_, O) {
                        this.panLeftV.setFromMatrixColumn(O, 0), this.panLeftV.multiplyScalar(-_), this.panOffset.add(this.panLeftV)
                    }
                    panUp(_, O) {
                        this.panUpV.setFromMatrixColumn(O, 1), this.panUpV.multiplyScalar(_), this.panOffset.add(this.panUpV)
                    }
                    pan(_, O) {
                        let B = this.domElement;
                        if (B && this.object.isPerspectiveCamera) {
                            let N = this.object.position;
                            this.panV.copy(N).sub(this.target);
                            let k = this.panV.length();
                            k *= Math.tan(this.object.fov / 2 * Math.PI / 180), this.panLeft(2 * _ * k / B.clientHeight, this.object.matrixWorld), this.panUp(2 * O * k / B.clientHeight, this.object.matrixWorld)
                        } else B && this.object.isOrthographicCamera && (this.panLeft(_ * (this.object.right - this.object.left) / this.object.zoom / B.clientWidth, this.object.matrixWorld), this.panUp(O * (this.object.top - this.object.bottom) / this.object.zoom / B.clientHeight, this.object.matrixWorld));
                        this.dispatchEvent(DP)
                    }
                    dollyOut(_) {
                        this.object.isPerspectiveCamera ? this.scale /= _ : this.object.isOrthographicCamera && (this.object.zoom *= _, this.zoomLimitsEnabled && (this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom))), this.object.updateProjectionMatrix(), this.zoomChanged = !0), this.dispatchEvent(DD)
                    }
                    dollyIn(_) {
                        this.object.isPerspectiveCamera ? this.scale *= _ : this.object.isOrthographicCamera && (this.object.zoom /= _, this.zoomLimitsEnabled && (this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom))), this.object.updateProjectionMatrix(), this.zoomChanged = !0), this.dispatchEvent(DD)
                    }
                    zoomOut(_ = this.getZoomScale()) {
                        this.dispatchEvent(DI), this.dollyOut(_), this.dispatchEvent(DO)
                    }
                    zoomIn(_ = this.getZoomScale()) {
                        this.dispatchEvent(DI), this.dollyIn(_), this.dispatchEvent(DO)
                    }
                    handleMouseDownRotate(_) {
                        this.rotateStart.set(_.clientX, _.clientY)
                    }
                    handleMouseDownDolly(_) {
                        this.dollyStart.set(_.clientX, _.clientY)
                    }
                    handleMouseDownPan(_) {
                        this.panStart.set(_.clientX, _.clientY)
                    }
                    handleMouseMoveRotate(_, O = 1) {
                        void 0 !== _.movementX ? this.rotateDelta.set(_.movementX, _.movementY) : (this.rotateEnd.set(_.clientX, _.clientY), this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart), this.rotateStart.copy(this.rotateEnd)), this.rotateDelta.multiplyScalar(this.rotateSpeed * O).rotateAround(Dz, -this.object.angleOffsetFromUp);
                        let B = this.domElement,
                            N = this.useWindowEvents ? window.innerHeight : B.clientHeight,
                            k = 2 * Math.PI * this.rotateDelta.x / N,
                            F = 2 * Math.PI * this.rotateDelta.y / N;
                        this.rotateLeft(k), this.rotateUp(F), this.update()
                    }
                    handleMouseMoveDolly(_) {
                        this.dollyEnd.set(_.clientX, _.clientY), this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart), this.dollyDelta.y > 0 ? this.dollyOut(this.getZoomScale()) : this.dollyDelta.y < 0 && this.dollyIn(this.getZoomScale()), this.dollyStart.copy(this.dollyEnd), this.update()
                    }
                    handleMouseMovePan(_, O = 1) {
                        void 0 !== _.movementX ? this.panDelta.set(_.movementX, _.movementY) : (this.panEnd.set(_.clientX, _.clientY), this.panDelta.subVectors(this.panEnd, this.panStart), this.panStart.copy(this.panEnd)), this.panDelta.multiplyScalar(this.panSpeed * O), this.pan(this.panDelta.x, this.panDelta.y), this.update()
                    }
                    handleMouseWheel(_) {
                        if (!1 === dj && !1 === ip(_) && !0 == (0 === _.wheelDeltaY || 0 === _.deltaY ? !(dF && _.shiftKey && Math.abs(_.wheelDeltaX) >= 120) && (_.wheelDeltaX ? _.wheelDeltaX === -3 * _.deltaX || _.wheelDeltaX === -3 * window.devicePixelRatio * _.deltaX : 0 === _.deltaMode) : _.wheelDeltaY ? _.wheelDeltaY === -3 * _.deltaY || _.wheelDeltaY === -3 * window.devicePixelRatio * _.deltaY : 0 === _.deltaMode)) !1 !== this.enablePan && (this.gesture ? (this.panDelta.set(-_.deltaX, -_.deltaY).multiplyScalar(this.panSpeed), this.panDelta.x = Math.min(Math.abs(this.panDelta.x), 100) * (this.panDelta.x < 0 ? -1 : 1), this.panDelta.y = Math.min(Math.abs(this.panDelta.y), 100) * (this.panDelta.y < 0 ? -1 : 1), _.altKey ? this.pan(0, this.panDelta.y) : _.shiftKey ? this.pan(this.panDelta.x, 0) : this.pan(this.panDelta.x, this.panDelta.y), this.update()) : (this.gesture = !0, this.isPointerDown = !0), window.clearTimeout(this.timer), this.timer = window.setTimeout(() => {
                            this.gesture = !1, this.isPointerDown = !1
                        }, 30));
                        else {
                            if (!1 === this.enableZoom) return;
                            0 === _.deltaY ? _.deltaX < 0 ? this.dollyIn(this.getZoomScale()) : _.deltaX > 0 && this.dollyOut(this.getZoomScale()) : _.deltaY < 0 ? this.dollyIn(this.getZoomScale()) : _.deltaY > 0 && this.dollyOut(this.getZoomScale()), this.update(), this.gesture = !1, this.isPointerDown = !1
                        }
                    }
                    handleTouchStartRotate() {
                        if (2 === dq.length) {
                            let _ = .5 * (dq[0].pageX + dq[1].pageX),
                                O = .5 * (dq[0].pageY + dq[1].pageY);
                            this.rotateStart.set(_, O)
                        } else this.rotateStart.set(dq[0].pageX, dq[0].pageY)
                    }
                    handleTouchStartPan() {
                        if (2 === dq.length) {
                            let _ = .5 * (dq[0].pageX + dq[1].pageX),
                                O = .5 * (dq[0].pageY + dq[1].pageY);
                            this.panStart.set(_, O)
                        } else this.panStart.set(dq[0].pageX, dq[0].pageY)
                    }
                    handleTouchStartDolly() {
                        let _ = dq[0].pageX - dq[1].pageX,
                            O = dq[0].pageY - dq[1].pageY,
                            B = Math.sqrt(_ * _ + O * O);
                        this.dollyStart.set(0, B)
                    }
                    handleTouchStartDollyPan() {
                        this.enableZoom && !0 === this.isTouchZoom && this.handleTouchStartDolly(), this.enablePan && this.handleTouchStartPan()
                    }
                    handleTouchStartDollyRotate() {
                        this.enableZoom && !0 === this.isTouchZoom && this.handleTouchStartDolly(), this.enableRotate && this.handleTouchStartRotate()
                    }
                    handleTouchMoveRotate(_) {
                        if (2 === dq.length) {
                            let O = my(_),
                                B = .5 * (_.pageX + O.x),
                                N = .5 * (_.pageY + O.y);
                            this.rotateEnd.set(B, N)
                        } else {
                            if (_.pointerId !== dq[0].pointerId) return;
                            this.rotateEnd.set(_.pageX, _.pageY)
                        }
                        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
                        let O = this.domElement;
                        O && (this.rotateLeft(2 * Math.PI * this.rotateDelta.x / O.clientHeight), this.rotateUp(2 * Math.PI * this.rotateDelta.y / O.clientHeight)), this.rotateStart.copy(this.rotateEnd)
                    }
                    handleTouchMovePan(_) {
                        if (2 === dq.length) {
                            let O = my(_),
                                B = .5 * (_.pageX + O.x),
                                N = .5 * (_.pageY + O.y);
                            this.panEnd.set(B, N)
                        } else {
                            if (_.pointerId !== dq[0].pointerId) return;
                            this.panEnd.set(_.pageX, _.pageY)
                        }
                        this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed), this.pan(this.panDelta.x, this.panDelta.y), this.panStart.copy(this.panEnd)
                    }
                    handleTouchMoveDolly(_) {
                        let O = my(_),
                            B = _.pageX - O.x,
                            N = _.pageY - O.y,
                            k = Math.sqrt(B * B + N * N);
                        this.dollyEnd.set(0, k), this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed)), this.dollyOut(this.dollyDelta.y), this.dollyStart.copy(this.dollyEnd)
                    }
                    handleTouchMoveDollyPan(_) {
                        this.enableZoom && !0 === this.isTouchZoom && this.handleTouchMoveDolly(_), this.enablePan && this.handleTouchMovePan(_)
                    }
                    handleTouchMoveDollyRotate(_) {
                        this.enableZoom && !0 === this.isTouchZoom && this.handleTouchMoveDolly(_), this.enableRotate && this.handleTouchMoveRotate(_)
                    }
                    checkRaycastLock() {
                        if (!this.object.data.raycastLock || this.options.isPlayMode) return !1; {
                            let _ = this.options ? .showCameraLock;
                            return _ && _(), !0
                        }
                    }
                };

            function Do(_) {
                let O = 2 * Math.PI;
                for (; _ <= -Math.PI;) _ += O;
                for (; _ > Math.PI;) _ -= O;
                return _
            }

            function i3(_) {
                return 1 - Math.pow(1 - _, 4)
            }
            var Dq = class {
                constructor(_, O, B, N, k, F) {
                    this.id = _, this.data = O, this.object = B, this.page = N, this.currentIntersectedObjects = [], this.disabled = !1, this.alreadyPlayedNonTogglingActions = new Set, this.actions = nr(O, O.actions, N, k, F, B), this.target = O.target, this.useToggle = "Toggle" === O.runMode, this.triggeringObjects = O.triggeringObjects.map(_ => N.scene.find(_))
                }
                isValidTriggeringObject(_) {
                    return "all" === this.target || this.triggeringObjects.some(O => O === _ || O.isAncestorOf(_.uuid) || _.isAncestorOf(O.uuid))
                }
                disconnect() {
                    qt(this.actions)
                }
                dispatch() {
                    this.disabled || this.object.destroyedInAction || (this.actions.Transition.forEach(_ => {
                        _.object.currentTransitionEvent !== this ? (_.object.currentTransitionEvent = this, _.init()) : "Once" === this.data.runMode && this.alreadyPlayedNonTogglingActions.add(_)
                    }), this.object.dispatchEvent({
                        type: "beginEvent",
                        eventName: "Trigger"
                    }), this.useToggle ? (this.actions.Transition.forEach(_ => {
                        _.toggle()
                    }), this.actions.SwitchCamera.forEach(_ => {
                        _.toggle()
                    })) : (this.actions.Transition.forEach(_ => {
                        !1 === this.alreadyPlayedNonTogglingActions.has(_) && _.play()
                    }), this.actions.SwitchCamera.forEach(_ => {
                        _.play()
                    })), this.actions.Link.forEach(_ => {
                        _.dispatch()
                    }), this.actions.Reset.forEach(_ => {
                        _.dispatch()
                    }), this.actions.Create.forEach(_ => {
                        _.dispatch()
                    }), this.actions.Destroy.forEach(_ => {
                        _.dispatch(!1)
                    }), this.actions.Audio.forEach(_ => {
                        _.dispatchBasic()
                    }), this.actions.Video.forEach(_ => {
                        _.dispatchBasic()
                    }), this.actions.SceneTransition.forEach(_ => {
                        _.dispatch()
                    }), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch()))
                }
            };
            d8.then(_ => is = _);
            var DY = new rv,
                DX = new rm,
                DQ = new rv,
                DZ = new r9(0, 0, 0, "YXZ"),
                DK = new r9(0, 0, 0, "XYZ"),
                DJ = new rv,
                D$ = new rv,
                D2 = new rv(1, 1, 1),
                D3 = new rm,
                D4 = new rJ,
                D5 = new rJ,
                D6 = {
                    type: "updateMatrix"
                },
                D8 = new rm,
                D9 = new rG,
                D7 = {
                    type: "beginEvent",
                    eventName: "Collision"
                },
                Pt = {
                    type: "beginEvent",
                    eventName: "Trigger"
                },
                Im = _ => _.states.some(_ => void 0 !== _.data.position || void 0 !== _.data.rotation || void 0 !== _.data.hiddenMatrix || void 0 !== _.data.cloner || void 0 !== _.data.pathSnapping),
                Pi = class {
                    constructor(_) {
                        this.eventContext = _, this.isEnabled = !1, this.gameControl = null, this.joysticks = [], this.joystickToGameControls = [], this.sharedGameControlGlobals = {
                            entitiesWithTransformAnim: [],
                            entityToCollisionEvents: {},
                            colliderToEntity: new Map,
                            triggers: [],
                            gamePads: [],
                            createdObjects: [],
                            nCreatedPerAction: {}
                        }, this.sensorToTriggerEvent = {}, this.eventManager = void 0, this.needsCollisionDetection = !1, this.initializationCounter = -1, this.rigidBodyToMesh = new Map, this.nActiveRigidBodies = 0, this.collisionEvents = [], this.isExport = !1, this.processRigidBody = _ => {
                            if (_.bodyType() !== is.RigidBodyType.Dynamic) return;
                            _.isSleeping() || this.nActiveRigidBodies++;
                            let [O, B, N] = this.rigidBodyToMesh.get(_.handle);
                            if (DY.copy(_.translation()).multiplyScalar(this.pixelsPerMeter), DX.copy(_.rotation()), O.matrixWorld.compose(DY, DX, B), O.hasNonUniformScale && O.matrixWorld.multiply(O.shearScale), O.dispatchEvent(D6), N) {
                                let _ = O.cloner;
                                if (_ && void 0 === _.objectForSample)
                                    for (let B of (_.matrixWorld.copy(O.matrixWorld), _.children)) B.updateMatrixWorld(!0);
                                for (let _ of O.children) _.updateMatrixWorld(!0)
                            }
                        }, this.accumulator = 0, this.handleCollisionEvents = (_, O, B) => {
                            let N, k;
                            if (!1 !== B) {
                                if (this.sensorToTriggerEvent[_] ? (N = this.sensorToTriggerEvent[_], k = this.sharedGameControlGlobals.colliderToEntity.get(O)) : this.sensorToTriggerEvent[O] && (N = this.sensorToTriggerEvent[O], k = this.sharedGameControlGlobals.colliderToEntity.get(_)), N && k && N.isValidTriggeringObject(k)) {
                                    N.dispatch();
                                    return
                                }
                                for (let B = this.sharedGameControlGlobals.createdObjects.length - 1; B >= 0; B--) {
                                    let N = this.sharedGameControlGlobals.createdObjects[B];
                                    if (N.userData.hasCollisionDestroy && (N.rigidBody ? .collider(0).handle === _ || N.rigidBody ? .collider(0).handle === O)) {
                                        this.sharedGameControlGlobals.createdObjects.splice(B, 1), N.removeFromParent(), requestAnimationFrame(() => this.sharedGameControlGlobals.rapierWorld ? .removeRigidBody(N.rigidBody));
                                        break
                                    }
                                }
                                if (this.gameControl ? .object === this.sharedGameControlGlobals.colliderToEntity.get(_)) {
                                    let _ = this.sharedGameControlGlobals.colliderToEntity.get(O),
                                        B = this.sharedGameControlGlobals.entityToCollisionEvents[_.uuid];
                                    if (void 0 === B) return;
                                    for (let N of B) "character" === N.data.target && this.dispatchCollisionEvent(N, _, O)
                                } else if (this.gameControl ? .object === this.sharedGameControlGlobals.colliderToEntity.get(O)) {
                                    let O = this.sharedGameControlGlobals.colliderToEntity.get(_),
                                        B = this.sharedGameControlGlobals.entityToCollisionEvents[O.uuid];
                                    if (void 0 === B) return;
                                    for (let N of B) "character" === N.data.target && this.dispatchCollisionEvent(N, O, _)
                                } else {
                                    let B = this.sharedGameControlGlobals.colliderToEntity.get(_),
                                        N = this.sharedGameControlGlobals.entityToCollisionEvents[B.uuid];
                                    if (void 0 !== N)
                                        for (let O of N) "scene" === O.data.target && this.dispatchCollisionEvent(O, B, _);
                                    let k = this.sharedGameControlGlobals.colliderToEntity.get(O),
                                        F = this.sharedGameControlGlobals.entityToCollisionEvents[k ? .uuid];
                                    if (void 0 !== F)
                                        for (let _ of F) "scene" === _.data.target && this.dispatchCollisionEvent(_, k, O)
                                }
                            }
                        }, this.isExport = _.isExport, this.sharedAssets = _.sharedAssets, this.renderer = _.renderer, this.requestRender = _.requestRender, this.domElement = this.renderer.domElement, this.pixelsPerMeter = 200, this.gravity = this.page.data.globalPhysics.gravity
                    }
                    get page() {
                        return this.eventContext.page
                    }
                    attachVRControllers(_) {
                        _.forEach(_ => {
                            _.addEventListener("connected", _ => {
                                "gamepad" in _.data && "axes" in _.data.gamepad && this.sharedGameControlGlobals.gamePads.push(_.data.gamepad)
                            })
                        })
                    }
                    markIsDestroyTarget() {
                        this.page.traverseVisibleEntity(_ => {
                            for (let O of _.dataPatched.events) {
                                if (!0 === O.data.disabled) continue;
                                let _ = O.data.actions ? .find(_ => "Destroy" === _.data.type) ? .data;
                                if (_)
                                    for (let O of _.objects) {
                                        let _ = this.page.scene.find(O);
                                        _ && (_.userData.hasDestroy = !0)
                                    }
                            }
                        })
                    }
                    markIsDragObject() {
                        this.page.traverseVisibleEntity(_ => {
                            for (let O of _.dataPatched.events)
                                if (!(!0 === O.data.disabled || "DragDrop" !== O.data.type))
                                    for (let _ of O.data.objects) {
                                        let O = this.page.scene.find(_);
                                        O && (O.userData.hasDrag = !0)
                                    }
                        })
                    }
                    initBVH() {
                        let _ = [];
                        if (this.page.traverseChildren(O => {
                                let B;
                                if (O instanceof _3) return;
                                let N = (B = O instanceof vb ? O.object : O).dataPatched;
                                if (N.physics ? .enabled === "visibility" ? !N.visible : !N.physics ? .enabled) return !0;
                                let k = O.geometry,
                                    F = !0 === B.userData.hasDestroy,
                                    U = !0 === B.userData.hasDrag;
                                if (Im(N) || F || U || B.dataPatched.events.some(_ => !0 !== _.data.disabled && "GameControl" === _.data.type)) return O.updateMatrixWorldSVD(), this.addBoundsTree(O), !0;
                                k && _.push(Vs(k, O.matrixWorld))
                            }), _.length > 0) {
                            let O = ws(_, !1);
                            this.sharedGameControlGlobals.staticMeshBVH = new vt(O)
                        }
                    }
                    addRigidBody(_, O, B) {
                        let N = [],
                            k = "geometry" in _ ? _.geometry : void 0,
                            F = O.dataPatched;
                        if (k ? .getAttribute("position") !== void 0 && N.push(Vs(k, _.shearScale)), F.physics.fusedBody) {
                            let O = this.gatherChildrenGeom(_, N);
                            _.traverseObject(O), _.children.forEach(_ => _.updateMatrixWorld(!0));
                            let B = _.cloner;
                            B && void 0 === B.objectForSample && "dynamic" === F.physics.rigidBody && (B.traverseObject(O), B.children.forEach(_ => _.updateMatrixWorld(!0)))
                        }
                        if (N.length > 0) {
                            let U, j = !B.fromCreate && "dynamic" === F.physics.rigidBody || B.fromCreate && B.dynamic;
                            j ? (U = is.RigidBodyDesc.dynamic()).setLinearDamping(F.physics.damping).setAngularDamping(F.physics.damping).setAdditionalMass(1e-9).setGravityScale(F.physics.gravityScale).enabledRotations(...F.physics.enabledRotation).enabledTranslations(...F.physics.enabledTranslation) : (B.hasTransformAnim || B.hasFollow || B.hasDrag) && !B.fromCreate ? (U = is.RigidBodyDesc.kinematicPositionBased(), this.sharedGameControlGlobals.entitiesWithTransformAnim.push(_)) : U = is.RigidBodyDesc.fixed();
                            let G = ws(N);
                            (_.hasNonUniformScale ? _.matrixWorldRigid : _.matrixWorld).decompose(DY, DX, DQ), _.position0 = DY.clone().divideScalar(this.pixelsPerMeter), _.rotation0 = DX.clone(), DY.divideScalar(this.pixelsPerMeter), U.setTranslation(DY.x, DY.y, DY.z).setRotation(DX), k ? G ? .scale(1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter) : G ? .scale(DQ.x / this.pixelsPerMeter, DQ.y / this.pixelsPerMeter, DQ.z / this.pixelsPerMeter);
                            let Y = this.sharedGameControlGlobals.rapierWorld.createRigidBody(U);
                            j && this.rigidBodyToMesh.set(Y.handle, [_, DQ.clone(), F.physics.fusedBody]);
                            let Q = !(void 0 === F.geometry || "SubdivGeometry" === F.geometry.type || "NonParametricGeometry" === F.geometry.type || "BooleanGeometry" === F.geometry.type || "VectorGeometry" === F.geometry.type || "StarGeometry" === F.geometry.type || "RectangleGeometry" === F.geometry.type || "EllipseGeometry" === F.geometry.type || "TriangleGeometry" === F.geometry.type || "TorusGeometry" === F.geometry.type || "HelixGeometry" === F.geometry.type);
                            try {
                                this.addCollider(Y, F.physics, G, O, Q)
                            } catch {
                                try {
                                    this.addCollider(Y, F.physics, G, O, !1)
                                } catch (_) {
                                    console.error(_)
                                }
                            }
                            _.rigidBody = Y
                        }
                    }
                    addBoundsTree(_) {
                        let O = [];
                        if (_.geometry ? .getAttribute("position") !== void 0 && _.geometry ? .getAttribute("position").count > 0 && O.push(Vs(_.geometry, _.shearScale)), _.traverseObject(this.gatherChildrenGeom(_, O)), _.children.forEach(_ => _.updateMatrixWorld(!0)), O.length > 0) {
                            let B = ws(O, !1);
                            _.bvhGeometry = B, _.bvhGeometry.boundsTree = new vt(B), this.sharedGameControlGlobals.entitiesWithTransformAnim.push(_)
                        }
                    }
                    addCollider(_, O, B, N, k = !0) {
                        let F;
                        if (B ? .getAttribute("position").count === 0 || B ? .getIndex() ? .count === 0) return;
                        B && (F = "trimesh" === O.colliderType ? is.ColliderDesc.trimesh(B.getAttribute("position").array, B.getIndex().array) : is.ColliderDesc.convexMesh(B.getAttribute("position").array, k ? B.getIndex().array : void 0)), F.setFrictionCombineRule(is.CoefficientCombineRule.Average).setRestitutionCombineRule(is.CoefficientCombineRule.Average).setDensity(O.density).setFriction(O.friction).setRestitution(O.restitution);
                        let U = this.sharedGameControlGlobals.rapierWorld.createCollider(F, _);
                        this.sharedGameControlGlobals.colliderToEntity.set(U.handle, N), this.sharedGameControlGlobals.entityToCollisionEvents[N.uuid] ? .some(_ => "scene" === _.target) && U.setActiveEvents(is.ActiveEvents.COLLISION_EVENTS)
                    }
                    gatherChildrenGeom(_, O) {
                        return (B, N) => {
                            let k;
                            if (0 === N) return;
                            if (B instanceof _3) {
                                if (!B.objectForSample) return !0 === B.object.dataPatched.physics.fusedBody && "dynamic" === B.object.dataPatched.physics.rigidBody || void 0;
                                if (B.objectForSample.dataPatched.physics.fusedBody) return;
                                k = B.object
                            } else if (B instanceof vb) k = B.object;
                            else if (k = B, k.dataPatched.cloner ? .hideBase) return !0;
                            let F = k.dataPatched;
                            if ("visibility" === F.physics.enabled ? !F.visible : !F.physics.enabled) return !0;
                            1 === N ? _.hasNonUniformScale ? B.matrixWorld.multiplyMatrices(_.shearScale, B.hiddenMatrix) : B.matrixWorld.copy(B.hiddenMatrix) : B.matrixWorld.multiplyMatrices(B.parent.matrixWorld, B.hiddenMatrix), B.matrixWorld.multiply(B.matrix);
                            let U = B.geometry;
                            U ? .getAttribute("position") !== void 0 && O.push(Vs(U, B.matrixWorld))
                        }
                    }
                    activate(_) {
                        if (this.isEnabled) return;
                        this.isEnabled = !0, this.eventManager = _, this.usePhysics = this.page.data.globalPhysics.usePhysics;
                        let O = this.page.playCamera,
                            B = !1,
                            N = 5,
                            k = 8,
                            F = 9,
                            U = "drag",
                            j = this.page.data.publish.gameControlObject,
                            G = null !== j ? this.page.find(j) : null,
                            Y = null;
                        if (G)
                            for (let _ of G.data.events) {
                                if (_.data.disabled || "GameControl" !== _.data.type) break;
                                let O = G;
                                for (; this.usePhysics && (O = O.parent) ? .parent !== null && !O.data.physics ? .fusedBody;);
                                _.data.collisionEnabled && (this.needsCollisionDetection = !0), null === Y && (Y = _.data)
                            }
                        if (this.page.traverseEntity(_ => {
                                for (let O of _.dataPatched.events)
                                    if (!1 === O.data.disabled && "Trigger" === O.data.type) return this.needsCollisionDetection = !0, !0
                            }), G && Y) {
                            B = B || Y.camera === O.uuid || G.uuid === O.uuid;
                            let _ = new CK(G, this.renderer.domElement, Y, this.eventContext.page.data.globalPhysics, this, G.uuid !== O.uuid && Y.camera === O.uuid, O, this.page, this.sharedAssets);
                            this.gameControl = _, N = Y.joystickPosLoc, k = Y.joystickRotLoc, F = Y.jumpTouchButtonLoc, U = Y.rotByTouch, dG && Y.touchControl && (this.joystickToGameControls[N] = "pos", "walk" === Y.moveMode && (this.joystickToGameControls[F] = "jmp"), "joystick" === U && (this.joystickToGameControls[k] = "rot"))
                        }
                        if (this.gameControl && this.gameControl.data.navmesh.enabled) {
                            let _ = this.gameControl.data;
                            if (!this.navigationMeshWrapper) {
                                let O;
                                this.navigationMeshWrapper = new DA(this.usePhysics, this.isExport), O = Math.floor((O = "sphere" === _.collider.type ? 2 * _.collider.radius : _.collider.height) / _.navmesh.ch - 1), this.navigationMeshWrapper.init({ ..._.navmesh,
                                    walkableHeight: O
                                }, this.gameControl, this.eventContext)
                            }
                        }
                        if (!1 === B) {
                            let {
                                enableRotate: _,
                                enablePan: B,
                                enableZoom: N,
                                autoRotate: k,
                                hoverRotatePanMode: F
                            } = this.eventManager.publish.orbitControls;
                            (_ || B || N || k || 0 !== F) && (this.orbitControls = new DW(O, this.renderer.domElement, {
                                isExport: this.isExport,
                                isPlayMode: !0
                            }), this.orbitControls.addEventListener("change", this.requestRender), this.orbitControls.addEventListener("end", this.requestRender), this.orbitControls.addEventListener("start", this.requestRender), this.orbitControls.fromJSON(this.eventManager.publish.orbitControls, this.eventManager.publish.mouseEventTarget), this.orbitControls.useKeyEvents = !1, this.orbitControls.addEventListenersToCamera(), this.orbitControls.connect(), this.orbitControls.update())
                        }
                        let Q = this.renderer.domElement.width / this.renderer.getPixelRatio(),
                            K = this.renderer.domElement.height / this.renderer.getPixelRatio();
                        this.joystickToGameControls.forEach((_, O) => {
                            let B = document.body.appendChild(document.createElement("div")),
                                [N, k, F] = this.eventManager.eventContext.publish.joystickSizeAndXYOffset[O],
                                U = (Q - 5 * N) / 4 + N,
                                j = {},
                                G = "jmp" === _,
                                Y = G ? 0 : N;
                            for (let _ in O < 10 ? (O < 5 ? j.top = Y / 2 : j.bottom = Y / 2, j.left = Y / 2 + O % 5 * U) : (10 === O ? j.left = Y / 2 : j.right = Y / 2, j.top = K / 2), j.top ? j.top -= k[1] : j.bottom += k[1], j.left ? j.left += k[0] : j.right -= k[0], j) j[_] += "px";
                            if (G) {
                                let _ = B.appendChild(document.createElement("div"));
                                Object.assign(_.style, j, {
                                    position: "absolute",
                                    width: N + "px",
                                    height: N + "px",
                                    backgroundColor: `rgba(255,255,255,${"show"===F?.4:0})`,
                                    zIndex: "9999",
                                    borderRadius: N + "px",
                                    border: "show" === F ? "solid 2px rgba(0, 0, 0, .1)" : "none",
                                    display: "flex",
                                    alignItems: "center",
                                    justifyContent: "center",
                                    touchAction: "none"
                                });
                                let k = N / 16 * 6.4;
                                "show" === F && (_.innerHTML = `
						<svg width="${k}" height="${.4*N}" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M2 10L8 4L14 10" stroke="black" stroke-opacity="40%" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					`), _.addEventListener("pointerdown", () => {
                                    this.gameControl.movementState.jump = 1, this.requestRender()
                                }), _.addEventListener("touchend", _ => _.preventDefault()), this.joysticks[O] = [void 0, B];
                                return
                            }
                            let $ = {
                                zone: B,
                                mode: "static",
                                position: j,
                                size: N
                            };
                            "hide" === F && ($.restOpacity = 0);
                            let ee = EI.create($);
                            ee.on("move", (O, B) => {
                                let N = this.gameControl;
                                "pos" === _ ? B.force < .2 ? N.moveForce = 0 : (N.movementState.movePosZ = Math.sin(-B.angle.radian), N.movementState.movePosX = Math.cos(-B.angle.radian), B.force > 1.2 ? N.movementState.run = 1 : N.movementState.run = 0, B.force < .3 ? N.moveForce = (B.force - .2) / .1 : N.moveForce = 1) : "rot" === _ && (B.force < .2 ? N.rotForce = 0 : (N.movementState.rotPosX = B.vector.y, N.movementState.rotPosY = -B.vector.x, B.force < .3 ? N.rotForce = (B.force - .2) / .1 : N.rotForce = 1)), this.requestRender()
                            }), ee.on("end", (O, B) => {
                                let N = this.gameControl;
                                "pos" === _ ? (N.movementState.movePosZ = 0, N.movementState.movePosX = 0, N.moveForce = 1) : "rot" === _ && (N.movementState.rotPosX = 0, N.movementState.rotPosY = 0, N.rotForce = 1)
                            }), this.joysticks[O] = [ee, B]
                        }), this.markIsDestroyTarget(), this.markIsDragObject(), this.rebuildBVH(), this.initializationCounter++, window.setTimeout(() => {
                            this.collisionEvents.forEach(_ => _.disabled = !1)
                        }, 80)
                    }
                    initPhysics() {
                        this.sharedGameControlGlobals.rapierWorld ? .free(), this.sharedGameControlGlobals.rapierWorld = new is.World(new is.Vector3(0, this.gravity, 0)), this.events = new is.EventQueue(!0);
                        let _ = [],
                            O = [];
                        if (this.page.traverseChildren(B => {
                                let N;
                                if (B instanceof _3) {
                                    if (!B.objectForSample) return !0 === B.object.dataPatched.physics.fusedBody && "dynamic" === B.object.dataPatched.physics.rigidBody || void 0;
                                    if (B.objectForSample.dataPatched.physics.fusedBody) return;
                                    N = B.object
                                } else if (B instanceof vb) N = B.object;
                                else if (N = B, N.dataPatched.cloner ? .disabled === !1 && N.dataPatched.cloner ? .hideBase && N.dataPatched.physics ? .fusedBody !== !0) return !0;
                                let k = N.dataPatched,
                                    F;
                                for (let _ of k.events) !0 !== _.data.disabled && "GameControl" === _.data.type && (F = _.data);
                                if (!k.physics || ("visibility" === k.physics.enabled ? !k.visible : !k.physics.enabled)) return !0;
                                B.updateMatrixWorldSVD();
                                let U = Im(k),
                                    j = !1,
                                    G = N.userData.hasDestroy,
                                    Y = N.userData.hasDrag,
                                    Q = !1;
                                for (let _ of k.events)
                                    if (!0 !== _.data.disabled) {
                                        if ("Collision" === _.data.type) {
                                            j = !0;
                                            let O = new Dc(_.id, _.data, N, this.page, this.sharedAssets, this.eventManager);
                                            O.disabled = !0, this.collisionEvents.push(O), this.sharedGameControlGlobals.entityToCollisionEvents[N.uuid] && this.sharedGameControlGlobals.entityToCollisionEvents[N.uuid].every(O => O.id !== _.id) ? this.sharedGameControlGlobals.entityToCollisionEvents[N.uuid].push(O) : this.sharedGameControlGlobals.entityToCollisionEvents[N.uuid] = [O]
                                        } else if ("Follow" === _.data.type) {
                                            Q = !0;
                                            let O = _.data.target;
                                            B.traverseVisible(_ => {
                                                _.userData.isFollowingObj = O
                                            })
                                        }
                                    }
                                "dynamic" === k.physics.rigidBody && !1 === k.physics.fusedBody && (B.matrixWorldFusedFalse = B.matrixWorld.clone());
                                let K = B.geometry;
                                if (void 0 !== F) {
                                    let _, O = is.RigidBodyDesc.kinematicPositionBased();
                                    (B.hasNonUniformScale ? B.matrixWorldRigid : B.matrixWorld).decompose(DY, DX, DQ), B.position0 = DY.clone().divideScalar(this.pixelsPerMeter), B.rotation0 = DX.clone(), DY.divideScalar(this.pixelsPerMeter), O.setTranslation(DY.x, DY.y, DY.z).setRotation(DX);
                                    let U = this.sharedGameControlGlobals.rapierWorld.createRigidBody(O);
                                    B.rigidBody = U, (_ = "sphere" === F.collider.type ? is.ColliderDesc.ball(F.collider.radius / this.pixelsPerMeter) : "capsule" === F.collider.type ? is.ColliderDesc.capsule((F.collider.height / 2 - F.collider.radius) / this.pixelsPerMeter, F.collider.radius / this.pixelsPerMeter) : is.ColliderDesc.cuboid(F.collider.width / this.pixelsPerMeter / 2, F.collider.height / this.pixelsPerMeter / 2, F.collider.depth / this.pixelsPerMeter / 2)).setFrictionCombineRule(is.CoefficientCombineRule.Average).setRestitutionCombineRule(is.CoefficientCombineRule.Average).setDensity(k.physics.density).setFriction(k.physics.friction).setRestitution(k.physics.restitution);
                                    let j = this.sharedGameControlGlobals.rapierWorld.createCollider(_, U);
                                    this.sharedGameControlGlobals.colliderToEntity.set(j.handle, N), DY.fromArray(F.collider.position).multiply(DQ.setFromMatrixScale(N.matrixWorld)).divideScalar(this.pixelsPerMeter), j.setTranslationWrtParent(DY);
                                    let G = new rm().setFromEuler(new r9().setFromVector3(new rv().fromArray(F.collider.rotation)));
                                    j.setRotationWrtParent(G), j.setActiveEvents(is.ActiveEvents.COLLISION_EVENTS), this.generateSensorColliderDescs(N, !0)
                                } else "dynamic" === k.physics.rigidBody || U || Q || G || Y || j ? (this.addRigidBody(B, N, {
                                    hasFollow: Q,
                                    hasTransformAnim: U,
                                    hasDrag: Y
                                }), this.generateSensorColliderDescs(N, k.physics.fusedBody)) : (K && _.push(Vs(K, B.matrixWorld)), k.physics.fusedBody && B.traverseObject((O, B) => {
                                    let N;
                                    if (0 === B) return;
                                    if (O instanceof _3) {
                                        if (!O.objectForSample) return !0 === O.object.dataPatched.physics.fusedBody && "dynamic" === O.object.dataPatched.physics.rigidBody || void 0;
                                        if (O.objectForSample.dataPatched.physics.fusedBody) return;
                                        N = O.object
                                    } else if (O instanceof vb) N = O.object;
                                    else if (N = O, N.dataPatched.cloner ? .hideBase) return !0;
                                    let k = N.dataPatched;
                                    if ("visibility" === k.physics.enabled ? !k.visible : !k.physics.enabled) return !0;
                                    let F = O.geometry;
                                    F ? .getAttribute("position") !== void 0 && _.push(Vs(F, O.matrixWorld))
                                }), this.generateSensorColliderDescs(N, k.physics.fusedBody, O));
                                if (k.physics ? .fusedBody === !0 || F) return !0
                            }), 0 === _.length) return;
                        let B = ws(_);
                        B.scale(1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter);
                        let N = is.RigidBodyDesc.fixed(),
                            k = this.sharedGameControlGlobals.rapierWorld.createRigidBody(N),
                            F = is.ColliderDesc.trimesh(B.getAttribute("position").array, B.getIndex().array).setFrictionCombineRule(is.CoefficientCombineRule.Multiply).setRestitutionCombineRule(is.CoefficientCombineRule.Multiply).setFriction(1).setRestitution(1);
                        for (let [_, B] of (this.sharedGameControlGlobals.rapierWorld.createCollider(F, k), O)) {
                            let O = this.sharedGameControlGlobals.rapierWorld.createCollider(_, k);
                            this.sensorToTriggerEvent[O.handle] = B
                        }
                    }
                    updatePositions() {
                        return this.nActiveRigidBodies = 0, this.sharedGameControlGlobals.rapierWorld.forEachRigidBody(this.processRigidBody), this.nActiveRigidBodies > 0
                    }
                    rebuildBVH() {
                        this.usePhysics ? this.initPhysics() : (this.page.traverseEntity(_ => {
                            for (let O of _.dataPatched.events)
                                if ("Trigger" === O.data.type && !0 !== O.data.disabled) {
                                    let B = new Dq(O.id, O.data, _, this.page, this.sharedAssets, this.eventManager),
                                        N = new rJ().compose(DJ.fromArray(O.data.position), D3.setFromEuler(DK.fromArray(O.data.rotation)), D2);
                                    if ("box" === O.data.triggerZone) {
                                        let k = new rb;
                                        k.min.fromArray(O.data.size).multiplyScalar(-.5), k.max.fromArray(O.data.size).multiplyScalar(.5), this.sharedGameControlGlobals.triggers.push([k, N, _, B])
                                    } else this.sharedGameControlGlobals.triggers.push([O.data.radius, N, _, B])
                                }
                        }), this.needsCollisionDetection && this.initBVH())
                    }
                    disconnectEvents() {
                        this.collisionEvents.forEach(_ => _.disconnect()), this.sharedGameControlGlobals.triggers.forEach(_ => _[3].disconnect()), this.sharedGameControlGlobals.triggers.length = 0
                    }
                    deactivate() {
                        if (this.isEnabled) {
                            for (let _ of (this.isEnabled = !1, this.page.traverse(_ => {
                                    _.matrixWorldFusedFalse && (_.matrixWorldFusedFalse = void 0), _.rigidBody && (_.rigidBody = void 0), _.position0 && (_.position0 = void 0), _.rotation0 && (_.rotation0 = void 0)
                                }), this.sharedGameControlGlobals.rapierWorld ? .free(), this.sharedGameControlGlobals.rapierWorld = void 0, this.sharedGameControlGlobals.staticMeshBVH = void 0, this.accumulator = 0, this.sharedGameControlGlobals.entitiesWithTransformAnim = [], this.disconnectEvents(), this.gameControl ? .reset(), this.gameControl ? .dispose(), this.gameControl = null, this.initializationCounter = -1, this.joysticks.forEach(([_, O]) => {
                                    _ ? .destroy(), O.remove()
                                }), this.joystickToGameControls = [], this.joysticks = [], this.orbitControls && (this.orbitControls.dispose(), this.orbitControls = void 0), this.navigationMeshWrapper ? .dispose(), this.navigationMeshWrapper = void 0, Object.values(this.sharedGameControlGlobals.entityToCollisionEvents))) _.forEach(_ => _.disconnect());
                            this.sharedGameControlGlobals.entityToCollisionEvents = {}, this.page.updateMatrixWorld(!0)
                        }
                    }
                    update(_, O, B) {
                        if (!this.isEnabled) return !0;
                        let N = !0;
                        if (void 0 !== this.orbitControls && this.orbitControls.needsUpdate && (N = !this.orbitControls.update()), this.initializationCounter >= 0 && this.initializationCounter < 2 ? (this.initializationCounter++, N = !1) : 2 === this.initializationCounter && this.gameControl && (N = !this.gameControl.update(_, O, B) && N), !1 === this.usePhysics && this.checkTrigger(), this.usePhysics) {
                            if (0 === _) N = this.stepPhysics() && N;
                            else {
                                let O = _ / 1e3;
                                O < .016666666666666666 && O > .009166666666666667 && (O = .016666666666666666), this.accumulator += O;
                                let B = performance.now(),
                                    k = 0;
                                for (; this.accumulator >= .016666666666666666 && k < 6 && (N = this.stepPhysics() && N, this.accumulator -= .016666666666666666, k++, !(performance.now() - B > 16.666666666666668)););
                                this.accumulator = this.accumulator % .016666666666666666
                            }
                        }
                        return N
                    }
                    stepPhysics() {
                        for (let _ of this.sharedGameControlGlobals.entitiesWithTransformAnim)(_.hasNonUniformScale ? _.matrixWorldRigid : _.matrixWorld).decompose(DY, DX, DQ), DZ.setFromQuaternion(DX), void 0 === _.prevR ? (_.prevR = DZ.clone(), _.prevT = DY.clone()) : (_.prevR.copy(DZ), _.prevT.copy(DY)), _.rigidBody && (_.rigidBody.setNextKinematicTranslation(DY.divideScalar(this.pixelsPerMeter)), _.rigidBody.setNextKinematicRotation(DX));
                        return this.sharedGameControlGlobals.rapierWorld.step(this.events), this.events ? .drainCollisionEvents(this.handleCollisionEvents), !this.updatePositions()
                    }
                    dispatchCollisionEvent(_, O, B) {
                        let N = this.sharedGameControlGlobals.rapierWorld ? .getCollider(B)._parent,
                            k;
                        if (O.cloner) {
                            for (let _ of O.cloner.children)
                                if (_.rigidBody === N) {
                                    k = _;
                                    break
                                }
                        }
                        _.dispatch(k), O.dispatchEvent(D7)
                    }
                    updateUseWindowEvents(_) {
                        this.orbitControls ? .updateUseWindowEvents(_)
                    }
                    generateSensorColliderDescs(_, O, B) {
                        let N = D5.copy(_.matrixWorld).invert();
                        _.traverseEntity((k, F) => {
                            if (!1 === O && 1 === F) return !0;
                            for (let O of k.dataPatched.events)
                                if ("Trigger" === O.data.type && !0 !== O.data.disabled) {
                                    let F = new Dq(O.id, O.data, k, this.page, this.sharedAssets, this.eventManager),
                                        U;
                                    if ((U = "box" === O.data.triggerZone ? is.ColliderDesc.cuboid(...O.data.size.map(_ => _ / (2 * this.pixelsPerMeter))) : is.ColliderDesc.ball(O.data.radius / this.pixelsPerMeter)).setDensity(0).setSensor(!0).setActiveEvents(is.ActiveEvents.COLLISION_EVENTS), DJ.fromArray(O.data.position), D3.setFromEuler(DK.fromArray(O.data.rotation)), D4.compose(DJ, D3, D2).premultiply(k.matrixWorld), B ? (D4.decompose(DJ, D3, D$), U.setActiveCollisionTypes(is.ActiveCollisionTypes.KINEMATIC_FIXED | is.ActiveCollisionTypes.DYNAMIC_FIXED)) : (D4.premultiply(N).decompose(DJ, D3, D$), _.rigidBody.bodyType() === is.RigidBodyType.Dynamic || (_.rigidBody.bodyType() === is.RigidBodyType.Fixed ? U.setActiveCollisionTypes(is.ActiveCollisionTypes.KINEMATIC_FIXED | is.ActiveCollisionTypes.DYNAMIC_FIXED) : U.setActiveCollisionTypes(is.ActiveCollisionTypes.KINEMATIC_KINEMATIC | is.ActiveCollisionTypes.DYNAMIC_KINEMATIC))), DJ.divideScalar(this.pixelsPerMeter), U.setTranslation(DJ.x, DJ.y, DJ.z), U.setRotation(D3), B) B.push([U, F]);
                                    else {
                                        let O = this.sharedGameControlGlobals.rapierWorld.createCollider(U, _.rigidBody);
                                        this.sensorToTriggerEvent[O.handle] = F
                                    }
                                }
                        })
                    }
                    checkTrigger() {
                        let _;
                        for (let O = 0; O < this.sharedGameControlGlobals.triggers.length; O++) {
                            let [B, N, k, F] = this.sharedGameControlGlobals.triggers[O];
                            for (let O = 0; O < this.sharedGameControlGlobals.entitiesWithTransformAnim.length; O++) {
                                let U = this.sharedGameControlGlobals.entitiesWithTransformAnim[O];
                                if (k === U || !1 === F.isValidTriggeringObject(xu.is(U) ? U : U.object)) continue;
                                let j = D5.copy(k.matrixWorld).decompose(DJ, D8, D$).compose(DJ, D8, D2).multiply(N),
                                    G = D4.copy(U.matrixWorld).invert().multiply(j);
                                B instanceof rb ? _ = U.bvhGeometry.boundsTree.intersectsBox(B, G) : (D9.radius = B, D9.center.setFromMatrixPosition(G), _ = U.bvhGeometry.boundsTree.intersectsSphere(D9)), _ ? -1 === F.currentIntersectedObjects.indexOf(U) && (F.currentIntersectedObjects.push(U), F.dispatch(), k.dispatchEvent(Pt)) : F.currentIntersectedObjects = F.currentIntersectedObjects.filter(_ => _ !== U)
                            }
                        }
                    }
                };

            function c3(_) {
                let O = this._clip.duration,
                    B = this._clip.start ? ? 0,
                    N = this.loop,
                    k = this.time + _,
                    F = this._loopCount,
                    U = 2202 === N;
                if (0 === _) return -1 === F ? k : U && (1 & F) == 1 ? O - (k - B) : k;
                if (2200 === N) {
                    -1 === F && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (k >= O) k = O;
                        else if (k < 0) k = 0;
                        else {
                            this.time = k;
                            break e
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = k,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: _ < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === F && (_ >= 0 ? (F = 0, this._setEndings(!0, 0 === this.repetitions, U)) : this._setEndings(0 === this.repetitions, !0, U)), k >= O || k < B) {
                        let N = Math.floor((k - B) / (O - B));
                        k -= (O - B) * N, F += Math.abs(N);
                        let j = this.repetitions - F;
                        if (j <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, U || (k = _ > 0 ? O : B, 1 === this.repetitions && (k = O)), this.time = k, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: _ > 0 ? 1 : -1
                        });
                        else {
                            if (1 === j) {
                                let O = _ < 0;
                                this._setEndings(O, !O, U)
                            } else this._setEndings(!1, !1, U);
                            this._loopCount = F, this.time = k, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: N
                            })
                        }
                    } else this.time = k;
                    if (U && (1 & F) == 1) return O - (k - B)
                }
                return k
            }
            var Pa = !1,
                Pn = class {
                    constructor(_, O, B, N) {
                        this.scene = _, this.requestRender = O, this.updateDisplayProgress = B, this.animationInspectorState = N, this.clipIdToAction = {}, this.activeClip = null, this.needsUpdate = !1, this.addClip = _ => {
                            "Empty" === _.data.type && _.data.animations && _.data.animations.forEach((O, B) => {
                                let N = O[0] + "/";
                                if (Array.isArray(_.identity) ? N += _.identity[0] : N += _.uuid, this.clipIdToAction[N]) return;
                                let k = oj.parse(JSON.parse(O[2]));
                                _.animations[B] = k;
                                let F = this.mixer.clipAction(k, _);
                                !1 === Pa && (Object.getPrototypeOf(F)._updateTime = c3, Pa = !0), F.clampWhenFinished = !0, this.clipIdToAction[N] = F
                            })
                        }, this.mixer = new lw(_), this.scene.traverseEntity(this.addClip)
                    }
                    deleteClip(_, O) {
                        let B = this.scene.find(O);
                        if (!B) return;
                        let N = B.animations.find(O => O.uuid === _);
                        if (!N) return;
                        let k = this.clipIdToAction[_];
                        k && (k.stop(), this.mixer.uncacheClip(N), delete this.clipIdToAction[_], B.animations = B.animations.filter(O => O.uuid !== _))
                    }
                    get isPlaying() {
                        return Object.values(this.clipIdToAction).some(_ => _.isRunning())
                    }
                    playFromInspector(_) {
                        this.mixer.stopAllAction();
                        let O = this.clipIdToAction[_];
                        O && (O.play(), this.activeClip = O.getClip(), this.requestRender())
                    }
                    onExitPlayMode() {
                        Object.values(this.clipIdToAction).forEach(_ => {
                            _.repetitions = 1 / 0, _.loop = 2201
                        }), this.mixer.stopAllAction(), this.requestRender()
                    }
                    play(_) {
                        let O = _.clipId + "/" + _.object,
                            B = this.clipIdToAction[O];
                        if (B) return _ && (_.repeat >= 0 && (B.repetitions = _.repeat + 1), "pingpong" === _.direction && 0 !== _.repeat && (B.loop = 2202)), B.play(), B.paused = !1, this.requestRender(), B
                    }
                    resumeFromInspector(_) {
                        let O = this.clipIdToAction[_];
                        O && (O.play(), O.paused = !1, this.requestRender())
                    }
                    pauseFromInspector(_) {
                        let O = this.clipIdToAction[_];
                        O && (O.paused = !0)
                    }
                    stop() {
                        this.mixer.stopAllAction(), this.requestRender()
                    }
                    update(_) {
                        if (this.needsUpdate) this.needsUpdate = !1;
                        else if (!1 === this.isPlaying || this.animationInspectorState ? .isScrubbing) return;
                        this.mixer.update(_ / 1e3), this.activeClip && this.updateDisplayProgress(Math.round(this.mixer.time / this.activeClip.duration * this.maxFrames % this.maxFrames)), this.requestRender()
                    }
                    get maxFrames() {
                        return this.activeClip ? .tracks[0] ? .times.length ? ? 0
                    }
                    setProgressFromInspector(_, O) {
                        if (!this.clipIdToAction[O]) return;
                        this.activeClip !== this.clipIdToAction[O].getClip() && this.playFromInspector(O);
                        let B = this.clipIdToAction[O].paused;
                        this.clipIdToAction[O].paused = !1, this.mixer.setTime(Math.min(this.maxFrames ? _ / this.maxFrames : 0, .9999) * this.activeClip.duration), this.requestRender(), B && (this.clipIdToAction[O].paused = !0)
                    }
                },
                Po = new WeakMap,
                Pl = class extends oq {
                    constructor(_) {
                        super(_), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                            position: "POSITION",
                            normal: "NORMAL",
                            color: "COLOR",
                            uv: "TEX_COORD"
                        }, this.defaultAttributeTypes = {
                            position: "Float32Array",
                            normal: "Float32Array",
                            color: "Float32Array",
                            uv: "Float32Array"
                        }
                    }
                    setDecoderPath(_) {
                        return this.decoderPath = _, this
                    }
                    setDecoderConfig(_) {
                        return this.decoderConfig = _, this
                    }
                    setWorkerLimit(_) {
                        return this.workerLimit = _, this
                    }
                    load(_, O, B, N) {
                        let k = new oQ(this.manager);
                        k.setPath(this.path), k.setResponseType("arraybuffer"), k.setRequestHeader(this.requestHeader), k.setWithCredentials(this.withCredentials), k.load(_, _ => {
                            this.decodeDracoFile(_, O).catch(N)
                        }, B, N)
                    }
                    decodeDracoFile(_, O, B, N) {
                        let k = {
                            attributeIDs: B || this.defaultAttributeIDs,
                            attributeTypes: N || this.defaultAttributeTypes,
                            useUniqueIDs: !!B
                        };
                        return this.decodeGeometry(_, k).then(O)
                    }
                    decodeGeometry(_, O) {
                        let B = JSON.stringify(O);
                        if (Po.has(_)) {
                            let O = Po.get(_);
                            if (O.key === B) return O.promise;
                            if (0 === _.byteLength) throw Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                        }
                        let N, k = this.workerNextTaskID++,
                            F = _.byteLength,
                            U = this._getWorker(k, F).then(B => (N = B, new Promise((B, F) => {
                                N._callbacks[k] = {
                                    resolve: B,
                                    reject: F
                                }, N.postMessage({
                                    type: "decode",
                                    id: k,
                                    taskConfig: O,
                                    buffer: _
                                }, [_])
                            }))).then(_ => this._createGeometry(_.geometry));
                        return U.catch(() => !0).then(() => {
                            N && k && this._releaseTask(N, k)
                        }), Po.set(_, {
                            key: B,
                            promise: U
                        }), U
                    }
                    _createGeometry(_) {
                        let O = new sK;
                        _.index && O.setIndex(new sF(_.index.array, 1));
                        for (let B = 0; B < _.attributes.length; B++) {
                            let N = _.attributes[B],
                                k = N.name,
                                F = N.array,
                                U = N.itemSize;
                            O.setAttribute(k, new sF(F, U))
                        }
                        return O
                    }
                    _loadLibrary(_, O) {
                        let B = new oQ(this.manager);
                        return B.setPath(this.decoderPath), B.setResponseType(O), B.setWithCredentials(this.withCredentials), new Promise((O, N) => {
                            B.load(_, O, void 0, N)
                        })
                    }
                    preload() {
                        return this._initDecoder(), this
                    }
                    _initDecoder() {
                        if (this.decoderPending) return this.decoderPending;
                        let _ = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                            O = [];
                        return _ ? O.push(this._loadLibrary("draco_decoder.js", "text")) : (O.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), O.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(O).then(O => {
                            let B = O[0];
                            _ || (this.decoderConfig.wasmBinary = O[1]);
                            let N = kQ.toString(),
                                k = ["/* draco decoder */", B, "", "/* worker */", N.substring(N.indexOf("{") + 1, N.lastIndexOf("}"))].join(`
`);
                            this.workerSourceURL = URL.createObjectURL(new Blob([k]))
                        }), this.decoderPending
                    }
                    _getWorker(_, O) {
                        return this._initDecoder().then(() => {
                            if (this.workerPool.length < this.workerLimit) {
                                let _ = new Worker(this.workerSourceURL);
                                _._callbacks = {}, _._taskCosts = {}, _._taskLoad = 0, _.postMessage({
                                    type: "init",
                                    decoderConfig: this.decoderConfig
                                }), _.onmessage = function(O) {
                                    let B = O.data;
                                    switch (B.type) {
                                        case "decode":
                                            _._callbacks[B.id].resolve(B);
                                            break;
                                        case "error":
                                            _._callbacks[B.id].reject(B);
                                            break;
                                        default:
                                            console.error('THREE.DRACOLoader: Unexpected message, "' + B.type + '"')
                                    }
                                }, this.workerPool.push(_)
                            } else this.workerPool.sort(function(_, O) {
                                return _._taskLoad > O._taskLoad ? -1 : 1
                            });
                            let B = this.workerPool[this.workerPool.length - 1];
                            return B._taskCosts[_] = O, B._taskLoad += O, B
                        })
                    }
                    _releaseTask(_, O) {
                        _._taskLoad -= _._taskCosts[O], delete _._callbacks[O], delete _._taskCosts[O]
                    }
                    debug() {
                        console.log("Task load: ", this.workerPool.map(_ => _._taskLoad))
                    }
                    dispose() {
                        for (let _ = 0; _ < this.workerPool.length; ++_) this.workerPool[_].terminate();
                        return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
                    }
                };

            function kQ() {
                let _, O;
                onmessage = function(B) {
                    let N = B.data;
                    switch (N.type) {
                        case "init":
                            _ = N.decoderConfig, O = new Promise(function(O) {
                                _.onModuleLoaded = function(_) {
                                    O({
                                        draco: _
                                    })
                                }, DracoDecoderModule(_)
                            });
                            break;
                        case "decode":
                            let k = N.buffer,
                                F = N.taskConfig;
                            O.then(_ => {
                                let O = _.draco,
                                    B = new O.Decoder,
                                    U = new O.DecoderBuffer;
                                U.Init(new Int8Array(k), k.byteLength);
                                try {
                                    let _ = function(_, O, B, N) {
                                            let k = N.attributeIDs,
                                                F = N.attributeTypes,
                                                U, j, G = O.GetEncodedGeometryType(B);
                                            if (G === _.TRIANGULAR_MESH) U = new _.Mesh, j = O.DecodeBufferToMesh(B, U);
                                            else if (G === _.POINT_CLOUD) U = new _.PointCloud, j = O.DecodeBufferToPointCloud(B, U);
                                            else throw Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            if (!j.ok() || 0 === U.ptr) throw Error("THREE.DRACOLoader: Decoding failed: " + j.error_msg());
                                            let Y = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (let B in k) {
                                                let j = self[F[B]],
                                                    G, Q;
                                                if (N.useUniqueIDs) Q = k[B], G = O.GetAttributeByUniqueId(U, Q);
                                                else {
                                                    if (-1 === (Q = O.GetAttributeId(U, _[k[B]]))) continue;
                                                    G = O.GetAttribute(U, Q)
                                                }
                                                Y.attributes.push(function(_, O, B, N, k, F) {
                                                    let U = F.num_components(),
                                                        j = B.num_points() * U,
                                                        G = j * k.BYTES_PER_ELEMENT,
                                                        Y = function(_, O) {
                                                            switch (O) {
                                                                case Float32Array:
                                                                    return _.DT_FLOAT32;
                                                                case Int8Array:
                                                                    return _.DT_INT8;
                                                                case Int16Array:
                                                                    return _.DT_INT16;
                                                                case Int32Array:
                                                                    return _.DT_INT32;
                                                                case Uint8Array:
                                                                    return _.DT_UINT8;
                                                                case Uint16Array:
                                                                    return _.DT_UINT16;
                                                                case Uint32Array:
                                                                    return _.DT_UINT32
                                                            }
                                                        }(_, k),
                                                        Q = _._malloc(G);
                                                    O.GetAttributeDataArrayForAllPoints(B, F, Y, G, Q);
                                                    let K = new k(_.HEAPF32.buffer, Q, j).slice();
                                                    return _._free(Q), {
                                                        name: N,
                                                        array: K,
                                                        itemSize: U
                                                    }
                                                }(_, O, U, B, j, G))
                                            }
                                            return G === _.TRIANGULAR_MESH && (Y.index = function(_, O, B) {
                                                let N = 3 * B.num_faces(),
                                                    k = 4 * N,
                                                    F = _._malloc(k);
                                                O.GetTrianglesUInt32Array(B, k, F);
                                                let U = new Uint32Array(_.HEAPF32.buffer, F, N).slice();
                                                return _._free(F), {
                                                    array: U,
                                                    itemSize: 1
                                                }
                                            }(_, O, U)), _.destroy(U), Y
                                        }(O, B, U, F),
                                        k = _.attributes.map(_ => _.array.buffer);
                                    _.index && k.push(_.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: N.id,
                                        geometry: _
                                    }, k)
                                } catch (_) {
                                    console.error(_), self.postMessage({
                                        type: "error",
                                        id: N.id,
                                        error: _.message
                                    })
                                } finally {
                                    O.destroy(U), O.destroy(B)
                                }
                            })
                    }
                }
            }
            async function zQ(_) {
                if (ia) {
                    let O = {
                            attributeIDs: ia.defaultAttributeIDs,
                            attributeTypes: ia.defaultAttributeTypes,
                            useUniqueIDs: !1
                        },
                        B;
                    try {
                        B = await ia.decodeGeometry(new Int8Array(_).buffer, O)
                    } catch (_) {
                        console.error(_)
                    }
                    if (B) return {
                        index: B.index ? {
                            array: B.index.array
                        } : void 0,
                        attributes: Object.entries(B.attributes).map(([_, O]) => ({
                            name: _,
                            itemSize: O.itemSize,
                            array: O.array
                        }))
                    }
                }
                return null
            }
            async function h3(_, O) {
                let [B, N] = Pw(pj.deserialize(new Uint8Array(_)));
                tv(B);
                let k = [];
                for (let _ of (B.scene.objects.traverse((_, O) => {
                        "Mesh" === O.type && "NonParametricGeometry" === O.geometry.type && void 0 !== O.geometry.data.draco && k.push(O)
                    }), k.length && await (ia || (ia = new Pl).setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload(), ia.decoderPending), k)) {
                    let O = await zQ(xr(_.geometry.data.draco));
                    if (O) {
                        O.index && (_.geometry.data.index = {
                            array: O.index.array,
                            itemSize: 1,
                            normalized: !1,
                            type: "Uint32Array"
                        });
                        let B = {};
                        O.attributes.forEach(({
                            name: _,
                            array: O,
                            itemSize: N
                        }) => {
                            B[_] = {
                                array: O,
                                itemSize: N,
                                type: "Float32Array",
                                normalized: !1
                            }
                        }), _.geometry.data.attributes = B, _.geometry.data.draco = void 0
                    }
                }
                return O && O(B), N.result().data
            }
            var Pc = class {
                    constructor(_, O, B, N, k, F, U) {
                        this.id = _, this.data = O, this.dataEvent = B, this.object = N, this.stage = !1, this.actions = nr(B, O.actions, k, F, U, N)
                    }
                    disconnect() {
                        qt(this.actions)
                    }
                    dispatchIn() {
                        this.actions.Audio.forEach(_ => _.dispatchBasic()), this.actions.Video.forEach(_ => _.dispatchBasic()), this.actions.Create.forEach(_ => _.dispatch()), this.actions.Destroy.forEach(_ => _.dispatch()), this.actions.Reset.forEach(_ => _.dispatch()), this.actions.Link.forEach(_ => _.dispatch()), this.actions.Transition.forEach(_ => {
                            _.object.currentTransitionEvent !== this && (_.object.currentTransitionEvent = this, _.init())
                        }), this.actions.Transition.forEach(_ => _.toggle()), this.actions.Animation.forEach(_ => _.play()), this.actions.SwitchCamera.forEach(_ => _.play()), this.actions.SceneTransition.forEach(_ => _.dispatch()), this.actions.SetVariable.forEach(_ => _.checkConditions()), this.actions.SetVariable.forEach(_ => _.dispatch()), this.actions.DynamicVariablePlay.forEach(_ => _.dispatch())
                    }
                    dispatchOut() {
                        this.actions.Transition.forEach(_ => {
                            _.toggle()
                        })
                    }
                },
                Pu = class extends C8 {
                    constructor(_, O) {
                        super(_), this.eventManager = O, this.breakpoints = [], this.resize = (_, O) => {
                            this.breakpoints.forEach(B => {
                                let N = fR.deviceToSize(B.data.size),
                                    k = "horizontal" === B.dataEvent.orientation ? _ : O,
                                    F;
                                switch (B.data.operator) {
                                    case "<":
                                        F = k < N[0];
                                        break;
                                    case ">":
                                        F = k > N[0];
                                        break;
                                    case "<>":
                                        F = k > N[0] && k < N[1]
                                }
                                B.stage !== F && (B.stage = F, B.stage ? B.dispatchIn() : B.dispatchOut())
                            })
                        }, this.onResizeObserver = new ResizeObserver(_ => {
                            for (let O of _) {
                                let {
                                    width: _,
                                    height: B
                                } = O.contentRect;
                                this.resize(_, B)
                            }
                        })
                    }
                    connect() {
                        let {
                            page: _,
                            sharedAssets: O,
                            domElement: B
                        } = this.eventContext;
                        this.onResizeObserver.observe(B), _.traverseEntity(B => {
                            if (!(!B.visible || !B.data ? .events.length))
                                for (let {
                                        data: N
                                    } of B.data.events) N.disabled || "Resize" === N.type && N.breakpoints.forEach(({
                                    data: k,
                                    id: F
                                }) => {
                                    try {
                                        let U = new Pc(F, k, N, B, _, O, this.eventManager);
                                        this.breakpoints.push(U)
                                    } catch (_) {}
                                })
                        })
                    }
                    disconnect() {
                        this.onResizeObserver.disconnect(), this.breakpoints.forEach(_ => {
                            _.disconnect()
                        }), this.breakpoints = []
                    }
                },
                Pp = class {
                    constructor(_, O, B, N, k) {
                        this.publish = _, this.controlsManager = O, this.animationControls = B, this.eventContext = N, this.sharedVariables = k, this.isEnabled = !1, this.activateCount = 0, this.needsMouse = !1, this.needsRaycast = !1, this.onTouchMovePreventScroll = _ => {
                            (_.touches.length > 1 || this.preventTouchScroll) && _.preventDefault()
                        }, this.onMouseWheelPreventScroll = _ => {
                            this.preventScroll && _.preventDefault()
                        }, this.onMouseMove = _ => {
                            this.eventContext.sharedAssets.mouseProperty = { ...this.getMousePosition(_),
                                pressed: _.buttons > 0
                            }
                        }, this.onMouseDown = _ => {
                            this.eventContext.sharedAssets.mouseProperty = { ...this.getMousePosition(_),
                                pressed: !0
                            }
                        }, this.onMouseUp = _ => {
                            this.eventContext.sharedAssets.mouseProperty = { ...this.getMousePosition(_),
                                pressed: !1
                            }
                        }, this.getMousePosition = _ => {
                            let {
                                domRect: O
                            } = this.eventContext, {
                                pageX: B,
                                pageY: N
                            } = _.touches ? .length > 0 ? _.touches[0] : _;
                            return {
                                x: B - (O.left + window.scrollX),
                                y: N - (O.top + window.scrollY)
                            }
                        }, this.stopRaycast = _.stopRaycast, this.preventScroll = _.preventScroll, this.preventTouchScroll = _.preventTouchScroll, this.hideCursor = _.hideCursor, this.requestRender = N.requestRender
                    }
                    activate() {
                        if (this.isEnabled) return;
                        this.isEnabled = !0, this.initializeActionsDependentStates(), this.needsMouse && (this.eventContext.domElement.addEventListener("pointermove", this.onMouseMove), this.eventContext.domElement.addEventListener("pointerdown", this.onMouseDown)), this.handlers = {
                            Spline: new C7(this.eventContext),
                            DynamicVariable: new Dd(this.eventContext, this.sharedVariables, this, this.needsMouse, this.needsRaycast),
                            Conditional: new To(this.eventContext, this),
                            Start: new Dh(this.eventContext, this),
                            Basic: new Tt(this.eventContext, this, this.needsRaycast),
                            MouseHover: new Di(this.eventContext, this),
                            Scroll: new Dn(this.eventContext, this),
                            Follow: new TH(this.eventContext, this),
                            DragDrop: new TL(this.eventContext, this),
                            LookAt: new T6(this.eventContext),
                            Resize: new Pu(this.eventContext, this)
                        };
                        let {
                            page: _,
                            domElement: O,
                            eventElement: B
                        } = this.eventContext;
                        this.hideCursor && (O.style.cursor = "none"), _.traverseEntity(_ => {
                            _.addEventListener("requestRender", this.requestRender)
                        }), Object.values(this.handlers).forEach(_ => _.connect()), O.addEventListener("wheel", this.onMouseWheelPreventScroll), O.addEventListener("touchmove", this.onTouchMovePreventScroll), this.activateCount++
                    }
                    deactivate() {
                        if (!this.isEnabled) return;
                        this.isEnabled = !1, this.eventContext.domElement.removeEventListener("pointermove", this.onMouseMove), this.eventContext.domElement.removeEventListener("pointerdown", this.onMouseDown), this.eventContext.domElement.removeEventListener("pointerup", this.onMouseUp), this.eventContext.sharedAssets.mouseProperty = null, this.eventContext.sharedAssets.raycastProperty = null;
                        let {
                            page: _,
                            domElement: O
                        } = this.eventContext;
                        O.style.cursor = "", Object.values(this.handlers).forEach(_ => _.disconnect()), this.controlsManager.gameControl ? .disposeActions(), this.controlsManager.disconnectEvents(), _.traverseEntity(_ => {
                            _.removeEventListener("requestRender", this.requestRender), _.destroyedInAction = !1
                        }), O.removeEventListener("touchmove", this.onTouchMovePreventScroll), O.removeEventListener("wheel", this.onMouseWheelPreventScroll), this.animationControls.onExitPlayMode()
                    }
                    get isPaused() {
                        return this.isEnabled
                    }
                    pause() {
                        this.deactivate()
                    }
                    resume() {
                        this.activate()
                    }
                    reset() {
                        this.deactivate(), this.activate(), this.controlsManager.page.updateMatrixWorld(!0), this.controlsManager.rebuildBVH()
                    }
                    updateUseWindowEvents(_) {
                        let O = this.isEnabled;
                        O && this.deactivate(), this.eventContext.useWindowEvents = _, O && this.activate()
                    }
                    initializeActionsDependentStates() {
                        let _ = this.eventContext.sharedAssets;
                        _.resetDynamicVariablePlayState();
                        let e = O => {
                            if ("Conditional" === O.data.type && (O.data.ifActions.forEach(e), O.data.elseActions.forEach(e)), "Conditional" === O.data.type || "SetVariable" === O.data.type)
                                for (let _ of "Conditional" === O.data.type ? O.data.condition : O.data.expression) "id" in _ && Array.isArray(_.id) && ("mouse" === _.id[0] && (this.needsMouse = !0), "raycast" === _.id[0] && (this.needsRaycast = !0));
                            "DynamicVariablePlay" === O.data.type && "" !== O.data.variableId && ("Play" === O.data.mode || "PlayPause" === O.data.mode || "Toggle" === O.data.mode) && _.setDynamicVariablePlayState(O.data.variableId, "Stopped")
                        };
                        this.eventContext.page.traverseEntity(_ => {
                            if (_.data ? .events.length) {
                                for (let O of _.data.events)
                                    if (!O.data.disabled) {
                                        if ("VariableChange" === O.data.type && ("mouseProperty" === O.data.variableId && (this.needsMouse = !0), "raycastProperty" === O.data.variableId && (this.needsRaycast = !0)), "Conditional" === O.data.type)
                                            for (let _ of ["inActions", "outActions"]) O.data[_].forEach(e);
                                        else if ("DragDrop" === O.data.type)
                                            for (let _ of ["drag", "drop"]) O.data.dragDropActions[_].forEach(e);
                                        else if ("GameControl" === O.data.type)
                                            for (let _ of ["idle", "move", "jump", "run"]) O.data.gameActions[_].forEach(e);
                                        else if ("Resize" === O.data.type)
                                            for (let _ of O.data.breakpoints) _.data.actions.forEach(e);
                                        else "LookAt" === O.data.type || O.data.actions.forEach(e)
                                    }
                            }
                        })
                    }
                },
                Pf = class {
                    constructor(_, O, B, N, k) {
                        this._aspect = 1, this.enableResponsive = !1, this._renderer = _, this._camera = O, this._frameSize = new iJ().copy(B), this._editorSize = new iJ().copy(N), this._aspect = O.aspect, this._fov = k ? ? O.fov
                    }
                    set frameSize(_) {
                        this._frameSize.copy(_)
                    }
                    updateRenderer() {
                        this._renderer && this._renderer.setSize(this._frameSize.x, this._frameSize.y)
                    }
                    updateViewport() {
                        if (!this._renderer || !this._camera || "PerspectiveCamera" !== this._camera.cameraType) return;
                        let _ = this._frameSize.x,
                            O = this._frameSize.y,
                            B = this._editorSize.y;
                        this._aspect = _ / O, O <= B && (this._camera.zoom *= B / O), this._renderer.setViewport(0, 0, _, O)
                    }
                    updateCamera(_ = !0) {
                        if (this._camera) {
                            if ("PerspectiveCamera" === this._camera.cameraType) {
                                let O = this._frameSize.y,
                                    B = this._editorSize.y,
                                    N = this._fov;
                                if (_ && O > B) N *= O / B * (1 - ((O - 1080) / 1080 * 14 + 1) / 100);
                                this._camera.aspect = this._aspect, this._camera.fov = N, this._camera.updateProjectionMatrix()
                            } else this._camera.setViewplaneSize(this._frameSize.x, this._frameSize.y, this.enableResponsive)
                        }
                    }
                    setCamera(_) {
                        this._camera = _, this._aspect = _.aspect, this._fov = _.fov
                    }
                    revert() {
                        let _ = window.innerWidth,
                            O = window.innerHeight;
                        this._renderer && (this._renderer.setViewport(0, 0, _, O), this._renderer.setSize(_, O)), this._camera && (this._camera.aspect = _ / O, this._camera.fov = this._fov, this._camera.setViewplaneSize(_, O, this.enableResponsive), this._camera.updateProjectionMatrix())
                    }
                },
                Pm = class {
                    get sharedAssets() {
                        return this.shared
                    }
                    constructor(_, O = {}) {
                        this.shared = new _n(_.shared, O), this.scene = new Ep(_.scene, this.sharedAssets), this.shared.setEntityOpContext({
                            scene: this.scene,
                            shared: this.shared
                        })
                    }
                    reset(_, O) {
                        this.scene.clearScene(), this.sharedAssets.reset(_.shared), this.scene.resetAfterClear(_.scene, this.sharedAssets)
                    }
                    resetPersonalCameraFromDocumentData() {
                        for (let _ of this.scene.children) _ instanceof Mz && _.personalCamera.updateState(_.data.camera, {
                            scene: this.scene,
                            shared: this.shared
                        })
                    }
                    dispose() {
                        this.scene.dispose(), this.shared.dispose()
                    }
                    gc() {
                        this.shared.geometryCache.startGc(), this.shared.geometryCache2.startGc(), this.scene.traverseEntity(_ => {
                            _ instanceof _m && _.markGeometryAsReachable(this.shared)
                        }), this.shared.geometryCache.endGc(), this.shared.geometryCache2.endGc()
                    }
                },
                Pg = class {
                    constructor({
                        x: _ = 10,
                        y: O = 10
                    }) {
                        this._startTime = 0;
                        let B = document.getElementById("spe-perfs");
                        B ? this.element = B : (this.element = document.createElement("div"), document.body.appendChild(this.element), this.element.style.position = "absolute", this.element.style.zIndex = "10000", this.element.style.fontFamily = "monospace", this.element.style.background = "black", this.element.style.color = "white", this.element.style.padding = "10px", this.element.style.opacity = "0.5", this.element.style.fontSize = "11px", this.element.setAttribute("id", "spe-perfs")), this.element.style.left = `${_}px`, this.element.style.top = `${O}px`
                    }
                    dispose() {
                        this.element.parentElement ? .removeChild(this.element)
                    }
                    start() {
                        this._startTime = performance.now()
                    }
                    end() {
                        let _ = performance.now() - this._startTime;
                        this.element.innerHTML = _.toFixed(3) + " ms"
                    }
                };

            function Rm(_) {
                return _ instanceof _x ? "SubdivObject" : "NonParametricGeometry" === _.geometry.type ? "NonParametric" : "Mesh"
            }
            var Pv = pn(iU(), 1),
                Py = new iJ,
                Px = class {
                    constructor(_, {
                        renderOnDemand: O,
                        renderMode: B = "auto"
                    } = {}) {
                        this._viewportMode = 1, this._viewportWidth = window.innerWidth, this._viewportHeight = window.innerHeight, this._proxyObjectCache = new Map, this._variablesCache = new Map, this._isPaused = !1, this._renderRequested = !1, this._skipRender = !1, this.time = performance.now(), this.dt = 0, this.currentTAAFrame = 0, this.disposed = !1, this._requestRenderAutoMode = () => {
                            this._skipRender = !1
                        }, this.requestRender = () => {
                            this._renderRequested = !0
                        }, this.render = _ => {
                            if (this.time = _, this._lastTime && (this.dt = this.time - this._lastTime), this._lastTime = this.time, this._perfs ? .start(), !this._renderer || !this._isPaused && ("manual" === this.renderMode && !this._renderRequested || "auto" === this.renderMode && this._skipRender)) {
                                this._perfs ? .end();
                                return
                            }
                            if (this._renderRequested = !1, this._skipRender = !0, this._controls && (this._skipRender = this._controls.update(this.dt)), this._eventManager && (this._eventManager.handlers ? .Start.hasVideoAction || this._eventManager.handlers ? .Basic.hasVideoAction || this._eventManager.handlers ? .Conditional.hasVideoAction) && (this._skipRender = !1), this._animationControls ? .update(this.dt), this._skipRender ? (this.currentTAAFrame++, this.currentTAAFrame < 32 ? this._skipRender = !1 : this.currentTAAFrame = 0) : this.currentTAAFrame = 0, this._scene && this._scene.activeCamera !== this._camera && (this._camera = this._scene.activeCamera), this._eventManager ? .isEnabled && (this._eventManager.handlers ? .Follow.onAnimationFrameDamping(), this._eventManager.handlers ? .LookAt.onAnimationFrameDamping(), this._eventManager.handlers ? .DragDrop.onAnimationFrameDamping()), this._scene && this._camera) {
                                if (this._scene.pathConstraints.applyConstraints(this._scene), this._renderer.sceneTransitionTimeRemaining > 0) {
                                    this._renderer.sceneTransitionTimeRemaining -= this.dt;
                                    let _ = 1 - this._renderer.sceneTransitionTimeRemaining / this._renderer.sceneTransitionDuration;
                                    this._renderer.pipeline.sceneTransitionPass.uniforms.mixRatio.value = _, this._skipRender = !1
                                } else this._renderer.pipeline.sceneTransitionFromTexture = null;
                                this._renderer.renderSplineScene(this._scene, this._camera)
                            }
                            this.canvas.dispatchEvent(this._renderedEvent), this._perfs ? .end()
                        }, this._resize = () => {
                            if (this._renderer) {
                                if (1 === this._viewportMode && this._frameView && (this._frameView.frameSize = Py.set(this._viewportWidth, this._viewportHeight)), this._renderer.setSize(this._viewportWidth, this._viewportHeight, !1), this._camera = this._scene ? .activeCamera, this._scene ? .updateViewPlaneSize(this._frameView ? .frameSize ? .x ? ? this._viewportWidth, this._frameView ? .frameSize ? .y ? ? this._viewportHeight, this._frameView ? .enableResponsive ? ? !1), this._camera) {
                                    let _ = Object.values(this._data ? .frames ? ? {})[0].preset ? ? "fullscreen";
                                    this._frameView ? .setCamera(this._camera), this._frameView ? .updateCamera("fullscreen" !== _), "PerspectiveCamera" === this._camera.cameraType && (this._camera.aspect = this._viewportWidth / this._viewportHeight), this._camera.updateProjectionMatrix()
                                }
                                this.eventManager && (this.eventManager.eventContext.domRect = this.canvas.getBoundingClientRect()), this._requestRenderAutoMode()
                            }
                        }, this._debouncedResize = rc(this._resize, 10), this.canvas = _, this.renderMode = O ? "auto" : B, this._renderedEvent = new CustomEvent("rendered", {
                            bubbles: !0
                        }), Object.defineProperty(this._renderedEvent, "target", {
                            writable: !1,
                            value: this
                        }), window.location.search.includes("perfs") && (this._perfs = new Pg({
                            x: 10,
                            y: 10
                        })), _.addEventListener("pointerdown", KC, !0), _.addEventListener("pointerdown", py, !0), _.addEventListener("pointermove", py, !0), _.addEventListener("pointerup", oh, !0), _.addEventListener("pointercancel", oh, !0), _.addEventListener("pointerleave", oh, !0), window.addEventListener("keydown", JC, !0), window.addEventListener("keyup", $C, !0)
                    }
                    async load(_, O, B) {
                        let N;
                        N = "The Spline Runtime only accepts .splinecode files that are generated from Spline export panel.", _.endsWith(".spline") ? console.warn(N + " The .spline files are only meant to be used by the Editor.") : _.endsWith(".splinecode") || console.warn(N), this.disposed = !1;
                        let k = await (await fetch(_, B)).arrayBuffer();
                        await this.start(k, {
                            variables: O
                        })
                    }
                    async start(_, {
                        interactive: O = !0,
                        variables: N
                    } = {}) {
                        let k, F;
                        if (this.disposed) return;
                        let U = await h3(_);
                        this._data = U, U.version && (0, Pv.default)(U.version, "0.9.519") > 0 && console.warn("Your .splinecode file is more recent than the library. Please upgrade @splinetool/runtime to the latest version."), await Promise.all([KA(U) && (wc || (wc = async function() {
                            let _ = B.e(1515).then(B.bind(B, 91515)),
                                [O, N] = await Promise.all([_, fetch("https://unpkg.com/@splinetool/boolean-wasm@0.9.519/build/boolean.wasm").then(_ => _.arrayBuffer())]),
                                k = O.default,
                                F = await k({
                                    wasmBinary: N
                                });
                            wo(F)
                        }())), (k = !1, U.scene.objects.traverse((_, O) => {
                            "Mesh" === O.type && "SubdivGeometry" === O.geometry.type && (k = !0)
                        }), k && function() {
                            if (!x_) return xA || (xA = i());
                            async function i() {
                                let _ = B.e(5821).then(B.bind(B, 25821)),
                                    [O, N] = await Promise.all([_, fetch("https://unpkg.com/@splinetool/modelling-wasm@0.9.519/build/process.wasm").then(_ => _.arrayBuffer())]),
                                    k = O.default,
                                    F = await k({
                                        wasmBinary: N
                                    });
                                xm(F), x_ = !0
                            }
                        }()), gD.physicsEnabled(U.scene.objects) && (us || (us = async function() {
                            let _ = await B.e(1733).then(B.bind(B, 85442));
                            await _.init(), d5(_)
                        }())), GA(U) && function() {
                            if (!w6) return _k || (_k = i());
                            async function i() {
                                let _ = await B.e(8734).then(B.bind(B, 71356));
                                wJ(_), w6 = !0
                            }
                        }(), (F = !1, U.scene.objects.forEach(_ => {
                            "Page" === _.data.type && !F && _.data.publish.gameControlObject && gD.traverseModuleInstances(U, _.id, (_, O, B) => {
                                for (let _ of B) "GameControl" === _.data.type && _.data.navmesh.enabled && (F = !0)
                            })
                        }), F && (d4 || (d4 = async function() {
                            let _ = B.e(7408).then(B.bind(B, 67408)),
                                [O, N] = await Promise.all([_, fetch("https://unpkg.com/@splinetool/navmesh-wasm@0.9.519/build/navmesh.wasm").then(_ => _.arrayBuffer())]),
                                k = O.default,
                                F = await k({
                                    wasmBinary: N
                                });
                            d3(F)
                        }())))].filter(Boolean)), this._eventManager ? .deactivate(), this._controls ? .deactivate(), this._scene ? .dispose();
                        let j = new Pm(U);
                        if (j.resetPersonalCameraFromDocumentData(), this._scene = j.scene, this._sharedAssetsManager = j.sharedAssets, this._camera = this._scene.activeCamera, window.location.search.includes("merge-geometries")) {
                            let _ = performance.now();
                            ! function(_, O) {
                                let B, N;
                                let k = (B = {}, O.traverseEntity(O => {
                                        if (!O.visible || !(O instanceof xK) || "Mesh" !== O.type || Array.isArray(O.material) || O.states && Object.keys(O.states).length) return;
                                        let N = O.parent;
                                        for (; N;) {
                                            if (N instanceof xK && O.states && Object.keys(O.states).length) return;
                                            N = N.parent
                                        }
                                        let k = O.material.uuid,
                                            F = _.shared.materials[k];
                                        if (F) {
                                            if (!m0.isMergable(F)) return
                                        } else {
                                            let B = _.scene.objects.get(O.uuid) ? .data;
                                            if (B && "material" in B && "string" != typeof B.material) {
                                                if (!m0.isMergable(B.material)) return;
                                                k = m0.getHash(B.material)
                                            }
                                        }
                                        B[k] || (B[k] = {});
                                        let U = B[k][Rm(O)];
                                        if (U) {
                                            if (U.push(O), O.cloner)
                                                for (let _ of O.cloner.children) U.push(_)
                                        } else if (B[k][Rm(O)] = [O], O.cloner)
                                            for (let _ of O.cloner.children) B[k][Rm(O)].push(_)
                                    }), B),
                                    F = (N = 0, Object.values(k).forEach(_ => {
                                        Object.values(_).forEach(_ => {
                                            let O = _.length;
                                            O > N && (N = O)
                                        })
                                    }), N),
                                    U = Array(F),
                                    j = 0,
                                    G = Array(F),
                                    Y = 0,
                                    Q = Array(F),
                                    K = 0,
                                    $ = Array(F),
                                    ee = 0;
                                for (let [_, B] of Object.entries(k))
                                    for (let N of Object.values(B)) {
                                        if (Y = 0, K = 0, N.forEach(_ => {
                                                _ instanceof xK && (G[Y++] = _.geometry.clone(), Q[K++] = _)
                                            }), K < 2) continue;
                                        for (let _ = 0; _ < K; _++) Q[_].updateWorldMatrix(!0, !1), G[_].applyMatrix4(Q[_].matrixWorld), 0 > Q[_].matrixWorld.determinant() && function(_) {
                                            let O;
                                            if (_.index)
                                                for (let B = 0; B < _.index.array.length; B += 3) O = _.index.array[B], _.index.array[B] = _.index.array[B + 2], _.index.array[B + 2] = O
                                        }(G[_]);
                                        let B = ws(G.slice(0, Y), !1);
                                        if (B) {
                                            let N;
                                            "SubdivObject" === _ && console.warn("Turning subdiv object into mesh"), (N = new at(B, Q[0].material)).castShadow = Q[0].castShadow, N.receiveShadow = Q[0].receiveShadow, O.add(N);
                                            let y = _ => {
                                                for (let O of (ee = 0, _)) O.children && y(O.children), O instanceof xK && (Array.isArray(O.material) || k[O.material.uuid] && k[O.material.uuid][Rm(O)] && k[O.material.uuid][Rm(O)].length > 1 || ($[ee++] = O));
                                                for (let _ = 0; _ < ee; _++) O.attach($[_])
                                            };
                                            for (let _ = 0; _ < K; _++) {
                                                let O = Q[_];
                                                y(O.children), U[j++] = O
                                            }
                                        }
                                    }
                                for (let _ = 0; _ < j; _++) U[_].removeFromParent()
                            }(U, j.scene), console.log("Merged geometries in ", performance.now() - _, " ms")
                        }
                        KA(U) && this._scene.traverse(_ => {
                            Xn(_) && _.recomputeBoolean()
                        }), this._sharedAssetsManager.setRequestRender(() => {
                            this._requestRenderAutoMode(), this._scene ? .traverse(_ => {
                                _ instanceof _3 && _.pendingMediaLoad && _.update()
                            })
                        });
                        let G = Object.keys(U.shared.fonts).map(_ => this._sharedAssetsManager.getFont(_).loadingPromise);
                        Promise.all(G).then(() => {
                            j.scene.markNeedsUpdateRendererDirty(), this._requestRenderAutoMode()
                        }), GA(U) && function(_) {
                            if (gD.physicsEnabled(_.scene.objects)) return !0;
                            let O = !1;
                            return _.scene.objects.traverse((_, B) => {
                                if (B.events) {
                                    if (Array.isArray(B.events)) {
                                        for (let _ of B.events)
                                            if (!0 !== _.data.disabled && "GameControl" === _.data.type && _.data.collisionEnabled) {
                                                O = !0;
                                                break
                                            }
                                    } else
                                        for (let _ of Object.values(B.events))
                                            if (!0 !== _.disabled && "GameControl" === _.type && _.collisionEnabled) {
                                                O = !0;
                                                break
                                            }
                                }
                            }), O
                        }(U) && await Promise.all(G), this._scene.rewriteEventsBeforeGoToPlayMode(), nf(this._scene.activePage, this._sharedAssetsManager), this._renderer || (this._renderer = new Mb({
                            canvas: this.canvas,
                            antialias: !1,
                            alpha: !0,
                            stencil: !1,
                            depth: !1,
                            powerPreference: "high-performance"
                        }), this._renderer.hdTransmission = !0 === U.scene.publish.hdTransmission, this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.pipeline.addEventListener("smaaloaded", this._requestRenderAutoMode)), this._scene.initializeSplatViewer(this._renderer), void 0 !== U.scene.blueNoiseTextureData && this._renderer.pipeline.updateBlueNoiseTexture(U.scene.blueNoiseTextureData);
                        let Y = Object.values(U.frames)[0];
                        if (this._frameView ? this._frameView.setCamera(this._camera) : ("fullscreen" === Y.preset ? (this._viewportMode = 1, this.canvas.style.display = "block", this.canvas.parentElement && (this._viewportWidth = this.canvas.parentElement.clientWidth || 300, this.canvas.style.width = "100%"), this.canvas.parentElement && (this._viewportHeight = this.canvas.parentElement.clientHeight || 150, this.canvas.style.height = "100%")) : (this._viewportMode = 2, this._viewportWidth = Y.size[0], this._viewportHeight = Y.size[1], this.canvas.style.width = `${this._viewportWidth}px`, this.canvas.style.height = `${this._viewportHeight}px`), this._renderer.setSize(this._viewportWidth, this._viewportHeight, !1), this._frameView = new Pf(this._renderer, this._camera, new iJ(this._viewportWidth, this._viewportHeight), new iJ(window.innerWidth, window.innerHeight)), this._frameView.enableResponsive = (Y.allowResponsive ? ? !1) && "fullscreen" === Y.preset), O) {
                            let _ = new C6(this._renderer, this.data.scene.publish, this._scene, () => this._scene.activeCamera, this._sharedAssetsManager, this._requestRenderAutoMode, !0, Y);
                            this._scene.updateMatrixWorld(!0), this._controls = new Pi(_), this._animationControls = new Pn(this._scene, this._requestRenderAutoMode), this._eventManager = new Pp(U.scene.publish, this._controls, this._animationControls, _, U.shared.variables), this._eventManager.activate(), this._controls.activate(this._eventManager)
                        }
                        this._resize(), void 0 !== N && this.setVariables(N), 0 === this.dt && (this.render(performance.now()), setTimeout(() => {
                            this._renderer ? .setAnimationLoop(this.render)
                        }, 0)), this._resizeObserverTimeout = setTimeout(() => {
                            !this._resizeObserver && this.canvas.parentElement && (this._resizeObserver = new ResizeObserver(() => {
                                this._viewportWidth = this.canvas.clientWidth, this._viewportHeight = this.canvas.clientHeight, this._debouncedResize()
                            }), this._resizeObserver.observe(this.canvas.parentElement))
                        }, 300)
                    }
                    setVariables(_) {
                        if (void 0 !== this._data)
                            for (let [O, B] of Object.entries(_)) this.setVariable(O, B)
                    }
                    setVariable(_, O) {
                        let B = this._getVariableByName(_);
                        if (!B || "dynamicVariableType" in B.data) void 0 === B ? console.warn(`No variable named ${_} was found in your Spline file. Make sure to create it from Spline editor.`) : "dynamicVariableType" in B.data && console.warn(`Dynamic variables like ${_} cannot be updated from code.`);
                        else {
                            let _ = O;
                            "number" == typeof B.data.value ? _ = "number" == typeof O ? O : "boolean" == typeof O ? !0 === O ? 1 : 0 : parseFloat(O) : "boolean" == typeof B.data.value ? _ = "number" == typeof O ? !!O : "boolean" == typeof O ? O : "false" !== O.toLocaleLowerCase() && !!O : "string" != typeof B.data.value && void 0 !== B.data.value.textValue && (_ = O.toString());
                            let N = "string" == typeof _ ? {
                                textValue: _
                            } : _;
                            this._sharedAssetsManager ? .updateVariable(B.id, N), this.requestRender(), this._requestRenderAutoMode()
                        }
                    }
                    getVariables() {
                        let _ = {};
                        return this._data && this._data.shared.variables.forEach(O => {
                            void 0 === _[O.data.name] && (_[O.data.name] = this._getVariableValue(this._sharedAssetsManager.getVariable(O.id)))
                        }), _
                    }
                    getVariable(_) {
                        let O = this._getVariableByName(_);
                        if (O) {
                            let _ = this._sharedAssetsManager.getVariable(O.id);
                            return this._getVariableValue(_)
                        }
                    }
                    _getVariableValue(_) {
                        return "string" != typeof _ && gL.isTextValue(_) ? gL.getDisplayedValue(_) : _
                    }
                    _getVariableByName(_) {
                        if (this._data) {
                            if (this._variablesCache.has(_)) return this._variablesCache.get(_);
                            let O = this._data.shared.variables.find(O => O.data.name === _);
                            return O && this._variablesCache.set(_, O), O
                        }
                    }
                    findObjectById(_) {
                        let O = this._scene ? .getObjectByProperty("uuid", _);
                        return this._createProxyObject(O)
                    }
                    findObjectByName(_) {
                        let O = this._scene ? .getObjectByName(_);
                        return this._createProxyObject(O)
                    }
                    getAllObjects() {
                        let _ = [];
                        return this._scene ? .traverseEntity(O => {
                            if (O.uuid !== pq && !this._scene.isInvisibleObjects(O) && !(O instanceof Mz)) {
                                let B = this._createProxyObject(O);
                                B && _.push(B)
                            }
                        }), _
                    }
                    getSplineEvents() {
                        return this._eventManager ? .handlers ? .Spline.splineEvents
                    }
                    emitEvent(_, O) {
                        (this.findObjectById(O) || this.findObjectByName(O)) ? .emitEvent(_)
                    }
                    emitEventReverse(_, O) {
                        (this.findObjectById(O) || this.findObjectByName(O)) ? .emitEventReverse(_)
                    }
                    addEventListener(_, O) {
                        this.canvas.addEventListener(_, O)
                    }
                    removeEventListener(_, O) {
                        this.canvas.removeEventListener(_, O)
                    }
                    setZoom(_) {
                        this._controls ? .orbitControls instanceof DW && this._controls ? .orbitControls.zoomOut(_)
                    }
                    get eventManager() {
                        return this._eventManager
                    }
                    get controls() {
                        return this._controls
                    }
                    setSize(_, O) {
                        this._viewportWidth = _, this._viewportHeight = O, this._viewportMode = 2, this._resize()
                    }
                    setBackgroundColor(_) {
                        let {
                            r: O,
                            g: B,
                            b: N,
                            a: k
                        } = {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 1
                        }, F = new x8(O, B, N, k);
                        try {
                            F.setStyle(_)
                        } catch {
                            console.error("This is not a valid css color", _)
                        }
                        this._scene ? .activePage.setBackgroundColor(F), this._requestRenderAutoMode()
                    }
                    dispose() {
                        var _;
                        this.disposed = !0, this._eventManager ? .deactivate(), this._scene ? .dispose(), this._sharedAssetsManager ? .dispose(), this._proxyObjectCache.forEach(_ => {
                            fw.unsubscribe(_)
                        }), this._variablesCache.clear(), this._renderer ? .setAnimationLoop(null), this._renderer ? .dispose(), this._renderer = void 0, this._sharedAssetsManager ? .dispose(), this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = void 0), void 0 !== this._resizeObserverTimeout && clearTimeout(this._resizeObserverTimeout), this.canvas.style.width = "", this.canvas.style.height = "", this.canvas.removeAttribute("width"), this.canvas.removeAttribute("height"), this._frameView && (this._frameView = void 0), this._controls ? .deactivate(), (_ = this.canvas).removeEventListener("pointerdown", KC, !0), _.removeEventListener("pointerdown", py, !0), _.removeEventListener("pointermove", py, !0), _.removeEventListener("pointerup", oh, !0), _.removeEventListener("pointercancel", oh, !0), _.removeEventListener("pointerleave", oh, !0), window.removeEventListener("keydown", JC, !0), window.removeEventListener("keyup", $C, !0)
                    }
                    get isStopped() {
                        return this._isPaused
                    }
                    stop() {
                        this._isPaused || (this._renderer ? .setAnimationLoop(null), this._isPaused = !0, this._eventManager ? .pause(), this._controls ? .orbitControls && (this._controls.orbitControls.enabled = !1))
                    }
                    play() {
                        this._isPaused && (this._isPaused = !1, this._eventManager ? .resume(), this._controls ? .orbitControls && (this._controls.orbitControls.enabled = !0), this._renderer ? .setAnimationLoop(this.render))
                    }
                    setGlobalEvents(_) {
                        this._eventManager ? .updateUseWindowEvents(_)
                    }
                    get data() {
                        return this._data
                    }
                    _createProxyObject(_) {
                        let O;
                        if (null == _) return;
                        if (this._proxyObjectCache.has(_.uuid)) return this._proxyObjectCache.get(_.uuid);
                        _.traverseAncestors(_ => {
                            _ instanceof Mz && (O = _.name)
                        });
                        let B = fw({
                            name: _.name,
                            uuid: _.uuid,
                            visible: _.visible,
                            intensity: _.intensity,
                            position: _.position,
                            rotation: _.rotation,
                            scale: _.scale,
                            type: _.data.type,
                            page: O,
                            parentUuid: _.parent instanceof Mz || _ instanceof Ep ? void 0 : _.parent ? .uuid,
                            emitEvent(O) {
                                _.dispatchEvent({
                                    type: "userEvent",
                                    eventName: O
                                })
                            },
                            emitEventReverse(O) {
                                _.dispatchEvent({
                                    type: "userEvent",
                                    eventName: O,
                                    reverse: !0
                                })
                            }
                        }, (O, B) => {
                            "object" != typeof _[O] && Object.getOwnPropertyDescriptor(_, O) ? .writable && (_[O] = B), this._requestRenderAutoMode(), _.updateMatrix()
                        });
                        return this._proxyObjectCache.set(_.uuid, B), B
                    }
                }
        }
    }
]);